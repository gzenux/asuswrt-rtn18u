#ifndef __BCM6300_A0_DEFS_H__
#define __BCM6300_A0_DEFS_H__
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from the registers file.
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: (c) 2009 Broadcom Corp.
 * All Rights Reserved.$
 *
 * Definition file for the BCM6300_A0.
 * This file provides all basic definitions required to program the BCM6300_A0.
 *
 ******************************************************************************/

#include <cdk/cdk_string.h>
#include <cdk/cdk_field.h>
#include <cdk/arch/robo_reg.h>
#include <cdk/arch/robo_mem.h>

/*******************************************************************************
 *
 *                    CHIP DEFINITIONS BEGIN HERE
 *
 ******************************************************************************/



/* CPIC/IMP port */
#define BCM6300_A0_CPIC_PORT            8

/* Additional block types */
#define BCM6300_A0_BLKTYPE_SYS          0
#define BCM6300_A0_BLKTYPE_EXP          1
#define BCM6300_A0_BLKTYPE_GPIC         2
#define BCM6300_A0_BLKTYPE_CPIC         3
#define BCM6300_A0_BLKTYPE_SPI          4


#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPIC_PORT                       BCM6300_A0_CPIC_PORT

#define BLKTYPE_SYS                     BCM6300_A0_BLKTYPE_SYS
#define BLKTYPE_EXP                     BCM6300_A0_BLKTYPE_EXP
#define BLKTYPE_GPIC                    BCM6300_A0_BLKTYPE_GPIC
#define BLKTYPE_CPIC                    BCM6300_A0_BLKTYPE_CPIC
#define BLKTYPE_SPI                     BCM6300_A0_BLKTYPE_SPI


#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */



#if CDK_CONFIG_CHIP_DEFS_USE_DSYMS == 1
/* Use DSYM all_defs.h instead of static chip definitions */
#include "all_defs.h"
#else

/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  ACTLSTS
 * BLOCKS:   GPIC0
 * DESC:     Auxiliary Control/Status Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_ACTLSTSr 0x00001030

#define BCM6300_A0_ACTLSTSr_SIZE 2

/*
 * This structure should be used to declare and program ACTLSTS.
 *
 */
typedef union BCM6300_A0_ACTLSTSr_s {
	uint32_t v[1];
	uint32_t actlsts[1];
	uint32_t _actlsts;
} BCM6300_A0_ACTLSTSr_t;

#define BCM6300_A0_ACTLSTSr_CLR(r) (r).actlsts[0] = 0
#define BCM6300_A0_ACTLSTSr_SET(r,d) (r).actlsts[0] = d
#define BCM6300_A0_ACTLSTSr_GET(r) (r).actlsts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_ACTLSTSr_RESERVED_Rf_GET(r) (((r).actlsts[0]) & 0xffff)
#define BCM6300_A0_ACTLSTSr_RESERVED_Rf_SET(r,f) (r).actlsts[0]=(((r).actlsts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ACTLSTS.
 *
 */
#define BCM6300_A0_READ_ACTLSTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_ACTLSTSr,(r._actlsts),2)
#define BCM6300_A0_WRITE_ACTLSTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_ACTLSTSr,&(r._actlsts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ACTLSTSr BCM6300_A0_ACTLSTSr
#define ACTLSTSr_SIZE BCM6300_A0_ACTLSTSr_SIZE
typedef BCM6300_A0_ACTLSTSr_t ACTLSTSr_t;
#define ACTLSTSr_CLR BCM6300_A0_ACTLSTSr_CLR
#define ACTLSTSr_SET BCM6300_A0_ACTLSTSr_SET
#define ACTLSTSr_GET BCM6300_A0_ACTLSTSr_GET
#define ACTLSTSr_RESERVED_Rf_GET BCM6300_A0_ACTLSTSr_RESERVED_Rf_GET
#define ACTLSTSr_RESERVED_Rf_SET BCM6300_A0_ACTLSTSr_RESERVED_Rf_SET
#define READ_ACTLSTSr BCM6300_A0_READ_ACTLSTSr
#define WRITE_ACTLSTSr BCM6300_A0_WRITE_ACTLSTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_ACTLSTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  AEGSTS
 * BLOCKS:   GPIC0
 * DESC:     10BASE-T Auxiliary Error And General Status Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_AEGSTSr 0x00001038

#define BCM6300_A0_AEGSTSr_SIZE 2

/*
 * This structure should be used to declare and program AEGSTS.
 *
 */
typedef union BCM6300_A0_AEGSTSr_s {
	uint32_t v[1];
	uint32_t aegsts[1];
	uint32_t _aegsts;
} BCM6300_A0_AEGSTSr_t;

#define BCM6300_A0_AEGSTSr_CLR(r) (r).aegsts[0] = 0
#define BCM6300_A0_AEGSTSr_SET(r,d) (r).aegsts[0] = d
#define BCM6300_A0_AEGSTSr_GET(r) (r).aegsts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_AEGSTSr_RESERVED_Rf_GET(r) (((r).aegsts[0]) & 0xffff)
#define BCM6300_A0_AEGSTSr_RESERVED_Rf_SET(r,f) (r).aegsts[0]=(((r).aegsts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access AEGSTS.
 *
 */
#define BCM6300_A0_READ_AEGSTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_AEGSTSr,(r._aegsts),2)
#define BCM6300_A0_WRITE_AEGSTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_AEGSTSr,&(r._aegsts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AEGSTSr BCM6300_A0_AEGSTSr
#define AEGSTSr_SIZE BCM6300_A0_AEGSTSr_SIZE
typedef BCM6300_A0_AEGSTSr_t AEGSTSr_t;
#define AEGSTSr_CLR BCM6300_A0_AEGSTSr_CLR
#define AEGSTSr_SET BCM6300_A0_AEGSTSr_SET
#define AEGSTSr_GET BCM6300_A0_AEGSTSr_GET
#define AEGSTSr_RESERVED_Rf_GET BCM6300_A0_AEGSTSr_RESERVED_Rf_GET
#define AEGSTSr_RESERVED_Rf_SET BCM6300_A0_AEGSTSr_RESERVED_Rf_SET
#define READ_AEGSTSr BCM6300_A0_READ_AEGSTSr
#define WRITE_AEGSTSr BCM6300_A0_WRITE_AEGSTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_AEGSTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  AMODE2
 * BLOCKS:   GPIC0
 * DESC:     Auxiliary Mode 2 Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_AMODE2r 0x00001036

#define BCM6300_A0_AMODE2r_SIZE 2

/*
 * This structure should be used to declare and program AMODE2.
 *
 */
typedef union BCM6300_A0_AMODE2r_s {
	uint32_t v[1];
	uint32_t amode2[1];
	uint32_t _amode2;
} BCM6300_A0_AMODE2r_t;

#define BCM6300_A0_AMODE2r_CLR(r) (r).amode2[0] = 0
#define BCM6300_A0_AMODE2r_SET(r,d) (r).amode2[0] = d
#define BCM6300_A0_AMODE2r_GET(r) (r).amode2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_AMODE2r_RESERVED_Rf_GET(r) (((r).amode2[0]) & 0xffff)
#define BCM6300_A0_AMODE2r_RESERVED_Rf_SET(r,f) (r).amode2[0]=(((r).amode2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access AMODE2.
 *
 */
#define BCM6300_A0_READ_AMODE2r(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_AMODE2r,(r._amode2),2)
#define BCM6300_A0_WRITE_AMODE2r(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_AMODE2r,&(r._amode2),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AMODE2r BCM6300_A0_AMODE2r
#define AMODE2r_SIZE BCM6300_A0_AMODE2r_SIZE
typedef BCM6300_A0_AMODE2r_t AMODE2r_t;
#define AMODE2r_CLR BCM6300_A0_AMODE2r_CLR
#define AMODE2r_SET BCM6300_A0_AMODE2r_SET
#define AMODE2r_GET BCM6300_A0_AMODE2r_GET
#define AMODE2r_RESERVED_Rf_GET BCM6300_A0_AMODE2r_RESERVED_Rf_GET
#define AMODE2r_RESERVED_Rf_SET BCM6300_A0_AMODE2r_RESERVED_Rf_SET
#define READ_AMODE2r BCM6300_A0_READ_AMODE2r
#define WRITE_AMODE2r BCM6300_A0_WRITE_AMODE2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_AMODE2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  AMPHY
 * BLOCKS:   GPIC0
 * DESC:     Auxiliary Multiple PHY Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_AMPHYr 0x0000103c

#define BCM6300_A0_AMPHYr_SIZE 2

/*
 * This structure should be used to declare and program AMPHY.
 *
 */
typedef union BCM6300_A0_AMPHYr_s {
	uint32_t v[1];
	uint32_t amphy[1];
	uint32_t _amphy;
} BCM6300_A0_AMPHYr_t;

#define BCM6300_A0_AMPHYr_CLR(r) (r).amphy[0] = 0
#define BCM6300_A0_AMPHYr_SET(r,d) (r).amphy[0] = d
#define BCM6300_A0_AMPHYr_GET(r) (r).amphy[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_AMPHYr_RESERVED_Rf_GET(r) (((r).amphy[0]) & 0xffff)
#define BCM6300_A0_AMPHYr_RESERVED_Rf_SET(r,f) (r).amphy[0]=(((r).amphy[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access AMPHY.
 *
 */
#define BCM6300_A0_READ_AMPHYr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_AMPHYr,(r._amphy),2)
#define BCM6300_A0_WRITE_AMPHYr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_AMPHYr,&(r._amphy),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AMPHYr BCM6300_A0_AMPHYr
#define AMPHYr_SIZE BCM6300_A0_AMPHYr_SIZE
typedef BCM6300_A0_AMPHYr_t AMPHYr_t;
#define AMPHYr_CLR BCM6300_A0_AMPHYr_CLR
#define AMPHYr_SET BCM6300_A0_AMPHYr_SET
#define AMPHYr_GET BCM6300_A0_AMPHYr_GET
#define AMPHYr_RESERVED_Rf_GET BCM6300_A0_AMPHYr_RESERVED_Rf_GET
#define AMPHYr_RESERVED_Rf_SET BCM6300_A0_AMPHYr_RESERVED_Rf_SET
#define READ_AMPHYr BCM6300_A0_READ_AMPHYr
#define WRITE_AMPHYr BCM6300_A0_WRITE_AMPHYr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_AMPHYr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  ANADV
 * BLOCKS:   GPIC0
 * DESC:     Auto-Negotiation Advertisement Register
 * SIZE:     16
 * FIELDS:
 *     ADV_SEL_FIELD    
 *     ADV_B10T         
 *     ADV_B10T_FDX     
 *     ADV_B100X        
 *     ADV_B100X_FDX    
 *     ADV_B100T4       
 *     ADV_PAUSE_CAP    
 *     RESV_TECH        
 *     REMOTE_FAULT_R   
 *     RESERVED_R       Reserved
 *     NEXT_PAGE        
 *
 ******************************************************************************/
#define BCM6300_A0_ANADVr 0x00001008

#define BCM6300_A0_ANADVr_SIZE 2

/*
 * This structure should be used to declare and program ANADV.
 *
 */
typedef union BCM6300_A0_ANADVr_s {
	uint32_t v[1];
	uint32_t anadv[1];
	uint32_t _anadv;
} BCM6300_A0_ANADVr_t;

#define BCM6300_A0_ANADVr_CLR(r) (r).anadv[0] = 0
#define BCM6300_A0_ANADVr_SET(r,d) (r).anadv[0] = d
#define BCM6300_A0_ANADVr_GET(r) (r).anadv[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_ANADVr_ADV_SEL_FIELDf_GET(r) (((r).anadv[0]) & 0x1f)
#define BCM6300_A0_ANADVr_ADV_SEL_FIELDf_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM6300_A0_ANADVr_ADV_B10Tf_GET(r) ((((r).anadv[0]) >> 5) & 0x1)
#define BCM6300_A0_ANADVr_ADV_B10Tf_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM6300_A0_ANADVr_ADV_B10T_FDXf_GET(r) ((((r).anadv[0]) >> 6) & 0x1)
#define BCM6300_A0_ANADVr_ADV_B10T_FDXf_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM6300_A0_ANADVr_ADV_B100Xf_GET(r) ((((r).anadv[0]) >> 7) & 0x1)
#define BCM6300_A0_ANADVr_ADV_B100Xf_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM6300_A0_ANADVr_ADV_B100X_FDXf_GET(r) ((((r).anadv[0]) >> 8) & 0x1)
#define BCM6300_A0_ANADVr_ADV_B100X_FDXf_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM6300_A0_ANADVr_ADV_B100T4f_GET(r) ((((r).anadv[0]) >> 9) & 0x1)
#define BCM6300_A0_ANADVr_ADV_B100T4f_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM6300_A0_ANADVr_ADV_PAUSE_CAPf_GET(r) ((((r).anadv[0]) >> 10) & 0x1)
#define BCM6300_A0_ANADVr_ADV_PAUSE_CAPf_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM6300_A0_ANADVr_RESV_TECHf_GET(r) ((((r).anadv[0]) >> 11) & 0x3)
#define BCM6300_A0_ANADVr_RESV_TECHf_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11))
#define BCM6300_A0_ANADVr_REMOTE_FAULT_Rf_GET(r) ((((r).anadv[0]) >> 13) & 0x1)
#define BCM6300_A0_ANADVr_REMOTE_FAULT_Rf_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM6300_A0_ANADVr_RESERVED_Rf_GET(r) ((((r).anadv[0]) >> 14) & 0x1)
#define BCM6300_A0_ANADVr_RESERVED_Rf_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM6300_A0_ANADVr_NEXT_PAGEf_GET(r) ((((r).anadv[0]) >> 15) & 0x1)
#define BCM6300_A0_ANADVr_NEXT_PAGEf_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access ANADV.
 *
 */
#define BCM6300_A0_READ_ANADVr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_ANADVr,(r._anadv),2)
#define BCM6300_A0_WRITE_ANADVr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_ANADVr,&(r._anadv),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ANADVr BCM6300_A0_ANADVr
#define ANADVr_SIZE BCM6300_A0_ANADVr_SIZE
typedef BCM6300_A0_ANADVr_t ANADVr_t;
#define ANADVr_CLR BCM6300_A0_ANADVr_CLR
#define ANADVr_SET BCM6300_A0_ANADVr_SET
#define ANADVr_GET BCM6300_A0_ANADVr_GET
#define ANADVr_ADV_SEL_FIELDf_GET BCM6300_A0_ANADVr_ADV_SEL_FIELDf_GET
#define ANADVr_ADV_SEL_FIELDf_SET BCM6300_A0_ANADVr_ADV_SEL_FIELDf_SET
#define ANADVr_ADV_B10Tf_GET BCM6300_A0_ANADVr_ADV_B10Tf_GET
#define ANADVr_ADV_B10Tf_SET BCM6300_A0_ANADVr_ADV_B10Tf_SET
#define ANADVr_ADV_B10T_FDXf_GET BCM6300_A0_ANADVr_ADV_B10T_FDXf_GET
#define ANADVr_ADV_B10T_FDXf_SET BCM6300_A0_ANADVr_ADV_B10T_FDXf_SET
#define ANADVr_ADV_B100Xf_GET BCM6300_A0_ANADVr_ADV_B100Xf_GET
#define ANADVr_ADV_B100Xf_SET BCM6300_A0_ANADVr_ADV_B100Xf_SET
#define ANADVr_ADV_B100X_FDXf_GET BCM6300_A0_ANADVr_ADV_B100X_FDXf_GET
#define ANADVr_ADV_B100X_FDXf_SET BCM6300_A0_ANADVr_ADV_B100X_FDXf_SET
#define ANADVr_ADV_B100T4f_GET BCM6300_A0_ANADVr_ADV_B100T4f_GET
#define ANADVr_ADV_B100T4f_SET BCM6300_A0_ANADVr_ADV_B100T4f_SET
#define ANADVr_ADV_PAUSE_CAPf_GET BCM6300_A0_ANADVr_ADV_PAUSE_CAPf_GET
#define ANADVr_ADV_PAUSE_CAPf_SET BCM6300_A0_ANADVr_ADV_PAUSE_CAPf_SET
#define ANADVr_RESV_TECHf_GET BCM6300_A0_ANADVr_RESV_TECHf_GET
#define ANADVr_RESV_TECHf_SET BCM6300_A0_ANADVr_RESV_TECHf_SET
#define ANADVr_REMOTE_FAULT_Rf_GET BCM6300_A0_ANADVr_REMOTE_FAULT_Rf_GET
#define ANADVr_REMOTE_FAULT_Rf_SET BCM6300_A0_ANADVr_REMOTE_FAULT_Rf_SET
#define ANADVr_RESERVED_Rf_GET BCM6300_A0_ANADVr_RESERVED_Rf_GET
#define ANADVr_RESERVED_Rf_SET BCM6300_A0_ANADVr_RESERVED_Rf_SET
#define ANADVr_NEXT_PAGEf_GET BCM6300_A0_ANADVr_NEXT_PAGEf_GET
#define ANADVr_NEXT_PAGEf_SET BCM6300_A0_ANADVr_NEXT_PAGEf_SET
#define READ_ANADVr BCM6300_A0_READ_ANADVr
#define WRITE_ANADVr BCM6300_A0_WRITE_ANADVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_ANADVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  ANEXP
 * BLOCKS:   GPIC0
 * DESC:     Auto-Negotiation Expansion Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_ANEXPr 0x0000100c

#define BCM6300_A0_ANEXPr_SIZE 2

/*
 * This structure should be used to declare and program ANEXP.
 *
 */
typedef union BCM6300_A0_ANEXPr_s {
	uint32_t v[1];
	uint32_t anexp[1];
	uint32_t _anexp;
} BCM6300_A0_ANEXPr_t;

#define BCM6300_A0_ANEXPr_CLR(r) (r).anexp[0] = 0
#define BCM6300_A0_ANEXPr_SET(r,d) (r).anexp[0] = d
#define BCM6300_A0_ANEXPr_GET(r) (r).anexp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_ANEXPr_RESERVED_Rf_GET(r) (((r).anexp[0]) & 0xffff)
#define BCM6300_A0_ANEXPr_RESERVED_Rf_SET(r,f) (r).anexp[0]=(((r).anexp[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ANEXP.
 *
 */
#define BCM6300_A0_READ_ANEXPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_ANEXPr,(r._anexp),2)
#define BCM6300_A0_WRITE_ANEXPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_ANEXPr,&(r._anexp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ANEXPr BCM6300_A0_ANEXPr
#define ANEXPr_SIZE BCM6300_A0_ANEXPr_SIZE
typedef BCM6300_A0_ANEXPr_t ANEXPr_t;
#define ANEXPr_CLR BCM6300_A0_ANEXPr_CLR
#define ANEXPr_SET BCM6300_A0_ANEXPr_SET
#define ANEXPr_GET BCM6300_A0_ANEXPr_GET
#define ANEXPr_RESERVED_Rf_GET BCM6300_A0_ANEXPr_RESERVED_Rf_GET
#define ANEXPr_RESERVED_Rf_SET BCM6300_A0_ANEXPr_RESERVED_Rf_SET
#define READ_ANEXPr BCM6300_A0_READ_ANEXPr
#define WRITE_ANEXPr BCM6300_A0_WRITE_ANEXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_ANEXPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  ANLPAR
 * BLOCKS:   GPIC0
 * DESC:     Auto-Negotiation Link Partner (LP) Ability Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_ANLPARr 0x0000100a

#define BCM6300_A0_ANLPARr_SIZE 2

/*
 * This structure should be used to declare and program ANLPAR.
 *
 */
typedef union BCM6300_A0_ANLPARr_s {
	uint32_t v[1];
	uint32_t anlpar[1];
	uint32_t _anlpar;
} BCM6300_A0_ANLPARr_t;

#define BCM6300_A0_ANLPARr_CLR(r) (r).anlpar[0] = 0
#define BCM6300_A0_ANLPARr_SET(r,d) (r).anlpar[0] = d
#define BCM6300_A0_ANLPARr_GET(r) (r).anlpar[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_ANLPARr_RESERVED_Rf_GET(r) (((r).anlpar[0]) & 0xffff)
#define BCM6300_A0_ANLPARr_RESERVED_Rf_SET(r,f) (r).anlpar[0]=(((r).anlpar[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ANLPAR.
 *
 */
#define BCM6300_A0_READ_ANLPARr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_ANLPARr,(r._anlpar),2)
#define BCM6300_A0_WRITE_ANLPARr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_ANLPARr,&(r._anlpar),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ANLPARr BCM6300_A0_ANLPARr
#define ANLPARr_SIZE BCM6300_A0_ANLPARr_SIZE
typedef BCM6300_A0_ANLPARr_t ANLPARr_t;
#define ANLPARr_CLR BCM6300_A0_ANLPARr_CLR
#define ANLPARr_SET BCM6300_A0_ANLPARr_SET
#define ANLPARr_GET BCM6300_A0_ANLPARr_GET
#define ANLPARr_RESERVED_Rf_GET BCM6300_A0_ANLPARr_RESERVED_Rf_GET
#define ANLPARr_RESERVED_Rf_SET BCM6300_A0_ANLPARr_RESERVED_Rf_SET
#define READ_ANLPARr BCM6300_A0_READ_ANLPARr
#define WRITE_ANLPARr BCM6300_A0_WRITE_ANLPARr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_ANLPARr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  ANNXP
 * BLOCKS:   GPIC0
 * DESC:     Auto-Negotiation Next Page Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_ANNXPr 0x0000100e

#define BCM6300_A0_ANNXPr_SIZE 2

/*
 * This structure should be used to declare and program ANNXP.
 *
 */
typedef union BCM6300_A0_ANNXPr_s {
	uint32_t v[1];
	uint32_t annxp[1];
	uint32_t _annxp;
} BCM6300_A0_ANNXPr_t;

#define BCM6300_A0_ANNXPr_CLR(r) (r).annxp[0] = 0
#define BCM6300_A0_ANNXPr_SET(r,d) (r).annxp[0] = d
#define BCM6300_A0_ANNXPr_GET(r) (r).annxp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_ANNXPr_RESERVED_Rf_GET(r) (((r).annxp[0]) & 0xffff)
#define BCM6300_A0_ANNXPr_RESERVED_Rf_SET(r,f) (r).annxp[0]=(((r).annxp[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ANNXP.
 *
 */
#define BCM6300_A0_READ_ANNXPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_ANNXPr,(r._annxp),2)
#define BCM6300_A0_WRITE_ANNXPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_ANNXPr,&(r._annxp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ANNXPr BCM6300_A0_ANNXPr
#define ANNXPr_SIZE BCM6300_A0_ANNXPr_SIZE
typedef BCM6300_A0_ANNXPr_t ANNXPr_t;
#define ANNXPr_CLR BCM6300_A0_ANNXPr_CLR
#define ANNXPr_SET BCM6300_A0_ANNXPr_SET
#define ANNXPr_GET BCM6300_A0_ANNXPr_GET
#define ANNXPr_RESERVED_Rf_GET BCM6300_A0_ANNXPr_RESERVED_Rf_GET
#define ANNXPr_RESERVED_Rf_SET BCM6300_A0_ANNXPr_RESERVED_Rf_SET
#define READ_ANNXPr BCM6300_A0_READ_ANNXPr
#define WRITE_ANNXPr BCM6300_A0_WRITE_ANNXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_ANNXPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  ARLA_FWD_ENTRY0
 * BLOCKS:   SYS
 * DESC:     ARL FWD Entry 0 Register
 * SIZE:     16
 * FIELDS:
 *     PORTID_R         Port Identification.The port number which identifies where the station with unique MACADDR0 is connected.Forward Port Map.Multicast Group Forward Portmap.If(MACADDR0[47] ==1) FWD_PRT_MAP[3:0]Bit 3:0 = Chip 0 Port3:0
 *     RESERVERD        Reserve Bit.If(MACADDR0[47] ==1) FWD_PRT_MAP[8:6]Multicast Group Forward Portmap.Bit 7:4= Chip 0 Port 7:4
 *     ARL_CON          arl control bit for arl cintrol mode enhancement.
 *     ARL_PRI          
 *     ARL_AGE          
 *     ARL_STATIC       Static.Set to indicate that the entry is controlled by the external management processor, and automatic learning and aging of the entry will not take place.When cleared, the internal learning and aging process will control the validity of the entry.
 *     ARL_VALID        Valid.Set to indicate that a valid MAC address is stored in the MACADDR0 field, and that the entry has not aged out or been freed by the management processor.Reset when an entry is empty, the address has been aged out by the internal aging process, or the external management processor has invalidated the entry. Automatic learning will take place if an address location is not valid and has not been marked as static.
 *
 ******************************************************************************/
#define BCM6300_A0_ARLA_FWD_ENTRY0r 0x00000518

#define BCM6300_A0_ARLA_FWD_ENTRY0r_SIZE 2

/*
 * This structure should be used to declare and program ARLA_FWD_ENTRY0.
 *
 */
typedef union BCM6300_A0_ARLA_FWD_ENTRY0r_s {
	uint32_t v[1];
	uint32_t arla_fwd_entry0[1];
	uint32_t _arla_fwd_entry0;
} BCM6300_A0_ARLA_FWD_ENTRY0r_t;

#define BCM6300_A0_ARLA_FWD_ENTRY0r_CLR(r) (r).arla_fwd_entry0[0] = 0
#define BCM6300_A0_ARLA_FWD_ENTRY0r_SET(r,d) (r).arla_fwd_entry0[0] = d
#define BCM6300_A0_ARLA_FWD_ENTRY0r_GET(r) (r).arla_fwd_entry0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_ARLA_FWD_ENTRY0r_PORTID_Rf_GET(r) (((r).arla_fwd_entry0[0]) & 0xf)
#define BCM6300_A0_ARLA_FWD_ENTRY0r_PORTID_Rf_SET(r,f) (r).arla_fwd_entry0[0]=(((r).arla_fwd_entry0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM6300_A0_ARLA_FWD_ENTRY0r_RESERVERDf_GET(r) ((((r).arla_fwd_entry0[0]) >> 4) & 0xf)
#define BCM6300_A0_ARLA_FWD_ENTRY0r_RESERVERDf_SET(r,f) (r).arla_fwd_entry0[0]=(((r).arla_fwd_entry0[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM6300_A0_ARLA_FWD_ENTRY0r_ARL_CONf_GET(r) ((((r).arla_fwd_entry0[0]) >> 8) & 0x3)
#define BCM6300_A0_ARLA_FWD_ENTRY0r_ARL_CONf_SET(r,f) (r).arla_fwd_entry0[0]=(((r).arla_fwd_entry0[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM6300_A0_ARLA_FWD_ENTRY0r_ARL_PRIf_GET(r) ((((r).arla_fwd_entry0[0]) >> 10) & 0x7)
#define BCM6300_A0_ARLA_FWD_ENTRY0r_ARL_PRIf_SET(r,f) (r).arla_fwd_entry0[0]=(((r).arla_fwd_entry0[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM6300_A0_ARLA_FWD_ENTRY0r_ARL_AGEf_GET(r) ((((r).arla_fwd_entry0[0]) >> 13) & 0x1)
#define BCM6300_A0_ARLA_FWD_ENTRY0r_ARL_AGEf_SET(r,f) (r).arla_fwd_entry0[0]=(((r).arla_fwd_entry0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM6300_A0_ARLA_FWD_ENTRY0r_ARL_STATICf_GET(r) ((((r).arla_fwd_entry0[0]) >> 14) & 0x1)
#define BCM6300_A0_ARLA_FWD_ENTRY0r_ARL_STATICf_SET(r,f) (r).arla_fwd_entry0[0]=(((r).arla_fwd_entry0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM6300_A0_ARLA_FWD_ENTRY0r_ARL_VALIDf_GET(r) ((((r).arla_fwd_entry0[0]) >> 15) & 0x1)
#define BCM6300_A0_ARLA_FWD_ENTRY0r_ARL_VALIDf_SET(r,f) (r).arla_fwd_entry0[0]=(((r).arla_fwd_entry0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access ARLA_FWD_ENTRY0.
 *
 */
#define BCM6300_A0_READ_ARLA_FWD_ENTRY0r(u,r) cdk_robo_reg_read(u,BCM6300_A0_ARLA_FWD_ENTRY0r,(r._arla_fwd_entry0),2)
#define BCM6300_A0_WRITE_ARLA_FWD_ENTRY0r(u,r) cdk_robo_reg_write(u,BCM6300_A0_ARLA_FWD_ENTRY0r,&(r._arla_fwd_entry0),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_FWD_ENTRY0r BCM6300_A0_ARLA_FWD_ENTRY0r
#define ARLA_FWD_ENTRY0r_SIZE BCM6300_A0_ARLA_FWD_ENTRY0r_SIZE
typedef BCM6300_A0_ARLA_FWD_ENTRY0r_t ARLA_FWD_ENTRY0r_t;
#define ARLA_FWD_ENTRY0r_CLR BCM6300_A0_ARLA_FWD_ENTRY0r_CLR
#define ARLA_FWD_ENTRY0r_SET BCM6300_A0_ARLA_FWD_ENTRY0r_SET
#define ARLA_FWD_ENTRY0r_GET BCM6300_A0_ARLA_FWD_ENTRY0r_GET
#define ARLA_FWD_ENTRY0r_PORTID_Rf_GET BCM6300_A0_ARLA_FWD_ENTRY0r_PORTID_Rf_GET
#define ARLA_FWD_ENTRY0r_PORTID_Rf_SET BCM6300_A0_ARLA_FWD_ENTRY0r_PORTID_Rf_SET
#define ARLA_FWD_ENTRY0r_RESERVERDf_GET BCM6300_A0_ARLA_FWD_ENTRY0r_RESERVERDf_GET
#define ARLA_FWD_ENTRY0r_RESERVERDf_SET BCM6300_A0_ARLA_FWD_ENTRY0r_RESERVERDf_SET
#define ARLA_FWD_ENTRY0r_ARL_CONf_GET BCM6300_A0_ARLA_FWD_ENTRY0r_ARL_CONf_GET
#define ARLA_FWD_ENTRY0r_ARL_CONf_SET BCM6300_A0_ARLA_FWD_ENTRY0r_ARL_CONf_SET
#define ARLA_FWD_ENTRY0r_ARL_PRIf_GET BCM6300_A0_ARLA_FWD_ENTRY0r_ARL_PRIf_GET
#define ARLA_FWD_ENTRY0r_ARL_PRIf_SET BCM6300_A0_ARLA_FWD_ENTRY0r_ARL_PRIf_SET
#define ARLA_FWD_ENTRY0r_ARL_AGEf_GET BCM6300_A0_ARLA_FWD_ENTRY0r_ARL_AGEf_GET
#define ARLA_FWD_ENTRY0r_ARL_AGEf_SET BCM6300_A0_ARLA_FWD_ENTRY0r_ARL_AGEf_SET
#define ARLA_FWD_ENTRY0r_ARL_STATICf_GET BCM6300_A0_ARLA_FWD_ENTRY0r_ARL_STATICf_GET
#define ARLA_FWD_ENTRY0r_ARL_STATICf_SET BCM6300_A0_ARLA_FWD_ENTRY0r_ARL_STATICf_SET
#define ARLA_FWD_ENTRY0r_ARL_VALIDf_GET BCM6300_A0_ARLA_FWD_ENTRY0r_ARL_VALIDf_GET
#define ARLA_FWD_ENTRY0r_ARL_VALIDf_SET BCM6300_A0_ARLA_FWD_ENTRY0r_ARL_VALIDf_SET
#define READ_ARLA_FWD_ENTRY0r BCM6300_A0_READ_ARLA_FWD_ENTRY0r
#define WRITE_ARLA_FWD_ENTRY0r BCM6300_A0_WRITE_ARLA_FWD_ENTRY0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_ARLA_FWD_ENTRY0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  ARLA_MAC
 * BLOCKS:   SYS
 * DESC:     MAC Address Index Register
 * SIZE:     48
 * FIELDS:
 *     MAC_ADDR_INDX    MAC Address Index.The MAC address for which status is to be read or written.By writing the 48 bit SA or DA address, and initiating a read command, the complete ARL bin location is returned in the ARL Entry 0/1 locations. Both entries are 64 bits wide. Initiating a write command will write the contents of ARL Entry 0/1 to the specified bin location (2 entries deep) and will overwrite the current contents of the bin, regardless of the status of the Valid bit(s) in each entry.
 *
 ******************************************************************************/
#define BCM6300_A0_ARLA_MACr 0x00000502

#define BCM6300_A0_ARLA_MACr_SIZE 6

/*
 * This structure should be used to declare and program ARLA_MAC.
 *
 */
typedef union BCM6300_A0_ARLA_MACr_s {
	uint32_t v[2];
	uint32_t arla_mac[2];
	uint32_t _arla_mac;
} BCM6300_A0_ARLA_MACr_t;

#define BCM6300_A0_ARLA_MACr_CLR(r) CDK_MEMSET(&((r)._arla_mac), 0, sizeof(BCM6300_A0_ARLA_MACr_t))
#define BCM6300_A0_ARLA_MACr_SET(r,i,d) (r).arla_mac[i] = d
#define BCM6300_A0_ARLA_MACr_GET(r,i) (r).arla_mac[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_ARLA_MACr_MAC_ADDR_INDXf_GET(r,a) cdk_field_get((r).arla_mac,0,47,a)
#define BCM6300_A0_ARLA_MACr_MAC_ADDR_INDXf_SET(r,a) cdk_field_set((r).arla_mac,0,47,a)

/*
 * These macros can be used to access ARLA_MAC.
 *
 */
#define BCM6300_A0_READ_ARLA_MACr(u,r) cdk_robo_reg_read(u,BCM6300_A0_ARLA_MACr,(r._arla_mac),6)
#define BCM6300_A0_WRITE_ARLA_MACr(u,r) cdk_robo_reg_write(u,BCM6300_A0_ARLA_MACr,&(r._arla_mac),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_MACr BCM6300_A0_ARLA_MACr
#define ARLA_MACr_SIZE BCM6300_A0_ARLA_MACr_SIZE
typedef BCM6300_A0_ARLA_MACr_t ARLA_MACr_t;
#define ARLA_MACr_CLR BCM6300_A0_ARLA_MACr_CLR
#define ARLA_MACr_SET BCM6300_A0_ARLA_MACr_SET
#define ARLA_MACr_GET BCM6300_A0_ARLA_MACr_GET
#define ARLA_MACr_MAC_ADDR_INDXf_GET BCM6300_A0_ARLA_MACr_MAC_ADDR_INDXf_GET
#define ARLA_MACr_MAC_ADDR_INDXf_SET BCM6300_A0_ARLA_MACr_MAC_ADDR_INDXf_SET
#define READ_ARLA_MACr BCM6300_A0_READ_ARLA_MACr
#define WRITE_ARLA_MACr BCM6300_A0_WRITE_ARLA_MACr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_ARLA_MACr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  ARLA_MACVID_ENTRY0
 * BLOCKS:   SYS
 * DESC:     ARL MAC/VID Entry 0 Register
 * SIZE:     64
 * FIELDS:
 *     ARL_MACADDR      MAC Address.
 *     VID_R            VID0.The VID0 register is used to write VID field of ARL table, or to read VID field of ARL table entry ARL FWD Entry 0 Register and MAC/VID Entry 0 Register compose a complete Entry in ARL Table while 802.1Q enabled
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_ARLA_MACVID_ENTRY0r 0x00000510

#define BCM6300_A0_ARLA_MACVID_ENTRY0r_SIZE 8

/*
 * This structure should be used to declare and program ARLA_MACVID_ENTRY0.
 *
 */
typedef union BCM6300_A0_ARLA_MACVID_ENTRY0r_s {
	uint32_t v[2];
	uint32_t arla_macvid_entry0[2];
	uint32_t _arla_macvid_entry0;
} BCM6300_A0_ARLA_MACVID_ENTRY0r_t;

#define BCM6300_A0_ARLA_MACVID_ENTRY0r_CLR(r) CDK_MEMSET(&((r)._arla_macvid_entry0), 0, sizeof(BCM6300_A0_ARLA_MACVID_ENTRY0r_t))
#define BCM6300_A0_ARLA_MACVID_ENTRY0r_SET(r,i,d) (r).arla_macvid_entry0[i] = d
#define BCM6300_A0_ARLA_MACVID_ENTRY0r_GET(r,i) (r).arla_macvid_entry0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_ARLA_MACVID_ENTRY0r_ARL_MACADDRf_GET(r,a) cdk_field_get((r).arla_macvid_entry0,0,47,a)
#define BCM6300_A0_ARLA_MACVID_ENTRY0r_ARL_MACADDRf_SET(r,a) cdk_field_set((r).arla_macvid_entry0,0,47,a)
#define BCM6300_A0_ARLA_MACVID_ENTRY0r_VID_Rf_GET(r) ((((r).arla_macvid_entry0[1]) >> 16) & 0xfff)
#define BCM6300_A0_ARLA_MACVID_ENTRY0r_VID_Rf_SET(r,f) (r).arla_macvid_entry0[1]=(((r).arla_macvid_entry0[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM6300_A0_ARLA_MACVID_ENTRY0r_RESERVED_Rf_GET(r) ((((r).arla_macvid_entry0[1]) >> 28) & 0xf)
#define BCM6300_A0_ARLA_MACVID_ENTRY0r_RESERVED_Rf_SET(r,f) (r).arla_macvid_entry0[1]=(((r).arla_macvid_entry0[1] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access ARLA_MACVID_ENTRY0.
 *
 */
#define BCM6300_A0_READ_ARLA_MACVID_ENTRY0r(u,r) cdk_robo_reg_read(u,BCM6300_A0_ARLA_MACVID_ENTRY0r,(r._arla_macvid_entry0),8)
#define BCM6300_A0_WRITE_ARLA_MACVID_ENTRY0r(u,r) cdk_robo_reg_write(u,BCM6300_A0_ARLA_MACVID_ENTRY0r,&(r._arla_macvid_entry0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_MACVID_ENTRY0r BCM6300_A0_ARLA_MACVID_ENTRY0r
#define ARLA_MACVID_ENTRY0r_SIZE BCM6300_A0_ARLA_MACVID_ENTRY0r_SIZE
typedef BCM6300_A0_ARLA_MACVID_ENTRY0r_t ARLA_MACVID_ENTRY0r_t;
#define ARLA_MACVID_ENTRY0r_CLR BCM6300_A0_ARLA_MACVID_ENTRY0r_CLR
#define ARLA_MACVID_ENTRY0r_SET BCM6300_A0_ARLA_MACVID_ENTRY0r_SET
#define ARLA_MACVID_ENTRY0r_GET BCM6300_A0_ARLA_MACVID_ENTRY0r_GET
#define ARLA_MACVID_ENTRY0r_ARL_MACADDRf_GET BCM6300_A0_ARLA_MACVID_ENTRY0r_ARL_MACADDRf_GET
#define ARLA_MACVID_ENTRY0r_ARL_MACADDRf_SET BCM6300_A0_ARLA_MACVID_ENTRY0r_ARL_MACADDRf_SET
#define ARLA_MACVID_ENTRY0r_VID_Rf_GET BCM6300_A0_ARLA_MACVID_ENTRY0r_VID_Rf_GET
#define ARLA_MACVID_ENTRY0r_VID_Rf_SET BCM6300_A0_ARLA_MACVID_ENTRY0r_VID_Rf_SET
#define ARLA_MACVID_ENTRY0r_RESERVED_Rf_GET BCM6300_A0_ARLA_MACVID_ENTRY0r_RESERVED_Rf_GET
#define ARLA_MACVID_ENTRY0r_RESERVED_Rf_SET BCM6300_A0_ARLA_MACVID_ENTRY0r_RESERVED_Rf_SET
#define READ_ARLA_MACVID_ENTRY0r BCM6300_A0_READ_ARLA_MACVID_ENTRY0r
#define WRITE_ARLA_MACVID_ENTRY0r BCM6300_A0_WRITE_ARLA_MACVID_ENTRY0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_ARLA_MACVID_ENTRY0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  ARLA_RWCTL
 * BLOCKS:   SYS
 * DESC:     ARL Read/Write Control Register
 * SIZE:     8
 * FIELDS:
 *     ARL_RW           ARL Read/Write.1 = Read,0 = Write.
 *     RESERVED_R       Reserved
 *     ARL_STRTDN       Start/Done Command.Write as 1 to initiate a read or write command, after first loading the MAC_ADDR_INDX register with the MAC address for which the ARL entry is to be read or written.The BCM5388 will reset the bit to indicate a write operation completed, or a read operation has completed and data from the bin entry is available in ARL Entry 0/1 Note that both ARL Entry 0 and 1 are both always read/written by the BCM5388 when accessing the address table locations in memory.
 *
 ******************************************************************************/
#define BCM6300_A0_ARLA_RWCTLr 0x00000500

#define BCM6300_A0_ARLA_RWCTLr_SIZE 1

/*
 * This structure should be used to declare and program ARLA_RWCTL.
 *
 */
typedef union BCM6300_A0_ARLA_RWCTLr_s {
	uint32_t v[1];
	uint32_t arla_rwctl[1];
	uint32_t _arla_rwctl;
} BCM6300_A0_ARLA_RWCTLr_t;

#define BCM6300_A0_ARLA_RWCTLr_CLR(r) (r).arla_rwctl[0] = 0
#define BCM6300_A0_ARLA_RWCTLr_SET(r,d) (r).arla_rwctl[0] = d
#define BCM6300_A0_ARLA_RWCTLr_GET(r) (r).arla_rwctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_ARLA_RWCTLr_ARL_RWf_GET(r) (((r).arla_rwctl[0]) & 0x1)
#define BCM6300_A0_ARLA_RWCTLr_ARL_RWf_SET(r,f) (r).arla_rwctl[0]=(((r).arla_rwctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM6300_A0_ARLA_RWCTLr_RESERVED_Rf_GET(r) ((((r).arla_rwctl[0]) >> 1) & 0x3f)
#define BCM6300_A0_ARLA_RWCTLr_RESERVED_Rf_SET(r,f) (r).arla_rwctl[0]=(((r).arla_rwctl[0] & ~((uint32_t)0x3f << 1)) | ((((uint32_t)f) & 0x3f) << 1))
#define BCM6300_A0_ARLA_RWCTLr_ARL_STRTDNf_GET(r) ((((r).arla_rwctl[0]) >> 7) & 0x1)
#define BCM6300_A0_ARLA_RWCTLr_ARL_STRTDNf_SET(r,f) (r).arla_rwctl[0]=(((r).arla_rwctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access ARLA_RWCTL.
 *
 */
#define BCM6300_A0_READ_ARLA_RWCTLr(u,r) cdk_robo_reg_read(u,BCM6300_A0_ARLA_RWCTLr,(r._arla_rwctl),1)
#define BCM6300_A0_WRITE_ARLA_RWCTLr(u,r) cdk_robo_reg_write(u,BCM6300_A0_ARLA_RWCTLr,&(r._arla_rwctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_RWCTLr BCM6300_A0_ARLA_RWCTLr
#define ARLA_RWCTLr_SIZE BCM6300_A0_ARLA_RWCTLr_SIZE
typedef BCM6300_A0_ARLA_RWCTLr_t ARLA_RWCTLr_t;
#define ARLA_RWCTLr_CLR BCM6300_A0_ARLA_RWCTLr_CLR
#define ARLA_RWCTLr_SET BCM6300_A0_ARLA_RWCTLr_SET
#define ARLA_RWCTLr_GET BCM6300_A0_ARLA_RWCTLr_GET
#define ARLA_RWCTLr_ARL_RWf_GET BCM6300_A0_ARLA_RWCTLr_ARL_RWf_GET
#define ARLA_RWCTLr_ARL_RWf_SET BCM6300_A0_ARLA_RWCTLr_ARL_RWf_SET
#define ARLA_RWCTLr_RESERVED_Rf_GET BCM6300_A0_ARLA_RWCTLr_RESERVED_Rf_GET
#define ARLA_RWCTLr_RESERVED_Rf_SET BCM6300_A0_ARLA_RWCTLr_RESERVED_Rf_SET
#define ARLA_RWCTLr_ARL_STRTDNf_GET BCM6300_A0_ARLA_RWCTLr_ARL_STRTDNf_GET
#define ARLA_RWCTLr_ARL_STRTDNf_SET BCM6300_A0_ARLA_RWCTLr_ARL_STRTDNf_SET
#define READ_ARLA_RWCTLr BCM6300_A0_READ_ARLA_RWCTLr
#define WRITE_ARLA_RWCTLr BCM6300_A0_WRITE_ARLA_RWCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_ARLA_RWCTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  ARLA_SRCH_ADR
 * BLOCKS:   SYS
 * DESC:     ARL Search Address Register
 * SIZE:     16
 * FIELDS:
 *     ARLA_SRCH_ADR    ARL Address.15 bit internal representation of the address of the ARL entry currently being accessed by the ARL search routine.This is not a direct address of the ARL location, and is intended for factory test/diagnostic use only.
 *     ARLA_SRCH_ADR_EN ARL Address Valid.Indicates the lower 15 bits of this register contain a valid internal representation of the ARL entry currently being accessed. Intended for factory test/diagnostic use only.
 *
 ******************************************************************************/
#define BCM6300_A0_ARLA_SRCH_ADRr 0x00000532

#define BCM6300_A0_ARLA_SRCH_ADRr_SIZE 2

/*
 * This structure should be used to declare and program ARLA_SRCH_ADR.
 *
 */
typedef union BCM6300_A0_ARLA_SRCH_ADRr_s {
	uint32_t v[1];
	uint32_t arla_srch_adr[1];
	uint32_t _arla_srch_adr;
} BCM6300_A0_ARLA_SRCH_ADRr_t;

#define BCM6300_A0_ARLA_SRCH_ADRr_CLR(r) (r).arla_srch_adr[0] = 0
#define BCM6300_A0_ARLA_SRCH_ADRr_SET(r,d) (r).arla_srch_adr[0] = d
#define BCM6300_A0_ARLA_SRCH_ADRr_GET(r) (r).arla_srch_adr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADRf_GET(r) (((r).arla_srch_adr[0]) & 0x7fff)
#define BCM6300_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADRf_SET(r,f) (r).arla_srch_adr[0]=(((r).arla_srch_adr[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff))
#define BCM6300_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADR_ENf_GET(r) ((((r).arla_srch_adr[0]) >> 15) & 0x1)
#define BCM6300_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADR_ENf_SET(r,f) (r).arla_srch_adr[0]=(((r).arla_srch_adr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access ARLA_SRCH_ADR.
 *
 */
#define BCM6300_A0_READ_ARLA_SRCH_ADRr(u,r) cdk_robo_reg_read(u,BCM6300_A0_ARLA_SRCH_ADRr,(r._arla_srch_adr),2)
#define BCM6300_A0_WRITE_ARLA_SRCH_ADRr(u,r) cdk_robo_reg_write(u,BCM6300_A0_ARLA_SRCH_ADRr,&(r._arla_srch_adr),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_SRCH_ADRr BCM6300_A0_ARLA_SRCH_ADRr
#define ARLA_SRCH_ADRr_SIZE BCM6300_A0_ARLA_SRCH_ADRr_SIZE
typedef BCM6300_A0_ARLA_SRCH_ADRr_t ARLA_SRCH_ADRr_t;
#define ARLA_SRCH_ADRr_CLR BCM6300_A0_ARLA_SRCH_ADRr_CLR
#define ARLA_SRCH_ADRr_SET BCM6300_A0_ARLA_SRCH_ADRr_SET
#define ARLA_SRCH_ADRr_GET BCM6300_A0_ARLA_SRCH_ADRr_GET
#define ARLA_SRCH_ADRr_ARLA_SRCH_ADRf_GET BCM6300_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADRf_GET
#define ARLA_SRCH_ADRr_ARLA_SRCH_ADRf_SET BCM6300_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADRf_SET
#define ARLA_SRCH_ADRr_ARLA_SRCH_ADR_ENf_GET BCM6300_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADR_ENf_GET
#define ARLA_SRCH_ADRr_ARLA_SRCH_ADR_ENf_SET BCM6300_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADR_ENf_SET
#define READ_ARLA_SRCH_ADRr BCM6300_A0_READ_ARLA_SRCH_ADRr
#define WRITE_ARLA_SRCH_ADRr BCM6300_A0_WRITE_ARLA_SRCH_ADRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_ARLA_SRCH_ADRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  ARLA_SRCH_CTL
 * BLOCKS:   SYS
 * DESC:     ARL Search Control Register
 * SIZE:     8
 * FIELDS:
 *     ARLA_SRCH_VLID   
 *     RESERVED_R       Reserved
 *     ARLA_SRCH_STDN   Start/Done.Write as 1 to initiate a sequential search of the ARL entries, returning each entry that is currently occupied (Valid = 1 and AGE = 0) in the ARL Search Result register. Reading the ARL Search Result Register causes the ARL search to continue.The BCM5388 will clear this bit to indicate the entire ARL entry database has been searched.)
 *
 ******************************************************************************/
#define BCM6300_A0_ARLA_SRCH_CTLr 0x00000530

#define BCM6300_A0_ARLA_SRCH_CTLr_SIZE 2

/*
 * This structure should be used to declare and program ARLA_SRCH_CTL.
 *
 */
typedef union BCM6300_A0_ARLA_SRCH_CTLr_s {
	uint32_t v[1];
	uint32_t arla_srch_ctl[1];
	uint32_t _arla_srch_ctl;
} BCM6300_A0_ARLA_SRCH_CTLr_t;

#define BCM6300_A0_ARLA_SRCH_CTLr_CLR(r) (r).arla_srch_ctl[0] = 0
#define BCM6300_A0_ARLA_SRCH_CTLr_SET(r,d) (r).arla_srch_ctl[0] = d
#define BCM6300_A0_ARLA_SRCH_CTLr_GET(r) (r).arla_srch_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_ARLA_SRCH_CTLr_ARLA_SRCH_VLIDf_GET(r) (((r).arla_srch_ctl[0]) & 0x1)
#define BCM6300_A0_ARLA_SRCH_CTLr_ARLA_SRCH_VLIDf_SET(r,f) (r).arla_srch_ctl[0]=(((r).arla_srch_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM6300_A0_ARLA_SRCH_CTLr_RESERVED_Rf_GET(r) ((((r).arla_srch_ctl[0]) >> 1) & 0x3f)
#define BCM6300_A0_ARLA_SRCH_CTLr_RESERVED_Rf_SET(r,f) (r).arla_srch_ctl[0]=(((r).arla_srch_ctl[0] & ~((uint32_t)0x3f << 1)) | ((((uint32_t)f) & 0x3f) << 1))
#define BCM6300_A0_ARLA_SRCH_CTLr_ARLA_SRCH_STDNf_GET(r) ((((r).arla_srch_ctl[0]) >> 7) & 0x1)
#define BCM6300_A0_ARLA_SRCH_CTLr_ARLA_SRCH_STDNf_SET(r,f) (r).arla_srch_ctl[0]=(((r).arla_srch_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access ARLA_SRCH_CTL.
 *
 */
#define BCM6300_A0_READ_ARLA_SRCH_CTLr(u,r) cdk_robo_reg_read(u,BCM6300_A0_ARLA_SRCH_CTLr,(r._arla_srch_ctl),2)
#define BCM6300_A0_WRITE_ARLA_SRCH_CTLr(u,r) cdk_robo_reg_write(u,BCM6300_A0_ARLA_SRCH_CTLr,&(r._arla_srch_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_SRCH_CTLr BCM6300_A0_ARLA_SRCH_CTLr
#define ARLA_SRCH_CTLr_SIZE BCM6300_A0_ARLA_SRCH_CTLr_SIZE
typedef BCM6300_A0_ARLA_SRCH_CTLr_t ARLA_SRCH_CTLr_t;
#define ARLA_SRCH_CTLr_CLR BCM6300_A0_ARLA_SRCH_CTLr_CLR
#define ARLA_SRCH_CTLr_SET BCM6300_A0_ARLA_SRCH_CTLr_SET
#define ARLA_SRCH_CTLr_GET BCM6300_A0_ARLA_SRCH_CTLr_GET
#define ARLA_SRCH_CTLr_ARLA_SRCH_VLIDf_GET BCM6300_A0_ARLA_SRCH_CTLr_ARLA_SRCH_VLIDf_GET
#define ARLA_SRCH_CTLr_ARLA_SRCH_VLIDf_SET BCM6300_A0_ARLA_SRCH_CTLr_ARLA_SRCH_VLIDf_SET
#define ARLA_SRCH_CTLr_RESERVED_Rf_GET BCM6300_A0_ARLA_SRCH_CTLr_RESERVED_Rf_GET
#define ARLA_SRCH_CTLr_RESERVED_Rf_SET BCM6300_A0_ARLA_SRCH_CTLr_RESERVED_Rf_SET
#define ARLA_SRCH_CTLr_ARLA_SRCH_STDNf_GET BCM6300_A0_ARLA_SRCH_CTLr_ARLA_SRCH_STDNf_GET
#define ARLA_SRCH_CTLr_ARLA_SRCH_STDNf_SET BCM6300_A0_ARLA_SRCH_CTLr_ARLA_SRCH_STDNf_SET
#define READ_ARLA_SRCH_CTLr BCM6300_A0_READ_ARLA_SRCH_CTLr
#define WRITE_ARLA_SRCH_CTLr BCM6300_A0_WRITE_ARLA_SRCH_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_ARLA_SRCH_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  ARLA_SRCH_RSLT
 * BLOCKS:   SYS
 * DESC:     ARL Search Result Register
 * SIZE:     16
 * FIELDS:
 *     PORTID_R         Port Identification.The port number which identifies where the station with unique MACADDR0 is connected.Forward Port Map.Multicast Group Forward Portmap.If(MACADDR0[47] ==1) FWD_PRT_MAP[3:0]Bit 3:0 = Chip 0 Port 3:0
 *     RESERVED_0R      Reserved.If(MACADDR[47] ==1) FWD_PRT_MAP[7:4].Multicast Group Forward Portmap.Bit 7:4= Chip 0 Port7~Port4.
 *     ARLA_SRCH_RSLT_CON ARL control bit for arl control mode enhancement.
 *     ARLA_SRCH_RSLT_PRI Priority Bit For MAC based QOS.
 *     ARLA_SRCH_RSLT_AGE Age.Set to indicate that an address entry has been learned or accessed.Reset by the internal aging algorithm. If the internal aging process detects a Valid entry has remained unused for the period set by the AGE_TIME, and the entry has not been marked as Static, the entry will have the Valid bit cleared. The Age bit is ignored if the entry has been marked as Static.Multicast group Forward Portmap bit8 for CPU.
 *     ARLA_SRCH_RSLT_STATIC Static.Set to indicate that the entry is controlled by the external management processor, and automatic learning and aging of the entry will not take place.When cleared, the internal learning and aging process will control the validity of the entry.
 *     ARLA_SRCH_RSLT_VLID Valid.Set to indicate that a valid MAC address is stored in the MACADDR field, and that the entry has not aged out or been freed by the management processor.Reset when an entry is empty, the address has been aged out by the internal aging process, or the external management processor has invalidated the entry. Automatic learning will take place if an address location is not valid and has not been marked as static.
 *
 ******************************************************************************/
#define BCM6300_A0_ARLA_SRCH_RSLTr 0x0000053c

#define BCM6300_A0_ARLA_SRCH_RSLTr_SIZE 2

/*
 * This structure should be used to declare and program ARLA_SRCH_RSLT.
 *
 */
typedef union BCM6300_A0_ARLA_SRCH_RSLTr_s {
	uint32_t v[1];
	uint32_t arla_srch_rslt[1];
	uint32_t _arla_srch_rslt;
} BCM6300_A0_ARLA_SRCH_RSLTr_t;

#define BCM6300_A0_ARLA_SRCH_RSLTr_CLR(r) (r).arla_srch_rslt[0] = 0
#define BCM6300_A0_ARLA_SRCH_RSLTr_SET(r,d) (r).arla_srch_rslt[0] = d
#define BCM6300_A0_ARLA_SRCH_RSLTr_GET(r) (r).arla_srch_rslt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_ARLA_SRCH_RSLTr_PORTID_Rf_GET(r) ((((r).arla_srch_rslt[0]) >> 1) & 0xf)
#define BCM6300_A0_ARLA_SRCH_RSLTr_PORTID_Rf_SET(r,f) (r).arla_srch_rslt[0]=(((r).arla_srch_rslt[0] & ~((uint32_t)0xf << 1)) | ((((uint32_t)f) & 0xf) << 1))
#define BCM6300_A0_ARLA_SRCH_RSLTr_RESERVED_0Rf_GET(r) ((((r).arla_srch_rslt[0]) >> 4) & 0xf)
#define BCM6300_A0_ARLA_SRCH_RSLTr_RESERVED_0Rf_SET(r,f) (r).arla_srch_rslt[0]=(((r).arla_srch_rslt[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM6300_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_CONf_GET(r) ((((r).arla_srch_rslt[0]) >> 8) & 0x3)
#define BCM6300_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_CONf_SET(r,f) (r).arla_srch_rslt[0]=(((r).arla_srch_rslt[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM6300_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIf_GET(r) ((((r).arla_srch_rslt[0]) >> 10) & 0x7)
#define BCM6300_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIf_SET(r,f) (r).arla_srch_rslt[0]=(((r).arla_srch_rslt[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM6300_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_AGEf_GET(r) ((((r).arla_srch_rslt[0]) >> 13) & 0x1)
#define BCM6300_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_AGEf_SET(r,f) (r).arla_srch_rslt[0]=(((r).arla_srch_rslt[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM6300_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_GET(r) ((((r).arla_srch_rslt[0]) >> 14) & 0x1)
#define BCM6300_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_SET(r,f) (r).arla_srch_rslt[0]=(((r).arla_srch_rslt[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM6300_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_GET(r) ((((r).arla_srch_rslt[0]) >> 15) & 0x1)
#define BCM6300_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_SET(r,f) (r).arla_srch_rslt[0]=(((r).arla_srch_rslt[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access ARLA_SRCH_RSLT.
 *
 */
#define BCM6300_A0_READ_ARLA_SRCH_RSLTr(u,r) cdk_robo_reg_read(u,BCM6300_A0_ARLA_SRCH_RSLTr,(r._arla_srch_rslt),2)
#define BCM6300_A0_WRITE_ARLA_SRCH_RSLTr(u,r) cdk_robo_reg_write(u,BCM6300_A0_ARLA_SRCH_RSLTr,&(r._arla_srch_rslt),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_SRCH_RSLTr BCM6300_A0_ARLA_SRCH_RSLTr
#define ARLA_SRCH_RSLTr_SIZE BCM6300_A0_ARLA_SRCH_RSLTr_SIZE
typedef BCM6300_A0_ARLA_SRCH_RSLTr_t ARLA_SRCH_RSLTr_t;
#define ARLA_SRCH_RSLTr_CLR BCM6300_A0_ARLA_SRCH_RSLTr_CLR
#define ARLA_SRCH_RSLTr_SET BCM6300_A0_ARLA_SRCH_RSLTr_SET
#define ARLA_SRCH_RSLTr_GET BCM6300_A0_ARLA_SRCH_RSLTr_GET
#define ARLA_SRCH_RSLTr_PORTID_Rf_GET BCM6300_A0_ARLA_SRCH_RSLTr_PORTID_Rf_GET
#define ARLA_SRCH_RSLTr_PORTID_Rf_SET BCM6300_A0_ARLA_SRCH_RSLTr_PORTID_Rf_SET
#define ARLA_SRCH_RSLTr_RESERVED_0Rf_GET BCM6300_A0_ARLA_SRCH_RSLTr_RESERVED_0Rf_GET
#define ARLA_SRCH_RSLTr_RESERVED_0Rf_SET BCM6300_A0_ARLA_SRCH_RSLTr_RESERVED_0Rf_SET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_CONf_GET BCM6300_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_CONf_GET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_CONf_SET BCM6300_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_CONf_SET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIf_GET BCM6300_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIf_GET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIf_SET BCM6300_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIf_SET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_AGEf_GET BCM6300_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_AGEf_GET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_AGEf_SET BCM6300_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_AGEf_SET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_GET BCM6300_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_GET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_SET BCM6300_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_SET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_GET BCM6300_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_GET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_SET BCM6300_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_SET
#define READ_ARLA_SRCH_RSLTr BCM6300_A0_READ_ARLA_SRCH_RSLTr
#define WRITE_ARLA_SRCH_RSLTr BCM6300_A0_WRITE_ARLA_SRCH_RSLTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_ARLA_SRCH_RSLTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  ARLA_SRCH_RSLT_MACVID
 * BLOCKS:   SYS
 * DESC:     ARL Search MAC/VID Result Register
 * SIZE:     64
 * FIELDS:
 *     ARLA_SRCH_MACADDR MAC Address.
 *     ARLA_SRCH_RSLT_VID ARL SEARCH VID RESULT.The ARL Search VID Result Registers Keep the VID field in Valid ARL Entry indicated by ARL Search Function.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM6300_A0_ARLA_SRCH_RSLT_MACVIDr 0x00000534

#define BCM6300_A0_ARLA_SRCH_RSLT_MACVIDr_SIZE 8

/*
 * This structure should be used to declare and program ARLA_SRCH_RSLT_MACVID.
 *
 */
typedef union BCM6300_A0_ARLA_SRCH_RSLT_MACVIDr_s {
	uint32_t v[2];
	uint32_t arla_srch_rslt_macvid[2];
	uint32_t _arla_srch_rslt_macvid;
} BCM6300_A0_ARLA_SRCH_RSLT_MACVIDr_t;

#define BCM6300_A0_ARLA_SRCH_RSLT_MACVIDr_CLR(r) CDK_MEMSET(&((r)._arla_srch_rslt_macvid), 0, sizeof(BCM6300_A0_ARLA_SRCH_RSLT_MACVIDr_t))
#define BCM6300_A0_ARLA_SRCH_RSLT_MACVIDr_SET(r,i,d) (r).arla_srch_rslt_macvid[i] = d
#define BCM6300_A0_ARLA_SRCH_RSLT_MACVIDr_GET(r,i) (r).arla_srch_rslt_macvid[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_ARLA_SRCH_RSLT_MACVIDr_ARLA_SRCH_MACADDRf_GET(r,a) cdk_field_get((r).arla_srch_rslt_macvid,0,47,a)
#define BCM6300_A0_ARLA_SRCH_RSLT_MACVIDr_ARLA_SRCH_MACADDRf_SET(r,a) cdk_field_set((r).arla_srch_rslt_macvid,0,47,a)
#define BCM6300_A0_ARLA_SRCH_RSLT_MACVIDr_ARLA_SRCH_RSLT_VIDf_GET(r) ((((r).arla_srch_rslt_macvid[1]) >> 16) & 0xfff)
#define BCM6300_A0_ARLA_SRCH_RSLT_MACVIDr_ARLA_SRCH_RSLT_VIDf_SET(r,f) (r).arla_srch_rslt_macvid[1]=(((r).arla_srch_rslt_macvid[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM6300_A0_ARLA_SRCH_RSLT_MACVIDr_RESERVED_Rf_GET(r) ((((r).arla_srch_rslt_macvid[1]) >> 28) & 0xf)
#define BCM6300_A0_ARLA_SRCH_RSLT_MACVIDr_RESERVED_Rf_SET(r,f) (r).arla_srch_rslt_macvid[1]=(((r).arla_srch_rslt_macvid[1] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access ARLA_SRCH_RSLT_MACVID.
 *
 */
#define BCM6300_A0_READ_ARLA_SRCH_RSLT_MACVIDr(u,r) cdk_robo_reg_read(u,BCM6300_A0_ARLA_SRCH_RSLT_MACVIDr,(r._arla_srch_rslt_macvid),8)
#define BCM6300_A0_WRITE_ARLA_SRCH_RSLT_MACVIDr(u,r) cdk_robo_reg_write(u,BCM6300_A0_ARLA_SRCH_RSLT_MACVIDr,&(r._arla_srch_rslt_macvid),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_SRCH_RSLT_MACVIDr BCM6300_A0_ARLA_SRCH_RSLT_MACVIDr
#define ARLA_SRCH_RSLT_MACVIDr_SIZE BCM6300_A0_ARLA_SRCH_RSLT_MACVIDr_SIZE
typedef BCM6300_A0_ARLA_SRCH_RSLT_MACVIDr_t ARLA_SRCH_RSLT_MACVIDr_t;
#define ARLA_SRCH_RSLT_MACVIDr_CLR BCM6300_A0_ARLA_SRCH_RSLT_MACVIDr_CLR
#define ARLA_SRCH_RSLT_MACVIDr_SET BCM6300_A0_ARLA_SRCH_RSLT_MACVIDr_SET
#define ARLA_SRCH_RSLT_MACVIDr_GET BCM6300_A0_ARLA_SRCH_RSLT_MACVIDr_GET
#define ARLA_SRCH_RSLT_MACVIDr_ARLA_SRCH_MACADDRf_GET BCM6300_A0_ARLA_SRCH_RSLT_MACVIDr_ARLA_SRCH_MACADDRf_GET
#define ARLA_SRCH_RSLT_MACVIDr_ARLA_SRCH_MACADDRf_SET BCM6300_A0_ARLA_SRCH_RSLT_MACVIDr_ARLA_SRCH_MACADDRf_SET
#define ARLA_SRCH_RSLT_MACVIDr_ARLA_SRCH_RSLT_VIDf_GET BCM6300_A0_ARLA_SRCH_RSLT_MACVIDr_ARLA_SRCH_RSLT_VIDf_GET
#define ARLA_SRCH_RSLT_MACVIDr_ARLA_SRCH_RSLT_VIDf_SET BCM6300_A0_ARLA_SRCH_RSLT_MACVIDr_ARLA_SRCH_RSLT_VIDf_SET
#define ARLA_SRCH_RSLT_MACVIDr_RESERVED_Rf_GET BCM6300_A0_ARLA_SRCH_RSLT_MACVIDr_RESERVED_Rf_GET
#define ARLA_SRCH_RSLT_MACVIDr_RESERVED_Rf_SET BCM6300_A0_ARLA_SRCH_RSLT_MACVIDr_RESERVED_Rf_SET
#define READ_ARLA_SRCH_RSLT_MACVIDr BCM6300_A0_READ_ARLA_SRCH_RSLT_MACVIDr
#define WRITE_ARLA_SRCH_RSLT_MACVIDr BCM6300_A0_WRITE_ARLA_SRCH_RSLT_MACVIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_ARLA_SRCH_RSLT_MACVIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  ARLA_VID
 * BLOCKS:   SYS
 * DESC:     VID Index Register
 * SIZE:     16
 * FIELDS:
 *     ARLA_VIDTAB_INDX VID Index.The MAC address for which status is to be read or written.By writing the 48 bit SA or DA address upon MAC Address Index, upon 12 bit VID Index Register if 802.1Q is enabled, and initiating a read command, the complete ARL bin location is returned in the ARL Entry 0 locations and VID Entry0. Both ARL entries are 64 bits wide. Both VID entries are 12 bits wide.Initiating a write command will write the contents of ARL Entry 0/1 and VID Entry 0/1 to the specified bin location and will overwrite the current contents of the bin, regardless of the status of the Valid bit(s) in each entry.
 *     ARLA_VIDTAB_RSRV0 Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_ARLA_VIDr 0x00000508

#define BCM6300_A0_ARLA_VIDr_SIZE 2

/*
 * This structure should be used to declare and program ARLA_VID.
 *
 */
typedef union BCM6300_A0_ARLA_VIDr_s {
	uint32_t v[1];
	uint32_t arla_vid[1];
	uint32_t _arla_vid;
} BCM6300_A0_ARLA_VIDr_t;

#define BCM6300_A0_ARLA_VIDr_CLR(r) (r).arla_vid[0] = 0
#define BCM6300_A0_ARLA_VIDr_SET(r,d) (r).arla_vid[0] = d
#define BCM6300_A0_ARLA_VIDr_GET(r) (r).arla_vid[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_ARLA_VIDr_ARLA_VIDTAB_INDXf_GET(r) (((r).arla_vid[0]) & 0xfff)
#define BCM6300_A0_ARLA_VIDr_ARLA_VIDTAB_INDXf_SET(r,f) (r).arla_vid[0]=(((r).arla_vid[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM6300_A0_ARLA_VIDr_ARLA_VIDTAB_RSRV0f_GET(r) ((((r).arla_vid[0]) >> 12) & 0xf)
#define BCM6300_A0_ARLA_VIDr_ARLA_VIDTAB_RSRV0f_SET(r,f) (r).arla_vid[0]=(((r).arla_vid[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access ARLA_VID.
 *
 */
#define BCM6300_A0_READ_ARLA_VIDr(u,r) cdk_robo_reg_read(u,BCM6300_A0_ARLA_VIDr,(r._arla_vid),2)
#define BCM6300_A0_WRITE_ARLA_VIDr(u,r) cdk_robo_reg_write(u,BCM6300_A0_ARLA_VIDr,&(r._arla_vid),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_VIDr BCM6300_A0_ARLA_VIDr
#define ARLA_VIDr_SIZE BCM6300_A0_ARLA_VIDr_SIZE
typedef BCM6300_A0_ARLA_VIDr_t ARLA_VIDr_t;
#define ARLA_VIDr_CLR BCM6300_A0_ARLA_VIDr_CLR
#define ARLA_VIDr_SET BCM6300_A0_ARLA_VIDr_SET
#define ARLA_VIDr_GET BCM6300_A0_ARLA_VIDr_GET
#define ARLA_VIDr_ARLA_VIDTAB_INDXf_GET BCM6300_A0_ARLA_VIDr_ARLA_VIDTAB_INDXf_GET
#define ARLA_VIDr_ARLA_VIDTAB_INDXf_SET BCM6300_A0_ARLA_VIDr_ARLA_VIDTAB_INDXf_SET
#define ARLA_VIDr_ARLA_VIDTAB_RSRV0f_GET BCM6300_A0_ARLA_VIDr_ARLA_VIDTAB_RSRV0f_GET
#define ARLA_VIDr_ARLA_VIDTAB_RSRV0f_SET BCM6300_A0_ARLA_VIDr_ARLA_VIDTAB_RSRV0f_SET
#define READ_ARLA_VIDr BCM6300_A0_READ_ARLA_VIDr
#define WRITE_ARLA_VIDr BCM6300_A0_WRITE_ARLA_VIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_ARLA_VIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  ARLA_VTBL_ADDR
 * BLOCKS:   SYS
 * DESC:     VTBL Address Index Register
 * SIZE:     16
 * FIELDS:
 *     VTBL_ADDR_INDEX  VLAN Table Address Index.The VLAN Table Address Index Register is used to access VLAN Table Entry.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_ARLA_VTBL_ADDRr 0x00000562

#define BCM6300_A0_ARLA_VTBL_ADDRr_SIZE 2

/*
 * This structure should be used to declare and program ARLA_VTBL_ADDR.
 *
 */
typedef union BCM6300_A0_ARLA_VTBL_ADDRr_s {
	uint32_t v[1];
	uint32_t arla_vtbl_addr[1];
	uint32_t _arla_vtbl_addr;
} BCM6300_A0_ARLA_VTBL_ADDRr_t;

#define BCM6300_A0_ARLA_VTBL_ADDRr_CLR(r) (r).arla_vtbl_addr[0] = 0
#define BCM6300_A0_ARLA_VTBL_ADDRr_SET(r,d) (r).arla_vtbl_addr[0] = d
#define BCM6300_A0_ARLA_VTBL_ADDRr_GET(r) (r).arla_vtbl_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_ARLA_VTBL_ADDRr_VTBL_ADDR_INDEXf_GET(r) (((r).arla_vtbl_addr[0]) & 0xfff)
#define BCM6300_A0_ARLA_VTBL_ADDRr_VTBL_ADDR_INDEXf_SET(r,f) (r).arla_vtbl_addr[0]=(((r).arla_vtbl_addr[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM6300_A0_ARLA_VTBL_ADDRr_RESERVED_Rf_GET(r) ((((r).arla_vtbl_addr[0]) >> 12) & 0xf)
#define BCM6300_A0_ARLA_VTBL_ADDRr_RESERVED_Rf_SET(r,f) (r).arla_vtbl_addr[0]=(((r).arla_vtbl_addr[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access ARLA_VTBL_ADDR.
 *
 */
#define BCM6300_A0_READ_ARLA_VTBL_ADDRr(u,r) cdk_robo_reg_read(u,BCM6300_A0_ARLA_VTBL_ADDRr,(r._arla_vtbl_addr),2)
#define BCM6300_A0_WRITE_ARLA_VTBL_ADDRr(u,r) cdk_robo_reg_write(u,BCM6300_A0_ARLA_VTBL_ADDRr,&(r._arla_vtbl_addr),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_VTBL_ADDRr BCM6300_A0_ARLA_VTBL_ADDRr
#define ARLA_VTBL_ADDRr_SIZE BCM6300_A0_ARLA_VTBL_ADDRr_SIZE
typedef BCM6300_A0_ARLA_VTBL_ADDRr_t ARLA_VTBL_ADDRr_t;
#define ARLA_VTBL_ADDRr_CLR BCM6300_A0_ARLA_VTBL_ADDRr_CLR
#define ARLA_VTBL_ADDRr_SET BCM6300_A0_ARLA_VTBL_ADDRr_SET
#define ARLA_VTBL_ADDRr_GET BCM6300_A0_ARLA_VTBL_ADDRr_GET
#define ARLA_VTBL_ADDRr_VTBL_ADDR_INDEXf_GET BCM6300_A0_ARLA_VTBL_ADDRr_VTBL_ADDR_INDEXf_GET
#define ARLA_VTBL_ADDRr_VTBL_ADDR_INDEXf_SET BCM6300_A0_ARLA_VTBL_ADDRr_VTBL_ADDR_INDEXf_SET
#define ARLA_VTBL_ADDRr_RESERVED_Rf_GET BCM6300_A0_ARLA_VTBL_ADDRr_RESERVED_Rf_GET
#define ARLA_VTBL_ADDRr_RESERVED_Rf_SET BCM6300_A0_ARLA_VTBL_ADDRr_RESERVED_Rf_SET
#define READ_ARLA_VTBL_ADDRr BCM6300_A0_READ_ARLA_VTBL_ADDRr
#define WRITE_ARLA_VTBL_ADDRr BCM6300_A0_WRITE_ARLA_VTBL_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_ARLA_VTBL_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  ARLA_VTBL_ENTRY
 * BLOCKS:   SYS
 * DESC:     VTBL Address Index Register
 * SIZE:     32
 * FIELDS:
 *     FWD_MAP          Forward PORT MAP.The VLAN-tagged Frame is allowed to be forwarded to the destination ports corresponding bits set in the Map.Bits7-0: Port 7-0.Bit8: Management Port.
 *     UNTAG_MAP        Untag Port Map.The VLAN-tagged Frame forward to the destination ports corresponding bits set in the Map will be untagged.Bits7-0: Port 7-0.Bit8: Management Port.
 *     MSPT_INDEX       Index for 16 spanning tree.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_ARLA_VTBL_ENTRYr 0x00000564

#define BCM6300_A0_ARLA_VTBL_ENTRYr_SIZE 4

/*
 * This structure should be used to declare and program ARLA_VTBL_ENTRY.
 *
 */
typedef union BCM6300_A0_ARLA_VTBL_ENTRYr_s {
	uint32_t v[1];
	uint32_t arla_vtbl_entry[1];
	uint32_t _arla_vtbl_entry;
} BCM6300_A0_ARLA_VTBL_ENTRYr_t;

#define BCM6300_A0_ARLA_VTBL_ENTRYr_CLR(r) (r).arla_vtbl_entry[0] = 0
#define BCM6300_A0_ARLA_VTBL_ENTRYr_SET(r,d) (r).arla_vtbl_entry[0] = d
#define BCM6300_A0_ARLA_VTBL_ENTRYr_GET(r) (r).arla_vtbl_entry[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_ARLA_VTBL_ENTRYr_FWD_MAPf_GET(r) (((r).arla_vtbl_entry[0]) & 0x1ff)
#define BCM6300_A0_ARLA_VTBL_ENTRYr_FWD_MAPf_SET(r,f) (r).arla_vtbl_entry[0]=(((r).arla_vtbl_entry[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_ARLA_VTBL_ENTRYr_UNTAG_MAPf_GET(r) ((((r).arla_vtbl_entry[0]) >> 9) & 0x1ff)
#define BCM6300_A0_ARLA_VTBL_ENTRYr_UNTAG_MAPf_SET(r,f) (r).arla_vtbl_entry[0]=(((r).arla_vtbl_entry[0] & ~((uint32_t)0x1ff << 9)) | ((((uint32_t)f) & 0x1ff) << 9))
#define BCM6300_A0_ARLA_VTBL_ENTRYr_MSPT_INDEXf_GET(r) ((((r).arla_vtbl_entry[0]) >> 18) & 0xf)
#define BCM6300_A0_ARLA_VTBL_ENTRYr_MSPT_INDEXf_SET(r,f) (r).arla_vtbl_entry[0]=(((r).arla_vtbl_entry[0] & ~((uint32_t)0xf << 18)) | ((((uint32_t)f) & 0xf) << 18))
#define BCM6300_A0_ARLA_VTBL_ENTRYr_RESERVED_Rf_GET(r) ((((r).arla_vtbl_entry[0]) >> 22) & 0x3ff)
#define BCM6300_A0_ARLA_VTBL_ENTRYr_RESERVED_Rf_SET(r,f) (r).arla_vtbl_entry[0]=(((r).arla_vtbl_entry[0] & ~((uint32_t)0x3ff << 22)) | ((((uint32_t)f) & 0x3ff) << 22))

/*
 * These macros can be used to access ARLA_VTBL_ENTRY.
 *
 */
#define BCM6300_A0_READ_ARLA_VTBL_ENTRYr(u,r) cdk_robo_reg_read(u,BCM6300_A0_ARLA_VTBL_ENTRYr,(r._arla_vtbl_entry),4)
#define BCM6300_A0_WRITE_ARLA_VTBL_ENTRYr(u,r) cdk_robo_reg_write(u,BCM6300_A0_ARLA_VTBL_ENTRYr,&(r._arla_vtbl_entry),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_VTBL_ENTRYr BCM6300_A0_ARLA_VTBL_ENTRYr
#define ARLA_VTBL_ENTRYr_SIZE BCM6300_A0_ARLA_VTBL_ENTRYr_SIZE
typedef BCM6300_A0_ARLA_VTBL_ENTRYr_t ARLA_VTBL_ENTRYr_t;
#define ARLA_VTBL_ENTRYr_CLR BCM6300_A0_ARLA_VTBL_ENTRYr_CLR
#define ARLA_VTBL_ENTRYr_SET BCM6300_A0_ARLA_VTBL_ENTRYr_SET
#define ARLA_VTBL_ENTRYr_GET BCM6300_A0_ARLA_VTBL_ENTRYr_GET
#define ARLA_VTBL_ENTRYr_FWD_MAPf_GET BCM6300_A0_ARLA_VTBL_ENTRYr_FWD_MAPf_GET
#define ARLA_VTBL_ENTRYr_FWD_MAPf_SET BCM6300_A0_ARLA_VTBL_ENTRYr_FWD_MAPf_SET
#define ARLA_VTBL_ENTRYr_UNTAG_MAPf_GET BCM6300_A0_ARLA_VTBL_ENTRYr_UNTAG_MAPf_GET
#define ARLA_VTBL_ENTRYr_UNTAG_MAPf_SET BCM6300_A0_ARLA_VTBL_ENTRYr_UNTAG_MAPf_SET
#define ARLA_VTBL_ENTRYr_MSPT_INDEXf_GET BCM6300_A0_ARLA_VTBL_ENTRYr_MSPT_INDEXf_GET
#define ARLA_VTBL_ENTRYr_MSPT_INDEXf_SET BCM6300_A0_ARLA_VTBL_ENTRYr_MSPT_INDEXf_SET
#define ARLA_VTBL_ENTRYr_RESERVED_Rf_GET BCM6300_A0_ARLA_VTBL_ENTRYr_RESERVED_Rf_GET
#define ARLA_VTBL_ENTRYr_RESERVED_Rf_SET BCM6300_A0_ARLA_VTBL_ENTRYr_RESERVED_Rf_SET
#define READ_ARLA_VTBL_ENTRYr BCM6300_A0_READ_ARLA_VTBL_ENTRYr
#define WRITE_ARLA_VTBL_ENTRYr BCM6300_A0_WRITE_ARLA_VTBL_ENTRYr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_ARLA_VTBL_ENTRYr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  ARLA_VTBL_RWCTRL
 * BLOCKS:   SYS
 * DESC:     VTBL Read/Write Control Register
 * SIZE:     8
 * FIELDS:
 *     ARLA_VTBL_RW     VTBL Read/Write1 = Read0 = Write
 *     RESERVED_R       Reserved
 *     ARLA_VTBL_STDN   Start/Done.Write as 1 to initiate a sequential search of the ARL entries, returning each entry that is currently occupied (Valid = 1 and AGE = 0) in the ARL Search Result register. Reading the ARL Search Result Register causes the ARL search to continue.The BCM5388 will clear this bit to indicate the entire ARL entry database has been searched.)
 *
 ******************************************************************************/
#define BCM6300_A0_ARLA_VTBL_RWCTRLr 0x00000560

#define BCM6300_A0_ARLA_VTBL_RWCTRLr_SIZE 1

/*
 * This structure should be used to declare and program ARLA_VTBL_RWCTRL.
 *
 */
typedef union BCM6300_A0_ARLA_VTBL_RWCTRLr_s {
	uint32_t v[1];
	uint32_t arla_vtbl_rwctrl[1];
	uint32_t _arla_vtbl_rwctrl;
} BCM6300_A0_ARLA_VTBL_RWCTRLr_t;

#define BCM6300_A0_ARLA_VTBL_RWCTRLr_CLR(r) (r).arla_vtbl_rwctrl[0] = 0
#define BCM6300_A0_ARLA_VTBL_RWCTRLr_SET(r,d) (r).arla_vtbl_rwctrl[0] = d
#define BCM6300_A0_ARLA_VTBL_RWCTRLr_GET(r) (r).arla_vtbl_rwctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_RWf_GET(r) (((r).arla_vtbl_rwctrl[0]) & 0x1)
#define BCM6300_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_RWf_SET(r,f) (r).arla_vtbl_rwctrl[0]=(((r).arla_vtbl_rwctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM6300_A0_ARLA_VTBL_RWCTRLr_RESERVED_Rf_GET(r) ((((r).arla_vtbl_rwctrl[0]) >> 1) & 0x3f)
#define BCM6300_A0_ARLA_VTBL_RWCTRLr_RESERVED_Rf_SET(r,f) (r).arla_vtbl_rwctrl[0]=(((r).arla_vtbl_rwctrl[0] & ~((uint32_t)0x3f << 1)) | ((((uint32_t)f) & 0x3f) << 1))
#define BCM6300_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_STDNf_GET(r) ((((r).arla_vtbl_rwctrl[0]) >> 7) & 0x1)
#define BCM6300_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_STDNf_SET(r,f) (r).arla_vtbl_rwctrl[0]=(((r).arla_vtbl_rwctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access ARLA_VTBL_RWCTRL.
 *
 */
#define BCM6300_A0_READ_ARLA_VTBL_RWCTRLr(u,r) cdk_robo_reg_read(u,BCM6300_A0_ARLA_VTBL_RWCTRLr,(r._arla_vtbl_rwctrl),1)
#define BCM6300_A0_WRITE_ARLA_VTBL_RWCTRLr(u,r) cdk_robo_reg_write(u,BCM6300_A0_ARLA_VTBL_RWCTRLr,&(r._arla_vtbl_rwctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_VTBL_RWCTRLr BCM6300_A0_ARLA_VTBL_RWCTRLr
#define ARLA_VTBL_RWCTRLr_SIZE BCM6300_A0_ARLA_VTBL_RWCTRLr_SIZE
typedef BCM6300_A0_ARLA_VTBL_RWCTRLr_t ARLA_VTBL_RWCTRLr_t;
#define ARLA_VTBL_RWCTRLr_CLR BCM6300_A0_ARLA_VTBL_RWCTRLr_CLR
#define ARLA_VTBL_RWCTRLr_SET BCM6300_A0_ARLA_VTBL_RWCTRLr_SET
#define ARLA_VTBL_RWCTRLr_GET BCM6300_A0_ARLA_VTBL_RWCTRLr_GET
#define ARLA_VTBL_RWCTRLr_ARLA_VTBL_RWf_GET BCM6300_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_RWf_GET
#define ARLA_VTBL_RWCTRLr_ARLA_VTBL_RWf_SET BCM6300_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_RWf_SET
#define ARLA_VTBL_RWCTRLr_RESERVED_Rf_GET BCM6300_A0_ARLA_VTBL_RWCTRLr_RESERVED_Rf_GET
#define ARLA_VTBL_RWCTRLr_RESERVED_Rf_SET BCM6300_A0_ARLA_VTBL_RWCTRLr_RESERVED_Rf_SET
#define ARLA_VTBL_RWCTRLr_ARLA_VTBL_STDNf_GET BCM6300_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_STDNf_GET
#define ARLA_VTBL_RWCTRLr_ARLA_VTBL_STDNf_SET BCM6300_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_STDNf_SET
#define READ_ARLA_VTBL_RWCTRLr BCM6300_A0_READ_ARLA_VTBL_RWCTRLr
#define WRITE_ARLA_VTBL_RWCTRLr BCM6300_A0_WRITE_ARLA_VTBL_RWCTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_ARLA_VTBL_RWCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  ASTSSUM
 * BLOCKS:   GPIC0
 * DESC:     Auxiliary Status Summary Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_ASTSSUMr 0x00001032

#define BCM6300_A0_ASTSSUMr_SIZE 2

/*
 * This structure should be used to declare and program ASTSSUM.
 *
 */
typedef union BCM6300_A0_ASTSSUMr_s {
	uint32_t v[1];
	uint32_t astssum[1];
	uint32_t _astssum;
} BCM6300_A0_ASTSSUMr_t;

#define BCM6300_A0_ASTSSUMr_CLR(r) (r).astssum[0] = 0
#define BCM6300_A0_ASTSSUMr_SET(r,d) (r).astssum[0] = d
#define BCM6300_A0_ASTSSUMr_GET(r) (r).astssum[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_ASTSSUMr_RESERVED_Rf_GET(r) (((r).astssum[0]) & 0xffff)
#define BCM6300_A0_ASTSSUMr_RESERVED_Rf_SET(r,f) (r).astssum[0]=(((r).astssum[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access ASTSSUM.
 *
 */
#define BCM6300_A0_READ_ASTSSUMr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_ASTSSUMr,(r._astssum),2)
#define BCM6300_A0_WRITE_ASTSSUMr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_ASTSSUMr,&(r._astssum),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ASTSSUMr BCM6300_A0_ASTSSUMr
#define ASTSSUMr_SIZE BCM6300_A0_ASTSSUMr_SIZE
typedef BCM6300_A0_ASTSSUMr_t ASTSSUMr_t;
#define ASTSSUMr_CLR BCM6300_A0_ASTSSUMr_CLR
#define ASTSSUMr_SET BCM6300_A0_ASTSSUMr_SET
#define ASTSSUMr_GET BCM6300_A0_ASTSSUMr_GET
#define ASTSSUMr_RESERVED_Rf_GET BCM6300_A0_ASTSSUMr_RESERVED_Rf_GET
#define ASTSSUMr_RESERVED_Rf_SET BCM6300_A0_ASTSSUMr_RESERVED_Rf_SET
#define READ_ASTSSUMr BCM6300_A0_READ_ASTSSUMr
#define WRITE_ASTSSUMr BCM6300_A0_WRITE_ASTSSUMr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_ASTSSUMr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  BC_SUP_PKTDROP_CNT_P
 * BLOCKS:   GPIC0
 * DESC:     Port N Suppressed Packet Drop Counter Register
 * SIZE:     32
 * FIELDS:
 *     PK_DROP_CNT      Packet Dropped Count.Record the Dropped packet count for Suppression Drop Count or Jumbo Filtered Count.Reset after the Register has been read.
 *
 ******************************************************************************/
#define BCM6300_A0_BC_SUP_PKTDROP_CNT_Pr 0x00004150

#define BCM6300_A0_BC_SUP_PKTDROP_CNT_Pr_SIZE 4

/*
 * This structure should be used to declare and program BC_SUP_PKTDROP_CNT_P.
 *
 */
typedef union BCM6300_A0_BC_SUP_PKTDROP_CNT_Pr_s {
	uint32_t v[1];
	uint32_t bc_sup_pktdrop_cnt_p[1];
	uint32_t _bc_sup_pktdrop_cnt_p;
} BCM6300_A0_BC_SUP_PKTDROP_CNT_Pr_t;

#define BCM6300_A0_BC_SUP_PKTDROP_CNT_Pr_CLR(r) (r).bc_sup_pktdrop_cnt_p[0] = 0
#define BCM6300_A0_BC_SUP_PKTDROP_CNT_Pr_SET(r,d) (r).bc_sup_pktdrop_cnt_p[0] = d
#define BCM6300_A0_BC_SUP_PKTDROP_CNT_Pr_GET(r) (r).bc_sup_pktdrop_cnt_p[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_BC_SUP_PKTDROP_CNT_Pr_PK_DROP_CNTf_GET(r) ((r).bc_sup_pktdrop_cnt_p[0])
#define BCM6300_A0_BC_SUP_PKTDROP_CNT_Pr_PK_DROP_CNTf_SET(r,f) (r).bc_sup_pktdrop_cnt_p[0]=((uint32_t)f)

/*
 * These macros can be used to access BC_SUP_PKTDROP_CNT_P.
 *
 */
#define BCM6300_A0_READ_BC_SUP_PKTDROP_CNT_Pr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_BC_SUP_PKTDROP_CNT_Pr,(r._bc_sup_pktdrop_cnt_p),4)
#define BCM6300_A0_WRITE_BC_SUP_PKTDROP_CNT_Pr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_BC_SUP_PKTDROP_CNT_Pr,&(r._bc_sup_pktdrop_cnt_p),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BC_SUP_PKTDROP_CNT_Pr BCM6300_A0_BC_SUP_PKTDROP_CNT_Pr
#define BC_SUP_PKTDROP_CNT_Pr_SIZE BCM6300_A0_BC_SUP_PKTDROP_CNT_Pr_SIZE
typedef BCM6300_A0_BC_SUP_PKTDROP_CNT_Pr_t BC_SUP_PKTDROP_CNT_Pr_t;
#define BC_SUP_PKTDROP_CNT_Pr_CLR BCM6300_A0_BC_SUP_PKTDROP_CNT_Pr_CLR
#define BC_SUP_PKTDROP_CNT_Pr_SET BCM6300_A0_BC_SUP_PKTDROP_CNT_Pr_SET
#define BC_SUP_PKTDROP_CNT_Pr_GET BCM6300_A0_BC_SUP_PKTDROP_CNT_Pr_GET
#define BC_SUP_PKTDROP_CNT_Pr_PK_DROP_CNTf_GET BCM6300_A0_BC_SUP_PKTDROP_CNT_Pr_PK_DROP_CNTf_GET
#define BC_SUP_PKTDROP_CNT_Pr_PK_DROP_CNTf_SET BCM6300_A0_BC_SUP_PKTDROP_CNT_Pr_PK_DROP_CNTf_SET
#define READ_BC_SUP_PKTDROP_CNT_Pr BCM6300_A0_READ_BC_SUP_PKTDROP_CNT_Pr
#define WRITE_BC_SUP_PKTDROP_CNT_Pr BCM6300_A0_WRITE_BC_SUP_PKTDROP_CNT_Pr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_BC_SUP_PKTDROP_CNT_Pr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  BIST_STS
 * BLOCKS:   SYS
 * DESC:     BIST Status Register
 * SIZE:     32
 * FIELDS:
 *     BUFTAG_ERR       Buffer Tag Ram Error.Set to indicate the Buffer Tag memory failed the internal self test during initialization/power-up.
 *     VTBL_ERR         VLAN Table Ram Error.Set to indicate the VTBL memory failed the internal self test during initialization/power-up.
 *     TXQ_ERR          Transmit Queue Ram Error.Set to indicate the TXQ memory failed the internal self test during initialization/power-up.
 *     MIB_RAM_ERR      MIB RAM Error.Set to indicate the MIB RAM failed the internal self test during initialization/power-up.
 *     BUFF_CON_ERR     Buffer Control RAM Error.Set to indicate the Buffer Control RAM failed the internal self test during initialization/power-up.
 *     FMMEM_ERR        Internal packet data buffer memory Error.Set to indicate the packet buffer memory failed the internal self test during initialization/power-up.
 *     ATMEM_ERR        Address Table memory Error.Set to indicate the ARL memory failed the internal self test during initialization/power-up.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM6300_A0_BIST_STSr 0x00000146

#define BCM6300_A0_BIST_STSr_SIZE 4

/*
 * This structure should be used to declare and program BIST_STS.
 *
 */
typedef union BCM6300_A0_BIST_STSr_s {
	uint32_t v[1];
	uint32_t bist_sts[1];
	uint32_t _bist_sts;
} BCM6300_A0_BIST_STSr_t;

#define BCM6300_A0_BIST_STSr_CLR(r) (r).bist_sts[0] = 0
#define BCM6300_A0_BIST_STSr_SET(r,d) (r).bist_sts[0] = d
#define BCM6300_A0_BIST_STSr_GET(r) (r).bist_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_BIST_STSr_BUFTAG_ERRf_GET(r) (((r).bist_sts[0]) & 0x1)
#define BCM6300_A0_BIST_STSr_BUFTAG_ERRf_SET(r,f) (r).bist_sts[0]=(((r).bist_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM6300_A0_BIST_STSr_VTBL_ERRf_GET(r) ((((r).bist_sts[0]) >> 1) & 0x1)
#define BCM6300_A0_BIST_STSr_VTBL_ERRf_SET(r,f) (r).bist_sts[0]=(((r).bist_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM6300_A0_BIST_STSr_TXQ_ERRf_GET(r) ((((r).bist_sts[0]) >> 2) & 0x1ff)
#define BCM6300_A0_BIST_STSr_TXQ_ERRf_SET(r,f) (r).bist_sts[0]=(((r).bist_sts[0] & ~((uint32_t)0x1ff << 2)) | ((((uint32_t)f) & 0x1ff) << 2))
#define BCM6300_A0_BIST_STSr_MIB_RAM_ERRf_GET(r) ((((r).bist_sts[0]) >> 11) & 0x3ff)
#define BCM6300_A0_BIST_STSr_MIB_RAM_ERRf_SET(r,f) (r).bist_sts[0]=(((r).bist_sts[0] & ~((uint32_t)0x3ff << 11)) | ((((uint32_t)f) & 0x3ff) << 11))
#define BCM6300_A0_BIST_STSr_BUFF_CON_ERRf_GET(r) ((((r).bist_sts[0]) >> 21) & 0x1)
#define BCM6300_A0_BIST_STSr_BUFF_CON_ERRf_SET(r,f) (r).bist_sts[0]=(((r).bist_sts[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM6300_A0_BIST_STSr_FMMEM_ERRf_GET(r) ((((r).bist_sts[0]) >> 22) & 0xf)
#define BCM6300_A0_BIST_STSr_FMMEM_ERRf_SET(r,f) (r).bist_sts[0]=(((r).bist_sts[0] & ~((uint32_t)0xf << 22)) | ((((uint32_t)f) & 0xf) << 22))
#define BCM6300_A0_BIST_STSr_ATMEM_ERRf_GET(r) ((((r).bist_sts[0]) >> 26) & 0x1)
#define BCM6300_A0_BIST_STSr_ATMEM_ERRf_SET(r,f) (r).bist_sts[0]=(((r).bist_sts[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM6300_A0_BIST_STSr_RESERVED_Rf_GET(r) ((((r).bist_sts[0]) >> 27) & 0x1f)
#define BCM6300_A0_BIST_STSr_RESERVED_Rf_SET(r,f) (r).bist_sts[0]=(((r).bist_sts[0] & ~((uint32_t)0x1f << 27)) | ((((uint32_t)f) & 0x1f) << 27))

/*
 * These macros can be used to access BIST_STS.
 *
 */
#define BCM6300_A0_READ_BIST_STSr(u,r) cdk_robo_reg_read(u,BCM6300_A0_BIST_STSr,(r._bist_sts),4)
#define BCM6300_A0_WRITE_BIST_STSr(u,r) cdk_robo_reg_write(u,BCM6300_A0_BIST_STSr,&(r._bist_sts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BIST_STSr BCM6300_A0_BIST_STSr
#define BIST_STSr_SIZE BCM6300_A0_BIST_STSr_SIZE
typedef BCM6300_A0_BIST_STSr_t BIST_STSr_t;
#define BIST_STSr_CLR BCM6300_A0_BIST_STSr_CLR
#define BIST_STSr_SET BCM6300_A0_BIST_STSr_SET
#define BIST_STSr_GET BCM6300_A0_BIST_STSr_GET
#define BIST_STSr_BUFTAG_ERRf_GET BCM6300_A0_BIST_STSr_BUFTAG_ERRf_GET
#define BIST_STSr_BUFTAG_ERRf_SET BCM6300_A0_BIST_STSr_BUFTAG_ERRf_SET
#define BIST_STSr_VTBL_ERRf_GET BCM6300_A0_BIST_STSr_VTBL_ERRf_GET
#define BIST_STSr_VTBL_ERRf_SET BCM6300_A0_BIST_STSr_VTBL_ERRf_SET
#define BIST_STSr_TXQ_ERRf_GET BCM6300_A0_BIST_STSr_TXQ_ERRf_GET
#define BIST_STSr_TXQ_ERRf_SET BCM6300_A0_BIST_STSr_TXQ_ERRf_SET
#define BIST_STSr_MIB_RAM_ERRf_GET BCM6300_A0_BIST_STSr_MIB_RAM_ERRf_GET
#define BIST_STSr_MIB_RAM_ERRf_SET BCM6300_A0_BIST_STSr_MIB_RAM_ERRf_SET
#define BIST_STSr_BUFF_CON_ERRf_GET BCM6300_A0_BIST_STSr_BUFF_CON_ERRf_GET
#define BIST_STSr_BUFF_CON_ERRf_SET BCM6300_A0_BIST_STSr_BUFF_CON_ERRf_SET
#define BIST_STSr_FMMEM_ERRf_GET BCM6300_A0_BIST_STSr_FMMEM_ERRf_GET
#define BIST_STSr_FMMEM_ERRf_SET BCM6300_A0_BIST_STSr_FMMEM_ERRf_SET
#define BIST_STSr_ATMEM_ERRf_GET BCM6300_A0_BIST_STSr_ATMEM_ERRf_GET
#define BIST_STSr_ATMEM_ERRf_SET BCM6300_A0_BIST_STSr_ATMEM_ERRf_SET
#define BIST_STSr_RESERVED_Rf_GET BCM6300_A0_BIST_STSr_RESERVED_Rf_GET
#define BIST_STSr_RESERVED_Rf_SET BCM6300_A0_BIST_STSr_RESERVED_Rf_SET
#define READ_BIST_STSr BCM6300_A0_READ_BIST_STSr
#define WRITE_BIST_STSr BCM6300_A0_WRITE_BIST_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_BIST_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  BOND_DIRECT_PIN
 * BLOCKS:   SYS
 * DESC:     Bounding and Direct inport control value register
 * SIZE:     32
 * FIELDS:
 *     ACT_LPDECT       
 *     GPHY_CLASAA_AB   
 *     GPHY_TST         
 *     IMP_DUPLEX       
 *     IMP_LINK         
 *     IMP_PAUSECAP_RX  
 *     IMP_PAUSECAP_TX  
 *     IMP_SPEED        
 *     OVST_B           
 *     PROBE_SYSCLK     
 *     TST_EN           
 *     TST_MODE         
 *     RESERVED_0R      Reserved.
 *     RESERVED_1R      Reserved.
 *     BOND_OPTION      Bonding Option1: for bcm6300;0: for bcm5387.
 *
 ******************************************************************************/
#define BCM6300_A0_BOND_DIRECT_PINr 0x00000180

#define BCM6300_A0_BOND_DIRECT_PINr_SIZE 4

/*
 * This structure should be used to declare and program BOND_DIRECT_PIN.
 *
 */
typedef union BCM6300_A0_BOND_DIRECT_PINr_s {
	uint32_t v[1];
	uint32_t bond_direct_pin[1];
	uint32_t _bond_direct_pin;
} BCM6300_A0_BOND_DIRECT_PINr_t;

#define BCM6300_A0_BOND_DIRECT_PINr_CLR(r) (r).bond_direct_pin[0] = 0
#define BCM6300_A0_BOND_DIRECT_PINr_SET(r,d) (r).bond_direct_pin[0] = d
#define BCM6300_A0_BOND_DIRECT_PINr_GET(r) (r).bond_direct_pin[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_BOND_DIRECT_PINr_ACT_LPDECTf_GET(r) (((r).bond_direct_pin[0]) & 0x1)
#define BCM6300_A0_BOND_DIRECT_PINr_ACT_LPDECTf_SET(r,f) (r).bond_direct_pin[0]=(((r).bond_direct_pin[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM6300_A0_BOND_DIRECT_PINr_GPHY_CLASAA_ABf_GET(r) ((((r).bond_direct_pin[0]) >> 1) & 0x1)
#define BCM6300_A0_BOND_DIRECT_PINr_GPHY_CLASAA_ABf_SET(r,f) (r).bond_direct_pin[0]=(((r).bond_direct_pin[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM6300_A0_BOND_DIRECT_PINr_GPHY_TSTf_GET(r) ((((r).bond_direct_pin[0]) >> 2) & 0x1)
#define BCM6300_A0_BOND_DIRECT_PINr_GPHY_TSTf_SET(r,f) (r).bond_direct_pin[0]=(((r).bond_direct_pin[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM6300_A0_BOND_DIRECT_PINr_IMP_DUPLEXf_GET(r) ((((r).bond_direct_pin[0]) >> 3) & 0x1)
#define BCM6300_A0_BOND_DIRECT_PINr_IMP_DUPLEXf_SET(r,f) (r).bond_direct_pin[0]=(((r).bond_direct_pin[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM6300_A0_BOND_DIRECT_PINr_IMP_LINKf_GET(r) ((((r).bond_direct_pin[0]) >> 4) & 0x1)
#define BCM6300_A0_BOND_DIRECT_PINr_IMP_LINKf_SET(r,f) (r).bond_direct_pin[0]=(((r).bond_direct_pin[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM6300_A0_BOND_DIRECT_PINr_IMP_PAUSECAP_RXf_GET(r) ((((r).bond_direct_pin[0]) >> 5) & 0x1)
#define BCM6300_A0_BOND_DIRECT_PINr_IMP_PAUSECAP_RXf_SET(r,f) (r).bond_direct_pin[0]=(((r).bond_direct_pin[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM6300_A0_BOND_DIRECT_PINr_IMP_PAUSECAP_TXf_GET(r) ((((r).bond_direct_pin[0]) >> 6) & 0x1)
#define BCM6300_A0_BOND_DIRECT_PINr_IMP_PAUSECAP_TXf_SET(r,f) (r).bond_direct_pin[0]=(((r).bond_direct_pin[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM6300_A0_BOND_DIRECT_PINr_IMP_SPEEDf_GET(r) ((((r).bond_direct_pin[0]) >> 7) & 0x3)
#define BCM6300_A0_BOND_DIRECT_PINr_IMP_SPEEDf_SET(r,f) (r).bond_direct_pin[0]=(((r).bond_direct_pin[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7))
#define BCM6300_A0_BOND_DIRECT_PINr_OVST_Bf_GET(r) ((((r).bond_direct_pin[0]) >> 9) & 0x1)
#define BCM6300_A0_BOND_DIRECT_PINr_OVST_Bf_SET(r,f) (r).bond_direct_pin[0]=(((r).bond_direct_pin[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM6300_A0_BOND_DIRECT_PINr_PROBE_SYSCLKf_GET(r) ((((r).bond_direct_pin[0]) >> 10) & 0x1)
#define BCM6300_A0_BOND_DIRECT_PINr_PROBE_SYSCLKf_SET(r,f) (r).bond_direct_pin[0]=(((r).bond_direct_pin[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM6300_A0_BOND_DIRECT_PINr_TST_ENf_GET(r) ((((r).bond_direct_pin[0]) >> 11) & 0x1)
#define BCM6300_A0_BOND_DIRECT_PINr_TST_ENf_SET(r,f) (r).bond_direct_pin[0]=(((r).bond_direct_pin[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM6300_A0_BOND_DIRECT_PINr_TST_MODEf_GET(r) ((((r).bond_direct_pin[0]) >> 12) & 0x7)
#define BCM6300_A0_BOND_DIRECT_PINr_TST_MODEf_SET(r,f) (r).bond_direct_pin[0]=(((r).bond_direct_pin[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM6300_A0_BOND_DIRECT_PINr_RESERVED_0Rf_GET(r) ((((r).bond_direct_pin[0]) >> 15) & 0xfff)
#define BCM6300_A0_BOND_DIRECT_PINr_RESERVED_0Rf_SET(r,f) (r).bond_direct_pin[0]=(((r).bond_direct_pin[0] & ~((uint32_t)0xfff << 15)) | ((((uint32_t)f) & 0xfff) << 15))
#define BCM6300_A0_BOND_DIRECT_PINr_RESERVED_1Rf_GET(r) ((((r).bond_direct_pin[0]) >> 27) & 0xf)
#define BCM6300_A0_BOND_DIRECT_PINr_RESERVED_1Rf_SET(r,f) (r).bond_direct_pin[0]=(((r).bond_direct_pin[0] & ~((uint32_t)0xf << 27)) | ((((uint32_t)f) & 0xf) << 27))
#define BCM6300_A0_BOND_DIRECT_PINr_BOND_OPTIONf_GET(r) ((((r).bond_direct_pin[0]) >> 31) & 0x1)
#define BCM6300_A0_BOND_DIRECT_PINr_BOND_OPTIONf_SET(r,f) (r).bond_direct_pin[0]=(((r).bond_direct_pin[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access BOND_DIRECT_PIN.
 *
 */
#define BCM6300_A0_READ_BOND_DIRECT_PINr(u,i,r) cdk_robo_reg_read(u,BCM6300_A0_BOND_DIRECT_PINr+(4*(i)),(r._bond_direct_pin),4)
#define BCM6300_A0_WRITE_BOND_DIRECT_PINr(u,i,r) cdk_robo_reg_write(u,BCM6300_A0_BOND_DIRECT_PINr+(4*(i)),&(r._bond_direct_pin),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BOND_DIRECT_PINr BCM6300_A0_BOND_DIRECT_PINr
#define BOND_DIRECT_PINr_SIZE BCM6300_A0_BOND_DIRECT_PINr_SIZE
typedef BCM6300_A0_BOND_DIRECT_PINr_t BOND_DIRECT_PINr_t;
#define BOND_DIRECT_PINr_CLR BCM6300_A0_BOND_DIRECT_PINr_CLR
#define BOND_DIRECT_PINr_SET BCM6300_A0_BOND_DIRECT_PINr_SET
#define BOND_DIRECT_PINr_GET BCM6300_A0_BOND_DIRECT_PINr_GET
#define BOND_DIRECT_PINr_ACT_LPDECTf_GET BCM6300_A0_BOND_DIRECT_PINr_ACT_LPDECTf_GET
#define BOND_DIRECT_PINr_ACT_LPDECTf_SET BCM6300_A0_BOND_DIRECT_PINr_ACT_LPDECTf_SET
#define BOND_DIRECT_PINr_GPHY_CLASAA_ABf_GET BCM6300_A0_BOND_DIRECT_PINr_GPHY_CLASAA_ABf_GET
#define BOND_DIRECT_PINr_GPHY_CLASAA_ABf_SET BCM6300_A0_BOND_DIRECT_PINr_GPHY_CLASAA_ABf_SET
#define BOND_DIRECT_PINr_GPHY_TSTf_GET BCM6300_A0_BOND_DIRECT_PINr_GPHY_TSTf_GET
#define BOND_DIRECT_PINr_GPHY_TSTf_SET BCM6300_A0_BOND_DIRECT_PINr_GPHY_TSTf_SET
#define BOND_DIRECT_PINr_IMP_DUPLEXf_GET BCM6300_A0_BOND_DIRECT_PINr_IMP_DUPLEXf_GET
#define BOND_DIRECT_PINr_IMP_DUPLEXf_SET BCM6300_A0_BOND_DIRECT_PINr_IMP_DUPLEXf_SET
#define BOND_DIRECT_PINr_IMP_LINKf_GET BCM6300_A0_BOND_DIRECT_PINr_IMP_LINKf_GET
#define BOND_DIRECT_PINr_IMP_LINKf_SET BCM6300_A0_BOND_DIRECT_PINr_IMP_LINKf_SET
#define BOND_DIRECT_PINr_IMP_PAUSECAP_RXf_GET BCM6300_A0_BOND_DIRECT_PINr_IMP_PAUSECAP_RXf_GET
#define BOND_DIRECT_PINr_IMP_PAUSECAP_RXf_SET BCM6300_A0_BOND_DIRECT_PINr_IMP_PAUSECAP_RXf_SET
#define BOND_DIRECT_PINr_IMP_PAUSECAP_TXf_GET BCM6300_A0_BOND_DIRECT_PINr_IMP_PAUSECAP_TXf_GET
#define BOND_DIRECT_PINr_IMP_PAUSECAP_TXf_SET BCM6300_A0_BOND_DIRECT_PINr_IMP_PAUSECAP_TXf_SET
#define BOND_DIRECT_PINr_IMP_SPEEDf_GET BCM6300_A0_BOND_DIRECT_PINr_IMP_SPEEDf_GET
#define BOND_DIRECT_PINr_IMP_SPEEDf_SET BCM6300_A0_BOND_DIRECT_PINr_IMP_SPEEDf_SET
#define BOND_DIRECT_PINr_OVST_Bf_GET BCM6300_A0_BOND_DIRECT_PINr_OVST_Bf_GET
#define BOND_DIRECT_PINr_OVST_Bf_SET BCM6300_A0_BOND_DIRECT_PINr_OVST_Bf_SET
#define BOND_DIRECT_PINr_PROBE_SYSCLKf_GET BCM6300_A0_BOND_DIRECT_PINr_PROBE_SYSCLKf_GET
#define BOND_DIRECT_PINr_PROBE_SYSCLKf_SET BCM6300_A0_BOND_DIRECT_PINr_PROBE_SYSCLKf_SET
#define BOND_DIRECT_PINr_TST_ENf_GET BCM6300_A0_BOND_DIRECT_PINr_TST_ENf_GET
#define BOND_DIRECT_PINr_TST_ENf_SET BCM6300_A0_BOND_DIRECT_PINr_TST_ENf_SET
#define BOND_DIRECT_PINr_TST_MODEf_GET BCM6300_A0_BOND_DIRECT_PINr_TST_MODEf_GET
#define BOND_DIRECT_PINr_TST_MODEf_SET BCM6300_A0_BOND_DIRECT_PINr_TST_MODEf_SET
#define BOND_DIRECT_PINr_RESERVED_0Rf_GET BCM6300_A0_BOND_DIRECT_PINr_RESERVED_0Rf_GET
#define BOND_DIRECT_PINr_RESERVED_0Rf_SET BCM6300_A0_BOND_DIRECT_PINr_RESERVED_0Rf_SET
#define BOND_DIRECT_PINr_RESERVED_1Rf_GET BCM6300_A0_BOND_DIRECT_PINr_RESERVED_1Rf_GET
#define BOND_DIRECT_PINr_RESERVED_1Rf_SET BCM6300_A0_BOND_DIRECT_PINr_RESERVED_1Rf_SET
#define BOND_DIRECT_PINr_BOND_OPTIONf_GET BCM6300_A0_BOND_DIRECT_PINr_BOND_OPTIONf_GET
#define BOND_DIRECT_PINr_BOND_OPTIONf_SET BCM6300_A0_BOND_DIRECT_PINr_BOND_OPTIONf_SET
#define READ_BOND_DIRECT_PINr BCM6300_A0_READ_BOND_DIRECT_PINr
#define WRITE_BOND_DIRECT_PINr BCM6300_A0_WRITE_BOND_DIRECT_PINr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_BOND_DIRECT_PINr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  BPDU_MCADDR
 * BLOCKS:   SYS
 * DESC:     BPDU Multicast Address Register
 * SIZE:     48
 * FIELDS:
 *     BPDU_MC_ADDR     BPDU Multicast Address.(not release to customer).Defaults to the 802.1 defined reserved multicast address for the Bridge Group #Address. Programming to an alternate value allows support of proprietary #protocols in place of the normal Spanning Tree Protocol. Frames with a matching #DA to this address will be forwarded only to the designated management port #(IMP).
 *
 ******************************************************************************/
#define BCM6300_A0_BPDU_MCADDRr 0x00000404

#define BCM6300_A0_BPDU_MCADDRr_SIZE 6

/*
 * This structure should be used to declare and program BPDU_MCADDR.
 *
 */
typedef union BCM6300_A0_BPDU_MCADDRr_s {
	uint32_t v[2];
	uint32_t bpdu_mcaddr[2];
	uint32_t _bpdu_mcaddr;
} BCM6300_A0_BPDU_MCADDRr_t;

#define BCM6300_A0_BPDU_MCADDRr_CLR(r) CDK_MEMSET(&((r)._bpdu_mcaddr), 0, sizeof(BCM6300_A0_BPDU_MCADDRr_t))
#define BCM6300_A0_BPDU_MCADDRr_SET(r,i,d) (r).bpdu_mcaddr[i] = d
#define BCM6300_A0_BPDU_MCADDRr_GET(r,i) (r).bpdu_mcaddr[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_BPDU_MCADDRr_BPDU_MC_ADDRf_GET(r,a) cdk_field_get((r).bpdu_mcaddr,0,47,a)
#define BCM6300_A0_BPDU_MCADDRr_BPDU_MC_ADDRf_SET(r,a) cdk_field_set((r).bpdu_mcaddr,0,47,a)

/*
 * These macros can be used to access BPDU_MCADDR.
 *
 */
#define BCM6300_A0_READ_BPDU_MCADDRr(u,r) cdk_robo_reg_read(u,BCM6300_A0_BPDU_MCADDRr,(r._bpdu_mcaddr),6)
#define BCM6300_A0_WRITE_BPDU_MCADDRr(u,r) cdk_robo_reg_write(u,BCM6300_A0_BPDU_MCADDRr,&(r._bpdu_mcaddr),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BPDU_MCADDRr BCM6300_A0_BPDU_MCADDRr
#define BPDU_MCADDRr_SIZE BCM6300_A0_BPDU_MCADDRr_SIZE
typedef BCM6300_A0_BPDU_MCADDRr_t BPDU_MCADDRr_t;
#define BPDU_MCADDRr_CLR BCM6300_A0_BPDU_MCADDRr_CLR
#define BPDU_MCADDRr_SET BCM6300_A0_BPDU_MCADDRr_SET
#define BPDU_MCADDRr_GET BCM6300_A0_BPDU_MCADDRr_GET
#define BPDU_MCADDRr_BPDU_MC_ADDRf_GET BCM6300_A0_BPDU_MCADDRr_BPDU_MC_ADDRf_GET
#define BPDU_MCADDRr_BPDU_MC_ADDRf_SET BCM6300_A0_BPDU_MCADDRr_BPDU_MC_ADDRf_SET
#define READ_BPDU_MCADDRr BCM6300_A0_READ_BPDU_MCADDRr
#define WRITE_BPDU_MCADDRr BCM6300_A0_WRITE_BPDU_MCADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_BPDU_MCADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  BRCMTST
 * BLOCKS:   GPIC0
 * DESC:     Broadcom Test Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_BRCMTSTr 0x0000103e

#define BCM6300_A0_BRCMTSTr_SIZE 2

/*
 * This structure should be used to declare and program BRCMTST.
 *
 */
typedef union BCM6300_A0_BRCMTSTr_s {
	uint32_t v[1];
	uint32_t brcmtst[1];
	uint32_t _brcmtst;
} BCM6300_A0_BRCMTSTr_t;

#define BCM6300_A0_BRCMTSTr_CLR(r) (r).brcmtst[0] = 0
#define BCM6300_A0_BRCMTSTr_SET(r,d) (r).brcmtst[0] = d
#define BCM6300_A0_BRCMTSTr_GET(r) (r).brcmtst[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_BRCMTSTr_RESERVED_Rf_GET(r) (((r).brcmtst[0]) & 0xffff)
#define BCM6300_A0_BRCMTSTr_RESERVED_Rf_SET(r,f) (r).brcmtst[0]=(((r).brcmtst[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access BRCMTST.
 *
 */
#define BCM6300_A0_READ_BRCMTSTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_BRCMTSTr,(r._brcmtst),2)
#define BCM6300_A0_WRITE_BRCMTSTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_BRCMTSTr,&(r._brcmtst),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BRCMTSTr BCM6300_A0_BRCMTSTr
#define BRCMTSTr_SIZE BCM6300_A0_BRCMTSTr_SIZE
typedef BCM6300_A0_BRCMTSTr_t BRCMTSTr_t;
#define BRCMTSTr_CLR BCM6300_A0_BRCMTSTr_CLR
#define BRCMTSTr_SET BCM6300_A0_BRCMTSTr_SET
#define BRCMTSTr_GET BCM6300_A0_BRCMTSTr_GET
#define BRCMTSTr_RESERVED_Rf_GET BCM6300_A0_BRCMTSTr_RESERVED_Rf_GET
#define BRCMTSTr_RESERVED_Rf_SET BCM6300_A0_BRCMTSTr_RESERVED_Rf_SET
#define READ_BRCMTSTr BCM6300_A0_READ_BRCMTSTr
#define WRITE_BRCMTSTr BCM6300_A0_WRITE_BRCMTSTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_BRCMTSTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  CHIP_REVID
 * BLOCKS:   SYS
 * DESC:     Chip Revision ID Register
 * SIZE:     8
 * FIELDS:
 *     REVID_R          Chip Revision ID.
 *
 ******************************************************************************/
#define BCM6300_A0_CHIP_REVIDr 0x00000240

#define BCM6300_A0_CHIP_REVIDr_SIZE 1

/*
 * This structure should be used to declare and program CHIP_REVID.
 *
 */
typedef union BCM6300_A0_CHIP_REVIDr_s {
	uint32_t v[1];
	uint32_t chip_revid[1];
	uint32_t _chip_revid;
} BCM6300_A0_CHIP_REVIDr_t;

#define BCM6300_A0_CHIP_REVIDr_CLR(r) (r).chip_revid[0] = 0
#define BCM6300_A0_CHIP_REVIDr_SET(r,d) (r).chip_revid[0] = d
#define BCM6300_A0_CHIP_REVIDr_GET(r) (r).chip_revid[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_CHIP_REVIDr_REVID_Rf_GET(r) (((r).chip_revid[0]) & 0xff)
#define BCM6300_A0_CHIP_REVIDr_REVID_Rf_SET(r,f) (r).chip_revid[0]=(((r).chip_revid[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CHIP_REVID.
 *
 */
#define BCM6300_A0_READ_CHIP_REVIDr(u,r) cdk_robo_reg_read(u,BCM6300_A0_CHIP_REVIDr,(r._chip_revid),1)
#define BCM6300_A0_WRITE_CHIP_REVIDr(u,r) cdk_robo_reg_write(u,BCM6300_A0_CHIP_REVIDr,&(r._chip_revid),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CHIP_REVIDr BCM6300_A0_CHIP_REVIDr
#define CHIP_REVIDr_SIZE BCM6300_A0_CHIP_REVIDr_SIZE
typedef BCM6300_A0_CHIP_REVIDr_t CHIP_REVIDr_t;
#define CHIP_REVIDr_CLR BCM6300_A0_CHIP_REVIDr_CLR
#define CHIP_REVIDr_SET BCM6300_A0_CHIP_REVIDr_SET
#define CHIP_REVIDr_GET BCM6300_A0_CHIP_REVIDr_GET
#define CHIP_REVIDr_REVID_Rf_GET BCM6300_A0_CHIP_REVIDr_REVID_Rf_GET
#define CHIP_REVIDr_REVID_Rf_SET BCM6300_A0_CHIP_REVIDr_REVID_Rf_SET
#define READ_CHIP_REVIDr BCM6300_A0_READ_CHIP_REVIDr
#define WRITE_CHIP_REVIDr BCM6300_A0_WRITE_CHIP_REVIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_CHIP_REVIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  COMM_IRC_CON
 * BLOCKS:   SYS
 * DESC:     Common Ingress rate Control Configuration Registers
 * SIZE:     32
 * FIELDS:
 *     PKT_MSK0         Packet Mask for Bucket 0.default value : {2'b0, bc_supp_en, bcsupp_en, 2'b0}
 *     DROP_EN0         suppression Drop Mode Enabled.default value : base on strap pin bc_supp_en.
 *     RATE_TYPE0       Bit Rate Mode selection.default value : base on strap pin bc_supp_en.
 *     PKT_MSK1         Packet Mask for Bucket 1.
 *     DROP_EN1         suppression Drop Mode Enabled for bucket 1.
 *     RATE_TYPE1       Bit Rate Mode selection.
 *     XLEN_EN          bit rate Mode  Selection.0 : Rx rate exclude IGP,1 : Rx rate include IGP,
 *     EXT_PKT_MSK0     Extended packet mask for bucket 0SA look up fail
 *     EXT_PKT_MSK1     Extended packet mask for bucket 1SA look up fail
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_COMM_IRC_CONr 0x00004100

#define BCM6300_A0_COMM_IRC_CONr_SIZE 4

/*
 * This structure should be used to declare and program COMM_IRC_CON.
 *
 */
typedef union BCM6300_A0_COMM_IRC_CONr_s {
	uint32_t v[1];
	uint32_t comm_irc_con[1];
	uint32_t _comm_irc_con;
} BCM6300_A0_COMM_IRC_CONr_t;

#define BCM6300_A0_COMM_IRC_CONr_CLR(r) (r).comm_irc_con[0] = 0
#define BCM6300_A0_COMM_IRC_CONr_SET(r,d) (r).comm_irc_con[0] = d
#define BCM6300_A0_COMM_IRC_CONr_GET(r) (r).comm_irc_con[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_COMM_IRC_CONr_PKT_MSK0f_GET(r) (((r).comm_irc_con[0]) & 0x3f)
#define BCM6300_A0_COMM_IRC_CONr_PKT_MSK0f_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM6300_A0_COMM_IRC_CONr_DROP_EN0f_GET(r) ((((r).comm_irc_con[0]) >> 6) & 0x1)
#define BCM6300_A0_COMM_IRC_CONr_DROP_EN0f_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM6300_A0_COMM_IRC_CONr_RATE_TYPE0f_GET(r) ((((r).comm_irc_con[0]) >> 7) & 0x1)
#define BCM6300_A0_COMM_IRC_CONr_RATE_TYPE0f_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM6300_A0_COMM_IRC_CONr_PKT_MSK1f_GET(r) ((((r).comm_irc_con[0]) >> 8) & 0x3f)
#define BCM6300_A0_COMM_IRC_CONr_PKT_MSK1f_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM6300_A0_COMM_IRC_CONr_DROP_EN1f_GET(r) ((((r).comm_irc_con[0]) >> 14) & 0x1)
#define BCM6300_A0_COMM_IRC_CONr_DROP_EN1f_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM6300_A0_COMM_IRC_CONr_RATE_TYPE1f_GET(r) ((((r).comm_irc_con[0]) >> 15) & 0x1)
#define BCM6300_A0_COMM_IRC_CONr_RATE_TYPE1f_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM6300_A0_COMM_IRC_CONr_XLEN_ENf_GET(r) ((((r).comm_irc_con[0]) >> 16) & 0x1)
#define BCM6300_A0_COMM_IRC_CONr_XLEN_ENf_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM6300_A0_COMM_IRC_CONr_EXT_PKT_MSK0f_GET(r) ((((r).comm_irc_con[0]) >> 17) & 0x1)
#define BCM6300_A0_COMM_IRC_CONr_EXT_PKT_MSK0f_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM6300_A0_COMM_IRC_CONr_EXT_PKT_MSK1f_GET(r) ((((r).comm_irc_con[0]) >> 18) & 0x1)
#define BCM6300_A0_COMM_IRC_CONr_EXT_PKT_MSK1f_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM6300_A0_COMM_IRC_CONr_RESERVED_Rf_GET(r) ((((r).comm_irc_con[0]) >> 19) & 0x1fff)
#define BCM6300_A0_COMM_IRC_CONr_RESERVED_Rf_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x1fff << 19)) | ((((uint32_t)f) & 0x1fff) << 19))

/*
 * These macros can be used to access COMM_IRC_CON.
 *
 */
#define BCM6300_A0_READ_COMM_IRC_CONr(u,r) cdk_robo_reg_read(u,BCM6300_A0_COMM_IRC_CONr,(r._comm_irc_con),4)
#define BCM6300_A0_WRITE_COMM_IRC_CONr(u,r) cdk_robo_reg_write(u,BCM6300_A0_COMM_IRC_CONr,&(r._comm_irc_con),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define COMM_IRC_CONr BCM6300_A0_COMM_IRC_CONr
#define COMM_IRC_CONr_SIZE BCM6300_A0_COMM_IRC_CONr_SIZE
typedef BCM6300_A0_COMM_IRC_CONr_t COMM_IRC_CONr_t;
#define COMM_IRC_CONr_CLR BCM6300_A0_COMM_IRC_CONr_CLR
#define COMM_IRC_CONr_SET BCM6300_A0_COMM_IRC_CONr_SET
#define COMM_IRC_CONr_GET BCM6300_A0_COMM_IRC_CONr_GET
#define COMM_IRC_CONr_PKT_MSK0f_GET BCM6300_A0_COMM_IRC_CONr_PKT_MSK0f_GET
#define COMM_IRC_CONr_PKT_MSK0f_SET BCM6300_A0_COMM_IRC_CONr_PKT_MSK0f_SET
#define COMM_IRC_CONr_DROP_EN0f_GET BCM6300_A0_COMM_IRC_CONr_DROP_EN0f_GET
#define COMM_IRC_CONr_DROP_EN0f_SET BCM6300_A0_COMM_IRC_CONr_DROP_EN0f_SET
#define COMM_IRC_CONr_RATE_TYPE0f_GET BCM6300_A0_COMM_IRC_CONr_RATE_TYPE0f_GET
#define COMM_IRC_CONr_RATE_TYPE0f_SET BCM6300_A0_COMM_IRC_CONr_RATE_TYPE0f_SET
#define COMM_IRC_CONr_PKT_MSK1f_GET BCM6300_A0_COMM_IRC_CONr_PKT_MSK1f_GET
#define COMM_IRC_CONr_PKT_MSK1f_SET BCM6300_A0_COMM_IRC_CONr_PKT_MSK1f_SET
#define COMM_IRC_CONr_DROP_EN1f_GET BCM6300_A0_COMM_IRC_CONr_DROP_EN1f_GET
#define COMM_IRC_CONr_DROP_EN1f_SET BCM6300_A0_COMM_IRC_CONr_DROP_EN1f_SET
#define COMM_IRC_CONr_RATE_TYPE1f_GET BCM6300_A0_COMM_IRC_CONr_RATE_TYPE1f_GET
#define COMM_IRC_CONr_RATE_TYPE1f_SET BCM6300_A0_COMM_IRC_CONr_RATE_TYPE1f_SET
#define COMM_IRC_CONr_XLEN_ENf_GET BCM6300_A0_COMM_IRC_CONr_XLEN_ENf_GET
#define COMM_IRC_CONr_XLEN_ENf_SET BCM6300_A0_COMM_IRC_CONr_XLEN_ENf_SET
#define COMM_IRC_CONr_EXT_PKT_MSK0f_GET BCM6300_A0_COMM_IRC_CONr_EXT_PKT_MSK0f_GET
#define COMM_IRC_CONr_EXT_PKT_MSK0f_SET BCM6300_A0_COMM_IRC_CONr_EXT_PKT_MSK0f_SET
#define COMM_IRC_CONr_EXT_PKT_MSK1f_GET BCM6300_A0_COMM_IRC_CONr_EXT_PKT_MSK1f_GET
#define COMM_IRC_CONr_EXT_PKT_MSK1f_SET BCM6300_A0_COMM_IRC_CONr_EXT_PKT_MSK1f_SET
#define COMM_IRC_CONr_RESERVED_Rf_GET BCM6300_A0_COMM_IRC_CONr_RESERVED_Rf_GET
#define COMM_IRC_CONr_RESERVED_Rf_SET BCM6300_A0_COMM_IRC_CONr_RESERVED_Rf_SET
#define READ_COMM_IRC_CONr BCM6300_A0_READ_COMM_IRC_CONr
#define WRITE_COMM_IRC_CONr BCM6300_A0_WRITE_COMM_IRC_CONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_COMM_IRC_CONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  DEBUG_REG
 * BLOCKS:   SYS
 * DESC:     Debug Control Register
 * SIZE:     8
 * FIELDS:
 *     EN_DEBUG         1 : Enable debugging bus
 *     DBG_SEL          Debug bus select.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM6300_A0_DEBUG_REGr 0x0000001e

#define BCM6300_A0_DEBUG_REGr_SIZE 1

/*
 * This structure should be used to declare and program DEBUG_REG.
 *
 */
typedef union BCM6300_A0_DEBUG_REGr_s {
	uint32_t v[1];
	uint32_t debug_reg[1];
	uint32_t _debug_reg;
} BCM6300_A0_DEBUG_REGr_t;

#define BCM6300_A0_DEBUG_REGr_CLR(r) (r).debug_reg[0] = 0
#define BCM6300_A0_DEBUG_REGr_SET(r,d) (r).debug_reg[0] = d
#define BCM6300_A0_DEBUG_REGr_GET(r) (r).debug_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_DEBUG_REGr_EN_DEBUGf_GET(r) (((r).debug_reg[0]) & 0x1)
#define BCM6300_A0_DEBUG_REGr_EN_DEBUGf_SET(r,f) (r).debug_reg[0]=(((r).debug_reg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM6300_A0_DEBUG_REGr_DBG_SELf_GET(r) ((((r).debug_reg[0]) >> 1) & 0x3f)
#define BCM6300_A0_DEBUG_REGr_DBG_SELf_SET(r,f) (r).debug_reg[0]=(((r).debug_reg[0] & ~((uint32_t)0x3f << 1)) | ((((uint32_t)f) & 0x3f) << 1))
#define BCM6300_A0_DEBUG_REGr_RESERVED_Rf_GET(r) ((((r).debug_reg[0]) >> 7) & 0x1)
#define BCM6300_A0_DEBUG_REGr_RESERVED_Rf_SET(r,f) (r).debug_reg[0]=(((r).debug_reg[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access DEBUG_REG.
 *
 */
#define BCM6300_A0_READ_DEBUG_REGr(u,r) cdk_robo_reg_read(u,BCM6300_A0_DEBUG_REGr,(r._debug_reg),1)
#define BCM6300_A0_WRITE_DEBUG_REGr(u,r) cdk_robo_reg_write(u,BCM6300_A0_DEBUG_REGr,&(r._debug_reg),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DEBUG_REGr BCM6300_A0_DEBUG_REGr
#define DEBUG_REGr_SIZE BCM6300_A0_DEBUG_REGr_SIZE
typedef BCM6300_A0_DEBUG_REGr_t DEBUG_REGr_t;
#define DEBUG_REGr_CLR BCM6300_A0_DEBUG_REGr_CLR
#define DEBUG_REGr_SET BCM6300_A0_DEBUG_REGr_SET
#define DEBUG_REGr_GET BCM6300_A0_DEBUG_REGr_GET
#define DEBUG_REGr_EN_DEBUGf_GET BCM6300_A0_DEBUG_REGr_EN_DEBUGf_GET
#define DEBUG_REGr_EN_DEBUGf_SET BCM6300_A0_DEBUG_REGr_EN_DEBUGf_SET
#define DEBUG_REGr_DBG_SELf_GET BCM6300_A0_DEBUG_REGr_DBG_SELf_GET
#define DEBUG_REGr_DBG_SELf_SET BCM6300_A0_DEBUG_REGr_DBG_SELf_SET
#define DEBUG_REGr_RESERVED_Rf_GET BCM6300_A0_DEBUG_REGr_RESERVED_Rf_GET
#define DEBUG_REGr_RESERVED_Rf_SET BCM6300_A0_DEBUG_REGr_RESERVED_Rf_SET
#define READ_DEBUG_REGr BCM6300_A0_READ_DEBUG_REGr
#define WRITE_DEBUG_REGr BCM6300_A0_WRITE_DEBUG_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_DEBUG_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  DEFAULT_1Q_TAG
 * BLOCKS:   GPIC0 CPIC
 * DESC:     802.1Q Default Port Tag Registers
 * SIZE:     16
 * FIELDS:
 *     VID_R            Default VLAN ID.When incoming packet is non-1Q tagged frame or priority tagged frame, Default VLAN ID will be used as the VID for the port if VLAN_1Q enabled.
 *     CFI_R            Canonical Form Indicator (BCM5388 don't care this bit).
 *     PRI_R            Default Priority Bit.When incoming packet is non-priority tagged frame or non-1Q  frame, Default Priority Bit will be used as the Priority bit for the port if VLAN_1Q enabled.When Port-Based QOS enabled, the bits will be the default priority for the ingress port.
 *
 ******************************************************************************/
#define BCM6300_A0_DEFAULT_1Q_TAGr 0x00003410

#define BCM6300_A0_DEFAULT_1Q_TAGr_SIZE 2

/*
 * This structure should be used to declare and program DEFAULT_1Q_TAG.
 *
 */
typedef union BCM6300_A0_DEFAULT_1Q_TAGr_s {
	uint32_t v[1];
	uint32_t default_1q_tag[1];
	uint32_t _default_1q_tag;
} BCM6300_A0_DEFAULT_1Q_TAGr_t;

#define BCM6300_A0_DEFAULT_1Q_TAGr_CLR(r) (r).default_1q_tag[0] = 0
#define BCM6300_A0_DEFAULT_1Q_TAGr_SET(r,d) (r).default_1q_tag[0] = d
#define BCM6300_A0_DEFAULT_1Q_TAGr_GET(r) (r).default_1q_tag[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_DEFAULT_1Q_TAGr_VID_Rf_GET(r) (((r).default_1q_tag[0]) & 0xfff)
#define BCM6300_A0_DEFAULT_1Q_TAGr_VID_Rf_SET(r,f) (r).default_1q_tag[0]=(((r).default_1q_tag[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM6300_A0_DEFAULT_1Q_TAGr_CFI_Rf_GET(r) ((((r).default_1q_tag[0]) >> 12) & 0x1)
#define BCM6300_A0_DEFAULT_1Q_TAGr_CFI_Rf_SET(r,f) (r).default_1q_tag[0]=(((r).default_1q_tag[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM6300_A0_DEFAULT_1Q_TAGr_PRI_Rf_GET(r) ((((r).default_1q_tag[0]) >> 13) & 0x7)
#define BCM6300_A0_DEFAULT_1Q_TAGr_PRI_Rf_SET(r,f) (r).default_1q_tag[0]=(((r).default_1q_tag[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access DEFAULT_1Q_TAG.
 *
 */
#define BCM6300_A0_READ_DEFAULT_1Q_TAGr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_DEFAULT_1Q_TAGr,(r._default_1q_tag),2)
#define BCM6300_A0_WRITE_DEFAULT_1Q_TAGr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_DEFAULT_1Q_TAGr,&(r._default_1q_tag),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DEFAULT_1Q_TAGr BCM6300_A0_DEFAULT_1Q_TAGr
#define DEFAULT_1Q_TAGr_SIZE BCM6300_A0_DEFAULT_1Q_TAGr_SIZE
typedef BCM6300_A0_DEFAULT_1Q_TAGr_t DEFAULT_1Q_TAGr_t;
#define DEFAULT_1Q_TAGr_CLR BCM6300_A0_DEFAULT_1Q_TAGr_CLR
#define DEFAULT_1Q_TAGr_SET BCM6300_A0_DEFAULT_1Q_TAGr_SET
#define DEFAULT_1Q_TAGr_GET BCM6300_A0_DEFAULT_1Q_TAGr_GET
#define DEFAULT_1Q_TAGr_VID_Rf_GET BCM6300_A0_DEFAULT_1Q_TAGr_VID_Rf_GET
#define DEFAULT_1Q_TAGr_VID_Rf_SET BCM6300_A0_DEFAULT_1Q_TAGr_VID_Rf_SET
#define DEFAULT_1Q_TAGr_CFI_Rf_GET BCM6300_A0_DEFAULT_1Q_TAGr_CFI_Rf_GET
#define DEFAULT_1Q_TAGr_CFI_Rf_SET BCM6300_A0_DEFAULT_1Q_TAGr_CFI_Rf_SET
#define DEFAULT_1Q_TAGr_PRI_Rf_GET BCM6300_A0_DEFAULT_1Q_TAGr_PRI_Rf_GET
#define DEFAULT_1Q_TAGr_PRI_Rf_SET BCM6300_A0_DEFAULT_1Q_TAGr_PRI_Rf_SET
#define READ_DEFAULT_1Q_TAGr BCM6300_A0_READ_DEFAULT_1Q_TAGr
#define WRITE_DEFAULT_1Q_TAGr BCM6300_A0_WRITE_DEFAULT_1Q_TAGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_DEFAULT_1Q_TAGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  DF_TIMER
 * BLOCKS:   SYS
 * DESC:     Discovery Frame Timer Registers
 * SIZE:     8
 * FIELDS:
 *     DF_TIME          Frome 1 sec to 16 sec,scale = 1 sec
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM6300_A0_DF_TIMERr 0x00007202

#define BCM6300_A0_DF_TIMERr_SIZE 1

/*
 * This structure should be used to declare and program DF_TIMER.
 *
 */
typedef union BCM6300_A0_DF_TIMERr_s {
	uint32_t v[1];
	uint32_t df_timer[1];
	uint32_t _df_timer;
} BCM6300_A0_DF_TIMERr_t;

#define BCM6300_A0_DF_TIMERr_CLR(r) (r).df_timer[0] = 0
#define BCM6300_A0_DF_TIMERr_SET(r,d) (r).df_timer[0] = d
#define BCM6300_A0_DF_TIMERr_GET(r) (r).df_timer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_DF_TIMERr_DF_TIMEf_GET(r) (((r).df_timer[0]) & 0xf)
#define BCM6300_A0_DF_TIMERr_DF_TIMEf_SET(r,f) (r).df_timer[0]=(((r).df_timer[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM6300_A0_DF_TIMERr_RESERVED_Rf_GET(r) ((((r).df_timer[0]) >> 4) & 0xf)
#define BCM6300_A0_DF_TIMERr_RESERVED_Rf_SET(r,f) (r).df_timer[0]=(((r).df_timer[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access DF_TIMER.
 *
 */
#define BCM6300_A0_READ_DF_TIMERr(u,r) cdk_robo_reg_read(u,BCM6300_A0_DF_TIMERr,(r._df_timer),1)
#define BCM6300_A0_WRITE_DF_TIMERr(u,r) cdk_robo_reg_write(u,BCM6300_A0_DF_TIMERr,&(r._df_timer),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DF_TIMERr BCM6300_A0_DF_TIMERr
#define DF_TIMERr_SIZE BCM6300_A0_DF_TIMERr_SIZE
typedef BCM6300_A0_DF_TIMERr_t DF_TIMERr_t;
#define DF_TIMERr_CLR BCM6300_A0_DF_TIMERr_CLR
#define DF_TIMERr_SET BCM6300_A0_DF_TIMERr_SET
#define DF_TIMERr_GET BCM6300_A0_DF_TIMERr_GET
#define DF_TIMERr_DF_TIMEf_GET BCM6300_A0_DF_TIMERr_DF_TIMEf_GET
#define DF_TIMERr_DF_TIMEf_SET BCM6300_A0_DF_TIMERr_DF_TIMEf_SET
#define DF_TIMERr_RESERVED_Rf_GET BCM6300_A0_DF_TIMERr_RESERVED_Rf_GET
#define DF_TIMERr_RESERVED_Rf_SET BCM6300_A0_DF_TIMERr_RESERVED_Rf_SET
#define READ_DF_TIMERr BCM6300_A0_READ_DF_TIMERr
#define WRITE_DF_TIMERr BCM6300_A0_WRITE_DF_TIMERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_DF_TIMERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  DIS_LEARN
 * BLOCKS:   SYS
 * DESC:     Disable Learning Registrer
 * SIZE:     16
 * FIELDS:
 *     DIS_LEARN        1 : Disable learning.0 : Enable Learning.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_DIS_LEARNr 0x0000003c

#define BCM6300_A0_DIS_LEARNr_SIZE 2

/*
 * This structure should be used to declare and program DIS_LEARN.
 *
 */
typedef union BCM6300_A0_DIS_LEARNr_s {
	uint32_t v[1];
	uint32_t dis_learn[1];
	uint32_t _dis_learn;
} BCM6300_A0_DIS_LEARNr_t;

#define BCM6300_A0_DIS_LEARNr_CLR(r) (r).dis_learn[0] = 0
#define BCM6300_A0_DIS_LEARNr_SET(r,d) (r).dis_learn[0] = d
#define BCM6300_A0_DIS_LEARNr_GET(r) (r).dis_learn[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_DIS_LEARNr_DIS_LEARNf_GET(r) (((r).dis_learn[0]) & 0x1ff)
#define BCM6300_A0_DIS_LEARNr_DIS_LEARNf_SET(r,f) (r).dis_learn[0]=(((r).dis_learn[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_DIS_LEARNr_RESERVED_Rf_GET(r) ((((r).dis_learn[0]) >> 9) & 0x7f)
#define BCM6300_A0_DIS_LEARNr_RESERVED_Rf_SET(r,f) (r).dis_learn[0]=(((r).dis_learn[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access DIS_LEARN.
 *
 */
#define BCM6300_A0_READ_DIS_LEARNr(u,r) cdk_robo_reg_read(u,BCM6300_A0_DIS_LEARNr,(r._dis_learn),2)
#define BCM6300_A0_WRITE_DIS_LEARNr(u,r) cdk_robo_reg_write(u,BCM6300_A0_DIS_LEARNr,&(r._dis_learn),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DIS_LEARNr BCM6300_A0_DIS_LEARNr
#define DIS_LEARNr_SIZE BCM6300_A0_DIS_LEARNr_SIZE
typedef BCM6300_A0_DIS_LEARNr_t DIS_LEARNr_t;
#define DIS_LEARNr_CLR BCM6300_A0_DIS_LEARNr_CLR
#define DIS_LEARNr_SET BCM6300_A0_DIS_LEARNr_SET
#define DIS_LEARNr_GET BCM6300_A0_DIS_LEARNr_GET
#define DIS_LEARNr_DIS_LEARNf_GET BCM6300_A0_DIS_LEARNr_DIS_LEARNf_GET
#define DIS_LEARNr_DIS_LEARNf_SET BCM6300_A0_DIS_LEARNr_DIS_LEARNf_SET
#define DIS_LEARNr_RESERVED_Rf_GET BCM6300_A0_DIS_LEARNr_RESERVED_Rf_GET
#define DIS_LEARNr_RESERVED_Rf_SET BCM6300_A0_DIS_LEARNr_RESERVED_Rf_SET
#define READ_DIS_LEARNr BCM6300_A0_READ_DIS_LEARNr
#define WRITE_DIS_LEARNr BCM6300_A0_WRITE_DIS_LEARNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_DIS_LEARNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  DOU_TAG_TPID
 * BLOCKS:   SYS
 * DESC:     Double Tagging TPID Register
 * SIZE:     16
 * FIELDS:
 *     ISP_TPID         TPID used to identify double tagged frame.                
 *
 ******************************************************************************/
#define BCM6300_A0_DOU_TAG_TPIDr 0x00003430

#define BCM6300_A0_DOU_TAG_TPIDr_SIZE 2

/*
 * This structure should be used to declare and program DOU_TAG_TPID.
 *
 */
typedef union BCM6300_A0_DOU_TAG_TPIDr_s {
	uint32_t v[1];
	uint32_t dou_tag_tpid[1];
	uint32_t _dou_tag_tpid;
} BCM6300_A0_DOU_TAG_TPIDr_t;

#define BCM6300_A0_DOU_TAG_TPIDr_CLR(r) (r).dou_tag_tpid[0] = 0
#define BCM6300_A0_DOU_TAG_TPIDr_SET(r,d) (r).dou_tag_tpid[0] = d
#define BCM6300_A0_DOU_TAG_TPIDr_GET(r) (r).dou_tag_tpid[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_DOU_TAG_TPIDr_ISP_TPIDf_GET(r) (((r).dou_tag_tpid[0]) & 0xffff)
#define BCM6300_A0_DOU_TAG_TPIDr_ISP_TPIDf_SET(r,f) (r).dou_tag_tpid[0]=(((r).dou_tag_tpid[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access DOU_TAG_TPID.
 *
 */
#define BCM6300_A0_READ_DOU_TAG_TPIDr(u,r) cdk_robo_reg_read(u,BCM6300_A0_DOU_TAG_TPIDr,(r._dou_tag_tpid),2)
#define BCM6300_A0_WRITE_DOU_TAG_TPIDr(u,r) cdk_robo_reg_write(u,BCM6300_A0_DOU_TAG_TPIDr,&(r._dou_tag_tpid),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DOU_TAG_TPIDr BCM6300_A0_DOU_TAG_TPIDr
#define DOU_TAG_TPIDr_SIZE BCM6300_A0_DOU_TAG_TPIDr_SIZE
typedef BCM6300_A0_DOU_TAG_TPIDr_t DOU_TAG_TPIDr_t;
#define DOU_TAG_TPIDr_CLR BCM6300_A0_DOU_TAG_TPIDr_CLR
#define DOU_TAG_TPIDr_SET BCM6300_A0_DOU_TAG_TPIDr_SET
#define DOU_TAG_TPIDr_GET BCM6300_A0_DOU_TAG_TPIDr_GET
#define DOU_TAG_TPIDr_ISP_TPIDf_GET BCM6300_A0_DOU_TAG_TPIDr_ISP_TPIDf_GET
#define DOU_TAG_TPIDr_ISP_TPIDf_SET BCM6300_A0_DOU_TAG_TPIDr_ISP_TPIDf_SET
#define READ_DOU_TAG_TPIDr BCM6300_A0_READ_DOU_TAG_TPIDr
#define WRITE_DOU_TAG_TPIDr BCM6300_A0_WRITE_DOU_TAG_TPIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_DOU_TAG_TPIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  DUPSTS
 * BLOCKS:   SYS
 * DESC:     Duplex status Summary Register
 * SIZE:     16
 * FIELDS:
 *     DUP_STS          Duplex State.16 bit field indicating the half/full duplex state for each 10/100/1000BASE-T port.(bits 0-7 = 10/100/1000BASE-T ports).0 = Half Duplex.1 = Full Duplex.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_DUPSTSr 0x0000010c

#define BCM6300_A0_DUPSTSr_SIZE 2

/*
 * This structure should be used to declare and program DUPSTS.
 *
 */
typedef union BCM6300_A0_DUPSTSr_s {
	uint32_t v[1];
	uint32_t dupsts[1];
	uint32_t _dupsts;
} BCM6300_A0_DUPSTSr_t;

#define BCM6300_A0_DUPSTSr_CLR(r) (r).dupsts[0] = 0
#define BCM6300_A0_DUPSTSr_SET(r,d) (r).dupsts[0] = d
#define BCM6300_A0_DUPSTSr_GET(r) (r).dupsts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_DUPSTSr_DUP_STSf_GET(r) (((r).dupsts[0]) & 0x1ff)
#define BCM6300_A0_DUPSTSr_DUP_STSf_SET(r,f) (r).dupsts[0]=(((r).dupsts[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_DUPSTSr_RESERVED_Rf_GET(r) ((((r).dupsts[0]) >> 9) & 0x7f)
#define BCM6300_A0_DUPSTSr_RESERVED_Rf_SET(r,f) (r).dupsts[0]=(((r).dupsts[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access DUPSTS.
 *
 */
#define BCM6300_A0_READ_DUPSTSr(u,r) cdk_robo_reg_read(u,BCM6300_A0_DUPSTSr,(r._dupsts),2)
#define BCM6300_A0_WRITE_DUPSTSr(u,r) cdk_robo_reg_write(u,BCM6300_A0_DUPSTSr,&(r._dupsts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DUPSTSr BCM6300_A0_DUPSTSr
#define DUPSTSr_SIZE BCM6300_A0_DUPSTSr_SIZE
typedef BCM6300_A0_DUPSTSr_t DUPSTSr_t;
#define DUPSTSr_CLR BCM6300_A0_DUPSTSr_CLR
#define DUPSTSr_SET BCM6300_A0_DUPSTSr_SET
#define DUPSTSr_GET BCM6300_A0_DUPSTSr_GET
#define DUPSTSr_DUP_STSf_GET BCM6300_A0_DUPSTSr_DUP_STSf_GET
#define DUPSTSr_DUP_STSf_SET BCM6300_A0_DUPSTSr_DUP_STSf_SET
#define DUPSTSr_RESERVED_Rf_GET BCM6300_A0_DUPSTSr_RESERVED_Rf_GET
#define DUPSTSr_RESERVED_Rf_SET BCM6300_A0_DUPSTSr_RESERVED_Rf_SET
#define READ_DUPSTSr BCM6300_A0_READ_DUPSTSr
#define WRITE_DUPSTSr BCM6300_A0_WRITE_DUPSTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_DUPSTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  EAP_DIP
 * BLOCKS:   SYS
 * DESC:     EAP Destination IP Registers
 * SIZE:     64
 * FIELDS:
 *     DIP_MASK_REG     
 *     DIP_SUB_REG      
 *
 ******************************************************************************/
#define BCM6300_A0_EAP_DIPr 0x00004204

#define BCM6300_A0_EAP_DIPr_SIZE 8

/*
 * This structure should be used to declare and program EAP_DIP.
 *
 */
typedef union BCM6300_A0_EAP_DIPr_s {
	uint32_t v[2];
	uint32_t eap_dip[2];
	uint32_t _eap_dip;
} BCM6300_A0_EAP_DIPr_t;

#define BCM6300_A0_EAP_DIPr_CLR(r) CDK_MEMSET(&((r)._eap_dip), 0, sizeof(BCM6300_A0_EAP_DIPr_t))
#define BCM6300_A0_EAP_DIPr_SET(r,i,d) (r).eap_dip[i] = d
#define BCM6300_A0_EAP_DIPr_GET(r,i) (r).eap_dip[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_EAP_DIPr_DIP_MASK_REGf_GET(r) ((r).eap_dip[0])
#define BCM6300_A0_EAP_DIPr_DIP_MASK_REGf_SET(r,f) (r).eap_dip[0]=((uint32_t)f)
#define BCM6300_A0_EAP_DIPr_DIP_SUB_REGf_GET(r) ((r).eap_dip[1])
#define BCM6300_A0_EAP_DIPr_DIP_SUB_REGf_SET(r,f) (r).eap_dip[1]=((uint32_t)f)

/*
 * These macros can be used to access EAP_DIP.
 *
 */
#define BCM6300_A0_READ_EAP_DIPr(u,i,r) cdk_robo_reg_read(u,BCM6300_A0_EAP_DIPr+(8*(i)),(r._eap_dip),8)
#define BCM6300_A0_WRITE_EAP_DIPr(u,i,r) cdk_robo_reg_write(u,BCM6300_A0_EAP_DIPr+(8*(i)),&(r._eap_dip),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EAP_DIPr BCM6300_A0_EAP_DIPr
#define EAP_DIPr_SIZE BCM6300_A0_EAP_DIPr_SIZE
typedef BCM6300_A0_EAP_DIPr_t EAP_DIPr_t;
#define EAP_DIPr_CLR BCM6300_A0_EAP_DIPr_CLR
#define EAP_DIPr_SET BCM6300_A0_EAP_DIPr_SET
#define EAP_DIPr_GET BCM6300_A0_EAP_DIPr_GET
#define EAP_DIPr_DIP_MASK_REGf_GET BCM6300_A0_EAP_DIPr_DIP_MASK_REGf_GET
#define EAP_DIPr_DIP_MASK_REGf_SET BCM6300_A0_EAP_DIPr_DIP_MASK_REGf_SET
#define EAP_DIPr_DIP_SUB_REGf_GET BCM6300_A0_EAP_DIPr_DIP_SUB_REGf_GET
#define EAP_DIPr_DIP_SUB_REGf_SET BCM6300_A0_EAP_DIPr_DIP_SUB_REGf_SET
#define READ_EAP_DIPr BCM6300_A0_READ_EAP_DIPr
#define WRITE_EAP_DIPr BCM6300_A0_WRITE_EAP_DIPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_EAP_DIPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  EAP_GLO_CON
 * BLOCKS:   SYS
 * DESC:     EAP Global Configuration Registers
 * SIZE:     8
 * FIELDS:
 *     EN_MPORT         1b1: allow multiport address define at Page/Offset=04/10h & 20h to pass1b0: drop
 *     EN_2_DIP         when EAP_BLK_MODE is set, 2 destination IP defined in EAP_DIP0_MASK & EAP_DIP1_MASK are allowed to pass.
 *     EN_ARP           1: allow ARP to pass.0: drop ARP. 
 *     EN_DHCP          1: allow DHCP to pass.0: drop DHCP. 
 *     EN_RMC           1: allow DA=01-80-C2-00-00-02, 04-0F to pass.0: drop DA=01-80-C2-00-00-02, 04-0F. 
 *     EN_BPDU          1: allow BPDU to pass.0: drop BPDUF. 
 *     EAP_GLO_CON_RSRV Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_EAP_GLO_CONr 0x00004200

#define BCM6300_A0_EAP_GLO_CONr_SIZE 1

/*
 * This structure should be used to declare and program EAP_GLO_CON.
 *
 */
typedef union BCM6300_A0_EAP_GLO_CONr_s {
	uint32_t v[1];
	uint32_t eap_glo_con[1];
	uint32_t _eap_glo_con;
} BCM6300_A0_EAP_GLO_CONr_t;

#define BCM6300_A0_EAP_GLO_CONr_CLR(r) (r).eap_glo_con[0] = 0
#define BCM6300_A0_EAP_GLO_CONr_SET(r,d) (r).eap_glo_con[0] = d
#define BCM6300_A0_EAP_GLO_CONr_GET(r) (r).eap_glo_con[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_EAP_GLO_CONr_EN_MPORTf_GET(r) (((r).eap_glo_con[0]) & 0x1)
#define BCM6300_A0_EAP_GLO_CONr_EN_MPORTf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM6300_A0_EAP_GLO_CONr_EN_2_DIPf_GET(r) ((((r).eap_glo_con[0]) >> 1) & 0x1)
#define BCM6300_A0_EAP_GLO_CONr_EN_2_DIPf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM6300_A0_EAP_GLO_CONr_EN_ARPf_GET(r) ((((r).eap_glo_con[0]) >> 2) & 0x1)
#define BCM6300_A0_EAP_GLO_CONr_EN_ARPf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM6300_A0_EAP_GLO_CONr_EN_DHCPf_GET(r) ((((r).eap_glo_con[0]) >> 3) & 0x1)
#define BCM6300_A0_EAP_GLO_CONr_EN_DHCPf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM6300_A0_EAP_GLO_CONr_EN_RMCf_GET(r) ((((r).eap_glo_con[0]) >> 4) & 0x1)
#define BCM6300_A0_EAP_GLO_CONr_EN_RMCf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM6300_A0_EAP_GLO_CONr_EN_BPDUf_GET(r) ((((r).eap_glo_con[0]) >> 5) & 0x1)
#define BCM6300_A0_EAP_GLO_CONr_EN_BPDUf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM6300_A0_EAP_GLO_CONr_EAP_GLO_CON_RSRVf_GET(r) ((((r).eap_glo_con[0]) >> 6) & 0x3)
#define BCM6300_A0_EAP_GLO_CONr_EAP_GLO_CON_RSRVf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access EAP_GLO_CON.
 *
 */
#define BCM6300_A0_READ_EAP_GLO_CONr(u,r) cdk_robo_reg_read(u,BCM6300_A0_EAP_GLO_CONr,(r._eap_glo_con),1)
#define BCM6300_A0_WRITE_EAP_GLO_CONr(u,r) cdk_robo_reg_write(u,BCM6300_A0_EAP_GLO_CONr,&(r._eap_glo_con),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EAP_GLO_CONr BCM6300_A0_EAP_GLO_CONr
#define EAP_GLO_CONr_SIZE BCM6300_A0_EAP_GLO_CONr_SIZE
typedef BCM6300_A0_EAP_GLO_CONr_t EAP_GLO_CONr_t;
#define EAP_GLO_CONr_CLR BCM6300_A0_EAP_GLO_CONr_CLR
#define EAP_GLO_CONr_SET BCM6300_A0_EAP_GLO_CONr_SET
#define EAP_GLO_CONr_GET BCM6300_A0_EAP_GLO_CONr_GET
#define EAP_GLO_CONr_EN_MPORTf_GET BCM6300_A0_EAP_GLO_CONr_EN_MPORTf_GET
#define EAP_GLO_CONr_EN_MPORTf_SET BCM6300_A0_EAP_GLO_CONr_EN_MPORTf_SET
#define EAP_GLO_CONr_EN_2_DIPf_GET BCM6300_A0_EAP_GLO_CONr_EN_2_DIPf_GET
#define EAP_GLO_CONr_EN_2_DIPf_SET BCM6300_A0_EAP_GLO_CONr_EN_2_DIPf_SET
#define EAP_GLO_CONr_EN_ARPf_GET BCM6300_A0_EAP_GLO_CONr_EN_ARPf_GET
#define EAP_GLO_CONr_EN_ARPf_SET BCM6300_A0_EAP_GLO_CONr_EN_ARPf_SET
#define EAP_GLO_CONr_EN_DHCPf_GET BCM6300_A0_EAP_GLO_CONr_EN_DHCPf_GET
#define EAP_GLO_CONr_EN_DHCPf_SET BCM6300_A0_EAP_GLO_CONr_EN_DHCPf_SET
#define EAP_GLO_CONr_EN_RMCf_GET BCM6300_A0_EAP_GLO_CONr_EN_RMCf_GET
#define EAP_GLO_CONr_EN_RMCf_SET BCM6300_A0_EAP_GLO_CONr_EN_RMCf_SET
#define EAP_GLO_CONr_EN_BPDUf_GET BCM6300_A0_EAP_GLO_CONr_EN_BPDUf_GET
#define EAP_GLO_CONr_EN_BPDUf_SET BCM6300_A0_EAP_GLO_CONr_EN_BPDUf_SET
#define EAP_GLO_CONr_EAP_GLO_CON_RSRVf_GET BCM6300_A0_EAP_GLO_CONr_EAP_GLO_CON_RSRVf_GET
#define EAP_GLO_CONr_EAP_GLO_CON_RSRVf_SET BCM6300_A0_EAP_GLO_CONr_EAP_GLO_CON_RSRVf_SET
#define READ_EAP_GLO_CONr BCM6300_A0_READ_EAP_GLO_CONr
#define WRITE_EAP_GLO_CONr BCM6300_A0_WRITE_EAP_GLO_CONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_EAP_GLO_CONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  EGMIRCTL
 * BLOCKS:   SYS
 * DESC:     Egress Mirror Control Register
 * SIZE:     16
 * FIELDS:
 *     OUT_MIR_MSK      Egress Mirror Port Mask.9 bit mask which selectively allows any port with its corresponding bit set, to be mirrored to the port identified by the MIRROR_CAPTURE_PORT value. Note that while multiple bits in a device may be set, severe congestion and/or frame loss may occur if excessive bandwidth from the mirrored port(s) is directed to the MIRROR_CAPTURE_PORT.Bits 0-7 = Port0-7Bit 8= IMP.
 *     RESERVED_R       Reserved
 *     OUT_DIV_EN       Egress Divider Enable.Mirror every nth transmitted frame (n=OUT_MIRROR_DIV) that has passed through the OUT_MIRROR_FILTER.
 *     OUT_MIR_FLTR     Egress Mirror Filter.Defines the conditions under which frames transmitted on a port that has been selected in the OUT_MRROR_MASK[10:0], will be compared in orderto determine if they should be forwarded to the MIRROR_CAPTURE_PORT.00: Mirror all egress frames.01: Mirror all transmitted frames with DA = IN_MIROR_MAC.10: Mirror all transmitted frames with SA = IN_MIRROR_MAC.11: Reserved.
 *
 ******************************************************************************/
#define BCM6300_A0_EGMIRCTLr 0x0000021c

#define BCM6300_A0_EGMIRCTLr_SIZE 2

/*
 * This structure should be used to declare and program EGMIRCTL.
 *
 */
typedef union BCM6300_A0_EGMIRCTLr_s {
	uint32_t v[1];
	uint32_t egmirctl[1];
	uint32_t _egmirctl;
} BCM6300_A0_EGMIRCTLr_t;

#define BCM6300_A0_EGMIRCTLr_CLR(r) (r).egmirctl[0] = 0
#define BCM6300_A0_EGMIRCTLr_SET(r,d) (r).egmirctl[0] = d
#define BCM6300_A0_EGMIRCTLr_GET(r) (r).egmirctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_EGMIRCTLr_OUT_MIR_MSKf_GET(r) (((r).egmirctl[0]) & 0x1ff)
#define BCM6300_A0_EGMIRCTLr_OUT_MIR_MSKf_SET(r,f) (r).egmirctl[0]=(((r).egmirctl[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_EGMIRCTLr_RESERVED_Rf_GET(r) ((((r).egmirctl[0]) >> 9) & 0xf)
#define BCM6300_A0_EGMIRCTLr_RESERVED_Rf_SET(r,f) (r).egmirctl[0]=(((r).egmirctl[0] & ~((uint32_t)0xf << 9)) | ((((uint32_t)f) & 0xf) << 9))
#define BCM6300_A0_EGMIRCTLr_OUT_DIV_ENf_GET(r) ((((r).egmirctl[0]) >> 13) & 0x1)
#define BCM6300_A0_EGMIRCTLr_OUT_DIV_ENf_SET(r,f) (r).egmirctl[0]=(((r).egmirctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM6300_A0_EGMIRCTLr_OUT_MIR_FLTRf_GET(r) ((((r).egmirctl[0]) >> 14) & 0x3)
#define BCM6300_A0_EGMIRCTLr_OUT_MIR_FLTRf_SET(r,f) (r).egmirctl[0]=(((r).egmirctl[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access EGMIRCTL.
 *
 */
#define BCM6300_A0_READ_EGMIRCTLr(u,r) cdk_robo_reg_read(u,BCM6300_A0_EGMIRCTLr,(r._egmirctl),2)
#define BCM6300_A0_WRITE_EGMIRCTLr(u,r) cdk_robo_reg_write(u,BCM6300_A0_EGMIRCTLr,&(r._egmirctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGMIRCTLr BCM6300_A0_EGMIRCTLr
#define EGMIRCTLr_SIZE BCM6300_A0_EGMIRCTLr_SIZE
typedef BCM6300_A0_EGMIRCTLr_t EGMIRCTLr_t;
#define EGMIRCTLr_CLR BCM6300_A0_EGMIRCTLr_CLR
#define EGMIRCTLr_SET BCM6300_A0_EGMIRCTLr_SET
#define EGMIRCTLr_GET BCM6300_A0_EGMIRCTLr_GET
#define EGMIRCTLr_OUT_MIR_MSKf_GET BCM6300_A0_EGMIRCTLr_OUT_MIR_MSKf_GET
#define EGMIRCTLr_OUT_MIR_MSKf_SET BCM6300_A0_EGMIRCTLr_OUT_MIR_MSKf_SET
#define EGMIRCTLr_RESERVED_Rf_GET BCM6300_A0_EGMIRCTLr_RESERVED_Rf_GET
#define EGMIRCTLr_RESERVED_Rf_SET BCM6300_A0_EGMIRCTLr_RESERVED_Rf_SET
#define EGMIRCTLr_OUT_DIV_ENf_GET BCM6300_A0_EGMIRCTLr_OUT_DIV_ENf_GET
#define EGMIRCTLr_OUT_DIV_ENf_SET BCM6300_A0_EGMIRCTLr_OUT_DIV_ENf_SET
#define EGMIRCTLr_OUT_MIR_FLTRf_GET BCM6300_A0_EGMIRCTLr_OUT_MIR_FLTRf_GET
#define EGMIRCTLr_OUT_MIR_FLTRf_SET BCM6300_A0_EGMIRCTLr_OUT_MIR_FLTRf_SET
#define READ_EGMIRCTLr BCM6300_A0_READ_EGMIRCTLr
#define WRITE_EGMIRCTLr BCM6300_A0_WRITE_EGMIRCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_EGMIRCTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  EGMIRDIV
 * BLOCKS:   SYS
 * DESC:     Egress Mirror Divider Register
 * SIZE:     16
 * FIELDS:
 *     OUT_MIR_DIV      Egress Mirror Divider.Transmit frames that have passed the OUT_MIRROR_FILTER rule can further be pruned to reduce the overall number of frames returned to the MIRROR_CAPTURE_PORT. When the OUT_DIV_EN bit in the Egress Mirror Control register is set, frames that pass the OUT_MIRROR_FILTER rule are further divided by the value loaded into this register, so that only one in n frames (where n = OUT_MIRROR_DIV) will be mirrored.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_EGMIRDIVr 0x0000021e

#define BCM6300_A0_EGMIRDIVr_SIZE 2

/*
 * This structure should be used to declare and program EGMIRDIV.
 *
 */
typedef union BCM6300_A0_EGMIRDIVr_s {
	uint32_t v[1];
	uint32_t egmirdiv[1];
	uint32_t _egmirdiv;
} BCM6300_A0_EGMIRDIVr_t;

#define BCM6300_A0_EGMIRDIVr_CLR(r) (r).egmirdiv[0] = 0
#define BCM6300_A0_EGMIRDIVr_SET(r,d) (r).egmirdiv[0] = d
#define BCM6300_A0_EGMIRDIVr_GET(r) (r).egmirdiv[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_EGMIRDIVr_OUT_MIR_DIVf_GET(r) (((r).egmirdiv[0]) & 0x3ff)
#define BCM6300_A0_EGMIRDIVr_OUT_MIR_DIVf_SET(r,f) (r).egmirdiv[0]=(((r).egmirdiv[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM6300_A0_EGMIRDIVr_RESERVED_Rf_GET(r) ((((r).egmirdiv[0]) >> 10) & 0x3f)
#define BCM6300_A0_EGMIRDIVr_RESERVED_Rf_SET(r,f) (r).egmirdiv[0]=(((r).egmirdiv[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access EGMIRDIV.
 *
 */
#define BCM6300_A0_READ_EGMIRDIVr(u,r) cdk_robo_reg_read(u,BCM6300_A0_EGMIRDIVr,(r._egmirdiv),2)
#define BCM6300_A0_WRITE_EGMIRDIVr(u,r) cdk_robo_reg_write(u,BCM6300_A0_EGMIRDIVr,&(r._egmirdiv),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGMIRDIVr BCM6300_A0_EGMIRDIVr
#define EGMIRDIVr_SIZE BCM6300_A0_EGMIRDIVr_SIZE
typedef BCM6300_A0_EGMIRDIVr_t EGMIRDIVr_t;
#define EGMIRDIVr_CLR BCM6300_A0_EGMIRDIVr_CLR
#define EGMIRDIVr_SET BCM6300_A0_EGMIRDIVr_SET
#define EGMIRDIVr_GET BCM6300_A0_EGMIRDIVr_GET
#define EGMIRDIVr_OUT_MIR_DIVf_GET BCM6300_A0_EGMIRDIVr_OUT_MIR_DIVf_GET
#define EGMIRDIVr_OUT_MIR_DIVf_SET BCM6300_A0_EGMIRDIVr_OUT_MIR_DIVf_SET
#define EGMIRDIVr_RESERVED_Rf_GET BCM6300_A0_EGMIRDIVr_RESERVED_Rf_GET
#define EGMIRDIVr_RESERVED_Rf_SET BCM6300_A0_EGMIRDIVr_RESERVED_Rf_SET
#define READ_EGMIRDIVr BCM6300_A0_READ_EGMIRDIVr
#define WRITE_EGMIRDIVr BCM6300_A0_WRITE_EGMIRDIVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_EGMIRDIVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  EGMIRMAC
 * BLOCKS:   SYS
 * DESC:     Egress Mirror MAC Address Register
 * SIZE:     48
 * FIELDS:
 *     OUT_MIR_MAC      Egress Mirror MAC Address.MAC address that will be compared against engress frames in accordance with the OUT_MIRROR_FILTER rules.
 *
 ******************************************************************************/
#define BCM6300_A0_EGMIRMACr 0x00000220

#define BCM6300_A0_EGMIRMACr_SIZE 6

/*
 * This structure should be used to declare and program EGMIRMAC.
 *
 */
typedef union BCM6300_A0_EGMIRMACr_s {
	uint32_t v[2];
	uint32_t egmirmac[2];
	uint32_t _egmirmac;
} BCM6300_A0_EGMIRMACr_t;

#define BCM6300_A0_EGMIRMACr_CLR(r) CDK_MEMSET(&((r)._egmirmac), 0, sizeof(BCM6300_A0_EGMIRMACr_t))
#define BCM6300_A0_EGMIRMACr_SET(r,i,d) (r).egmirmac[i] = d
#define BCM6300_A0_EGMIRMACr_GET(r,i) (r).egmirmac[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_EGMIRMACr_OUT_MIR_MACf_GET(r,a) cdk_field_get((r).egmirmac,0,47,a)
#define BCM6300_A0_EGMIRMACr_OUT_MIR_MACf_SET(r,a) cdk_field_set((r).egmirmac,0,47,a)

/*
 * These macros can be used to access EGMIRMAC.
 *
 */
#define BCM6300_A0_READ_EGMIRMACr(u,r) cdk_robo_reg_read(u,BCM6300_A0_EGMIRMACr,(r._egmirmac),6)
#define BCM6300_A0_WRITE_EGMIRMACr(u,r) cdk_robo_reg_write(u,BCM6300_A0_EGMIRMACr,&(r._egmirmac),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGMIRMACr BCM6300_A0_EGMIRMACr
#define EGMIRMACr_SIZE BCM6300_A0_EGMIRMACr_SIZE
typedef BCM6300_A0_EGMIRMACr_t EGMIRMACr_t;
#define EGMIRMACr_CLR BCM6300_A0_EGMIRMACr_CLR
#define EGMIRMACr_SET BCM6300_A0_EGMIRMACr_SET
#define EGMIRMACr_GET BCM6300_A0_EGMIRMACr_GET
#define EGMIRMACr_OUT_MIR_MACf_GET BCM6300_A0_EGMIRMACr_OUT_MIR_MACf_GET
#define EGMIRMACr_OUT_MIR_MACf_SET BCM6300_A0_EGMIRMACr_OUT_MIR_MACf_SET
#define READ_EGMIRMACr BCM6300_A0_READ_EGMIRMACr
#define WRITE_EGMIRMACr BCM6300_A0_WRITE_EGMIRMACr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_EGMIRMACr'
 ******************************************************************************/

/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  FAST_AGE_CTL
 * BLOCKS:   SYS
 * DESC:     Fast Ageing Control Registrer
 * SIZE:     8
 * FIELDS:
 *     EN_FAST_AGE_STATIC Set 1'b1 to Age out Dymanic Entry.
 *     EN_AGE_DYNAMIC   Set 1'b1 to Age out Dymanic Entry.
 *     EN_AGE_PORT      Set 1'b1 to Check Port ID
 *     EN_AGE_VLAN      Set 1'b1 to Check Vlan ID.
 *     EN_AGE_SPT       set 1'b1 to check spanning Tree ID(refer to EN_802_1S/MSPT_AGE_MAP at page/address=43h/00h,02-05h)
 *     RESERVED_R       Reserved
 *     FAST_AGE_START_DONE When Set 1'b1, a control signal (fast_age_start) will invoke fast ageing mechanism.When Fast aging is done, a control signal (fast_age_done) will clear the control bit.
 *
 ******************************************************************************/
#define BCM6300_A0_FAST_AGE_CTLr 0x00000088

#define BCM6300_A0_FAST_AGE_CTLr_SIZE 1

/*
 * This structure should be used to declare and program FAST_AGE_CTL.
 *
 */
typedef union BCM6300_A0_FAST_AGE_CTLr_s {
	uint32_t v[1];
	uint32_t fast_age_ctl[1];
	uint32_t _fast_age_ctl;
} BCM6300_A0_FAST_AGE_CTLr_t;

#define BCM6300_A0_FAST_AGE_CTLr_CLR(r) (r).fast_age_ctl[0] = 0
#define BCM6300_A0_FAST_AGE_CTLr_SET(r,d) (r).fast_age_ctl[0] = d
#define BCM6300_A0_FAST_AGE_CTLr_GET(r) (r).fast_age_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_FAST_AGE_CTLr_EN_FAST_AGE_STATICf_GET(r) (((r).fast_age_ctl[0]) & 0x1)
#define BCM6300_A0_FAST_AGE_CTLr_EN_FAST_AGE_STATICf_SET(r,f) (r).fast_age_ctl[0]=(((r).fast_age_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM6300_A0_FAST_AGE_CTLr_EN_AGE_DYNAMICf_GET(r) ((((r).fast_age_ctl[0]) >> 1) & 0x1)
#define BCM6300_A0_FAST_AGE_CTLr_EN_AGE_DYNAMICf_SET(r,f) (r).fast_age_ctl[0]=(((r).fast_age_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM6300_A0_FAST_AGE_CTLr_EN_AGE_PORTf_GET(r) ((((r).fast_age_ctl[0]) >> 2) & 0x1)
#define BCM6300_A0_FAST_AGE_CTLr_EN_AGE_PORTf_SET(r,f) (r).fast_age_ctl[0]=(((r).fast_age_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM6300_A0_FAST_AGE_CTLr_EN_AGE_VLANf_GET(r) ((((r).fast_age_ctl[0]) >> 3) & 0x1)
#define BCM6300_A0_FAST_AGE_CTLr_EN_AGE_VLANf_SET(r,f) (r).fast_age_ctl[0]=(((r).fast_age_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM6300_A0_FAST_AGE_CTLr_EN_AGE_SPTf_GET(r) ((((r).fast_age_ctl[0]) >> 4) & 0x1)
#define BCM6300_A0_FAST_AGE_CTLr_EN_AGE_SPTf_SET(r,f) (r).fast_age_ctl[0]=(((r).fast_age_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM6300_A0_FAST_AGE_CTLr_RESERVED_Rf_GET(r) ((((r).fast_age_ctl[0]) >> 5) & 0x3)
#define BCM6300_A0_FAST_AGE_CTLr_RESERVED_Rf_SET(r,f) (r).fast_age_ctl[0]=(((r).fast_age_ctl[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM6300_A0_FAST_AGE_CTLr_FAST_AGE_START_DONEf_GET(r) ((((r).fast_age_ctl[0]) >> 7) & 0x1)
#define BCM6300_A0_FAST_AGE_CTLr_FAST_AGE_START_DONEf_SET(r,f) (r).fast_age_ctl[0]=(((r).fast_age_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access FAST_AGE_CTL.
 *
 */
#define BCM6300_A0_READ_FAST_AGE_CTLr(u,r) cdk_robo_reg_read(u,BCM6300_A0_FAST_AGE_CTLr,(r._fast_age_ctl),1)
#define BCM6300_A0_WRITE_FAST_AGE_CTLr(u,r) cdk_robo_reg_write(u,BCM6300_A0_FAST_AGE_CTLr,&(r._fast_age_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FAST_AGE_CTLr BCM6300_A0_FAST_AGE_CTLr
#define FAST_AGE_CTLr_SIZE BCM6300_A0_FAST_AGE_CTLr_SIZE
typedef BCM6300_A0_FAST_AGE_CTLr_t FAST_AGE_CTLr_t;
#define FAST_AGE_CTLr_CLR BCM6300_A0_FAST_AGE_CTLr_CLR
#define FAST_AGE_CTLr_SET BCM6300_A0_FAST_AGE_CTLr_SET
#define FAST_AGE_CTLr_GET BCM6300_A0_FAST_AGE_CTLr_GET
#define FAST_AGE_CTLr_EN_FAST_AGE_STATICf_GET BCM6300_A0_FAST_AGE_CTLr_EN_FAST_AGE_STATICf_GET
#define FAST_AGE_CTLr_EN_FAST_AGE_STATICf_SET BCM6300_A0_FAST_AGE_CTLr_EN_FAST_AGE_STATICf_SET
#define FAST_AGE_CTLr_EN_AGE_DYNAMICf_GET BCM6300_A0_FAST_AGE_CTLr_EN_AGE_DYNAMICf_GET
#define FAST_AGE_CTLr_EN_AGE_DYNAMICf_SET BCM6300_A0_FAST_AGE_CTLr_EN_AGE_DYNAMICf_SET
#define FAST_AGE_CTLr_EN_AGE_PORTf_GET BCM6300_A0_FAST_AGE_CTLr_EN_AGE_PORTf_GET
#define FAST_AGE_CTLr_EN_AGE_PORTf_SET BCM6300_A0_FAST_AGE_CTLr_EN_AGE_PORTf_SET
#define FAST_AGE_CTLr_EN_AGE_VLANf_GET BCM6300_A0_FAST_AGE_CTLr_EN_AGE_VLANf_GET
#define FAST_AGE_CTLr_EN_AGE_VLANf_SET BCM6300_A0_FAST_AGE_CTLr_EN_AGE_VLANf_SET
#define FAST_AGE_CTLr_EN_AGE_SPTf_GET BCM6300_A0_FAST_AGE_CTLr_EN_AGE_SPTf_GET
#define FAST_AGE_CTLr_EN_AGE_SPTf_SET BCM6300_A0_FAST_AGE_CTLr_EN_AGE_SPTf_SET
#define FAST_AGE_CTLr_RESERVED_Rf_GET BCM6300_A0_FAST_AGE_CTLr_RESERVED_Rf_GET
#define FAST_AGE_CTLr_RESERVED_Rf_SET BCM6300_A0_FAST_AGE_CTLr_RESERVED_Rf_SET
#define FAST_AGE_CTLr_FAST_AGE_START_DONEf_GET BCM6300_A0_FAST_AGE_CTLr_FAST_AGE_START_DONEf_GET
#define FAST_AGE_CTLr_FAST_AGE_START_DONEf_SET BCM6300_A0_FAST_AGE_CTLr_FAST_AGE_START_DONEf_SET
#define READ_FAST_AGE_CTLr BCM6300_A0_READ_FAST_AGE_CTLr
#define WRITE_FAST_AGE_CTLr BCM6300_A0_WRITE_FAST_AGE_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_FAST_AGE_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  FAST_AGING_PORT
 * BLOCKS:   SYS
 * DESC:     Fast Ageing Port Control Registrer
 * SIZE:     8
 * FIELDS:
 *     AGE_SRC_PORT     Select Fast Ageing Source Port.Select a specified Port ID to be aged-out.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_FAST_AGING_PORTr 0x00000089

#define BCM6300_A0_FAST_AGING_PORTr_SIZE 1

/*
 * This structure should be used to declare and program FAST_AGING_PORT.
 *
 */
typedef union BCM6300_A0_FAST_AGING_PORTr_s {
	uint32_t v[1];
	uint32_t fast_aging_port[1];
	uint32_t _fast_aging_port;
} BCM6300_A0_FAST_AGING_PORTr_t;

#define BCM6300_A0_FAST_AGING_PORTr_CLR(r) (r).fast_aging_port[0] = 0
#define BCM6300_A0_FAST_AGING_PORTr_SET(r,d) (r).fast_aging_port[0] = d
#define BCM6300_A0_FAST_AGING_PORTr_GET(r) (r).fast_aging_port[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_FAST_AGING_PORTr_AGE_SRC_PORTf_GET(r) (((r).fast_aging_port[0]) & 0xf)
#define BCM6300_A0_FAST_AGING_PORTr_AGE_SRC_PORTf_SET(r,f) (r).fast_aging_port[0]=(((r).fast_aging_port[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM6300_A0_FAST_AGING_PORTr_RESERVED_Rf_GET(r) ((((r).fast_aging_port[0]) >> 4) & 0xf)
#define BCM6300_A0_FAST_AGING_PORTr_RESERVED_Rf_SET(r,f) (r).fast_aging_port[0]=(((r).fast_aging_port[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access FAST_AGING_PORT.
 *
 */
#define BCM6300_A0_READ_FAST_AGING_PORTr(u,r) cdk_robo_reg_read(u,BCM6300_A0_FAST_AGING_PORTr,(r._fast_aging_port),1)
#define BCM6300_A0_WRITE_FAST_AGING_PORTr(u,r) cdk_robo_reg_write(u,BCM6300_A0_FAST_AGING_PORTr,&(r._fast_aging_port),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FAST_AGING_PORTr BCM6300_A0_FAST_AGING_PORTr
#define FAST_AGING_PORTr_SIZE BCM6300_A0_FAST_AGING_PORTr_SIZE
typedef BCM6300_A0_FAST_AGING_PORTr_t FAST_AGING_PORTr_t;
#define FAST_AGING_PORTr_CLR BCM6300_A0_FAST_AGING_PORTr_CLR
#define FAST_AGING_PORTr_SET BCM6300_A0_FAST_AGING_PORTr_SET
#define FAST_AGING_PORTr_GET BCM6300_A0_FAST_AGING_PORTr_GET
#define FAST_AGING_PORTr_AGE_SRC_PORTf_GET BCM6300_A0_FAST_AGING_PORTr_AGE_SRC_PORTf_GET
#define FAST_AGING_PORTr_AGE_SRC_PORTf_SET BCM6300_A0_FAST_AGING_PORTr_AGE_SRC_PORTf_SET
#define FAST_AGING_PORTr_RESERVED_Rf_GET BCM6300_A0_FAST_AGING_PORTr_RESERVED_Rf_GET
#define FAST_AGING_PORTr_RESERVED_Rf_SET BCM6300_A0_FAST_AGING_PORTr_RESERVED_Rf_SET
#define READ_FAST_AGING_PORTr BCM6300_A0_READ_FAST_AGING_PORTr
#define WRITE_FAST_AGING_PORTr BCM6300_A0_WRITE_FAST_AGING_PORTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_FAST_AGING_PORTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  FAST_AGING_VID
 * BLOCKS:   SYS
 * DESC:     Fast Ageing VID Control Registrer
 * SIZE:     16
 * FIELDS:
 *     AGE_VID          Select Fast Ageing VLAN IDSelect a specified VLAN ID to be aged-out.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_FAST_AGING_VIDr 0x0000008a

#define BCM6300_A0_FAST_AGING_VIDr_SIZE 2

/*
 * This structure should be used to declare and program FAST_AGING_VID.
 *
 */
typedef union BCM6300_A0_FAST_AGING_VIDr_s {
	uint32_t v[1];
	uint32_t fast_aging_vid[1];
	uint32_t _fast_aging_vid;
} BCM6300_A0_FAST_AGING_VIDr_t;

#define BCM6300_A0_FAST_AGING_VIDr_CLR(r) (r).fast_aging_vid[0] = 0
#define BCM6300_A0_FAST_AGING_VIDr_SET(r,d) (r).fast_aging_vid[0] = d
#define BCM6300_A0_FAST_AGING_VIDr_GET(r) (r).fast_aging_vid[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_FAST_AGING_VIDr_AGE_VIDf_GET(r) (((r).fast_aging_vid[0]) & 0xfff)
#define BCM6300_A0_FAST_AGING_VIDr_AGE_VIDf_SET(r,f) (r).fast_aging_vid[0]=(((r).fast_aging_vid[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM6300_A0_FAST_AGING_VIDr_RESERVED_Rf_GET(r) ((((r).fast_aging_vid[0]) >> 12) & 0xf)
#define BCM6300_A0_FAST_AGING_VIDr_RESERVED_Rf_SET(r,f) (r).fast_aging_vid[0]=(((r).fast_aging_vid[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access FAST_AGING_VID.
 *
 */
#define BCM6300_A0_READ_FAST_AGING_VIDr(u,r) cdk_robo_reg_read(u,BCM6300_A0_FAST_AGING_VIDr,(r._fast_aging_vid),2)
#define BCM6300_A0_WRITE_FAST_AGING_VIDr(u,r) cdk_robo_reg_write(u,BCM6300_A0_FAST_AGING_VIDr,&(r._fast_aging_vid),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FAST_AGING_VIDr BCM6300_A0_FAST_AGING_VIDr
#define FAST_AGING_VIDr_SIZE BCM6300_A0_FAST_AGING_VIDr_SIZE
typedef BCM6300_A0_FAST_AGING_VIDr_t FAST_AGING_VIDr_t;
#define FAST_AGING_VIDr_CLR BCM6300_A0_FAST_AGING_VIDr_CLR
#define FAST_AGING_VIDr_SET BCM6300_A0_FAST_AGING_VIDr_SET
#define FAST_AGING_VIDr_GET BCM6300_A0_FAST_AGING_VIDr_GET
#define FAST_AGING_VIDr_AGE_VIDf_GET BCM6300_A0_FAST_AGING_VIDr_AGE_VIDf_GET
#define FAST_AGING_VIDr_AGE_VIDf_SET BCM6300_A0_FAST_AGING_VIDr_AGE_VIDf_SET
#define FAST_AGING_VIDr_RESERVED_Rf_GET BCM6300_A0_FAST_AGING_VIDr_RESERVED_Rf_GET
#define FAST_AGING_VIDr_RESERVED_Rf_SET BCM6300_A0_FAST_AGING_VIDr_RESERVED_Rf_SET
#define READ_FAST_AGING_VIDr BCM6300_A0_READ_FAST_AGING_VIDr
#define WRITE_FAST_AGING_VIDr BCM6300_A0_WRITE_FAST_AGING_VIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_FAST_AGING_VIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  FC_CHIP_INFO
 * BLOCKS:   SYS
 * DESC:     Chip Info For FC Register
 * SIZE:     16
 * FIELDS:
 *     PRT_LINK         
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_FC_CHIP_INFOr 0x00000a9a

#define BCM6300_A0_FC_CHIP_INFOr_SIZE 2

/*
 * This structure should be used to declare and program FC_CHIP_INFO.
 *
 */
typedef union BCM6300_A0_FC_CHIP_INFOr_s {
	uint32_t v[1];
	uint32_t fc_chip_info[1];
	uint32_t _fc_chip_info;
} BCM6300_A0_FC_CHIP_INFOr_t;

#define BCM6300_A0_FC_CHIP_INFOr_CLR(r) (r).fc_chip_info[0] = 0
#define BCM6300_A0_FC_CHIP_INFOr_SET(r,d) (r).fc_chip_info[0] = d
#define BCM6300_A0_FC_CHIP_INFOr_GET(r) (r).fc_chip_info[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_FC_CHIP_INFOr_PRT_LINKf_GET(r) (((r).fc_chip_info[0]) & 0x1ff)
#define BCM6300_A0_FC_CHIP_INFOr_PRT_LINKf_SET(r,f) (r).fc_chip_info[0]=(((r).fc_chip_info[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_FC_CHIP_INFOr_RESERVED_Rf_GET(r) ((((r).fc_chip_info[0]) >> 9) & 0x7f)
#define BCM6300_A0_FC_CHIP_INFOr_RESERVED_Rf_SET(r,f) (r).fc_chip_info[0]=(((r).fc_chip_info[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access FC_CHIP_INFO.
 *
 */
#define BCM6300_A0_READ_FC_CHIP_INFOr(u,r) cdk_robo_reg_read(u,BCM6300_A0_FC_CHIP_INFOr,(r._fc_chip_info),2)
#define BCM6300_A0_WRITE_FC_CHIP_INFOr(u,r) cdk_robo_reg_write(u,BCM6300_A0_FC_CHIP_INFOr,&(r._fc_chip_info),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_CHIP_INFOr BCM6300_A0_FC_CHIP_INFOr
#define FC_CHIP_INFOr_SIZE BCM6300_A0_FC_CHIP_INFOr_SIZE
typedef BCM6300_A0_FC_CHIP_INFOr_t FC_CHIP_INFOr_t;
#define FC_CHIP_INFOr_CLR BCM6300_A0_FC_CHIP_INFOr_CLR
#define FC_CHIP_INFOr_SET BCM6300_A0_FC_CHIP_INFOr_SET
#define FC_CHIP_INFOr_GET BCM6300_A0_FC_CHIP_INFOr_GET
#define FC_CHIP_INFOr_PRT_LINKf_GET BCM6300_A0_FC_CHIP_INFOr_PRT_LINKf_GET
#define FC_CHIP_INFOr_PRT_LINKf_SET BCM6300_A0_FC_CHIP_INFOr_PRT_LINKf_SET
#define FC_CHIP_INFOr_RESERVED_Rf_GET BCM6300_A0_FC_CHIP_INFOr_RESERVED_Rf_GET
#define FC_CHIP_INFOr_RESERVED_Rf_SET BCM6300_A0_FC_CHIP_INFOr_RESERVED_Rf_SET
#define READ_FC_CHIP_INFOr BCM6300_A0_READ_FC_CHIP_INFOr
#define WRITE_FC_CHIP_INFOr BCM6300_A0_WRITE_FC_CHIP_INFOr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_FC_CHIP_INFOr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  FC_CONG_BUF_ERR_HIS
 * BLOCKS:   SYS
 * DESC:     Congested Bus Error Register
 * SIZE:     16
 * FIELDS:
 *     CONG_BUF_ERR_HIS 
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_FC_CONG_BUF_ERR_HISr 0x00000aaa

#define BCM6300_A0_FC_CONG_BUF_ERR_HISr_SIZE 2

/*
 * This structure should be used to declare and program FC_CONG_BUF_ERR_HIS.
 *
 */
typedef union BCM6300_A0_FC_CONG_BUF_ERR_HISr_s {
	uint32_t v[1];
	uint32_t fc_cong_buf_err_his[1];
	uint32_t _fc_cong_buf_err_his;
} BCM6300_A0_FC_CONG_BUF_ERR_HISr_t;

#define BCM6300_A0_FC_CONG_BUF_ERR_HISr_CLR(r) (r).fc_cong_buf_err_his[0] = 0
#define BCM6300_A0_FC_CONG_BUF_ERR_HISr_SET(r,d) (r).fc_cong_buf_err_his[0] = d
#define BCM6300_A0_FC_CONG_BUF_ERR_HISr_GET(r) (r).fc_cong_buf_err_his[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_FC_CONG_BUF_ERR_HISr_CONG_BUF_ERR_HISf_GET(r) (((r).fc_cong_buf_err_his[0]) & 0x1)
#define BCM6300_A0_FC_CONG_BUF_ERR_HISr_CONG_BUF_ERR_HISf_SET(r,f) (r).fc_cong_buf_err_his[0]=(((r).fc_cong_buf_err_his[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM6300_A0_FC_CONG_BUF_ERR_HISr_RESERVED_Rf_GET(r) ((((r).fc_cong_buf_err_his[0]) >> 1) & 0x7fff)
#define BCM6300_A0_FC_CONG_BUF_ERR_HISr_RESERVED_Rf_SET(r,f) (r).fc_cong_buf_err_his[0]=(((r).fc_cong_buf_err_his[0] & ~((uint32_t)0x7fff << 1)) | ((((uint32_t)f) & 0x7fff) << 1))

/*
 * These macros can be used to access FC_CONG_BUF_ERR_HIS.
 *
 */
#define BCM6300_A0_READ_FC_CONG_BUF_ERR_HISr(u,r) cdk_robo_reg_read(u,BCM6300_A0_FC_CONG_BUF_ERR_HISr,(r._fc_cong_buf_err_his),2)
#define BCM6300_A0_WRITE_FC_CONG_BUF_ERR_HISr(u,r) cdk_robo_reg_write(u,BCM6300_A0_FC_CONG_BUF_ERR_HISr,&(r._fc_cong_buf_err_his),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_CONG_BUF_ERR_HISr BCM6300_A0_FC_CONG_BUF_ERR_HISr
#define FC_CONG_BUF_ERR_HISr_SIZE BCM6300_A0_FC_CONG_BUF_ERR_HISr_SIZE
typedef BCM6300_A0_FC_CONG_BUF_ERR_HISr_t FC_CONG_BUF_ERR_HISr_t;
#define FC_CONG_BUF_ERR_HISr_CLR BCM6300_A0_FC_CONG_BUF_ERR_HISr_CLR
#define FC_CONG_BUF_ERR_HISr_SET BCM6300_A0_FC_CONG_BUF_ERR_HISr_SET
#define FC_CONG_BUF_ERR_HISr_GET BCM6300_A0_FC_CONG_BUF_ERR_HISr_GET
#define FC_CONG_BUF_ERR_HISr_CONG_BUF_ERR_HISf_GET BCM6300_A0_FC_CONG_BUF_ERR_HISr_CONG_BUF_ERR_HISf_GET
#define FC_CONG_BUF_ERR_HISr_CONG_BUF_ERR_HISf_SET BCM6300_A0_FC_CONG_BUF_ERR_HISr_CONG_BUF_ERR_HISf_SET
#define FC_CONG_BUF_ERR_HISr_RESERVED_Rf_GET BCM6300_A0_FC_CONG_BUF_ERR_HISr_RESERVED_Rf_GET
#define FC_CONG_BUF_ERR_HISr_RESERVED_Rf_SET BCM6300_A0_FC_CONG_BUF_ERR_HISr_RESERVED_Rf_SET
#define READ_FC_CONG_BUF_ERR_HISr BCM6300_A0_READ_FC_CONG_BUF_ERR_HISr
#define WRITE_FC_CONG_BUF_ERR_HISr BCM6300_A0_WRITE_FC_CONG_BUF_ERR_HISr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_FC_CONG_BUF_ERR_HISr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  FC_CONG_PORTMAP01
 * BLOCKS:   SYS
 * DESC:     Congested PortMap Port01 Register
 * SIZE:     16
 * FIELDS:
 *     CONG_PORTMAP0    
 *     CONG_PORTMAP1    Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_FC_CONG_PORTMAP01r 0x00000a90

#define BCM6300_A0_FC_CONG_PORTMAP01r_SIZE 2

/*
 * This structure should be used to declare and program FC_CONG_PORTMAP01.
 *
 */
typedef union BCM6300_A0_FC_CONG_PORTMAP01r_s {
	uint32_t v[1];
	uint32_t fc_cong_portmap01[1];
	uint32_t _fc_cong_portmap01;
} BCM6300_A0_FC_CONG_PORTMAP01r_t;

#define BCM6300_A0_FC_CONG_PORTMAP01r_CLR(r) (r).fc_cong_portmap01[0] = 0
#define BCM6300_A0_FC_CONG_PORTMAP01r_SET(r,d) (r).fc_cong_portmap01[0] = d
#define BCM6300_A0_FC_CONG_PORTMAP01r_GET(r) (r).fc_cong_portmap01[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP0f_GET(r) (((r).fc_cong_portmap01[0]) & 0xff)
#define BCM6300_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP0f_SET(r,f) (r).fc_cong_portmap01[0]=(((r).fc_cong_portmap01[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM6300_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP1f_GET(r) ((((r).fc_cong_portmap01[0]) >> 8) & 0xff)
#define BCM6300_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP1f_SET(r,f) (r).fc_cong_portmap01[0]=(((r).fc_cong_portmap01[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_CONG_PORTMAP01.
 *
 */
#define BCM6300_A0_READ_FC_CONG_PORTMAP01r(u,r) cdk_robo_reg_read(u,BCM6300_A0_FC_CONG_PORTMAP01r,(r._fc_cong_portmap01),2)
#define BCM6300_A0_WRITE_FC_CONG_PORTMAP01r(u,r) cdk_robo_reg_write(u,BCM6300_A0_FC_CONG_PORTMAP01r,&(r._fc_cong_portmap01),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_CONG_PORTMAP01r BCM6300_A0_FC_CONG_PORTMAP01r
#define FC_CONG_PORTMAP01r_SIZE BCM6300_A0_FC_CONG_PORTMAP01r_SIZE
typedef BCM6300_A0_FC_CONG_PORTMAP01r_t FC_CONG_PORTMAP01r_t;
#define FC_CONG_PORTMAP01r_CLR BCM6300_A0_FC_CONG_PORTMAP01r_CLR
#define FC_CONG_PORTMAP01r_SET BCM6300_A0_FC_CONG_PORTMAP01r_SET
#define FC_CONG_PORTMAP01r_GET BCM6300_A0_FC_CONG_PORTMAP01r_GET
#define FC_CONG_PORTMAP01r_CONG_PORTMAP0f_GET BCM6300_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP0f_GET
#define FC_CONG_PORTMAP01r_CONG_PORTMAP0f_SET BCM6300_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP0f_SET
#define FC_CONG_PORTMAP01r_CONG_PORTMAP1f_GET BCM6300_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP1f_GET
#define FC_CONG_PORTMAP01r_CONG_PORTMAP1f_SET BCM6300_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP1f_SET
#define READ_FC_CONG_PORTMAP01r BCM6300_A0_READ_FC_CONG_PORTMAP01r
#define WRITE_FC_CONG_PORTMAP01r BCM6300_A0_WRITE_FC_CONG_PORTMAP01r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_FC_CONG_PORTMAP01r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  FC_CONG_PORTMAP23
 * BLOCKS:   SYS
 * DESC:     Congested PortMap Port23 Register
 * SIZE:     16
 * FIELDS:
 *     CONG_PORTMAP2    
 *     CONG_PORTMAP3    Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_FC_CONG_PORTMAP23r 0x00000a92

#define BCM6300_A0_FC_CONG_PORTMAP23r_SIZE 2

/*
 * This structure should be used to declare and program FC_CONG_PORTMAP23.
 *
 */
typedef union BCM6300_A0_FC_CONG_PORTMAP23r_s {
	uint32_t v[1];
	uint32_t fc_cong_portmap23[1];
	uint32_t _fc_cong_portmap23;
} BCM6300_A0_FC_CONG_PORTMAP23r_t;

#define BCM6300_A0_FC_CONG_PORTMAP23r_CLR(r) (r).fc_cong_portmap23[0] = 0
#define BCM6300_A0_FC_CONG_PORTMAP23r_SET(r,d) (r).fc_cong_portmap23[0] = d
#define BCM6300_A0_FC_CONG_PORTMAP23r_GET(r) (r).fc_cong_portmap23[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP2f_GET(r) (((r).fc_cong_portmap23[0]) & 0xff)
#define BCM6300_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP2f_SET(r,f) (r).fc_cong_portmap23[0]=(((r).fc_cong_portmap23[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM6300_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP3f_GET(r) ((((r).fc_cong_portmap23[0]) >> 8) & 0xff)
#define BCM6300_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP3f_SET(r,f) (r).fc_cong_portmap23[0]=(((r).fc_cong_portmap23[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_CONG_PORTMAP23.
 *
 */
#define BCM6300_A0_READ_FC_CONG_PORTMAP23r(u,r) cdk_robo_reg_read(u,BCM6300_A0_FC_CONG_PORTMAP23r,(r._fc_cong_portmap23),2)
#define BCM6300_A0_WRITE_FC_CONG_PORTMAP23r(u,r) cdk_robo_reg_write(u,BCM6300_A0_FC_CONG_PORTMAP23r,&(r._fc_cong_portmap23),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_CONG_PORTMAP23r BCM6300_A0_FC_CONG_PORTMAP23r
#define FC_CONG_PORTMAP23r_SIZE BCM6300_A0_FC_CONG_PORTMAP23r_SIZE
typedef BCM6300_A0_FC_CONG_PORTMAP23r_t FC_CONG_PORTMAP23r_t;
#define FC_CONG_PORTMAP23r_CLR BCM6300_A0_FC_CONG_PORTMAP23r_CLR
#define FC_CONG_PORTMAP23r_SET BCM6300_A0_FC_CONG_PORTMAP23r_SET
#define FC_CONG_PORTMAP23r_GET BCM6300_A0_FC_CONG_PORTMAP23r_GET
#define FC_CONG_PORTMAP23r_CONG_PORTMAP2f_GET BCM6300_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP2f_GET
#define FC_CONG_PORTMAP23r_CONG_PORTMAP2f_SET BCM6300_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP2f_SET
#define FC_CONG_PORTMAP23r_CONG_PORTMAP3f_GET BCM6300_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP3f_GET
#define FC_CONG_PORTMAP23r_CONG_PORTMAP3f_SET BCM6300_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP3f_SET
#define READ_FC_CONG_PORTMAP23r BCM6300_A0_READ_FC_CONG_PORTMAP23r
#define WRITE_FC_CONG_PORTMAP23r BCM6300_A0_WRITE_FC_CONG_PORTMAP23r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_FC_CONG_PORTMAP23r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  FC_CONG_PORTMAP45
 * BLOCKS:   SYS
 * DESC:     Congested PortMap Port45 Register
 * SIZE:     16
 * FIELDS:
 *     CONG_PORTMAP4    
 *     CONG_PORTMAP5    Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_FC_CONG_PORTMAP45r 0x00000a94

#define BCM6300_A0_FC_CONG_PORTMAP45r_SIZE 2

/*
 * This structure should be used to declare and program FC_CONG_PORTMAP45.
 *
 */
typedef union BCM6300_A0_FC_CONG_PORTMAP45r_s {
	uint32_t v[1];
	uint32_t fc_cong_portmap45[1];
	uint32_t _fc_cong_portmap45;
} BCM6300_A0_FC_CONG_PORTMAP45r_t;

#define BCM6300_A0_FC_CONG_PORTMAP45r_CLR(r) (r).fc_cong_portmap45[0] = 0
#define BCM6300_A0_FC_CONG_PORTMAP45r_SET(r,d) (r).fc_cong_portmap45[0] = d
#define BCM6300_A0_FC_CONG_PORTMAP45r_GET(r) (r).fc_cong_portmap45[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP4f_GET(r) (((r).fc_cong_portmap45[0]) & 0xff)
#define BCM6300_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP4f_SET(r,f) (r).fc_cong_portmap45[0]=(((r).fc_cong_portmap45[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM6300_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP5f_GET(r) ((((r).fc_cong_portmap45[0]) >> 8) & 0xff)
#define BCM6300_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP5f_SET(r,f) (r).fc_cong_portmap45[0]=(((r).fc_cong_portmap45[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_CONG_PORTMAP45.
 *
 */
#define BCM6300_A0_READ_FC_CONG_PORTMAP45r(u,r) cdk_robo_reg_read(u,BCM6300_A0_FC_CONG_PORTMAP45r,(r._fc_cong_portmap45),2)
#define BCM6300_A0_WRITE_FC_CONG_PORTMAP45r(u,r) cdk_robo_reg_write(u,BCM6300_A0_FC_CONG_PORTMAP45r,&(r._fc_cong_portmap45),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_CONG_PORTMAP45r BCM6300_A0_FC_CONG_PORTMAP45r
#define FC_CONG_PORTMAP45r_SIZE BCM6300_A0_FC_CONG_PORTMAP45r_SIZE
typedef BCM6300_A0_FC_CONG_PORTMAP45r_t FC_CONG_PORTMAP45r_t;
#define FC_CONG_PORTMAP45r_CLR BCM6300_A0_FC_CONG_PORTMAP45r_CLR
#define FC_CONG_PORTMAP45r_SET BCM6300_A0_FC_CONG_PORTMAP45r_SET
#define FC_CONG_PORTMAP45r_GET BCM6300_A0_FC_CONG_PORTMAP45r_GET
#define FC_CONG_PORTMAP45r_CONG_PORTMAP4f_GET BCM6300_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP4f_GET
#define FC_CONG_PORTMAP45r_CONG_PORTMAP4f_SET BCM6300_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP4f_SET
#define FC_CONG_PORTMAP45r_CONG_PORTMAP5f_GET BCM6300_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP5f_GET
#define FC_CONG_PORTMAP45r_CONG_PORTMAP5f_SET BCM6300_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP5f_SET
#define READ_FC_CONG_PORTMAP45r BCM6300_A0_READ_FC_CONG_PORTMAP45r
#define WRITE_FC_CONG_PORTMAP45r BCM6300_A0_WRITE_FC_CONG_PORTMAP45r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_FC_CONG_PORTMAP45r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  FC_CONG_PORTMAP67
 * BLOCKS:   SYS
 * DESC:     Congested PortMap Port67 Register
 * SIZE:     16
 * FIELDS:
 *     CONG_PORTMAP6    
 *     CONG_PORTMAP7    Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_FC_CONG_PORTMAP67r 0x00000a96

#define BCM6300_A0_FC_CONG_PORTMAP67r_SIZE 2

/*
 * This structure should be used to declare and program FC_CONG_PORTMAP67.
 *
 */
typedef union BCM6300_A0_FC_CONG_PORTMAP67r_s {
	uint32_t v[1];
	uint32_t fc_cong_portmap67[1];
	uint32_t _fc_cong_portmap67;
} BCM6300_A0_FC_CONG_PORTMAP67r_t;

#define BCM6300_A0_FC_CONG_PORTMAP67r_CLR(r) (r).fc_cong_portmap67[0] = 0
#define BCM6300_A0_FC_CONG_PORTMAP67r_SET(r,d) (r).fc_cong_portmap67[0] = d
#define BCM6300_A0_FC_CONG_PORTMAP67r_GET(r) (r).fc_cong_portmap67[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP6f_GET(r) (((r).fc_cong_portmap67[0]) & 0xff)
#define BCM6300_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP6f_SET(r,f) (r).fc_cong_portmap67[0]=(((r).fc_cong_portmap67[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM6300_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP7f_GET(r) ((((r).fc_cong_portmap67[0]) >> 8) & 0xff)
#define BCM6300_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP7f_SET(r,f) (r).fc_cong_portmap67[0]=(((r).fc_cong_portmap67[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_CONG_PORTMAP67.
 *
 */
#define BCM6300_A0_READ_FC_CONG_PORTMAP67r(u,r) cdk_robo_reg_read(u,BCM6300_A0_FC_CONG_PORTMAP67r,(r._fc_cong_portmap67),2)
#define BCM6300_A0_WRITE_FC_CONG_PORTMAP67r(u,r) cdk_robo_reg_write(u,BCM6300_A0_FC_CONG_PORTMAP67r,&(r._fc_cong_portmap67),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_CONG_PORTMAP67r BCM6300_A0_FC_CONG_PORTMAP67r
#define FC_CONG_PORTMAP67r_SIZE BCM6300_A0_FC_CONG_PORTMAP67r_SIZE
typedef BCM6300_A0_FC_CONG_PORTMAP67r_t FC_CONG_PORTMAP67r_t;
#define FC_CONG_PORTMAP67r_CLR BCM6300_A0_FC_CONG_PORTMAP67r_CLR
#define FC_CONG_PORTMAP67r_SET BCM6300_A0_FC_CONG_PORTMAP67r_SET
#define FC_CONG_PORTMAP67r_GET BCM6300_A0_FC_CONG_PORTMAP67r_GET
#define FC_CONG_PORTMAP67r_CONG_PORTMAP6f_GET BCM6300_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP6f_GET
#define FC_CONG_PORTMAP67r_CONG_PORTMAP6f_SET BCM6300_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP6f_SET
#define FC_CONG_PORTMAP67r_CONG_PORTMAP7f_GET BCM6300_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP7f_GET
#define FC_CONG_PORTMAP67r_CONG_PORTMAP7f_SET BCM6300_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP7f_SET
#define READ_FC_CONG_PORTMAP67r BCM6300_A0_READ_FC_CONG_PORTMAP67r
#define WRITE_FC_CONG_PORTMAP67r BCM6300_A0_WRITE_FC_CONG_PORTMAP67r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_FC_CONG_PORTMAP67r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  FC_CONG_PORTMAP8
 * BLOCKS:   SYS
 * DESC:     Congested PortMap Port8 Register
 * SIZE:     8
 * FIELDS:
 *     CONG_PORTMAP8    
 *
 ******************************************************************************/
#define BCM6300_A0_FC_CONG_PORTMAP8r 0x00000a98

#define BCM6300_A0_FC_CONG_PORTMAP8r_SIZE 1

/*
 * This structure should be used to declare and program FC_CONG_PORTMAP8.
 *
 */
typedef union BCM6300_A0_FC_CONG_PORTMAP8r_s {
	uint32_t v[1];
	uint32_t fc_cong_portmap8[1];
	uint32_t _fc_cong_portmap8;
} BCM6300_A0_FC_CONG_PORTMAP8r_t;

#define BCM6300_A0_FC_CONG_PORTMAP8r_CLR(r) (r).fc_cong_portmap8[0] = 0
#define BCM6300_A0_FC_CONG_PORTMAP8r_SET(r,d) (r).fc_cong_portmap8[0] = d
#define BCM6300_A0_FC_CONG_PORTMAP8r_GET(r) (r).fc_cong_portmap8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_FC_CONG_PORTMAP8r_CONG_PORTMAP8f_GET(r) (((r).fc_cong_portmap8[0]) & 0xff)
#define BCM6300_A0_FC_CONG_PORTMAP8r_CONG_PORTMAP8f_SET(r,f) (r).fc_cong_portmap8[0]=(((r).fc_cong_portmap8[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access FC_CONG_PORTMAP8.
 *
 */
#define BCM6300_A0_READ_FC_CONG_PORTMAP8r(u,r) cdk_robo_reg_read(u,BCM6300_A0_FC_CONG_PORTMAP8r,(r._fc_cong_portmap8),1)
#define BCM6300_A0_WRITE_FC_CONG_PORTMAP8r(u,r) cdk_robo_reg_write(u,BCM6300_A0_FC_CONG_PORTMAP8r,&(r._fc_cong_portmap8),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_CONG_PORTMAP8r BCM6300_A0_FC_CONG_PORTMAP8r
#define FC_CONG_PORTMAP8r_SIZE BCM6300_A0_FC_CONG_PORTMAP8r_SIZE
typedef BCM6300_A0_FC_CONG_PORTMAP8r_t FC_CONG_PORTMAP8r_t;
#define FC_CONG_PORTMAP8r_CLR BCM6300_A0_FC_CONG_PORTMAP8r_CLR
#define FC_CONG_PORTMAP8r_SET BCM6300_A0_FC_CONG_PORTMAP8r_SET
#define FC_CONG_PORTMAP8r_GET BCM6300_A0_FC_CONG_PORTMAP8r_GET
#define FC_CONG_PORTMAP8r_CONG_PORTMAP8f_GET BCM6300_A0_FC_CONG_PORTMAP8r_CONG_PORTMAP8f_GET
#define FC_CONG_PORTMAP8r_CONG_PORTMAP8f_SET BCM6300_A0_FC_CONG_PORTMAP8r_CONG_PORTMAP8f_SET
#define READ_FC_CONG_PORTMAP8r BCM6300_A0_READ_FC_CONG_PORTMAP8r
#define WRITE_FC_CONG_PORTMAP8r BCM6300_A0_WRITE_FC_CONG_PORTMAP8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_FC_CONG_PORTMAP8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  FC_DIAG_CTRL
 * BLOCKS:   SYS
 * DESC:     Flowcon Diagnosis Control Register
 * SIZE:     16
 * FIELDS:
 *     DIG_FLOWCON_PROT Diagnosis only: Select which port to be monitored. 4'd0 : port 0; 4'd1: port1;  4'd 7: port 7
 *     RESERVED_1R      Reserved.
 *     RESERVED_2R      Reserved.
 *     RESERVED_3R      Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_FC_DIAG_CTRLr 0x00000a00

#define BCM6300_A0_FC_DIAG_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program FC_DIAG_CTRL.
 *
 */
typedef union BCM6300_A0_FC_DIAG_CTRLr_s {
	uint32_t v[1];
	uint32_t fc_diag_ctrl[1];
	uint32_t _fc_diag_ctrl;
} BCM6300_A0_FC_DIAG_CTRLr_t;

#define BCM6300_A0_FC_DIAG_CTRLr_CLR(r) (r).fc_diag_ctrl[0] = 0
#define BCM6300_A0_FC_DIAG_CTRLr_SET(r,d) (r).fc_diag_ctrl[0] = d
#define BCM6300_A0_FC_DIAG_CTRLr_GET(r) (r).fc_diag_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_FC_DIAG_CTRLr_DIG_FLOWCON_PROTf_GET(r) (((r).fc_diag_ctrl[0]) & 0xf)
#define BCM6300_A0_FC_DIAG_CTRLr_DIG_FLOWCON_PROTf_SET(r,f) (r).fc_diag_ctrl[0]=(((r).fc_diag_ctrl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM6300_A0_FC_DIAG_CTRLr_RESERVED_1Rf_GET(r) ((((r).fc_diag_ctrl[0]) >> 4) & 0x3)
#define BCM6300_A0_FC_DIAG_CTRLr_RESERVED_1Rf_SET(r,f) (r).fc_diag_ctrl[0]=(((r).fc_diag_ctrl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM6300_A0_FC_DIAG_CTRLr_RESERVED_2Rf_GET(r) ((((r).fc_diag_ctrl[0]) >> 6) & 0x3)
#define BCM6300_A0_FC_DIAG_CTRLr_RESERVED_2Rf_SET(r,f) (r).fc_diag_ctrl[0]=(((r).fc_diag_ctrl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM6300_A0_FC_DIAG_CTRLr_RESERVED_3Rf_GET(r) ((((r).fc_diag_ctrl[0]) >> 8) & 0xff)
#define BCM6300_A0_FC_DIAG_CTRLr_RESERVED_3Rf_SET(r,f) (r).fc_diag_ctrl[0]=(((r).fc_diag_ctrl[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_DIAG_CTRL.
 *
 */
#define BCM6300_A0_READ_FC_DIAG_CTRLr(u,r) cdk_robo_reg_read(u,BCM6300_A0_FC_DIAG_CTRLr,(r._fc_diag_ctrl),2)
#define BCM6300_A0_WRITE_FC_DIAG_CTRLr(u,r) cdk_robo_reg_write(u,BCM6300_A0_FC_DIAG_CTRLr,&(r._fc_diag_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_DIAG_CTRLr BCM6300_A0_FC_DIAG_CTRLr
#define FC_DIAG_CTRLr_SIZE BCM6300_A0_FC_DIAG_CTRLr_SIZE
typedef BCM6300_A0_FC_DIAG_CTRLr_t FC_DIAG_CTRLr_t;
#define FC_DIAG_CTRLr_CLR BCM6300_A0_FC_DIAG_CTRLr_CLR
#define FC_DIAG_CTRLr_SET BCM6300_A0_FC_DIAG_CTRLr_SET
#define FC_DIAG_CTRLr_GET BCM6300_A0_FC_DIAG_CTRLr_GET
#define FC_DIAG_CTRLr_DIG_FLOWCON_PROTf_GET BCM6300_A0_FC_DIAG_CTRLr_DIG_FLOWCON_PROTf_GET
#define FC_DIAG_CTRLr_DIG_FLOWCON_PROTf_SET BCM6300_A0_FC_DIAG_CTRLr_DIG_FLOWCON_PROTf_SET
#define FC_DIAG_CTRLr_RESERVED_1Rf_GET BCM6300_A0_FC_DIAG_CTRLr_RESERVED_1Rf_GET
#define FC_DIAG_CTRLr_RESERVED_1Rf_SET BCM6300_A0_FC_DIAG_CTRLr_RESERVED_1Rf_SET
#define FC_DIAG_CTRLr_RESERVED_2Rf_GET BCM6300_A0_FC_DIAG_CTRLr_RESERVED_2Rf_GET
#define FC_DIAG_CTRLr_RESERVED_2Rf_SET BCM6300_A0_FC_DIAG_CTRLr_RESERVED_2Rf_SET
#define FC_DIAG_CTRLr_RESERVED_3Rf_GET BCM6300_A0_FC_DIAG_CTRLr_RESERVED_3Rf_GET
#define FC_DIAG_CTRLr_RESERVED_3Rf_SET BCM6300_A0_FC_DIAG_CTRLr_RESERVED_3Rf_SET
#define READ_FC_DIAG_CTRLr BCM6300_A0_READ_FC_DIAG_CTRLr
#define WRITE_FC_DIAG_CTRLr BCM6300_A0_WRITE_FC_DIAG_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_FC_DIAG_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  FC_GIGA_INFO
 * BLOCKS:   SYS
 * DESC:     Giga Speed Info For FC Register
 * SIZE:     16
 * FIELDS:
 *     GIGA_PORTMAP     
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_FC_GIGA_INFOr 0x00000a9c

#define BCM6300_A0_FC_GIGA_INFOr_SIZE 2

/*
 * This structure should be used to declare and program FC_GIGA_INFO.
 *
 */
typedef union BCM6300_A0_FC_GIGA_INFOr_s {
	uint32_t v[1];
	uint32_t fc_giga_info[1];
	uint32_t _fc_giga_info;
} BCM6300_A0_FC_GIGA_INFOr_t;

#define BCM6300_A0_FC_GIGA_INFOr_CLR(r) (r).fc_giga_info[0] = 0
#define BCM6300_A0_FC_GIGA_INFOr_SET(r,d) (r).fc_giga_info[0] = d
#define BCM6300_A0_FC_GIGA_INFOr_GET(r) (r).fc_giga_info[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_FC_GIGA_INFOr_GIGA_PORTMAPf_GET(r) (((r).fc_giga_info[0]) & 0x1ff)
#define BCM6300_A0_FC_GIGA_INFOr_GIGA_PORTMAPf_SET(r,f) (r).fc_giga_info[0]=(((r).fc_giga_info[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_FC_GIGA_INFOr_RESERVED_Rf_GET(r) ((((r).fc_giga_info[0]) >> 9) & 0x7f)
#define BCM6300_A0_FC_GIGA_INFOr_RESERVED_Rf_SET(r,f) (r).fc_giga_info[0]=(((r).fc_giga_info[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access FC_GIGA_INFO.
 *
 */
#define BCM6300_A0_READ_FC_GIGA_INFOr(u,r) cdk_robo_reg_read(u,BCM6300_A0_FC_GIGA_INFOr,(r._fc_giga_info),2)
#define BCM6300_A0_WRITE_FC_GIGA_INFOr(u,r) cdk_robo_reg_write(u,BCM6300_A0_FC_GIGA_INFOr,&(r._fc_giga_info),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_GIGA_INFOr BCM6300_A0_FC_GIGA_INFOr
#define FC_GIGA_INFOr_SIZE BCM6300_A0_FC_GIGA_INFOr_SIZE
typedef BCM6300_A0_FC_GIGA_INFOr_t FC_GIGA_INFOr_t;
#define FC_GIGA_INFOr_CLR BCM6300_A0_FC_GIGA_INFOr_CLR
#define FC_GIGA_INFOr_SET BCM6300_A0_FC_GIGA_INFOr_SET
#define FC_GIGA_INFOr_GET BCM6300_A0_FC_GIGA_INFOr_GET
#define FC_GIGA_INFOr_GIGA_PORTMAPf_GET BCM6300_A0_FC_GIGA_INFOr_GIGA_PORTMAPf_GET
#define FC_GIGA_INFOr_GIGA_PORTMAPf_SET BCM6300_A0_FC_GIGA_INFOr_GIGA_PORTMAPf_SET
#define FC_GIGA_INFOr_RESERVED_Rf_GET BCM6300_A0_FC_GIGA_INFOr_RESERVED_Rf_GET
#define FC_GIGA_INFOr_RESERVED_Rf_SET BCM6300_A0_FC_GIGA_INFOr_RESERVED_Rf_SET
#define READ_FC_GIGA_INFOr BCM6300_A0_READ_FC_GIGA_INFOr
#define WRITE_FC_GIGA_INFOr BCM6300_A0_WRITE_FC_GIGA_INFOr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_FC_GIGA_INFOr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  FC_MCAST_DROP_CTRL
 * BLOCKS:   SYS
 * DESC:     Multicast Drop Control Register
 * SIZE:     16
 * FIELDS:
 *     PAR_DROP_EN      Multicast Partial Drop Enalbed.Bit 8 = IMP port,Bit 7:0 = Port 7~ Port 0,1: Multicast Frame can forward to uncongested Destination Port, and will not forward to congested Destination Port0: Multicast Frame can forward only if all destination ports are not congested.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM6300_A0_FC_MCAST_DROP_CTRLr 0x00000a0c

#define BCM6300_A0_FC_MCAST_DROP_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program FC_MCAST_DROP_CTRL.
 *
 */
typedef union BCM6300_A0_FC_MCAST_DROP_CTRLr_s {
	uint32_t v[1];
	uint32_t fc_mcast_drop_ctrl[1];
	uint32_t _fc_mcast_drop_ctrl;
} BCM6300_A0_FC_MCAST_DROP_CTRLr_t;

#define BCM6300_A0_FC_MCAST_DROP_CTRLr_CLR(r) (r).fc_mcast_drop_ctrl[0] = 0
#define BCM6300_A0_FC_MCAST_DROP_CTRLr_SET(r,d) (r).fc_mcast_drop_ctrl[0] = d
#define BCM6300_A0_FC_MCAST_DROP_CTRLr_GET(r) (r).fc_mcast_drop_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_FC_MCAST_DROP_CTRLr_PAR_DROP_ENf_GET(r) (((r).fc_mcast_drop_ctrl[0]) & 0x1ff)
#define BCM6300_A0_FC_MCAST_DROP_CTRLr_PAR_DROP_ENf_SET(r,f) (r).fc_mcast_drop_ctrl[0]=(((r).fc_mcast_drop_ctrl[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_FC_MCAST_DROP_CTRLr_RESERVED_Rf_GET(r) ((((r).fc_mcast_drop_ctrl[0]) >> 9) & 0x7f)
#define BCM6300_A0_FC_MCAST_DROP_CTRLr_RESERVED_Rf_SET(r,f) (r).fc_mcast_drop_ctrl[0]=(((r).fc_mcast_drop_ctrl[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access FC_MCAST_DROP_CTRL.
 *
 */
#define BCM6300_A0_READ_FC_MCAST_DROP_CTRLr(u,r) cdk_robo_reg_read(u,BCM6300_A0_FC_MCAST_DROP_CTRLr,(r._fc_mcast_drop_ctrl),2)
#define BCM6300_A0_WRITE_FC_MCAST_DROP_CTRLr(u,r) cdk_robo_reg_write(u,BCM6300_A0_FC_MCAST_DROP_CTRLr,&(r._fc_mcast_drop_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_MCAST_DROP_CTRLr BCM6300_A0_FC_MCAST_DROP_CTRLr
#define FC_MCAST_DROP_CTRLr_SIZE BCM6300_A0_FC_MCAST_DROP_CTRLr_SIZE
typedef BCM6300_A0_FC_MCAST_DROP_CTRLr_t FC_MCAST_DROP_CTRLr_t;
#define FC_MCAST_DROP_CTRLr_CLR BCM6300_A0_FC_MCAST_DROP_CTRLr_CLR
#define FC_MCAST_DROP_CTRLr_SET BCM6300_A0_FC_MCAST_DROP_CTRLr_SET
#define FC_MCAST_DROP_CTRLr_GET BCM6300_A0_FC_MCAST_DROP_CTRLr_GET
#define FC_MCAST_DROP_CTRLr_PAR_DROP_ENf_GET BCM6300_A0_FC_MCAST_DROP_CTRLr_PAR_DROP_ENf_GET
#define FC_MCAST_DROP_CTRLr_PAR_DROP_ENf_SET BCM6300_A0_FC_MCAST_DROP_CTRLr_PAR_DROP_ENf_SET
#define FC_MCAST_DROP_CTRLr_RESERVED_Rf_GET BCM6300_A0_FC_MCAST_DROP_CTRLr_RESERVED_Rf_GET
#define FC_MCAST_DROP_CTRLr_RESERVED_Rf_SET BCM6300_A0_FC_MCAST_DROP_CTRLr_RESERVED_Rf_SET
#define READ_FC_MCAST_DROP_CTRLr BCM6300_A0_READ_FC_MCAST_DROP_CTRLr
#define WRITE_FC_MCAST_DROP_CTRLr BCM6300_A0_WRITE_FC_MCAST_DROP_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_FC_MCAST_DROP_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  FC_MON_TXQ
 * BLOCKS:   SYS
 * DESC:     Monitored TxQ N (0~3) Register
 * SIZE:     16
 * FIELDS:
 *     PEAK_TXQ_CNT     
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM6300_A0_FC_MON_TXQr 0x00000a60

#define BCM6300_A0_FC_MON_TXQr_SIZE 2

/*
 * This structure should be used to declare and program FC_MON_TXQ.
 *
 */
typedef union BCM6300_A0_FC_MON_TXQr_s {
	uint32_t v[1];
	uint32_t fc_mon_txq[1];
	uint32_t _fc_mon_txq;
} BCM6300_A0_FC_MON_TXQr_t;

#define BCM6300_A0_FC_MON_TXQr_CLR(r) (r).fc_mon_txq[0] = 0
#define BCM6300_A0_FC_MON_TXQr_SET(r,d) (r).fc_mon_txq[0] = d
#define BCM6300_A0_FC_MON_TXQr_GET(r) (r).fc_mon_txq[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_FC_MON_TXQr_PEAK_TXQ_CNTf_GET(r) (((r).fc_mon_txq[0]) & 0x7ff)
#define BCM6300_A0_FC_MON_TXQr_PEAK_TXQ_CNTf_SET(r,f) (r).fc_mon_txq[0]=(((r).fc_mon_txq[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM6300_A0_FC_MON_TXQr_RESERVED_Rf_GET(r) ((((r).fc_mon_txq[0]) >> 11) & 0x1f)
#define BCM6300_A0_FC_MON_TXQr_RESERVED_Rf_SET(r,f) (r).fc_mon_txq[0]=(((r).fc_mon_txq[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_MON_TXQ.
 *
 */
#define BCM6300_A0_READ_FC_MON_TXQr(u,i,r) cdk_robo_reg_read(u,BCM6300_A0_FC_MON_TXQr+(2*(i)),(r._fc_mon_txq),2)
#define BCM6300_A0_WRITE_FC_MON_TXQr(u,i,r) cdk_robo_reg_write(u,BCM6300_A0_FC_MON_TXQr+(2*(i)),&(r._fc_mon_txq),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_MON_TXQr BCM6300_A0_FC_MON_TXQr
#define FC_MON_TXQr_SIZE BCM6300_A0_FC_MON_TXQr_SIZE
typedef BCM6300_A0_FC_MON_TXQr_t FC_MON_TXQr_t;
#define FC_MON_TXQr_CLR BCM6300_A0_FC_MON_TXQr_CLR
#define FC_MON_TXQr_SET BCM6300_A0_FC_MON_TXQr_SET
#define FC_MON_TXQr_GET BCM6300_A0_FC_MON_TXQr_GET
#define FC_MON_TXQr_PEAK_TXQ_CNTf_GET BCM6300_A0_FC_MON_TXQr_PEAK_TXQ_CNTf_GET
#define FC_MON_TXQr_PEAK_TXQ_CNTf_SET BCM6300_A0_FC_MON_TXQr_PEAK_TXQ_CNTf_SET
#define FC_MON_TXQr_RESERVED_Rf_GET BCM6300_A0_FC_MON_TXQr_RESERVED_Rf_GET
#define FC_MON_TXQr_RESERVED_Rf_SET BCM6300_A0_FC_MON_TXQr_RESERVED_Rf_SET
#define READ_FC_MON_TXQr BCM6300_A0_READ_FC_MON_TXQr
#define WRITE_FC_MON_TXQr BCM6300_A0_WRITE_FC_MON_TXQr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_FC_MON_TXQr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  FC_PAUSE_DROP_CTRL
 * BLOCKS:   SYS
 * DESC:     Pause/Drop Control Register
 * SIZE:     16
 * FIELDS:
 *     EN_TX_PAUSE      
 *     EN_TX_DROP       
 *     EN_TOTAL_PAUSE   
 *     EN_TOTAL_DROP    
 *     EN_TX_LEGACY_PAUSE 
 *     RESERVED_R       Reserved.
 *     EN_RX_PAUSE      
 *     EN_RX_DROP       
 *     RESERVED_0R      Reserved.
 *     RESERVED_1R      Reserved.
 *
 ******************************************************************************/
#define BCM6300_A0_FC_PAUSE_DROP_CTRLr 0x00000a0e

#define BCM6300_A0_FC_PAUSE_DROP_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program FC_PAUSE_DROP_CTRL.
 *
 */
typedef union BCM6300_A0_FC_PAUSE_DROP_CTRLr_s {
	uint32_t v[1];
	uint32_t fc_pause_drop_ctrl[1];
	uint32_t _fc_pause_drop_ctrl;
} BCM6300_A0_FC_PAUSE_DROP_CTRLr_t;

#define BCM6300_A0_FC_PAUSE_DROP_CTRLr_CLR(r) (r).fc_pause_drop_ctrl[0] = 0
#define BCM6300_A0_FC_PAUSE_DROP_CTRLr_SET(r,d) (r).fc_pause_drop_ctrl[0] = d
#define BCM6300_A0_FC_PAUSE_DROP_CTRLr_GET(r) (r).fc_pause_drop_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_FC_PAUSE_DROP_CTRLr_EN_TX_PAUSEf_GET(r) (((r).fc_pause_drop_ctrl[0]) & 0x1)
#define BCM6300_A0_FC_PAUSE_DROP_CTRLr_EN_TX_PAUSEf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM6300_A0_FC_PAUSE_DROP_CTRLr_EN_TX_DROPf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 1) & 0x1)
#define BCM6300_A0_FC_PAUSE_DROP_CTRLr_EN_TX_DROPf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM6300_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_PAUSEf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 2) & 0x1)
#define BCM6300_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_PAUSEf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM6300_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_DROPf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 3) & 0x1)
#define BCM6300_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_DROPf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM6300_A0_FC_PAUSE_DROP_CTRLr_EN_TX_LEGACY_PAUSEf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 4) & 0x1)
#define BCM6300_A0_FC_PAUSE_DROP_CTRLr_EN_TX_LEGACY_PAUSEf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM6300_A0_FC_PAUSE_DROP_CTRLr_RESERVED_Rf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 5) & 0x1)
#define BCM6300_A0_FC_PAUSE_DROP_CTRLr_RESERVED_Rf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM6300_A0_FC_PAUSE_DROP_CTRLr_EN_RX_PAUSEf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 6) & 0x1)
#define BCM6300_A0_FC_PAUSE_DROP_CTRLr_EN_RX_PAUSEf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM6300_A0_FC_PAUSE_DROP_CTRLr_EN_RX_DROPf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 7) & 0x1)
#define BCM6300_A0_FC_PAUSE_DROP_CTRLr_EN_RX_DROPf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM6300_A0_FC_PAUSE_DROP_CTRLr_RESERVED_0Rf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 8) & 0x7)
#define BCM6300_A0_FC_PAUSE_DROP_CTRLr_RESERVED_0Rf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCM6300_A0_FC_PAUSE_DROP_CTRLr_RESERVED_1Rf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 11) & 0x1f)
#define BCM6300_A0_FC_PAUSE_DROP_CTRLr_RESERVED_1Rf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_PAUSE_DROP_CTRL.
 *
 */
#define BCM6300_A0_READ_FC_PAUSE_DROP_CTRLr(u,r) cdk_robo_reg_read(u,BCM6300_A0_FC_PAUSE_DROP_CTRLr,(r._fc_pause_drop_ctrl),2)
#define BCM6300_A0_WRITE_FC_PAUSE_DROP_CTRLr(u,r) cdk_robo_reg_write(u,BCM6300_A0_FC_PAUSE_DROP_CTRLr,&(r._fc_pause_drop_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_PAUSE_DROP_CTRLr BCM6300_A0_FC_PAUSE_DROP_CTRLr
#define FC_PAUSE_DROP_CTRLr_SIZE BCM6300_A0_FC_PAUSE_DROP_CTRLr_SIZE
typedef BCM6300_A0_FC_PAUSE_DROP_CTRLr_t FC_PAUSE_DROP_CTRLr_t;
#define FC_PAUSE_DROP_CTRLr_CLR BCM6300_A0_FC_PAUSE_DROP_CTRLr_CLR
#define FC_PAUSE_DROP_CTRLr_SET BCM6300_A0_FC_PAUSE_DROP_CTRLr_SET
#define FC_PAUSE_DROP_CTRLr_GET BCM6300_A0_FC_PAUSE_DROP_CTRLr_GET
#define FC_PAUSE_DROP_CTRLr_EN_TX_PAUSEf_GET BCM6300_A0_FC_PAUSE_DROP_CTRLr_EN_TX_PAUSEf_GET
#define FC_PAUSE_DROP_CTRLr_EN_TX_PAUSEf_SET BCM6300_A0_FC_PAUSE_DROP_CTRLr_EN_TX_PAUSEf_SET
#define FC_PAUSE_DROP_CTRLr_EN_TX_DROPf_GET BCM6300_A0_FC_PAUSE_DROP_CTRLr_EN_TX_DROPf_GET
#define FC_PAUSE_DROP_CTRLr_EN_TX_DROPf_SET BCM6300_A0_FC_PAUSE_DROP_CTRLr_EN_TX_DROPf_SET
#define FC_PAUSE_DROP_CTRLr_EN_TOTAL_PAUSEf_GET BCM6300_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_PAUSEf_GET
#define FC_PAUSE_DROP_CTRLr_EN_TOTAL_PAUSEf_SET BCM6300_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_PAUSEf_SET
#define FC_PAUSE_DROP_CTRLr_EN_TOTAL_DROPf_GET BCM6300_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_DROPf_GET
#define FC_PAUSE_DROP_CTRLr_EN_TOTAL_DROPf_SET BCM6300_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_DROPf_SET
#define FC_PAUSE_DROP_CTRLr_EN_TX_LEGACY_PAUSEf_GET BCM6300_A0_FC_PAUSE_DROP_CTRLr_EN_TX_LEGACY_PAUSEf_GET
#define FC_PAUSE_DROP_CTRLr_EN_TX_LEGACY_PAUSEf_SET BCM6300_A0_FC_PAUSE_DROP_CTRLr_EN_TX_LEGACY_PAUSEf_SET
#define FC_PAUSE_DROP_CTRLr_RESERVED_Rf_GET BCM6300_A0_FC_PAUSE_DROP_CTRLr_RESERVED_Rf_GET
#define FC_PAUSE_DROP_CTRLr_RESERVED_Rf_SET BCM6300_A0_FC_PAUSE_DROP_CTRLr_RESERVED_Rf_SET
#define FC_PAUSE_DROP_CTRLr_EN_RX_PAUSEf_GET BCM6300_A0_FC_PAUSE_DROP_CTRLr_EN_RX_PAUSEf_GET
#define FC_PAUSE_DROP_CTRLr_EN_RX_PAUSEf_SET BCM6300_A0_FC_PAUSE_DROP_CTRLr_EN_RX_PAUSEf_SET
#define FC_PAUSE_DROP_CTRLr_EN_RX_DROPf_GET BCM6300_A0_FC_PAUSE_DROP_CTRLr_EN_RX_DROPf_GET
#define FC_PAUSE_DROP_CTRLr_EN_RX_DROPf_SET BCM6300_A0_FC_PAUSE_DROP_CTRLr_EN_RX_DROPf_SET
#define FC_PAUSE_DROP_CTRLr_RESERVED_0Rf_GET BCM6300_A0_FC_PAUSE_DROP_CTRLr_RESERVED_0Rf_GET
#define FC_PAUSE_DROP_CTRLr_RESERVED_0Rf_SET BCM6300_A0_FC_PAUSE_DROP_CTRLr_RESERVED_0Rf_SET
#define FC_PAUSE_DROP_CTRLr_RESERVED_1Rf_GET BCM6300_A0_FC_PAUSE_DROP_CTRLr_RESERVED_1Rf_GET
#define FC_PAUSE_DROP_CTRLr_RESERVED_1Rf_SET BCM6300_A0_FC_PAUSE_DROP_CTRLr_RESERVED_1Rf_SET
#define READ_FC_PAUSE_DROP_CTRLr BCM6300_A0_READ_FC_PAUSE_DROP_CTRLr
#define WRITE_FC_PAUSE_DROP_CTRLr BCM6300_A0_WRITE_FC_PAUSE_DROP_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_FC_PAUSE_DROP_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  FC_PAUSE_HIS
 * BLOCKS:   SYS
 * DESC:     Pause History Register
 * SIZE:     16
 * FIELDS:
 *     PAUSE_HIS        
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_FC_PAUSE_HISr 0x00000aa0

#define BCM6300_A0_FC_PAUSE_HISr_SIZE 2

/*
 * This structure should be used to declare and program FC_PAUSE_HIS.
 *
 */
typedef union BCM6300_A0_FC_PAUSE_HISr_s {
	uint32_t v[1];
	uint32_t fc_pause_his[1];
	uint32_t _fc_pause_his;
} BCM6300_A0_FC_PAUSE_HISr_t;

#define BCM6300_A0_FC_PAUSE_HISr_CLR(r) (r).fc_pause_his[0] = 0
#define BCM6300_A0_FC_PAUSE_HISr_SET(r,d) (r).fc_pause_his[0] = d
#define BCM6300_A0_FC_PAUSE_HISr_GET(r) (r).fc_pause_his[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_FC_PAUSE_HISr_PAUSE_HISf_GET(r) (((r).fc_pause_his[0]) & 0x7ff)
#define BCM6300_A0_FC_PAUSE_HISr_PAUSE_HISf_SET(r,f) (r).fc_pause_his[0]=(((r).fc_pause_his[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM6300_A0_FC_PAUSE_HISr_RESERVED_Rf_GET(r) ((((r).fc_pause_his[0]) >> 11) & 0x1f)
#define BCM6300_A0_FC_PAUSE_HISr_RESERVED_Rf_SET(r,f) (r).fc_pause_his[0]=(((r).fc_pause_his[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_PAUSE_HIS.
 *
 */
#define BCM6300_A0_READ_FC_PAUSE_HISr(u,r) cdk_robo_reg_read(u,BCM6300_A0_FC_PAUSE_HISr,(r._fc_pause_his),2)
#define BCM6300_A0_WRITE_FC_PAUSE_HISr(u,r) cdk_robo_reg_write(u,BCM6300_A0_FC_PAUSE_HISr,&(r._fc_pause_his),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_PAUSE_HISr BCM6300_A0_FC_PAUSE_HISr
#define FC_PAUSE_HISr_SIZE BCM6300_A0_FC_PAUSE_HISr_SIZE
typedef BCM6300_A0_FC_PAUSE_HISr_t FC_PAUSE_HISr_t;
#define FC_PAUSE_HISr_CLR BCM6300_A0_FC_PAUSE_HISr_CLR
#define FC_PAUSE_HISr_SET BCM6300_A0_FC_PAUSE_HISr_SET
#define FC_PAUSE_HISr_GET BCM6300_A0_FC_PAUSE_HISr_GET
#define FC_PAUSE_HISr_PAUSE_HISf_GET BCM6300_A0_FC_PAUSE_HISr_PAUSE_HISf_GET
#define FC_PAUSE_HISr_PAUSE_HISf_SET BCM6300_A0_FC_PAUSE_HISr_PAUSE_HISf_SET
#define FC_PAUSE_HISr_RESERVED_Rf_GET BCM6300_A0_FC_PAUSE_HISr_RESERVED_Rf_GET
#define FC_PAUSE_HISr_RESERVED_Rf_SET BCM6300_A0_FC_PAUSE_HISr_RESERVED_Rf_SET
#define READ_FC_PAUSE_HISr BCM6300_A0_READ_FC_PAUSE_HISr
#define WRITE_FC_PAUSE_HISr BCM6300_A0_WRITE_FC_PAUSE_HISr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_FC_PAUSE_HISr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  FC_PEAK_RXBYTE
 * BLOCKS:   SYS
 * DESC:     Peak RxByte Count Register
 * SIZE:     16
 * FIELDS:
 *     PEAK_RXBYTE_CNT  Peak Rx Byte count.The diag_port setting in Diag register (Page 0A, Offset 00) can be selected for different Ports.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM6300_A0_FC_PEAK_RXBYTEr 0x00000a78

#define BCM6300_A0_FC_PEAK_RXBYTEr_SIZE 2

/*
 * This structure should be used to declare and program FC_PEAK_RXBYTE.
 *
 */
typedef union BCM6300_A0_FC_PEAK_RXBYTEr_s {
	uint32_t v[1];
	uint32_t fc_peak_rxbyte[1];
	uint32_t _fc_peak_rxbyte;
} BCM6300_A0_FC_PEAK_RXBYTEr_t;

#define BCM6300_A0_FC_PEAK_RXBYTEr_CLR(r) (r).fc_peak_rxbyte[0] = 0
#define BCM6300_A0_FC_PEAK_RXBYTEr_SET(r,d) (r).fc_peak_rxbyte[0] = d
#define BCM6300_A0_FC_PEAK_RXBYTEr_GET(r) (r).fc_peak_rxbyte[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_FC_PEAK_RXBYTEr_PEAK_RXBYTE_CNTf_GET(r) (((r).fc_peak_rxbyte[0]) & 0x7ff)
#define BCM6300_A0_FC_PEAK_RXBYTEr_PEAK_RXBYTE_CNTf_SET(r,f) (r).fc_peak_rxbyte[0]=(((r).fc_peak_rxbyte[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM6300_A0_FC_PEAK_RXBYTEr_RESERVED_Rf_GET(r) ((((r).fc_peak_rxbyte[0]) >> 11) & 0x1f)
#define BCM6300_A0_FC_PEAK_RXBYTEr_RESERVED_Rf_SET(r,f) (r).fc_peak_rxbyte[0]=(((r).fc_peak_rxbyte[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_PEAK_RXBYTE.
 *
 */
#define BCM6300_A0_READ_FC_PEAK_RXBYTEr(u,r) cdk_robo_reg_read(u,BCM6300_A0_FC_PEAK_RXBYTEr,(r._fc_peak_rxbyte),2)
#define BCM6300_A0_WRITE_FC_PEAK_RXBYTEr(u,r) cdk_robo_reg_write(u,BCM6300_A0_FC_PEAK_RXBYTEr,&(r._fc_peak_rxbyte),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_PEAK_RXBYTEr BCM6300_A0_FC_PEAK_RXBYTEr
#define FC_PEAK_RXBYTEr_SIZE BCM6300_A0_FC_PEAK_RXBYTEr_SIZE
typedef BCM6300_A0_FC_PEAK_RXBYTEr_t FC_PEAK_RXBYTEr_t;
#define FC_PEAK_RXBYTEr_CLR BCM6300_A0_FC_PEAK_RXBYTEr_CLR
#define FC_PEAK_RXBYTEr_SET BCM6300_A0_FC_PEAK_RXBYTEr_SET
#define FC_PEAK_RXBYTEr_GET BCM6300_A0_FC_PEAK_RXBYTEr_GET
#define FC_PEAK_RXBYTEr_PEAK_RXBYTE_CNTf_GET BCM6300_A0_FC_PEAK_RXBYTEr_PEAK_RXBYTE_CNTf_GET
#define FC_PEAK_RXBYTEr_PEAK_RXBYTE_CNTf_SET BCM6300_A0_FC_PEAK_RXBYTEr_PEAK_RXBYTE_CNTf_SET
#define FC_PEAK_RXBYTEr_RESERVED_Rf_GET BCM6300_A0_FC_PEAK_RXBYTEr_RESERVED_Rf_GET
#define FC_PEAK_RXBYTEr_RESERVED_Rf_SET BCM6300_A0_FC_PEAK_RXBYTEr_RESERVED_Rf_SET
#define READ_FC_PEAK_RXBYTEr BCM6300_A0_READ_FC_PEAK_RXBYTEr
#define WRITE_FC_PEAK_RXBYTEr BCM6300_A0_WRITE_FC_PEAK_RXBYTEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_FC_PEAK_RXBYTEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  FC_PEAK_TOTAL_USED
 * BLOCKS:   SYS
 * DESC:     Peak Total Used Count Register
 * SIZE:     16
 * FIELDS:
 *     PEAK_TOTAL_USE   Peak Total Used count.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_FC_PEAK_TOTAL_USEDr 0x00000a80

#define BCM6300_A0_FC_PEAK_TOTAL_USEDr_SIZE 2

/*
 * This structure should be used to declare and program FC_PEAK_TOTAL_USED.
 *
 */
typedef union BCM6300_A0_FC_PEAK_TOTAL_USEDr_s {
	uint32_t v[1];
	uint32_t fc_peak_total_used[1];
	uint32_t _fc_peak_total_used;
} BCM6300_A0_FC_PEAK_TOTAL_USEDr_t;

#define BCM6300_A0_FC_PEAK_TOTAL_USEDr_CLR(r) (r).fc_peak_total_used[0] = 0
#define BCM6300_A0_FC_PEAK_TOTAL_USEDr_SET(r,d) (r).fc_peak_total_used[0] = d
#define BCM6300_A0_FC_PEAK_TOTAL_USEDr_GET(r) (r).fc_peak_total_used[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_FC_PEAK_TOTAL_USEDr_PEAK_TOTAL_USEf_GET(r) (((r).fc_peak_total_used[0]) & 0x7ff)
#define BCM6300_A0_FC_PEAK_TOTAL_USEDr_PEAK_TOTAL_USEf_SET(r,f) (r).fc_peak_total_used[0]=(((r).fc_peak_total_used[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM6300_A0_FC_PEAK_TOTAL_USEDr_RESERVED_Rf_GET(r) ((((r).fc_peak_total_used[0]) >> 11) & 0x1f)
#define BCM6300_A0_FC_PEAK_TOTAL_USEDr_RESERVED_Rf_SET(r,f) (r).fc_peak_total_used[0]=(((r).fc_peak_total_used[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_PEAK_TOTAL_USED.
 *
 */
#define BCM6300_A0_READ_FC_PEAK_TOTAL_USEDr(u,r) cdk_robo_reg_read(u,BCM6300_A0_FC_PEAK_TOTAL_USEDr,(r._fc_peak_total_used),2)
#define BCM6300_A0_WRITE_FC_PEAK_TOTAL_USEDr(u,r) cdk_robo_reg_write(u,BCM6300_A0_FC_PEAK_TOTAL_USEDr,&(r._fc_peak_total_used),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_PEAK_TOTAL_USEDr BCM6300_A0_FC_PEAK_TOTAL_USEDr
#define FC_PEAK_TOTAL_USEDr_SIZE BCM6300_A0_FC_PEAK_TOTAL_USEDr_SIZE
typedef BCM6300_A0_FC_PEAK_TOTAL_USEDr_t FC_PEAK_TOTAL_USEDr_t;
#define FC_PEAK_TOTAL_USEDr_CLR BCM6300_A0_FC_PEAK_TOTAL_USEDr_CLR
#define FC_PEAK_TOTAL_USEDr_SET BCM6300_A0_FC_PEAK_TOTAL_USEDr_SET
#define FC_PEAK_TOTAL_USEDr_GET BCM6300_A0_FC_PEAK_TOTAL_USEDr_GET
#define FC_PEAK_TOTAL_USEDr_PEAK_TOTAL_USEf_GET BCM6300_A0_FC_PEAK_TOTAL_USEDr_PEAK_TOTAL_USEf_GET
#define FC_PEAK_TOTAL_USEDr_PEAK_TOTAL_USEf_SET BCM6300_A0_FC_PEAK_TOTAL_USEDr_PEAK_TOTAL_USEf_SET
#define FC_PEAK_TOTAL_USEDr_RESERVED_Rf_GET BCM6300_A0_FC_PEAK_TOTAL_USEDr_RESERVED_Rf_GET
#define FC_PEAK_TOTAL_USEDr_RESERVED_Rf_SET BCM6300_A0_FC_PEAK_TOTAL_USEDr_RESERVED_Rf_SET
#define READ_FC_PEAK_TOTAL_USEDr BCM6300_A0_READ_FC_PEAK_TOTAL_USEDr
#define WRITE_FC_PEAK_TOTAL_USEDr BCM6300_A0_WRITE_FC_PEAK_TOTAL_USEDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_FC_PEAK_TOTAL_USEDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  FC_PEAK_TXQ
 * BLOCKS:   SYS
 * DESC:     Peak TxQ N (0~3) Counter Register
 * SIZE:     16
 * FIELDS:
 *     PEAK_TXBCNT      Peak TxQ 0~3 counr.The diag_port setting in Diag register (Page 0Ah, Offset 00h)can selected for different Ports.Diagnosis only: read on clear.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM6300_A0_FC_PEAK_TXQr 0x00000a70

#define BCM6300_A0_FC_PEAK_TXQr_SIZE 2

/*
 * This structure should be used to declare and program FC_PEAK_TXQ.
 *
 */
typedef union BCM6300_A0_FC_PEAK_TXQr_s {
	uint32_t v[1];
	uint32_t fc_peak_txq[1];
	uint32_t _fc_peak_txq;
} BCM6300_A0_FC_PEAK_TXQr_t;

#define BCM6300_A0_FC_PEAK_TXQr_CLR(r) (r).fc_peak_txq[0] = 0
#define BCM6300_A0_FC_PEAK_TXQr_SET(r,d) (r).fc_peak_txq[0] = d
#define BCM6300_A0_FC_PEAK_TXQr_GET(r) (r).fc_peak_txq[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_FC_PEAK_TXQr_PEAK_TXBCNTf_GET(r) (((r).fc_peak_txq[0]) & 0x7ff)
#define BCM6300_A0_FC_PEAK_TXQr_PEAK_TXBCNTf_SET(r,f) (r).fc_peak_txq[0]=(((r).fc_peak_txq[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM6300_A0_FC_PEAK_TXQr_RESERVED_Rf_GET(r) ((((r).fc_peak_txq[0]) >> 10) & 0x3f)
#define BCM6300_A0_FC_PEAK_TXQr_RESERVED_Rf_SET(r,f) (r).fc_peak_txq[0]=(((r).fc_peak_txq[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_PEAK_TXQ.
 *
 */
#define BCM6300_A0_READ_FC_PEAK_TXQr(u,i,r) cdk_robo_reg_read(u,BCM6300_A0_FC_PEAK_TXQr+(2*(i)),(r._fc_peak_txq),2)
#define BCM6300_A0_WRITE_FC_PEAK_TXQr(u,i,r) cdk_robo_reg_write(u,BCM6300_A0_FC_PEAK_TXQr+(2*(i)),&(r._fc_peak_txq),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_PEAK_TXQr BCM6300_A0_FC_PEAK_TXQr
#define FC_PEAK_TXQr_SIZE BCM6300_A0_FC_PEAK_TXQr_SIZE
typedef BCM6300_A0_FC_PEAK_TXQr_t FC_PEAK_TXQr_t;
#define FC_PEAK_TXQr_CLR BCM6300_A0_FC_PEAK_TXQr_CLR
#define FC_PEAK_TXQr_SET BCM6300_A0_FC_PEAK_TXQr_SET
#define FC_PEAK_TXQr_GET BCM6300_A0_FC_PEAK_TXQr_GET
#define FC_PEAK_TXQr_PEAK_TXBCNTf_GET BCM6300_A0_FC_PEAK_TXQr_PEAK_TXBCNTf_GET
#define FC_PEAK_TXQr_PEAK_TXBCNTf_SET BCM6300_A0_FC_PEAK_TXQr_PEAK_TXBCNTf_SET
#define FC_PEAK_TXQr_RESERVED_Rf_GET BCM6300_A0_FC_PEAK_TXQr_RESERVED_Rf_GET
#define FC_PEAK_TXQr_RESERVED_Rf_SET BCM6300_A0_FC_PEAK_TXQr_RESERVED_Rf_SET
#define READ_FC_PEAK_TXQr BCM6300_A0_READ_FC_PEAK_TXQr
#define WRITE_FC_PEAK_TXQr BCM6300_A0_WRITE_FC_PEAK_TXQr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_FC_PEAK_TXQr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  FC_RXBUF_ERR_HIS
 * BLOCKS:   SYS
 * DESC:     Rx Buffer Error History Register
 * SIZE:     16
 * FIELDS:
 *     RXBUF_ERR_HIS    
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_FC_RXBUF_ERR_HISr 0x00000aa8

#define BCM6300_A0_FC_RXBUF_ERR_HISr_SIZE 2

/*
 * This structure should be used to declare and program FC_RXBUF_ERR_HIS.
 *
 */
typedef union BCM6300_A0_FC_RXBUF_ERR_HISr_s {
	uint32_t v[1];
	uint32_t fc_rxbuf_err_his[1];
	uint32_t _fc_rxbuf_err_his;
} BCM6300_A0_FC_RXBUF_ERR_HISr_t;

#define BCM6300_A0_FC_RXBUF_ERR_HISr_CLR(r) (r).fc_rxbuf_err_his[0] = 0
#define BCM6300_A0_FC_RXBUF_ERR_HISr_SET(r,d) (r).fc_rxbuf_err_his[0] = d
#define BCM6300_A0_FC_RXBUF_ERR_HISr_GET(r) (r).fc_rxbuf_err_his[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_FC_RXBUF_ERR_HISr_RXBUF_ERR_HISf_GET(r) (((r).fc_rxbuf_err_his[0]) & 0x7ff)
#define BCM6300_A0_FC_RXBUF_ERR_HISr_RXBUF_ERR_HISf_SET(r,f) (r).fc_rxbuf_err_his[0]=(((r).fc_rxbuf_err_his[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM6300_A0_FC_RXBUF_ERR_HISr_RESERVED_Rf_GET(r) ((((r).fc_rxbuf_err_his[0]) >> 11) & 0x1f)
#define BCM6300_A0_FC_RXBUF_ERR_HISr_RESERVED_Rf_SET(r,f) (r).fc_rxbuf_err_his[0]=(((r).fc_rxbuf_err_his[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_RXBUF_ERR_HIS.
 *
 */
#define BCM6300_A0_READ_FC_RXBUF_ERR_HISr(u,r) cdk_robo_reg_read(u,BCM6300_A0_FC_RXBUF_ERR_HISr,(r._fc_rxbuf_err_his),2)
#define BCM6300_A0_WRITE_FC_RXBUF_ERR_HISr(u,r) cdk_robo_reg_write(u,BCM6300_A0_FC_RXBUF_ERR_HISr,&(r._fc_rxbuf_err_his),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_RXBUF_ERR_HISr BCM6300_A0_FC_RXBUF_ERR_HISr
#define FC_RXBUF_ERR_HISr_SIZE BCM6300_A0_FC_RXBUF_ERR_HISr_SIZE
typedef BCM6300_A0_FC_RXBUF_ERR_HISr_t FC_RXBUF_ERR_HISr_t;
#define FC_RXBUF_ERR_HISr_CLR BCM6300_A0_FC_RXBUF_ERR_HISr_CLR
#define FC_RXBUF_ERR_HISr_SET BCM6300_A0_FC_RXBUF_ERR_HISr_SET
#define FC_RXBUF_ERR_HISr_GET BCM6300_A0_FC_RXBUF_ERR_HISr_GET
#define FC_RXBUF_ERR_HISr_RXBUF_ERR_HISf_GET BCM6300_A0_FC_RXBUF_ERR_HISr_RXBUF_ERR_HISf_GET
#define FC_RXBUF_ERR_HISr_RXBUF_ERR_HISf_SET BCM6300_A0_FC_RXBUF_ERR_HISr_RXBUF_ERR_HISf_SET
#define FC_RXBUF_ERR_HISr_RESERVED_Rf_GET BCM6300_A0_FC_RXBUF_ERR_HISr_RESERVED_Rf_GET
#define FC_RXBUF_ERR_HISr_RESERVED_Rf_SET BCM6300_A0_FC_RXBUF_ERR_HISr_RESERVED_Rf_SET
#define READ_FC_RXBUF_ERR_HISr BCM6300_A0_READ_FC_RXBUF_ERR_HISr
#define WRITE_FC_RXBUF_ERR_HISr BCM6300_A0_WRITE_FC_RXBUF_ERR_HISr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_FC_RXBUF_ERR_HISr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  FC_RXPAUSE_HIS
 * BLOCKS:   SYS
 * DESC:     RX Pause History Register
 * SIZE:     16
 * FIELDS:
 *     RXPAUSE_HIS      
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_FC_RXPAUSE_HISr 0x00000aa4

#define BCM6300_A0_FC_RXPAUSE_HISr_SIZE 2

/*
 * This structure should be used to declare and program FC_RXPAUSE_HIS.
 *
 */
typedef union BCM6300_A0_FC_RXPAUSE_HISr_s {
	uint32_t v[1];
	uint32_t fc_rxpause_his[1];
	uint32_t _fc_rxpause_his;
} BCM6300_A0_FC_RXPAUSE_HISr_t;

#define BCM6300_A0_FC_RXPAUSE_HISr_CLR(r) (r).fc_rxpause_his[0] = 0
#define BCM6300_A0_FC_RXPAUSE_HISr_SET(r,d) (r).fc_rxpause_his[0] = d
#define BCM6300_A0_FC_RXPAUSE_HISr_GET(r) (r).fc_rxpause_his[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_FC_RXPAUSE_HISr_RXPAUSE_HISf_GET(r) (((r).fc_rxpause_his[0]) & 0x7ff)
#define BCM6300_A0_FC_RXPAUSE_HISr_RXPAUSE_HISf_SET(r,f) (r).fc_rxpause_his[0]=(((r).fc_rxpause_his[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM6300_A0_FC_RXPAUSE_HISr_RESERVED_Rf_GET(r) ((((r).fc_rxpause_his[0]) >> 11) & 0x1f)
#define BCM6300_A0_FC_RXPAUSE_HISr_RESERVED_Rf_SET(r,f) (r).fc_rxpause_his[0]=(((r).fc_rxpause_his[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_RXPAUSE_HIS.
 *
 */
#define BCM6300_A0_READ_FC_RXPAUSE_HISr(u,r) cdk_robo_reg_read(u,BCM6300_A0_FC_RXPAUSE_HISr,(r._fc_rxpause_his),2)
#define BCM6300_A0_WRITE_FC_RXPAUSE_HISr(u,r) cdk_robo_reg_write(u,BCM6300_A0_FC_RXPAUSE_HISr,&(r._fc_rxpause_his),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_RXPAUSE_HISr BCM6300_A0_FC_RXPAUSE_HISr
#define FC_RXPAUSE_HISr_SIZE BCM6300_A0_FC_RXPAUSE_HISr_SIZE
typedef BCM6300_A0_FC_RXPAUSE_HISr_t FC_RXPAUSE_HISr_t;
#define FC_RXPAUSE_HISr_CLR BCM6300_A0_FC_RXPAUSE_HISr_CLR
#define FC_RXPAUSE_HISr_SET BCM6300_A0_FC_RXPAUSE_HISr_SET
#define FC_RXPAUSE_HISr_GET BCM6300_A0_FC_RXPAUSE_HISr_GET
#define FC_RXPAUSE_HISr_RXPAUSE_HISf_GET BCM6300_A0_FC_RXPAUSE_HISr_RXPAUSE_HISf_GET
#define FC_RXPAUSE_HISr_RXPAUSE_HISf_SET BCM6300_A0_FC_RXPAUSE_HISr_RXPAUSE_HISf_SET
#define FC_RXPAUSE_HISr_RESERVED_Rf_GET BCM6300_A0_FC_RXPAUSE_HISr_RESERVED_Rf_GET
#define FC_RXPAUSE_HISr_RESERVED_Rf_SET BCM6300_A0_FC_RXPAUSE_HISr_RESERVED_Rf_SET
#define READ_FC_RXPAUSE_HISr BCM6300_A0_READ_FC_RXPAUSE_HISr
#define WRITE_FC_RXPAUSE_HISr BCM6300_A0_WRITE_FC_RXPAUSE_HISr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_FC_RXPAUSE_HISr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  FC_RX_HYST
 * BLOCKS:   SYS
 * DESC:     Rx-Base Hysteresis Register
 * SIZE:     16
 * FIELDS:
 *     RX_HYST_THRS     
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM6300_A0_FC_RX_HYSTr 0x00000a54

#define BCM6300_A0_FC_RX_HYSTr_SIZE 2

/*
 * This structure should be used to declare and program FC_RX_HYST.
 *
 */
typedef union BCM6300_A0_FC_RX_HYSTr_s {
	uint32_t v[1];
	uint32_t fc_rx_hyst[1];
	uint32_t _fc_rx_hyst;
} BCM6300_A0_FC_RX_HYSTr_t;

#define BCM6300_A0_FC_RX_HYSTr_CLR(r) (r).fc_rx_hyst[0] = 0
#define BCM6300_A0_FC_RX_HYSTr_SET(r,d) (r).fc_rx_hyst[0] = d
#define BCM6300_A0_FC_RX_HYSTr_GET(r) (r).fc_rx_hyst[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_FC_RX_HYSTr_RX_HYST_THRSf_GET(r) (((r).fc_rx_hyst[0]) & 0xff)
#define BCM6300_A0_FC_RX_HYSTr_RX_HYST_THRSf_SET(r,f) (r).fc_rx_hyst[0]=(((r).fc_rx_hyst[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM6300_A0_FC_RX_HYSTr_RESERVED_Rf_GET(r) ((((r).fc_rx_hyst[0]) >> 8) & 0xff)
#define BCM6300_A0_FC_RX_HYSTr_RESERVED_Rf_SET(r,f) (r).fc_rx_hyst[0]=(((r).fc_rx_hyst[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_RX_HYST.
 *
 */
#define BCM6300_A0_READ_FC_RX_HYSTr(u,r) cdk_robo_reg_read(u,BCM6300_A0_FC_RX_HYSTr,(r._fc_rx_hyst),2)
#define BCM6300_A0_WRITE_FC_RX_HYSTr(u,r) cdk_robo_reg_write(u,BCM6300_A0_FC_RX_HYSTr,&(r._fc_rx_hyst),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_RX_HYSTr BCM6300_A0_FC_RX_HYSTr
#define FC_RX_HYSTr_SIZE BCM6300_A0_FC_RX_HYSTr_SIZE
typedef BCM6300_A0_FC_RX_HYSTr_t FC_RX_HYSTr_t;
#define FC_RX_HYSTr_CLR BCM6300_A0_FC_RX_HYSTr_CLR
#define FC_RX_HYSTr_SET BCM6300_A0_FC_RX_HYSTr_SET
#define FC_RX_HYSTr_GET BCM6300_A0_FC_RX_HYSTr_GET
#define FC_RX_HYSTr_RX_HYST_THRSf_GET BCM6300_A0_FC_RX_HYSTr_RX_HYST_THRSf_GET
#define FC_RX_HYSTr_RX_HYST_THRSf_SET BCM6300_A0_FC_RX_HYSTr_RX_HYST_THRSf_SET
#define FC_RX_HYSTr_RESERVED_Rf_GET BCM6300_A0_FC_RX_HYSTr_RESERVED_Rf_GET
#define FC_RX_HYSTr_RESERVED_Rf_SET BCM6300_A0_FC_RX_HYSTr_RESERVED_Rf_SET
#define READ_FC_RX_HYSTr BCM6300_A0_READ_FC_RX_HYSTr
#define WRITE_FC_RX_HYSTr BCM6300_A0_WRITE_FC_RX_HYSTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_FC_RX_HYSTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  FC_RX_MAX_PTR
 * BLOCKS:   SYS
 * DESC:     Rx-Base Max-Buffer Remap Register
 * SIZE:     16
 * FIELDS:
 *     MAXBUF_REMAP     Max_Buffer_ReMap Value.
 *     RESERVED_R       Reserved.
 *     EN_REMAP         Enable remap.
 *
 ******************************************************************************/
#define BCM6300_A0_FC_RX_MAX_PTRr 0x00000a56

#define BCM6300_A0_FC_RX_MAX_PTRr_SIZE 2

/*
 * This structure should be used to declare and program FC_RX_MAX_PTR.
 *
 */
typedef union BCM6300_A0_FC_RX_MAX_PTRr_s {
	uint32_t v[1];
	uint32_t fc_rx_max_ptr[1];
	uint32_t _fc_rx_max_ptr;
} BCM6300_A0_FC_RX_MAX_PTRr_t;

#define BCM6300_A0_FC_RX_MAX_PTRr_CLR(r) (r).fc_rx_max_ptr[0] = 0
#define BCM6300_A0_FC_RX_MAX_PTRr_SET(r,d) (r).fc_rx_max_ptr[0] = d
#define BCM6300_A0_FC_RX_MAX_PTRr_GET(r) (r).fc_rx_max_ptr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_FC_RX_MAX_PTRr_MAXBUF_REMAPf_GET(r) (((r).fc_rx_max_ptr[0]) & 0x7ff)
#define BCM6300_A0_FC_RX_MAX_PTRr_MAXBUF_REMAPf_SET(r,f) (r).fc_rx_max_ptr[0]=(((r).fc_rx_max_ptr[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM6300_A0_FC_RX_MAX_PTRr_RESERVED_Rf_GET(r) ((((r).fc_rx_max_ptr[0]) >> 11) & 0xf)
#define BCM6300_A0_FC_RX_MAX_PTRr_RESERVED_Rf_SET(r,f) (r).fc_rx_max_ptr[0]=(((r).fc_rx_max_ptr[0] & ~((uint32_t)0xf << 11)) | ((((uint32_t)f) & 0xf) << 11))
#define BCM6300_A0_FC_RX_MAX_PTRr_EN_REMAPf_GET(r) ((((r).fc_rx_max_ptr[0]) >> 15) & 0x1)
#define BCM6300_A0_FC_RX_MAX_PTRr_EN_REMAPf_SET(r,f) (r).fc_rx_max_ptr[0]=(((r).fc_rx_max_ptr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access FC_RX_MAX_PTR.
 *
 */
#define BCM6300_A0_READ_FC_RX_MAX_PTRr(u,r) cdk_robo_reg_read(u,BCM6300_A0_FC_RX_MAX_PTRr,(r._fc_rx_max_ptr),2)
#define BCM6300_A0_WRITE_FC_RX_MAX_PTRr(u,r) cdk_robo_reg_write(u,BCM6300_A0_FC_RX_MAX_PTRr,&(r._fc_rx_max_ptr),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_RX_MAX_PTRr BCM6300_A0_FC_RX_MAX_PTRr
#define FC_RX_MAX_PTRr_SIZE BCM6300_A0_FC_RX_MAX_PTRr_SIZE
typedef BCM6300_A0_FC_RX_MAX_PTRr_t FC_RX_MAX_PTRr_t;
#define FC_RX_MAX_PTRr_CLR BCM6300_A0_FC_RX_MAX_PTRr_CLR
#define FC_RX_MAX_PTRr_SET BCM6300_A0_FC_RX_MAX_PTRr_SET
#define FC_RX_MAX_PTRr_GET BCM6300_A0_FC_RX_MAX_PTRr_GET
#define FC_RX_MAX_PTRr_MAXBUF_REMAPf_GET BCM6300_A0_FC_RX_MAX_PTRr_MAXBUF_REMAPf_GET
#define FC_RX_MAX_PTRr_MAXBUF_REMAPf_SET BCM6300_A0_FC_RX_MAX_PTRr_MAXBUF_REMAPf_SET
#define FC_RX_MAX_PTRr_RESERVED_Rf_GET BCM6300_A0_FC_RX_MAX_PTRr_RESERVED_Rf_GET
#define FC_RX_MAX_PTRr_RESERVED_Rf_SET BCM6300_A0_FC_RX_MAX_PTRr_RESERVED_Rf_SET
#define FC_RX_MAX_PTRr_EN_REMAPf_GET BCM6300_A0_FC_RX_MAX_PTRr_EN_REMAPf_GET
#define FC_RX_MAX_PTRr_EN_REMAPf_SET BCM6300_A0_FC_RX_MAX_PTRr_EN_REMAPf_SET
#define READ_FC_RX_MAX_PTRr BCM6300_A0_READ_FC_RX_MAX_PTRr
#define WRITE_FC_RX_MAX_PTRr BCM6300_A0_WRITE_FC_RX_MAX_PTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_FC_RX_MAX_PTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  FC_RX_RSRV
 * BLOCKS:   SYS
 * DESC:     Rx-Base Reserved Register
 * SIZE:     16
 * FIELDS:
 *     RESV_CTRL        
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM6300_A0_FC_RX_RSRVr 0x00000a52

#define BCM6300_A0_FC_RX_RSRVr_SIZE 2

/*
 * This structure should be used to declare and program FC_RX_RSRV.
 *
 */
typedef union BCM6300_A0_FC_RX_RSRVr_s {
	uint32_t v[1];
	uint32_t fc_rx_rsrv[1];
	uint32_t _fc_rx_rsrv;
} BCM6300_A0_FC_RX_RSRVr_t;

#define BCM6300_A0_FC_RX_RSRVr_CLR(r) (r).fc_rx_rsrv[0] = 0
#define BCM6300_A0_FC_RX_RSRVr_SET(r,d) (r).fc_rx_rsrv[0] = d
#define BCM6300_A0_FC_RX_RSRVr_GET(r) (r).fc_rx_rsrv[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_FC_RX_RSRVr_RESV_CTRLf_GET(r) (((r).fc_rx_rsrv[0]) & 0xff)
#define BCM6300_A0_FC_RX_RSRVr_RESV_CTRLf_SET(r,f) (r).fc_rx_rsrv[0]=(((r).fc_rx_rsrv[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM6300_A0_FC_RX_RSRVr_RESERVED_Rf_GET(r) ((((r).fc_rx_rsrv[0]) >> 8) & 0xff)
#define BCM6300_A0_FC_RX_RSRVr_RESERVED_Rf_SET(r,f) (r).fc_rx_rsrv[0]=(((r).fc_rx_rsrv[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_RX_RSRV.
 *
 */
#define BCM6300_A0_READ_FC_RX_RSRVr(u,r) cdk_robo_reg_read(u,BCM6300_A0_FC_RX_RSRVr,(r._fc_rx_rsrv),2)
#define BCM6300_A0_WRITE_FC_RX_RSRVr(u,r) cdk_robo_reg_write(u,BCM6300_A0_FC_RX_RSRVr,&(r._fc_rx_rsrv),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_RX_RSRVr BCM6300_A0_FC_RX_RSRVr
#define FC_RX_RSRVr_SIZE BCM6300_A0_FC_RX_RSRVr_SIZE
typedef BCM6300_A0_FC_RX_RSRVr_t FC_RX_RSRVr_t;
#define FC_RX_RSRVr_CLR BCM6300_A0_FC_RX_RSRVr_CLR
#define FC_RX_RSRVr_SET BCM6300_A0_FC_RX_RSRVr_SET
#define FC_RX_RSRVr_GET BCM6300_A0_FC_RX_RSRVr_GET
#define FC_RX_RSRVr_RESV_CTRLf_GET BCM6300_A0_FC_RX_RSRVr_RESV_CTRLf_GET
#define FC_RX_RSRVr_RESV_CTRLf_SET BCM6300_A0_FC_RX_RSRVr_RESV_CTRLf_SET
#define FC_RX_RSRVr_RESERVED_Rf_GET BCM6300_A0_FC_RX_RSRVr_RESERVED_Rf_GET
#define FC_RX_RSRVr_RESERVED_Rf_SET BCM6300_A0_FC_RX_RSRVr_RESERVED_Rf_SET
#define READ_FC_RX_RSRVr BCM6300_A0_READ_FC_RX_RSRVr
#define WRITE_FC_RX_RSRVr BCM6300_A0_WRITE_FC_RX_RSRVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_FC_RX_RSRVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  FC_RX_RUNOFF
 * BLOCKS:   SYS
 * DESC:     Rx-Base Run-Off Register
 * SIZE:     16
 * FIELDS:
 *     RUN_OFF          
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM6300_A0_FC_RX_RUNOFFr 0x00000a50

#define BCM6300_A0_FC_RX_RUNOFFr_SIZE 2

/*
 * This structure should be used to declare and program FC_RX_RUNOFF.
 *
 */
typedef union BCM6300_A0_FC_RX_RUNOFFr_s {
	uint32_t v[1];
	uint32_t fc_rx_runoff[1];
	uint32_t _fc_rx_runoff;
} BCM6300_A0_FC_RX_RUNOFFr_t;

#define BCM6300_A0_FC_RX_RUNOFFr_CLR(r) (r).fc_rx_runoff[0] = 0
#define BCM6300_A0_FC_RX_RUNOFFr_SET(r,d) (r).fc_rx_runoff[0] = d
#define BCM6300_A0_FC_RX_RUNOFFr_GET(r) (r).fc_rx_runoff[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_FC_RX_RUNOFFr_RUN_OFFf_GET(r) (((r).fc_rx_runoff[0]) & 0xff)
#define BCM6300_A0_FC_RX_RUNOFFr_RUN_OFFf_SET(r,f) (r).fc_rx_runoff[0]=(((r).fc_rx_runoff[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM6300_A0_FC_RX_RUNOFFr_RESERVED_Rf_GET(r) ((((r).fc_rx_runoff[0]) >> 8) & 0xff)
#define BCM6300_A0_FC_RX_RUNOFFr_RESERVED_Rf_SET(r,f) (r).fc_rx_runoff[0]=(((r).fc_rx_runoff[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_RX_RUNOFF.
 *
 */
#define BCM6300_A0_READ_FC_RX_RUNOFFr(u,r) cdk_robo_reg_read(u,BCM6300_A0_FC_RX_RUNOFFr,(r._fc_rx_runoff),2)
#define BCM6300_A0_WRITE_FC_RX_RUNOFFr(u,r) cdk_robo_reg_write(u,BCM6300_A0_FC_RX_RUNOFFr,&(r._fc_rx_runoff),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_RX_RUNOFFr BCM6300_A0_FC_RX_RUNOFFr
#define FC_RX_RUNOFFr_SIZE BCM6300_A0_FC_RX_RUNOFFr_SIZE
typedef BCM6300_A0_FC_RX_RUNOFFr_t FC_RX_RUNOFFr_t;
#define FC_RX_RUNOFFr_CLR BCM6300_A0_FC_RX_RUNOFFr_CLR
#define FC_RX_RUNOFFr_SET BCM6300_A0_FC_RX_RUNOFFr_SET
#define FC_RX_RUNOFFr_GET BCM6300_A0_FC_RX_RUNOFFr_GET
#define FC_RX_RUNOFFr_RUN_OFFf_GET BCM6300_A0_FC_RX_RUNOFFr_RUN_OFFf_GET
#define FC_RX_RUNOFFr_RUN_OFFf_SET BCM6300_A0_FC_RX_RUNOFFr_RUN_OFFf_SET
#define FC_RX_RUNOFFr_RESERVED_Rf_GET BCM6300_A0_FC_RX_RUNOFFr_RESERVED_Rf_GET
#define FC_RX_RUNOFFr_RESERVED_Rf_SET BCM6300_A0_FC_RX_RUNOFFr_RESERVED_Rf_SET
#define READ_FC_RX_RUNOFFr BCM6300_A0_READ_FC_RX_RUNOFFr
#define WRITE_FC_RX_RUNOFFr BCM6300_A0_WRITE_FC_RX_RUNOFFr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_FC_RX_RUNOFFr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  FC_SPARE_REG
 * BLOCKS:   SYS
 * DESC:     Spare Registers
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM6300_A0_FC_SPARE_REGr 0x00000a58

#define BCM6300_A0_FC_SPARE_REGr_SIZE 2

/*
 * This structure should be used to declare and program FC_SPARE_REG.
 *
 */
typedef union BCM6300_A0_FC_SPARE_REGr_s {
	uint32_t v[1];
	uint32_t fc_spare_reg[1];
	uint32_t _fc_spare_reg;
} BCM6300_A0_FC_SPARE_REGr_t;

#define BCM6300_A0_FC_SPARE_REGr_CLR(r) (r).fc_spare_reg[0] = 0
#define BCM6300_A0_FC_SPARE_REGr_SET(r,d) (r).fc_spare_reg[0] = d
#define BCM6300_A0_FC_SPARE_REGr_GET(r) (r).fc_spare_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_FC_SPARE_REGr_RESERVED_Rf_GET(r) (((r).fc_spare_reg[0]) & 0xffff)
#define BCM6300_A0_FC_SPARE_REGr_RESERVED_Rf_SET(r,f) (r).fc_spare_reg[0]=(((r).fc_spare_reg[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access FC_SPARE_REG.
 *
 */
#define BCM6300_A0_READ_FC_SPARE_REGr(u,i,r) cdk_robo_reg_read(u,BCM6300_A0_FC_SPARE_REGr+(2*(i)),(r._fc_spare_reg),2)
#define BCM6300_A0_WRITE_FC_SPARE_REGr(u,i,r) cdk_robo_reg_write(u,BCM6300_A0_FC_SPARE_REGr+(2*(i)),&(r._fc_spare_reg),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_SPARE_REGr BCM6300_A0_FC_SPARE_REGr
#define FC_SPARE_REGr_SIZE BCM6300_A0_FC_SPARE_REGr_SIZE
typedef BCM6300_A0_FC_SPARE_REGr_t FC_SPARE_REGr_t;
#define FC_SPARE_REGr_CLR BCM6300_A0_FC_SPARE_REGr_CLR
#define FC_SPARE_REGr_SET BCM6300_A0_FC_SPARE_REGr_SET
#define FC_SPARE_REGr_GET BCM6300_A0_FC_SPARE_REGr_GET
#define FC_SPARE_REGr_RESERVED_Rf_GET BCM6300_A0_FC_SPARE_REGr_RESERVED_Rf_GET
#define FC_SPARE_REGr_RESERVED_Rf_SET BCM6300_A0_FC_SPARE_REGr_RESERVED_Rf_SET
#define READ_FC_SPARE_REGr BCM6300_A0_READ_FC_SPARE_REGr
#define WRITE_FC_SPARE_REGr BCM6300_A0_WRITE_FC_SPARE_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_FC_SPARE_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  FC_TOTAL_TH_DROP_Q
 * BLOCKS:   SYS
 * DESC:     Total Drop Threshold For Queue N Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_DROP_THRS if QOS is off, default is 512.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM6300_A0_FC_TOTAL_TH_DROP_Qr 0x00000a38

#define BCM6300_A0_FC_TOTAL_TH_DROP_Qr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_DROP_Q.
 *
 */
typedef union BCM6300_A0_FC_TOTAL_TH_DROP_Qr_s {
	uint32_t v[1];
	uint32_t fc_total_th_drop_q[1];
	uint32_t _fc_total_th_drop_q;
} BCM6300_A0_FC_TOTAL_TH_DROP_Qr_t;

#define BCM6300_A0_FC_TOTAL_TH_DROP_Qr_CLR(r) (r).fc_total_th_drop_q[0] = 0
#define BCM6300_A0_FC_TOTAL_TH_DROP_Qr_SET(r,d) (r).fc_total_th_drop_q[0] = d
#define BCM6300_A0_FC_TOTAL_TH_DROP_Qr_GET(r) (r).fc_total_th_drop_q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_FC_TOTAL_TH_DROP_Qr_TXQ_TOTAL_DROP_THRSf_GET(r) (((r).fc_total_th_drop_q[0]) & 0x7ff)
#define BCM6300_A0_FC_TOTAL_TH_DROP_Qr_TXQ_TOTAL_DROP_THRSf_SET(r,f) (r).fc_total_th_drop_q[0]=(((r).fc_total_th_drop_q[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM6300_A0_FC_TOTAL_TH_DROP_Qr_RESERVED_Rf_GET(r) ((((r).fc_total_th_drop_q[0]) >> 11) & 0x1f)
#define BCM6300_A0_FC_TOTAL_TH_DROP_Qr_RESERVED_Rf_SET(r,f) (r).fc_total_th_drop_q[0]=(((r).fc_total_th_drop_q[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_TOTAL_TH_DROP_Q.
 *
 */
#define BCM6300_A0_READ_FC_TOTAL_TH_DROP_Qr(u,i,r) cdk_robo_reg_read(u,BCM6300_A0_FC_TOTAL_TH_DROP_Qr+(2*(i)),(r._fc_total_th_drop_q),2)
#define BCM6300_A0_WRITE_FC_TOTAL_TH_DROP_Qr(u,i,r) cdk_robo_reg_write(u,BCM6300_A0_FC_TOTAL_TH_DROP_Qr+(2*(i)),&(r._fc_total_th_drop_q),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_DROP_Qr BCM6300_A0_FC_TOTAL_TH_DROP_Qr
#define FC_TOTAL_TH_DROP_Qr_SIZE BCM6300_A0_FC_TOTAL_TH_DROP_Qr_SIZE
typedef BCM6300_A0_FC_TOTAL_TH_DROP_Qr_t FC_TOTAL_TH_DROP_Qr_t;
#define FC_TOTAL_TH_DROP_Qr_CLR BCM6300_A0_FC_TOTAL_TH_DROP_Qr_CLR
#define FC_TOTAL_TH_DROP_Qr_SET BCM6300_A0_FC_TOTAL_TH_DROP_Qr_SET
#define FC_TOTAL_TH_DROP_Qr_GET BCM6300_A0_FC_TOTAL_TH_DROP_Qr_GET
#define FC_TOTAL_TH_DROP_Qr_TXQ_TOTAL_DROP_THRSf_GET BCM6300_A0_FC_TOTAL_TH_DROP_Qr_TXQ_TOTAL_DROP_THRSf_GET
#define FC_TOTAL_TH_DROP_Qr_TXQ_TOTAL_DROP_THRSf_SET BCM6300_A0_FC_TOTAL_TH_DROP_Qr_TXQ_TOTAL_DROP_THRSf_SET
#define FC_TOTAL_TH_DROP_Qr_RESERVED_Rf_GET BCM6300_A0_FC_TOTAL_TH_DROP_Qr_RESERVED_Rf_GET
#define FC_TOTAL_TH_DROP_Qr_RESERVED_Rf_SET BCM6300_A0_FC_TOTAL_TH_DROP_Qr_RESERVED_Rf_SET
#define READ_FC_TOTAL_TH_DROP_Qr BCM6300_A0_READ_FC_TOTAL_TH_DROP_Qr
#define WRITE_FC_TOTAL_TH_DROP_Qr BCM6300_A0_WRITE_FC_TOTAL_TH_DROP_Qr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_FC_TOTAL_TH_DROP_Qr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  FC_TOTAL_TH_HYST_Q
 * BLOCKS:   SYS
 * DESC:     Total Hysteresis Threshold For Queue N Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_HYST_THRS 
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM6300_A0_FC_TOTAL_TH_HYST_Qr 0x00000a28

#define BCM6300_A0_FC_TOTAL_TH_HYST_Qr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_HYST_Q.
 *
 */
typedef union BCM6300_A0_FC_TOTAL_TH_HYST_Qr_s {
	uint32_t v[1];
	uint32_t fc_total_th_hyst_q[1];
	uint32_t _fc_total_th_hyst_q;
} BCM6300_A0_FC_TOTAL_TH_HYST_Qr_t;

#define BCM6300_A0_FC_TOTAL_TH_HYST_Qr_CLR(r) (r).fc_total_th_hyst_q[0] = 0
#define BCM6300_A0_FC_TOTAL_TH_HYST_Qr_SET(r,d) (r).fc_total_th_hyst_q[0] = d
#define BCM6300_A0_FC_TOTAL_TH_HYST_Qr_GET(r) (r).fc_total_th_hyst_q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_FC_TOTAL_TH_HYST_Qr_TXQ_TOTAL_HYST_THRSf_GET(r) (((r).fc_total_th_hyst_q[0]) & 0x3ff)
#define BCM6300_A0_FC_TOTAL_TH_HYST_Qr_TXQ_TOTAL_HYST_THRSf_SET(r,f) (r).fc_total_th_hyst_q[0]=(((r).fc_total_th_hyst_q[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM6300_A0_FC_TOTAL_TH_HYST_Qr_RESERVED_Rf_GET(r) ((((r).fc_total_th_hyst_q[0]) >> 10) & 0x3f)
#define BCM6300_A0_FC_TOTAL_TH_HYST_Qr_RESERVED_Rf_SET(r,f) (r).fc_total_th_hyst_q[0]=(((r).fc_total_th_hyst_q[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TOTAL_TH_HYST_Q.
 *
 */
#define BCM6300_A0_READ_FC_TOTAL_TH_HYST_Qr(u,i,r) cdk_robo_reg_read(u,BCM6300_A0_FC_TOTAL_TH_HYST_Qr+(2*(i)),(r._fc_total_th_hyst_q),2)
#define BCM6300_A0_WRITE_FC_TOTAL_TH_HYST_Qr(u,i,r) cdk_robo_reg_write(u,BCM6300_A0_FC_TOTAL_TH_HYST_Qr+(2*(i)),&(r._fc_total_th_hyst_q),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_HYST_Qr BCM6300_A0_FC_TOTAL_TH_HYST_Qr
#define FC_TOTAL_TH_HYST_Qr_SIZE BCM6300_A0_FC_TOTAL_TH_HYST_Qr_SIZE
typedef BCM6300_A0_FC_TOTAL_TH_HYST_Qr_t FC_TOTAL_TH_HYST_Qr_t;
#define FC_TOTAL_TH_HYST_Qr_CLR BCM6300_A0_FC_TOTAL_TH_HYST_Qr_CLR
#define FC_TOTAL_TH_HYST_Qr_SET BCM6300_A0_FC_TOTAL_TH_HYST_Qr_SET
#define FC_TOTAL_TH_HYST_Qr_GET BCM6300_A0_FC_TOTAL_TH_HYST_Qr_GET
#define FC_TOTAL_TH_HYST_Qr_TXQ_TOTAL_HYST_THRSf_GET BCM6300_A0_FC_TOTAL_TH_HYST_Qr_TXQ_TOTAL_HYST_THRSf_GET
#define FC_TOTAL_TH_HYST_Qr_TXQ_TOTAL_HYST_THRSf_SET BCM6300_A0_FC_TOTAL_TH_HYST_Qr_TXQ_TOTAL_HYST_THRSf_SET
#define FC_TOTAL_TH_HYST_Qr_RESERVED_Rf_GET BCM6300_A0_FC_TOTAL_TH_HYST_Qr_RESERVED_Rf_GET
#define FC_TOTAL_TH_HYST_Qr_RESERVED_Rf_SET BCM6300_A0_FC_TOTAL_TH_HYST_Qr_RESERVED_Rf_SET
#define READ_FC_TOTAL_TH_HYST_Qr BCM6300_A0_READ_FC_TOTAL_TH_HYST_Qr
#define WRITE_FC_TOTAL_TH_HYST_Qr BCM6300_A0_WRITE_FC_TOTAL_TH_HYST_Qr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_FC_TOTAL_TH_HYST_Qr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  FC_TOTAL_TH_PAUSE_Q
 * BLOCKS:   SYS
 * DESC:     Total Pause Threshold For Queue N Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_PAUSE_THRS if QOS is on, default is 290.if QOS is off, default is 416.
 *     RESERVED_R       Reserved.                
 *
 ******************************************************************************/
#define BCM6300_A0_FC_TOTAL_TH_PAUSE_Qr 0x00000a30

#define BCM6300_A0_FC_TOTAL_TH_PAUSE_Qr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_PAUSE_Q.
 *
 */
typedef union BCM6300_A0_FC_TOTAL_TH_PAUSE_Qr_s {
	uint32_t v[1];
	uint32_t fc_total_th_pause_q[1];
	uint32_t _fc_total_th_pause_q;
} BCM6300_A0_FC_TOTAL_TH_PAUSE_Qr_t;

#define BCM6300_A0_FC_TOTAL_TH_PAUSE_Qr_CLR(r) (r).fc_total_th_pause_q[0] = 0
#define BCM6300_A0_FC_TOTAL_TH_PAUSE_Qr_SET(r,d) (r).fc_total_th_pause_q[0] = d
#define BCM6300_A0_FC_TOTAL_TH_PAUSE_Qr_GET(r) (r).fc_total_th_pause_q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_FC_TOTAL_TH_PAUSE_Qr_TXQ_TOTAL_PAUSE_THRSf_GET(r) (((r).fc_total_th_pause_q[0]) & 0x3ff)
#define BCM6300_A0_FC_TOTAL_TH_PAUSE_Qr_TXQ_TOTAL_PAUSE_THRSf_SET(r,f) (r).fc_total_th_pause_q[0]=(((r).fc_total_th_pause_q[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM6300_A0_FC_TOTAL_TH_PAUSE_Qr_RESERVED_Rf_GET(r) ((((r).fc_total_th_pause_q[0]) >> 10) & 0x3f)
#define BCM6300_A0_FC_TOTAL_TH_PAUSE_Qr_RESERVED_Rf_SET(r,f) (r).fc_total_th_pause_q[0]=(((r).fc_total_th_pause_q[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TOTAL_TH_PAUSE_Q.
 *
 */
#define BCM6300_A0_READ_FC_TOTAL_TH_PAUSE_Qr(u,i,r) cdk_robo_reg_read(u,BCM6300_A0_FC_TOTAL_TH_PAUSE_Qr+(2*(i)),(r._fc_total_th_pause_q),2)
#define BCM6300_A0_WRITE_FC_TOTAL_TH_PAUSE_Qr(u,i,r) cdk_robo_reg_write(u,BCM6300_A0_FC_TOTAL_TH_PAUSE_Qr+(2*(i)),&(r._fc_total_th_pause_q),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_PAUSE_Qr BCM6300_A0_FC_TOTAL_TH_PAUSE_Qr
#define FC_TOTAL_TH_PAUSE_Qr_SIZE BCM6300_A0_FC_TOTAL_TH_PAUSE_Qr_SIZE
typedef BCM6300_A0_FC_TOTAL_TH_PAUSE_Qr_t FC_TOTAL_TH_PAUSE_Qr_t;
#define FC_TOTAL_TH_PAUSE_Qr_CLR BCM6300_A0_FC_TOTAL_TH_PAUSE_Qr_CLR
#define FC_TOTAL_TH_PAUSE_Qr_SET BCM6300_A0_FC_TOTAL_TH_PAUSE_Qr_SET
#define FC_TOTAL_TH_PAUSE_Qr_GET BCM6300_A0_FC_TOTAL_TH_PAUSE_Qr_GET
#define FC_TOTAL_TH_PAUSE_Qr_TXQ_TOTAL_PAUSE_THRSf_GET BCM6300_A0_FC_TOTAL_TH_PAUSE_Qr_TXQ_TOTAL_PAUSE_THRSf_GET
#define FC_TOTAL_TH_PAUSE_Qr_TXQ_TOTAL_PAUSE_THRSf_SET BCM6300_A0_FC_TOTAL_TH_PAUSE_Qr_TXQ_TOTAL_PAUSE_THRSf_SET
#define FC_TOTAL_TH_PAUSE_Qr_RESERVED_Rf_GET BCM6300_A0_FC_TOTAL_TH_PAUSE_Qr_RESERVED_Rf_GET
#define FC_TOTAL_TH_PAUSE_Qr_RESERVED_Rf_SET BCM6300_A0_FC_TOTAL_TH_PAUSE_Qr_RESERVED_Rf_SET
#define READ_FC_TOTAL_TH_PAUSE_Qr BCM6300_A0_READ_FC_TOTAL_TH_PAUSE_Qr
#define WRITE_FC_TOTAL_TH_PAUSE_Qr BCM6300_A0_WRITE_FC_TOTAL_TH_PAUSE_Qr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_FC_TOTAL_TH_PAUSE_Qr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  FC_TXPAUSE_HIS
 * BLOCKS:   SYS
 * DESC:     TX Pause History Register
 * SIZE:     16
 * FIELDS:
 *     TXPAUSE_HIS      
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_FC_TXPAUSE_HISr 0x00000aa2

#define BCM6300_A0_FC_TXPAUSE_HISr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXPAUSE_HIS.
 *
 */
typedef union BCM6300_A0_FC_TXPAUSE_HISr_s {
	uint32_t v[1];
	uint32_t fc_txpause_his[1];
	uint32_t _fc_txpause_his;
} BCM6300_A0_FC_TXPAUSE_HISr_t;

#define BCM6300_A0_FC_TXPAUSE_HISr_CLR(r) (r).fc_txpause_his[0] = 0
#define BCM6300_A0_FC_TXPAUSE_HISr_SET(r,d) (r).fc_txpause_his[0] = d
#define BCM6300_A0_FC_TXPAUSE_HISr_GET(r) (r).fc_txpause_his[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_FC_TXPAUSE_HISr_TXPAUSE_HISf_GET(r) (((r).fc_txpause_his[0]) & 0x7ff)
#define BCM6300_A0_FC_TXPAUSE_HISr_TXPAUSE_HISf_SET(r,f) (r).fc_txpause_his[0]=(((r).fc_txpause_his[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM6300_A0_FC_TXPAUSE_HISr_RESERVED_Rf_GET(r) ((((r).fc_txpause_his[0]) >> 11) & 0x1f)
#define BCM6300_A0_FC_TXPAUSE_HISr_RESERVED_Rf_SET(r,f) (r).fc_txpause_his[0]=(((r).fc_txpause_his[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_TXPAUSE_HIS.
 *
 */
#define BCM6300_A0_READ_FC_TXPAUSE_HISr(u,r) cdk_robo_reg_read(u,BCM6300_A0_FC_TXPAUSE_HISr,(r._fc_txpause_his),2)
#define BCM6300_A0_WRITE_FC_TXPAUSE_HISr(u,r) cdk_robo_reg_write(u,BCM6300_A0_FC_TXPAUSE_HISr,&(r._fc_txpause_his),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXPAUSE_HISr BCM6300_A0_FC_TXPAUSE_HISr
#define FC_TXPAUSE_HISr_SIZE BCM6300_A0_FC_TXPAUSE_HISr_SIZE
typedef BCM6300_A0_FC_TXPAUSE_HISr_t FC_TXPAUSE_HISr_t;
#define FC_TXPAUSE_HISr_CLR BCM6300_A0_FC_TXPAUSE_HISr_CLR
#define FC_TXPAUSE_HISr_SET BCM6300_A0_FC_TXPAUSE_HISr_SET
#define FC_TXPAUSE_HISr_GET BCM6300_A0_FC_TXPAUSE_HISr_GET
#define FC_TXPAUSE_HISr_TXPAUSE_HISf_GET BCM6300_A0_FC_TXPAUSE_HISr_TXPAUSE_HISf_GET
#define FC_TXPAUSE_HISr_TXPAUSE_HISf_SET BCM6300_A0_FC_TXPAUSE_HISr_TXPAUSE_HISf_SET
#define FC_TXPAUSE_HISr_RESERVED_Rf_GET BCM6300_A0_FC_TXPAUSE_HISr_RESERVED_Rf_GET
#define FC_TXPAUSE_HISr_RESERVED_Rf_SET BCM6300_A0_FC_TXPAUSE_HISr_RESERVED_Rf_SET
#define READ_FC_TXPAUSE_HISr BCM6300_A0_READ_FC_TXPAUSE_HISr
#define WRITE_FC_TXPAUSE_HISr BCM6300_A0_WRITE_FC_TXPAUSE_HISr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_FC_TXPAUSE_HISr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  FC_TXQ_TH_DROP_Q
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(0~3) Pause Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_DROP_THRS                    
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM6300_A0_FC_TXQ_TH_DROP_Qr 0x00000a20

#define BCM6300_A0_FC_TXQ_TH_DROP_Qr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_DROP_Q.
 *
 */
typedef union BCM6300_A0_FC_TXQ_TH_DROP_Qr_s {
	uint32_t v[1];
	uint32_t fc_txq_th_drop_q[1];
	uint32_t _fc_txq_th_drop_q;
} BCM6300_A0_FC_TXQ_TH_DROP_Qr_t;

#define BCM6300_A0_FC_TXQ_TH_DROP_Qr_CLR(r) (r).fc_txq_th_drop_q[0] = 0
#define BCM6300_A0_FC_TXQ_TH_DROP_Qr_SET(r,d) (r).fc_txq_th_drop_q[0] = d
#define BCM6300_A0_FC_TXQ_TH_DROP_Qr_GET(r) (r).fc_txq_th_drop_q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_FC_TXQ_TH_DROP_Qr_TXQ_DROP_THRSf_GET(r) (((r).fc_txq_th_drop_q[0]) & 0x3ff)
#define BCM6300_A0_FC_TXQ_TH_DROP_Qr_TXQ_DROP_THRSf_SET(r,f) (r).fc_txq_th_drop_q[0]=(((r).fc_txq_th_drop_q[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM6300_A0_FC_TXQ_TH_DROP_Qr_RESERVED_Rf_GET(r) ((((r).fc_txq_th_drop_q[0]) >> 10) & 0x3f)
#define BCM6300_A0_FC_TXQ_TH_DROP_Qr_RESERVED_Rf_SET(r,f) (r).fc_txq_th_drop_q[0]=(((r).fc_txq_th_drop_q[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_DROP_Q.
 *
 */
#define BCM6300_A0_READ_FC_TXQ_TH_DROP_Qr(u,i,r) cdk_robo_reg_read(u,BCM6300_A0_FC_TXQ_TH_DROP_Qr+(2*(i)),(r._fc_txq_th_drop_q),2)
#define BCM6300_A0_WRITE_FC_TXQ_TH_DROP_Qr(u,i,r) cdk_robo_reg_write(u,BCM6300_A0_FC_TXQ_TH_DROP_Qr+(2*(i)),&(r._fc_txq_th_drop_q),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_DROP_Qr BCM6300_A0_FC_TXQ_TH_DROP_Qr
#define FC_TXQ_TH_DROP_Qr_SIZE BCM6300_A0_FC_TXQ_TH_DROP_Qr_SIZE
typedef BCM6300_A0_FC_TXQ_TH_DROP_Qr_t FC_TXQ_TH_DROP_Qr_t;
#define FC_TXQ_TH_DROP_Qr_CLR BCM6300_A0_FC_TXQ_TH_DROP_Qr_CLR
#define FC_TXQ_TH_DROP_Qr_SET BCM6300_A0_FC_TXQ_TH_DROP_Qr_SET
#define FC_TXQ_TH_DROP_Qr_GET BCM6300_A0_FC_TXQ_TH_DROP_Qr_GET
#define FC_TXQ_TH_DROP_Qr_TXQ_DROP_THRSf_GET BCM6300_A0_FC_TXQ_TH_DROP_Qr_TXQ_DROP_THRSf_GET
#define FC_TXQ_TH_DROP_Qr_TXQ_DROP_THRSf_SET BCM6300_A0_FC_TXQ_TH_DROP_Qr_TXQ_DROP_THRSf_SET
#define FC_TXQ_TH_DROP_Qr_RESERVED_Rf_GET BCM6300_A0_FC_TXQ_TH_DROP_Qr_RESERVED_Rf_GET
#define FC_TXQ_TH_DROP_Qr_RESERVED_Rf_SET BCM6300_A0_FC_TXQ_TH_DROP_Qr_RESERVED_Rf_SET
#define READ_FC_TXQ_TH_DROP_Qr BCM6300_A0_READ_FC_TXQ_TH_DROP_Qr
#define WRITE_FC_TXQ_TH_DROP_Qr BCM6300_A0_WRITE_FC_TXQ_TH_DROP_Qr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_FC_TXQ_TH_DROP_Qr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  FC_TXQ_TH_PAUSE_Q
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(0~3) Pause Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_PAUSE_THRS                   
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM6300_A0_FC_TXQ_TH_PAUSE_Qr 0x00000a18

#define BCM6300_A0_FC_TXQ_TH_PAUSE_Qr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_PAUSE_Q.
 *
 */
typedef union BCM6300_A0_FC_TXQ_TH_PAUSE_Qr_s {
	uint32_t v[1];
	uint32_t fc_txq_th_pause_q[1];
	uint32_t _fc_txq_th_pause_q;
} BCM6300_A0_FC_TXQ_TH_PAUSE_Qr_t;

#define BCM6300_A0_FC_TXQ_TH_PAUSE_Qr_CLR(r) (r).fc_txq_th_pause_q[0] = 0
#define BCM6300_A0_FC_TXQ_TH_PAUSE_Qr_SET(r,d) (r).fc_txq_th_pause_q[0] = d
#define BCM6300_A0_FC_TXQ_TH_PAUSE_Qr_GET(r) (r).fc_txq_th_pause_q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_FC_TXQ_TH_PAUSE_Qr_TXQ_PAUSE_THRSf_GET(r) (((r).fc_txq_th_pause_q[0]) & 0x3ff)
#define BCM6300_A0_FC_TXQ_TH_PAUSE_Qr_TXQ_PAUSE_THRSf_SET(r,f) (r).fc_txq_th_pause_q[0]=(((r).fc_txq_th_pause_q[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM6300_A0_FC_TXQ_TH_PAUSE_Qr_RESERVED_Rf_GET(r) ((((r).fc_txq_th_pause_q[0]) >> 10) & 0x3f)
#define BCM6300_A0_FC_TXQ_TH_PAUSE_Qr_RESERVED_Rf_SET(r,f) (r).fc_txq_th_pause_q[0]=(((r).fc_txq_th_pause_q[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_PAUSE_Q.
 *
 */
#define BCM6300_A0_READ_FC_TXQ_TH_PAUSE_Qr(u,i,r) cdk_robo_reg_read(u,BCM6300_A0_FC_TXQ_TH_PAUSE_Qr+(2*(i)),(r._fc_txq_th_pause_q),2)
#define BCM6300_A0_WRITE_FC_TXQ_TH_PAUSE_Qr(u,i,r) cdk_robo_reg_write(u,BCM6300_A0_FC_TXQ_TH_PAUSE_Qr+(2*(i)),&(r._fc_txq_th_pause_q),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_PAUSE_Qr BCM6300_A0_FC_TXQ_TH_PAUSE_Qr
#define FC_TXQ_TH_PAUSE_Qr_SIZE BCM6300_A0_FC_TXQ_TH_PAUSE_Qr_SIZE
typedef BCM6300_A0_FC_TXQ_TH_PAUSE_Qr_t FC_TXQ_TH_PAUSE_Qr_t;
#define FC_TXQ_TH_PAUSE_Qr_CLR BCM6300_A0_FC_TXQ_TH_PAUSE_Qr_CLR
#define FC_TXQ_TH_PAUSE_Qr_SET BCM6300_A0_FC_TXQ_TH_PAUSE_Qr_SET
#define FC_TXQ_TH_PAUSE_Qr_GET BCM6300_A0_FC_TXQ_TH_PAUSE_Qr_GET
#define FC_TXQ_TH_PAUSE_Qr_TXQ_PAUSE_THRSf_GET BCM6300_A0_FC_TXQ_TH_PAUSE_Qr_TXQ_PAUSE_THRSf_GET
#define FC_TXQ_TH_PAUSE_Qr_TXQ_PAUSE_THRSf_SET BCM6300_A0_FC_TXQ_TH_PAUSE_Qr_TXQ_PAUSE_THRSf_SET
#define FC_TXQ_TH_PAUSE_Qr_RESERVED_Rf_GET BCM6300_A0_FC_TXQ_TH_PAUSE_Qr_RESERVED_Rf_GET
#define FC_TXQ_TH_PAUSE_Qr_RESERVED_Rf_SET BCM6300_A0_FC_TXQ_TH_PAUSE_Qr_RESERVED_Rf_SET
#define READ_FC_TXQ_TH_PAUSE_Qr BCM6300_A0_READ_FC_TXQ_TH_PAUSE_Qr
#define WRITE_FC_TXQ_TH_PAUSE_Qr BCM6300_A0_WRITE_FC_TXQ_TH_PAUSE_Qr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_FC_TXQ_TH_PAUSE_Qr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  FC_TXQ_TH_RSRV_Q
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(0~3) Hysteresis Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_HYST_THRS    
 *     RESERVED_1R      Reserved.
 *
 ******************************************************************************/
#define BCM6300_A0_FC_TXQ_TH_RSRV_Qr 0x00000a10

#define BCM6300_A0_FC_TXQ_TH_RSRV_Qr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_RSRV_Q.
 *
 */
typedef union BCM6300_A0_FC_TXQ_TH_RSRV_Qr_s {
	uint32_t v[1];
	uint32_t fc_txq_th_rsrv_q[1];
	uint32_t _fc_txq_th_rsrv_q;
} BCM6300_A0_FC_TXQ_TH_RSRV_Qr_t;

#define BCM6300_A0_FC_TXQ_TH_RSRV_Qr_CLR(r) (r).fc_txq_th_rsrv_q[0] = 0
#define BCM6300_A0_FC_TXQ_TH_RSRV_Qr_SET(r,d) (r).fc_txq_th_rsrv_q[0] = d
#define BCM6300_A0_FC_TXQ_TH_RSRV_Qr_GET(r) (r).fc_txq_th_rsrv_q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_FC_TXQ_TH_RSRV_Qr_TXQ_HYST_THRSf_GET(r) (((r).fc_txq_th_rsrv_q[0]) & 0x3ff)
#define BCM6300_A0_FC_TXQ_TH_RSRV_Qr_TXQ_HYST_THRSf_SET(r,f) (r).fc_txq_th_rsrv_q[0]=(((r).fc_txq_th_rsrv_q[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM6300_A0_FC_TXQ_TH_RSRV_Qr_RESERVED_1Rf_GET(r) ((((r).fc_txq_th_rsrv_q[0]) >> 10) & 0x3f)
#define BCM6300_A0_FC_TXQ_TH_RSRV_Qr_RESERVED_1Rf_SET(r,f) (r).fc_txq_th_rsrv_q[0]=(((r).fc_txq_th_rsrv_q[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_RSRV_Q.
 *
 */
#define BCM6300_A0_READ_FC_TXQ_TH_RSRV_Qr(u,i,r) cdk_robo_reg_read(u,BCM6300_A0_FC_TXQ_TH_RSRV_Qr+(2*(i)),(r._fc_txq_th_rsrv_q),2)
#define BCM6300_A0_WRITE_FC_TXQ_TH_RSRV_Qr(u,i,r) cdk_robo_reg_write(u,BCM6300_A0_FC_TXQ_TH_RSRV_Qr+(2*(i)),&(r._fc_txq_th_rsrv_q),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_RSRV_Qr BCM6300_A0_FC_TXQ_TH_RSRV_Qr
#define FC_TXQ_TH_RSRV_Qr_SIZE BCM6300_A0_FC_TXQ_TH_RSRV_Qr_SIZE
typedef BCM6300_A0_FC_TXQ_TH_RSRV_Qr_t FC_TXQ_TH_RSRV_Qr_t;
#define FC_TXQ_TH_RSRV_Qr_CLR BCM6300_A0_FC_TXQ_TH_RSRV_Qr_CLR
#define FC_TXQ_TH_RSRV_Qr_SET BCM6300_A0_FC_TXQ_TH_RSRV_Qr_SET
#define FC_TXQ_TH_RSRV_Qr_GET BCM6300_A0_FC_TXQ_TH_RSRV_Qr_GET
#define FC_TXQ_TH_RSRV_Qr_TXQ_HYST_THRSf_GET BCM6300_A0_FC_TXQ_TH_RSRV_Qr_TXQ_HYST_THRSf_GET
#define FC_TXQ_TH_RSRV_Qr_TXQ_HYST_THRSf_SET BCM6300_A0_FC_TXQ_TH_RSRV_Qr_TXQ_HYST_THRSf_SET
#define FC_TXQ_TH_RSRV_Qr_RESERVED_1Rf_GET BCM6300_A0_FC_TXQ_TH_RSRV_Qr_RESERVED_1Rf_GET
#define FC_TXQ_TH_RSRV_Qr_RESERVED_1Rf_SET BCM6300_A0_FC_TXQ_TH_RSRV_Qr_RESERVED_1Rf_SET
#define READ_FC_TXQ_TH_RSRV_Qr BCM6300_A0_READ_FC_TXQ_TH_RSRV_Qr
#define WRITE_FC_TXQ_TH_RSRV_Qr BCM6300_A0_WRITE_FC_TXQ_TH_RSRV_Qr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_FC_TXQ_TH_RSRV_Qr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  GARLCFG
 * BLOCKS:   SYS
 * DESC:     Global ARL Configuration Register
 * SIZE:     8
 * FIELDS:
 *     HASH_DISABLE     Disable The hash function for the ARL such that entries are direct mapped to the table. The hash function is enable default for the BCM5389M ARL,but can be disabled by setting this bit.
 *     RESERVED_1R      Reserved
 *     AGE_ACC          Age Accele rate, test only. 
 *     MPORT_ADDR_EN    Multiport Address Enable.When set by the host, enables the Multiport Address 1 and 2 registers, and their associated Multiport Vector 1 and 2 registers. This enables these registers in the ARL search.Note that if only one multiport address is required, the host should write both Multiport Address/Vector entries to the same value. 
 *     MCAST_ARL_UNICAST  Allow unicast address matching in the multicast ARL 
 *     MCAST_ARL_EN           Enable Multicast ARL Table 
 *
 ******************************************************************************/
#define BCM6300_A0_GARLCFGr 0x00000400

#define BCM6300_A0_GARLCFGr_SIZE 1

/*
 * This structure should be used to declare and program GARLCFG.
 *
 */
typedef union BCM6300_A0_GARLCFGr_s {
	uint32_t v[1];
	uint32_t garlcfg[1];
	uint32_t _garlcfg;
} BCM6300_A0_GARLCFGr_t;

#define BCM6300_A0_GARLCFGr_CLR(r) (r).garlcfg[0] = 0
#define BCM6300_A0_GARLCFGr_SET(r,d) (r).garlcfg[0] = d
#define BCM6300_A0_GARLCFGr_GET(r) (r).garlcfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_GARLCFGr_HASH_DISABLEf_GET(r) (((r).garlcfg[0]) & 0x1)
#define BCM6300_A0_GARLCFGr_HASH_DISABLEf_SET(r,f) (r).garlcfg[0]=(((r).garlcfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM6300_A0_GARLCFGr_RESERVED_1Rf_GET(r) ((((r).garlcfg[0]) >> 1) & 0x1)
#define BCM6300_A0_GARLCFGr_RESERVED_1Rf_SET(r,f) (r).garlcfg[0]=(((r).garlcfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM6300_A0_GARLCFGr_AGE_ACCf_GET(r) ((((r).garlcfg[0]) >> 2) & 0x1)
#define BCM6300_A0_GARLCFGr_AGE_ACCf_SET(r,f) (r).garlcfg[0]=(((r).garlcfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM6300_A0_GARLCFGr_MPORT_ADDR_ENf_GET(r) ((((r).garlcfg[0]) >> 4) & 0x1)
#define BCM6300_A0_GARLCFGr_MPORT_ADDR_ENf_SET(r,f) (r).garlcfg[0]=(((r).garlcfg[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM6300_A0_GARLCFGr_MCAST_ARL_UNICASTf_GET(r) ((((r).garlcfg[0]) >> 6) & 0x1)
#define BCM6300_A0_GARLCFGr_MCAST_ARL_UNICASTf_SET(r,f) (r).garlcfg[0]=(((r).garlcfg[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM6300_A0_GARLCFGr_MCAST_ARL_ENf_GET(r) ((((r).garlcfg[0]) >> 7) & 0x1)
#define BCM6300_A0_GARLCFGr_MCAST_ARL_ENf_SET(r,f) (r).garlcfg[0]=(((r).garlcfg[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access GARLCFG.
 *
 */
#define BCM6300_A0_READ_GARLCFGr(u,r) cdk_robo_reg_read(u,BCM6300_A0_GARLCFGr,(r._garlcfg),1)
#define BCM6300_A0_WRITE_GARLCFGr(u,r) cdk_robo_reg_write(u,BCM6300_A0_GARLCFGr,&(r._garlcfg),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GARLCFGr BCM6300_A0_GARLCFGr
#define GARLCFGr_SIZE BCM6300_A0_GARLCFGr_SIZE
typedef BCM6300_A0_GARLCFGr_t GARLCFGr_t;
#define GARLCFGr_CLR BCM6300_A0_GARLCFGr_CLR
#define GARLCFGr_SET BCM6300_A0_GARLCFGr_SET
#define GARLCFGr_GET BCM6300_A0_GARLCFGr_GET
#define GARLCFGr_HASH_DISABLEf_GET BCM6300_A0_GARLCFGr_HASH_DISABLEf_GET
#define GARLCFGr_HASH_DISABLEf_SET BCM6300_A0_GARLCFGr_HASH_DISABLEf_SET
#define GARLCFGr_RESERVED_1Rf_GET BCM6300_A0_GARLCFGr_RESERVED_1Rf_GET
#define GARLCFGr_RESERVED_1Rf_SET BCM6300_A0_GARLCFGr_RESERVED_1Rf_SET
#define GARLCFGr_AGE_ACCf_GET BCM6300_A0_GARLCFGr_AGE_ACCf_GET
#define GARLCFGr_AGE_ACCf_SET BCM6300_A0_GARLCFGr_AGE_ACCf_SET
#define GARLCFGr_MPORT_ADDR_ENf_GET BCM6300_A0_GARLCFGr_MPORT_ADDR_ENf_GET
#define GARLCFGr_MPORT_ADDR_ENf_SET BCM6300_A0_GARLCFGr_MPORT_ADDR_ENf_SET
#define GARLCFGr_MCAST_ARL_UNICASTf_GET BCM6300_A0_GARLCFGr_MCAST_ARL_UNICASTf_GET
#define GARLCFGr_MCAST_ARL_UNICASTf_SET BCM6300_A0_GARLCFGr_MCAST_ARL_UNICASTf_SET
#define GARLCFGr_MCAST_ARL_ENf_GET BCM6300_A0_GARLCFGr_MCAST_ARL_ENf_GET
#define GARLCFGr_MCAST_ARL_ENf_SET BCM6300_A0_GARLCFGr_MCAST_ARL_ENf_SET
#define READ_GARLCFGr BCM6300_A0_READ_GARLCFGr
#define WRITE_GARLCFGr BCM6300_A0_WRITE_GARLCFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_GARLCFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  GLOBAL_TRUNK_CTL
 * BLOCKS:   SYS
 * DESC:     MAC Trunk Control Register
 * SIZE:     8
 * FIELDS:
 *     TRUNK_SEED       index selection00 : use hash DA ^ SA) to generate index. ( default=0 )01 : use hash(DA) to generate index.10 : Use hash (SA) to generate index.
 *     RESERVER_0       Reserved
 *     EN_TRUNK_LOCAL   Enable Mac trunking .BCM6300  support 4 trunking groups. The trunking group can support up to 2 ports as defined trunking group register.
 *     RESERVER_1       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_GLOBAL_TRUNK_CTLr 0x00003200

#define BCM6300_A0_GLOBAL_TRUNK_CTLr_SIZE 1

/*
 * This structure should be used to declare and program GLOBAL_TRUNK_CTL.
 *
 */
typedef union BCM6300_A0_GLOBAL_TRUNK_CTLr_s {
	uint32_t v[1];
	uint32_t global_trunk_ctl[1];
	uint32_t _global_trunk_ctl;
} BCM6300_A0_GLOBAL_TRUNK_CTLr_t;

#define BCM6300_A0_GLOBAL_TRUNK_CTLr_CLR(r) (r).global_trunk_ctl[0] = 0
#define BCM6300_A0_GLOBAL_TRUNK_CTLr_SET(r,d) (r).global_trunk_ctl[0] = d
#define BCM6300_A0_GLOBAL_TRUNK_CTLr_GET(r) (r).global_trunk_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_GLOBAL_TRUNK_CTLr_TRUNK_SEEDf_GET(r) (((r).global_trunk_ctl[0]) & 0x3)
#define BCM6300_A0_GLOBAL_TRUNK_CTLr_TRUNK_SEEDf_SET(r,f) (r).global_trunk_ctl[0]=(((r).global_trunk_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM6300_A0_GLOBAL_TRUNK_CTLr_RESERVER_0f_GET(r) ((((r).global_trunk_ctl[0]) >> 2) & 0x1)
#define BCM6300_A0_GLOBAL_TRUNK_CTLr_RESERVER_0f_SET(r,f) (r).global_trunk_ctl[0]=(((r).global_trunk_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM6300_A0_GLOBAL_TRUNK_CTLr_EN_TRUNK_LOCALf_GET(r) ((((r).global_trunk_ctl[0]) >> 3) & 0x1)
#define BCM6300_A0_GLOBAL_TRUNK_CTLr_EN_TRUNK_LOCALf_SET(r,f) (r).global_trunk_ctl[0]=(((r).global_trunk_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM6300_A0_GLOBAL_TRUNK_CTLr_RESERVER_1f_GET(r) ((((r).global_trunk_ctl[0]) >> 4) & 0xf)
#define BCM6300_A0_GLOBAL_TRUNK_CTLr_RESERVER_1f_SET(r,f) (r).global_trunk_ctl[0]=(((r).global_trunk_ctl[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access GLOBAL_TRUNK_CTL.
 *
 */
#define BCM6300_A0_READ_GLOBAL_TRUNK_CTLr(u,r) cdk_robo_reg_read(u,BCM6300_A0_GLOBAL_TRUNK_CTLr,(r._global_trunk_ctl),1)
#define BCM6300_A0_WRITE_GLOBAL_TRUNK_CTLr(u,r) cdk_robo_reg_write(u,BCM6300_A0_GLOBAL_TRUNK_CTLr,&(r._global_trunk_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GLOBAL_TRUNK_CTLr BCM6300_A0_GLOBAL_TRUNK_CTLr
#define GLOBAL_TRUNK_CTLr_SIZE BCM6300_A0_GLOBAL_TRUNK_CTLr_SIZE
typedef BCM6300_A0_GLOBAL_TRUNK_CTLr_t GLOBAL_TRUNK_CTLr_t;
#define GLOBAL_TRUNK_CTLr_CLR BCM6300_A0_GLOBAL_TRUNK_CTLr_CLR
#define GLOBAL_TRUNK_CTLr_SET BCM6300_A0_GLOBAL_TRUNK_CTLr_SET
#define GLOBAL_TRUNK_CTLr_GET BCM6300_A0_GLOBAL_TRUNK_CTLr_GET
#define GLOBAL_TRUNK_CTLr_TRUNK_SEEDf_GET BCM6300_A0_GLOBAL_TRUNK_CTLr_TRUNK_SEEDf_GET
#define GLOBAL_TRUNK_CTLr_TRUNK_SEEDf_SET BCM6300_A0_GLOBAL_TRUNK_CTLr_TRUNK_SEEDf_SET
#define GLOBAL_TRUNK_CTLr_RESERVER_0f_GET BCM6300_A0_GLOBAL_TRUNK_CTLr_RESERVER_0f_GET
#define GLOBAL_TRUNK_CTLr_RESERVER_0f_SET BCM6300_A0_GLOBAL_TRUNK_CTLr_RESERVER_0f_SET
#define GLOBAL_TRUNK_CTLr_EN_TRUNK_LOCALf_GET BCM6300_A0_GLOBAL_TRUNK_CTLr_EN_TRUNK_LOCALf_GET
#define GLOBAL_TRUNK_CTLr_EN_TRUNK_LOCALf_SET BCM6300_A0_GLOBAL_TRUNK_CTLr_EN_TRUNK_LOCALf_SET
#define GLOBAL_TRUNK_CTLr_RESERVER_1f_GET BCM6300_A0_GLOBAL_TRUNK_CTLr_RESERVER_1f_GET
#define GLOBAL_TRUNK_CTLr_RESERVER_1f_SET BCM6300_A0_GLOBAL_TRUNK_CTLr_RESERVER_1f_SET
#define READ_GLOBAL_TRUNK_CTLr BCM6300_A0_READ_GLOBAL_TRUNK_CTLr
#define WRITE_GLOBAL_TRUNK_CTLr BCM6300_A0_WRITE_GLOBAL_TRUNK_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_GLOBAL_TRUNK_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  GMNGCFG
 * BLOCKS:   SYS
 * DESC:     Global Management Configuration Register
 * SIZE:     8
 * FIELDS:
 *     RST_MIB_CNT      Reset MIB CountersResets all MIB counters for all ports to zero (Pages 20h-28h). The host must set the bit and then clear the bit in successive write cycles to activate the reset operation.
 *     RXBPDU_EN        Receive BPDU Enable.Enables all ports to receive BPDUs and forward to the defined Physical Management Port. Management CPU must set this bit to globally allow BPDUs to be received.
 *     RESERVED_1R      Reserved
 *     IGMPIP_SNOP_EN   IGMP IP layer Snooping Enable.When asserted, IGMP IP layer snooping is enabled. As incoming frame has value 2 in IP header's protocol field, it will be forwarded to CPU port.
 *     RESERVED_0R      Reserved
 *     FRM_MNGP         Frame Management Port.Defines the physical port used to report management frames directed to the switch.00=No Management Port10=MII Port (In-band Management Port - IMP)11=ReservedThese bits are ignored when SW_FWD_MODE=Unmanaged in the Switch Mode Register, and the device will behave as if there is no defined management port.
 *
 ******************************************************************************/
#define BCM6300_A0_GMNGCFGr 0x00000200

#define BCM6300_A0_GMNGCFGr_SIZE 1

/*
 * This structure should be used to declare and program GMNGCFG.
 *
 */
typedef union BCM6300_A0_GMNGCFGr_s {
	uint32_t v[1];
	uint32_t gmngcfg[1];
	uint32_t _gmngcfg;
} BCM6300_A0_GMNGCFGr_t;

#define BCM6300_A0_GMNGCFGr_CLR(r) (r).gmngcfg[0] = 0
#define BCM6300_A0_GMNGCFGr_SET(r,d) (r).gmngcfg[0] = d
#define BCM6300_A0_GMNGCFGr_GET(r) (r).gmngcfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_GMNGCFGr_RST_MIB_CNTf_GET(r) (((r).gmngcfg[0]) & 0x1)
#define BCM6300_A0_GMNGCFGr_RST_MIB_CNTf_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM6300_A0_GMNGCFGr_RXBPDU_ENf_GET(r) ((((r).gmngcfg[0]) >> 1) & 0x1)
#define BCM6300_A0_GMNGCFGr_RXBPDU_ENf_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM6300_A0_GMNGCFGr_RESERVED_1Rf_GET(r) ((((r).gmngcfg[0]) >> 2) & 0x1)
#define BCM6300_A0_GMNGCFGr_RESERVED_1Rf_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM6300_A0_GMNGCFGr_IGMPIP_SNOP_ENf_GET(r) ((((r).gmngcfg[0]) >> 3) & 0x1)
#define BCM6300_A0_GMNGCFGr_IGMPIP_SNOP_ENf_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM6300_A0_GMNGCFGr_RESERVED_0Rf_GET(r) ((((r).gmngcfg[0]) >> 4) & 0x3)
#define BCM6300_A0_GMNGCFGr_RESERVED_0Rf_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM6300_A0_GMNGCFGr_FRM_MNGPf_GET(r) ((((r).gmngcfg[0]) >> 6) & 0x3)
#define BCM6300_A0_GMNGCFGr_FRM_MNGPf_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access GMNGCFG.
 *
 */
#define BCM6300_A0_READ_GMNGCFGr(u,r) cdk_robo_reg_read(u,BCM6300_A0_GMNGCFGr,(r._gmngcfg),1)
#define BCM6300_A0_WRITE_GMNGCFGr(u,r) cdk_robo_reg_write(u,BCM6300_A0_GMNGCFGr,&(r._gmngcfg),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GMNGCFGr BCM6300_A0_GMNGCFGr
#define GMNGCFGr_SIZE BCM6300_A0_GMNGCFGr_SIZE
typedef BCM6300_A0_GMNGCFGr_t GMNGCFGr_t;
#define GMNGCFGr_CLR BCM6300_A0_GMNGCFGr_CLR
#define GMNGCFGr_SET BCM6300_A0_GMNGCFGr_SET
#define GMNGCFGr_GET BCM6300_A0_GMNGCFGr_GET
#define GMNGCFGr_RST_MIB_CNTf_GET BCM6300_A0_GMNGCFGr_RST_MIB_CNTf_GET
#define GMNGCFGr_RST_MIB_CNTf_SET BCM6300_A0_GMNGCFGr_RST_MIB_CNTf_SET
#define GMNGCFGr_RXBPDU_ENf_GET BCM6300_A0_GMNGCFGr_RXBPDU_ENf_GET
#define GMNGCFGr_RXBPDU_ENf_SET BCM6300_A0_GMNGCFGr_RXBPDU_ENf_SET
#define GMNGCFGr_RESERVED_1Rf_GET BCM6300_A0_GMNGCFGr_RESERVED_1Rf_GET
#define GMNGCFGr_RESERVED_1Rf_SET BCM6300_A0_GMNGCFGr_RESERVED_1Rf_SET
#define GMNGCFGr_IGMPIP_SNOP_ENf_GET BCM6300_A0_GMNGCFGr_IGMPIP_SNOP_ENf_GET
#define GMNGCFGr_IGMPIP_SNOP_ENf_SET BCM6300_A0_GMNGCFGr_IGMPIP_SNOP_ENf_SET
#define GMNGCFGr_RESERVED_0Rf_GET BCM6300_A0_GMNGCFGr_RESERVED_0Rf_GET
#define GMNGCFGr_RESERVED_0Rf_SET BCM6300_A0_GMNGCFGr_RESERVED_0Rf_SET
#define GMNGCFGr_FRM_MNGPf_GET BCM6300_A0_GMNGCFGr_FRM_MNGPf_GET
#define GMNGCFGr_FRM_MNGPf_SET BCM6300_A0_GMNGCFGr_FRM_MNGPf_SET
#define READ_GMNGCFGr BCM6300_A0_READ_GMNGCFGr
#define WRITE_GMNGCFGr BCM6300_A0_WRITE_GMNGCFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_GMNGCFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  GRPADDR1
 * BLOCKS:   SYS
 * DESC:     Multiport Address 1 Register
 * SIZE:     48
 * FIELDS:
 *     GRP_ADDR         Multiport Address 1.Allows a frames with a matching DA to this address to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 1 register.Must be enabled using the MPORT_ADDR_EN bit in the Global ARL Configuration register.
 *
 ******************************************************************************/
#define BCM6300_A0_GRPADDR1r 0x00000410

#define BCM6300_A0_GRPADDR1r_SIZE 6

/*
 * This structure should be used to declare and program GRPADDR1.
 *
 */
typedef union BCM6300_A0_GRPADDR1r_s {
	uint32_t v[2];
	uint32_t grpaddr1[2];
	uint32_t _grpaddr1;
} BCM6300_A0_GRPADDR1r_t;

#define BCM6300_A0_GRPADDR1r_CLR(r) CDK_MEMSET(&((r)._grpaddr1), 0, sizeof(BCM6300_A0_GRPADDR1r_t))
#define BCM6300_A0_GRPADDR1r_SET(r,i,d) (r).grpaddr1[i] = d
#define BCM6300_A0_GRPADDR1r_GET(r,i) (r).grpaddr1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_GRPADDR1r_GRP_ADDRf_GET(r,a) cdk_field_get((r).grpaddr1,0,47,a)
#define BCM6300_A0_GRPADDR1r_GRP_ADDRf_SET(r,a) cdk_field_set((r).grpaddr1,0,47,a)

/*
 * These macros can be used to access GRPADDR1.
 *
 */
#define BCM6300_A0_READ_GRPADDR1r(u,r) cdk_robo_reg_read(u,BCM6300_A0_GRPADDR1r,(r._grpaddr1),6)
#define BCM6300_A0_WRITE_GRPADDR1r(u,r) cdk_robo_reg_write(u,BCM6300_A0_GRPADDR1r,&(r._grpaddr1),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRPADDR1r BCM6300_A0_GRPADDR1r
#define GRPADDR1r_SIZE BCM6300_A0_GRPADDR1r_SIZE
typedef BCM6300_A0_GRPADDR1r_t GRPADDR1r_t;
#define GRPADDR1r_CLR BCM6300_A0_GRPADDR1r_CLR
#define GRPADDR1r_SET BCM6300_A0_GRPADDR1r_SET
#define GRPADDR1r_GET BCM6300_A0_GRPADDR1r_GET
#define GRPADDR1r_GRP_ADDRf_GET BCM6300_A0_GRPADDR1r_GRP_ADDRf_GET
#define GRPADDR1r_GRP_ADDRf_SET BCM6300_A0_GRPADDR1r_GRP_ADDRf_SET
#define READ_GRPADDR1r BCM6300_A0_READ_GRPADDR1r
#define WRITE_GRPADDR1r BCM6300_A0_WRITE_GRPADDR1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_GRPADDR1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  GRPADDR2
 * BLOCKS:   SYS
 * DESC:     Multiport Address 2 Register
 * SIZE:     48
 * FIELDS:
 *     GRP_ADDR         Multiport Address 2.Allows a frames with a matching DA to this address to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 2 register.Must be enabled using the MPORT_ADDR_EN bit in the Global ARL Configuration register.
 *
 ******************************************************************************/
#define BCM6300_A0_GRPADDR2r 0x00000420

#define BCM6300_A0_GRPADDR2r_SIZE 6

/*
 * This structure should be used to declare and program GRPADDR2.
 *
 */
typedef union BCM6300_A0_GRPADDR2r_s {
	uint32_t v[2];
	uint32_t grpaddr2[2];
	uint32_t _grpaddr2;
} BCM6300_A0_GRPADDR2r_t;

#define BCM6300_A0_GRPADDR2r_CLR(r) CDK_MEMSET(&((r)._grpaddr2), 0, sizeof(BCM6300_A0_GRPADDR2r_t))
#define BCM6300_A0_GRPADDR2r_SET(r,i,d) (r).grpaddr2[i] = d
#define BCM6300_A0_GRPADDR2r_GET(r,i) (r).grpaddr2[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_GRPADDR2r_GRP_ADDRf_GET(r,a) cdk_field_get((r).grpaddr2,0,47,a)
#define BCM6300_A0_GRPADDR2r_GRP_ADDRf_SET(r,a) cdk_field_set((r).grpaddr2,0,47,a)

/*
 * These macros can be used to access GRPADDR2.
 *
 */
#define BCM6300_A0_READ_GRPADDR2r(u,r) cdk_robo_reg_read(u,BCM6300_A0_GRPADDR2r,(r._grpaddr2),6)
#define BCM6300_A0_WRITE_GRPADDR2r(u,r) cdk_robo_reg_write(u,BCM6300_A0_GRPADDR2r,&(r._grpaddr2),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GRPADDR2r BCM6300_A0_GRPADDR2r
#define GRPADDR2r_SIZE BCM6300_A0_GRPADDR2r_SIZE
typedef BCM6300_A0_GRPADDR2r_t GRPADDR2r_t;
#define GRPADDR2r_CLR BCM6300_A0_GRPADDR2r_CLR
#define GRPADDR2r_SET BCM6300_A0_GRPADDR2r_SET
#define GRPADDR2r_GET BCM6300_A0_GRPADDR2r_GET
#define GRPADDR2r_GRP_ADDRf_GET BCM6300_A0_GRPADDR2r_GRP_ADDRf_GET
#define GRPADDR2r_GRP_ADDRf_SET BCM6300_A0_GRPADDR2r_GRP_ADDRf_SET
#define READ_GRPADDR2r BCM6300_A0_READ_GRPADDR2r
#define WRITE_GRPADDR2r BCM6300_A0_WRITE_GRPADDR2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_GRPADDR2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  G_PCTL
 * BLOCKS:   GPIC0
 * DESC:     10/100/1000 Port Control Register
 * SIZE:     8
 * FIELDS:
 *     MIRX_DIS         Disables the receive function of the port at the MAC level.
 *     MITX_DIS         Disables the transmit function of the port at the MAC level.
 *     RESERVED_R       Reserved.
 *     G_MISTP_STATE    CPU writes the current computed states of its Spanning Tree Algorithmfor this port.3b'b000: No Spanning Tree(Unmanaged mode).3b'b001: Disable State(default for managed mode).3b'b010: Blocking State.3b'b011: Listening State.3b'b100: Learning State.3b'b101: Forwarding State.3b'b110 - 3b'b111: Reserved.Programmed frome the HW_FWDG_EN Strap Option.Can be overwritten subsequently.
 *
 ******************************************************************************/
#define BCM6300_A0_G_PCTLr 0x00000000

#define BCM6300_A0_G_PCTLr_SIZE 1

/*
 * This structure should be used to declare and program G_PCTL.
 *
 */
typedef union BCM6300_A0_G_PCTLr_s {
	uint32_t v[1];
	uint32_t g_pctl[1];
	uint32_t _g_pctl;
} BCM6300_A0_G_PCTLr_t;

#define BCM6300_A0_G_PCTLr_CLR(r) (r).g_pctl[0] = 0
#define BCM6300_A0_G_PCTLr_SET(r,d) (r).g_pctl[0] = d
#define BCM6300_A0_G_PCTLr_GET(r) (r).g_pctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_G_PCTLr_MIRX_DISf_GET(r) (((r).g_pctl[0]) & 0x1)
#define BCM6300_A0_G_PCTLr_MIRX_DISf_SET(r,f) (r).g_pctl[0]=(((r).g_pctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM6300_A0_G_PCTLr_MITX_DISf_GET(r) ((((r).g_pctl[0]) >> 1) & 0x1)
#define BCM6300_A0_G_PCTLr_MITX_DISf_SET(r,f) (r).g_pctl[0]=(((r).g_pctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM6300_A0_G_PCTLr_RESERVED_Rf_GET(r) ((((r).g_pctl[0]) >> 2) & 0x7)
#define BCM6300_A0_G_PCTLr_RESERVED_Rf_SET(r,f) (r).g_pctl[0]=(((r).g_pctl[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2))
#define BCM6300_A0_G_PCTLr_G_MISTP_STATEf_GET(r) ((((r).g_pctl[0]) >> 5) & 0x7)
#define BCM6300_A0_G_PCTLr_G_MISTP_STATEf_SET(r,f) (r).g_pctl[0]=(((r).g_pctl[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access G_PCTL.
 *
 */
#define BCM6300_A0_READ_G_PCTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_G_PCTLr,(r._g_pctl),1)
#define BCM6300_A0_WRITE_G_PCTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_G_PCTLr,&(r._g_pctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PCTLr BCM6300_A0_G_PCTLr
#define G_PCTLr_SIZE BCM6300_A0_G_PCTLr_SIZE
typedef BCM6300_A0_G_PCTLr_t G_PCTLr_t;
#define G_PCTLr_CLR BCM6300_A0_G_PCTLr_CLR
#define G_PCTLr_SET BCM6300_A0_G_PCTLr_SET
#define G_PCTLr_GET BCM6300_A0_G_PCTLr_GET
#define G_PCTLr_MIRX_DISf_GET BCM6300_A0_G_PCTLr_MIRX_DISf_GET
#define G_PCTLr_MIRX_DISf_SET BCM6300_A0_G_PCTLr_MIRX_DISf_SET
#define G_PCTLr_MITX_DISf_GET BCM6300_A0_G_PCTLr_MITX_DISf_GET
#define G_PCTLr_MITX_DISf_SET BCM6300_A0_G_PCTLr_MITX_DISf_SET
#define G_PCTLr_RESERVED_Rf_GET BCM6300_A0_G_PCTLr_RESERVED_Rf_GET
#define G_PCTLr_RESERVED_Rf_SET BCM6300_A0_G_PCTLr_RESERVED_Rf_SET
#define G_PCTLr_G_MISTP_STATEf_GET BCM6300_A0_G_PCTLr_G_MISTP_STATEf_GET
#define G_PCTLr_G_MISTP_STATEf_SET BCM6300_A0_G_PCTLr_G_MISTP_STATEf_SET
#define READ_G_PCTLr BCM6300_A0_READ_G_PCTLr
#define WRITE_G_PCTLr BCM6300_A0_WRITE_G_PCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_G_PCTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  HNDRD_ACTL
 * BLOCKS:   GPIC0
 * DESC:     100Base-X Auxiliary Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_HNDRD_ACTLr 0x00001020

#define BCM6300_A0_HNDRD_ACTLr_SIZE 2

/*
 * This structure should be used to declare and program HNDRD_ACTL.
 *
 */
typedef union BCM6300_A0_HNDRD_ACTLr_s {
	uint32_t v[1];
	uint32_t hndrd_actl[1];
	uint32_t _hndrd_actl;
} BCM6300_A0_HNDRD_ACTLr_t;

#define BCM6300_A0_HNDRD_ACTLr_CLR(r) (r).hndrd_actl[0] = 0
#define BCM6300_A0_HNDRD_ACTLr_SET(r,d) (r).hndrd_actl[0] = d
#define BCM6300_A0_HNDRD_ACTLr_GET(r) (r).hndrd_actl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_HNDRD_ACTLr_RESERVED_Rf_GET(r) (((r).hndrd_actl[0]) & 0xffff)
#define BCM6300_A0_HNDRD_ACTLr_RESERVED_Rf_SET(r,f) (r).hndrd_actl[0]=(((r).hndrd_actl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access HNDRD_ACTL.
 *
 */
#define BCM6300_A0_READ_HNDRD_ACTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_HNDRD_ACTLr,(r._hndrd_actl),2)
#define BCM6300_A0_WRITE_HNDRD_ACTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_HNDRD_ACTLr,&(r._hndrd_actl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HNDRD_ACTLr BCM6300_A0_HNDRD_ACTLr
#define HNDRD_ACTLr_SIZE BCM6300_A0_HNDRD_ACTLr_SIZE
typedef BCM6300_A0_HNDRD_ACTLr_t HNDRD_ACTLr_t;
#define HNDRD_ACTLr_CLR BCM6300_A0_HNDRD_ACTLr_CLR
#define HNDRD_ACTLr_SET BCM6300_A0_HNDRD_ACTLr_SET
#define HNDRD_ACTLr_GET BCM6300_A0_HNDRD_ACTLr_GET
#define HNDRD_ACTLr_RESERVED_Rf_GET BCM6300_A0_HNDRD_ACTLr_RESERVED_Rf_GET
#define HNDRD_ACTLr_RESERVED_Rf_SET BCM6300_A0_HNDRD_ACTLr_RESERVED_Rf_SET
#define READ_HNDRD_ACTLr BCM6300_A0_READ_HNDRD_ACTLr
#define WRITE_HNDRD_ACTLr BCM6300_A0_WRITE_HNDRD_ACTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_HNDRD_ACTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  HNDRD_ASTS
 * BLOCKS:   GPIC0
 * DESC:     100Base-X Auxiliary Status Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_HNDRD_ASTSr 0x00001022

#define BCM6300_A0_HNDRD_ASTSr_SIZE 2

/*
 * This structure should be used to declare and program HNDRD_ASTS.
 *
 */
typedef union BCM6300_A0_HNDRD_ASTSr_s {
	uint32_t v[1];
	uint32_t hndrd_asts[1];
	uint32_t _hndrd_asts;
} BCM6300_A0_HNDRD_ASTSr_t;

#define BCM6300_A0_HNDRD_ASTSr_CLR(r) (r).hndrd_asts[0] = 0
#define BCM6300_A0_HNDRD_ASTSr_SET(r,d) (r).hndrd_asts[0] = d
#define BCM6300_A0_HNDRD_ASTSr_GET(r) (r).hndrd_asts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_HNDRD_ASTSr_RESERVED_Rf_GET(r) (((r).hndrd_asts[0]) & 0xffff)
#define BCM6300_A0_HNDRD_ASTSr_RESERVED_Rf_SET(r,f) (r).hndrd_asts[0]=(((r).hndrd_asts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access HNDRD_ASTS.
 *
 */
#define BCM6300_A0_READ_HNDRD_ASTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_HNDRD_ASTSr,(r._hndrd_asts),2)
#define BCM6300_A0_WRITE_HNDRD_ASTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_HNDRD_ASTSr,&(r._hndrd_asts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HNDRD_ASTSr BCM6300_A0_HNDRD_ASTSr
#define HNDRD_ASTSr_SIZE BCM6300_A0_HNDRD_ASTSr_SIZE
typedef BCM6300_A0_HNDRD_ASTSr_t HNDRD_ASTSr_t;
#define HNDRD_ASTSr_CLR BCM6300_A0_HNDRD_ASTSr_CLR
#define HNDRD_ASTSr_SET BCM6300_A0_HNDRD_ASTSr_SET
#define HNDRD_ASTSr_GET BCM6300_A0_HNDRD_ASTSr_GET
#define HNDRD_ASTSr_RESERVED_Rf_GET BCM6300_A0_HNDRD_ASTSr_RESERVED_Rf_GET
#define HNDRD_ASTSr_RESERVED_Rf_SET BCM6300_A0_HNDRD_ASTSr_RESERVED_Rf_SET
#define READ_HNDRD_ASTSr BCM6300_A0_READ_HNDRD_ASTSr
#define WRITE_HNDRD_ASTSr BCM6300_A0_WRITE_HNDRD_ASTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_HNDRD_ASTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  HNDRD_FCSCNT
 * BLOCKS:   GPIC0
 * DESC:     100Base-X False Carrier Sense Counter Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_HNDRD_FCSCNTr 0x00001026

#define BCM6300_A0_HNDRD_FCSCNTr_SIZE 2

/*
 * This structure should be used to declare and program HNDRD_FCSCNT.
 *
 */
typedef union BCM6300_A0_HNDRD_FCSCNTr_s {
	uint32_t v[1];
	uint32_t hndrd_fcscnt[1];
	uint32_t _hndrd_fcscnt;
} BCM6300_A0_HNDRD_FCSCNTr_t;

#define BCM6300_A0_HNDRD_FCSCNTr_CLR(r) (r).hndrd_fcscnt[0] = 0
#define BCM6300_A0_HNDRD_FCSCNTr_SET(r,d) (r).hndrd_fcscnt[0] = d
#define BCM6300_A0_HNDRD_FCSCNTr_GET(r) (r).hndrd_fcscnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_HNDRD_FCSCNTr_RESERVED_Rf_GET(r) (((r).hndrd_fcscnt[0]) & 0xffff)
#define BCM6300_A0_HNDRD_FCSCNTr_RESERVED_Rf_SET(r,f) (r).hndrd_fcscnt[0]=(((r).hndrd_fcscnt[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access HNDRD_FCSCNT.
 *
 */
#define BCM6300_A0_READ_HNDRD_FCSCNTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_HNDRD_FCSCNTr,(r._hndrd_fcscnt),2)
#define BCM6300_A0_WRITE_HNDRD_FCSCNTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_HNDRD_FCSCNTr,&(r._hndrd_fcscnt),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HNDRD_FCSCNTr BCM6300_A0_HNDRD_FCSCNTr
#define HNDRD_FCSCNTr_SIZE BCM6300_A0_HNDRD_FCSCNTr_SIZE
typedef BCM6300_A0_HNDRD_FCSCNTr_t HNDRD_FCSCNTr_t;
#define HNDRD_FCSCNTr_CLR BCM6300_A0_HNDRD_FCSCNTr_CLR
#define HNDRD_FCSCNTr_SET BCM6300_A0_HNDRD_FCSCNTr_SET
#define HNDRD_FCSCNTr_GET BCM6300_A0_HNDRD_FCSCNTr_GET
#define HNDRD_FCSCNTr_RESERVED_Rf_GET BCM6300_A0_HNDRD_FCSCNTr_RESERVED_Rf_GET
#define HNDRD_FCSCNTr_RESERVED_Rf_SET BCM6300_A0_HNDRD_FCSCNTr_RESERVED_Rf_SET
#define READ_HNDRD_FCSCNTr BCM6300_A0_READ_HNDRD_FCSCNTr
#define WRITE_HNDRD_FCSCNTr BCM6300_A0_WRITE_HNDRD_FCSCNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_HNDRD_FCSCNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  HNDRD_RECNT
 * BLOCKS:   GPIC0
 * DESC:     100Base-X Receive Error Counter Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_HNDRD_RECNTr 0x00001024

#define BCM6300_A0_HNDRD_RECNTr_SIZE 2

/*
 * This structure should be used to declare and program HNDRD_RECNT.
 *
 */
typedef union BCM6300_A0_HNDRD_RECNTr_s {
	uint32_t v[1];
	uint32_t hndrd_recnt[1];
	uint32_t _hndrd_recnt;
} BCM6300_A0_HNDRD_RECNTr_t;

#define BCM6300_A0_HNDRD_RECNTr_CLR(r) (r).hndrd_recnt[0] = 0
#define BCM6300_A0_HNDRD_RECNTr_SET(r,d) (r).hndrd_recnt[0] = d
#define BCM6300_A0_HNDRD_RECNTr_GET(r) (r).hndrd_recnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_HNDRD_RECNTr_RESERVED_Rf_GET(r) (((r).hndrd_recnt[0]) & 0xffff)
#define BCM6300_A0_HNDRD_RECNTr_RESERVED_Rf_SET(r,f) (r).hndrd_recnt[0]=(((r).hndrd_recnt[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access HNDRD_RECNT.
 *
 */
#define BCM6300_A0_READ_HNDRD_RECNTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_HNDRD_RECNTr,(r._hndrd_recnt),2)
#define BCM6300_A0_WRITE_HNDRD_RECNTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_HNDRD_RECNTr,&(r._hndrd_recnt),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HNDRD_RECNTr BCM6300_A0_HNDRD_RECNTr
#define HNDRD_RECNTr_SIZE BCM6300_A0_HNDRD_RECNTr_SIZE
typedef BCM6300_A0_HNDRD_RECNTr_t HNDRD_RECNTr_t;
#define HNDRD_RECNTr_CLR BCM6300_A0_HNDRD_RECNTr_CLR
#define HNDRD_RECNTr_SET BCM6300_A0_HNDRD_RECNTr_SET
#define HNDRD_RECNTr_GET BCM6300_A0_HNDRD_RECNTr_GET
#define HNDRD_RECNTr_RESERVED_Rf_GET BCM6300_A0_HNDRD_RECNTr_RESERVED_Rf_GET
#define HNDRD_RECNTr_RESERVED_Rf_SET BCM6300_A0_HNDRD_RECNTr_RESERVED_Rf_SET
#define READ_HNDRD_RECNTr BCM6300_A0_READ_HNDRD_RECNTr
#define WRITE_HNDRD_RECNTr BCM6300_A0_WRITE_HNDRD_RECNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_HNDRD_RECNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  IGMIRCTL
 * BLOCKS:   SYS
 * DESC:     Ingress Mirror Control Register
 * SIZE:     16
 * FIELDS:
 *     IN_MIR_MSK       Ingress Mirror Port Mask.9 bit mask which selectively allows any port with its corresponding bit set, to be mirrored to the port identified by the MIRROR_CAPTURE_PORT value. Note that while multiple bits in a device may be set, severe congestion and/or frame loss may occur if excessive bandwidth from the mirrored port(s) is directed to theMIRROR_CAPTURE_PORT.Bits 0-7 = Port 0-7Bit 8= IMP.
 *     RESERVED_R       Reserved
 *     IN_DIV_EN        Ingress Divider Enable.Mirror every nth received frame (n=IN_MIRROR_DIV) that has passed through the IN_MIRROR_FILTER.
 *     IN_MIR_FLTR      Ingress Mirror Filter.Defines the conditions under which frames received on a port that has been selected in the IN_MRROR_MASK[10:0], will be compared in order to determine if they should be forwarded to the MIRROR_CAPTURE_PORT.00: Mirror all ingress frames.01: Mirror all received frames with DA = IN_MIRROR_MAC.10: Mirror all received frames with SA = IN_MIRROR_MAC.11: Reserved.
 *
 ******************************************************************************/
#define BCM6300_A0_IGMIRCTLr 0x00000212

#define BCM6300_A0_IGMIRCTLr_SIZE 2

/*
 * This structure should be used to declare and program IGMIRCTL.
 *
 */
typedef union BCM6300_A0_IGMIRCTLr_s {
	uint32_t v[1];
	uint32_t igmirctl[1];
	uint32_t _igmirctl;
} BCM6300_A0_IGMIRCTLr_t;

#define BCM6300_A0_IGMIRCTLr_CLR(r) (r).igmirctl[0] = 0
#define BCM6300_A0_IGMIRCTLr_SET(r,d) (r).igmirctl[0] = d
#define BCM6300_A0_IGMIRCTLr_GET(r) (r).igmirctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_IGMIRCTLr_IN_MIR_MSKf_GET(r) (((r).igmirctl[0]) & 0x1ff)
#define BCM6300_A0_IGMIRCTLr_IN_MIR_MSKf_SET(r,f) (r).igmirctl[0]=(((r).igmirctl[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_IGMIRCTLr_RESERVED_Rf_GET(r) ((((r).igmirctl[0]) >> 9) & 0xf)
#define BCM6300_A0_IGMIRCTLr_RESERVED_Rf_SET(r,f) (r).igmirctl[0]=(((r).igmirctl[0] & ~((uint32_t)0xf << 9)) | ((((uint32_t)f) & 0xf) << 9))
#define BCM6300_A0_IGMIRCTLr_IN_DIV_ENf_GET(r) ((((r).igmirctl[0]) >> 13) & 0x1)
#define BCM6300_A0_IGMIRCTLr_IN_DIV_ENf_SET(r,f) (r).igmirctl[0]=(((r).igmirctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM6300_A0_IGMIRCTLr_IN_MIR_FLTRf_GET(r) ((((r).igmirctl[0]) >> 14) & 0x3)
#define BCM6300_A0_IGMIRCTLr_IN_MIR_FLTRf_SET(r,f) (r).igmirctl[0]=(((r).igmirctl[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access IGMIRCTL.
 *
 */
#define BCM6300_A0_READ_IGMIRCTLr(u,r) cdk_robo_reg_read(u,BCM6300_A0_IGMIRCTLr,(r._igmirctl),2)
#define BCM6300_A0_WRITE_IGMIRCTLr(u,r) cdk_robo_reg_write(u,BCM6300_A0_IGMIRCTLr,&(r._igmirctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IGMIRCTLr BCM6300_A0_IGMIRCTLr
#define IGMIRCTLr_SIZE BCM6300_A0_IGMIRCTLr_SIZE
typedef BCM6300_A0_IGMIRCTLr_t IGMIRCTLr_t;
#define IGMIRCTLr_CLR BCM6300_A0_IGMIRCTLr_CLR
#define IGMIRCTLr_SET BCM6300_A0_IGMIRCTLr_SET
#define IGMIRCTLr_GET BCM6300_A0_IGMIRCTLr_GET
#define IGMIRCTLr_IN_MIR_MSKf_GET BCM6300_A0_IGMIRCTLr_IN_MIR_MSKf_GET
#define IGMIRCTLr_IN_MIR_MSKf_SET BCM6300_A0_IGMIRCTLr_IN_MIR_MSKf_SET
#define IGMIRCTLr_RESERVED_Rf_GET BCM6300_A0_IGMIRCTLr_RESERVED_Rf_GET
#define IGMIRCTLr_RESERVED_Rf_SET BCM6300_A0_IGMIRCTLr_RESERVED_Rf_SET
#define IGMIRCTLr_IN_DIV_ENf_GET BCM6300_A0_IGMIRCTLr_IN_DIV_ENf_GET
#define IGMIRCTLr_IN_DIV_ENf_SET BCM6300_A0_IGMIRCTLr_IN_DIV_ENf_SET
#define IGMIRCTLr_IN_MIR_FLTRf_GET BCM6300_A0_IGMIRCTLr_IN_MIR_FLTRf_GET
#define IGMIRCTLr_IN_MIR_FLTRf_SET BCM6300_A0_IGMIRCTLr_IN_MIR_FLTRf_SET
#define READ_IGMIRCTLr BCM6300_A0_READ_IGMIRCTLr
#define WRITE_IGMIRCTLr BCM6300_A0_WRITE_IGMIRCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_IGMIRCTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  IGMIRDIV
 * BLOCKS:   SYS
 * DESC:     Ingress Mirror Divider Register
 * SIZE:     16
 * FIELDS:
 *     IN_MIR_DIV       Ingress Mirror Divider.Receive frames that have passed the IN_MIRROR_FILTER rule can further be pruned to reduce the overall number of frames returned to the MIRROR_CAPTURE_PORT. When the IN_DIV_EN bit in the Ingress Mirror Control register is set, frames that pass the IN_MIRROR_FILTER rule are further divided by the value loaded into this register, so that only one in n frames (where n = IN_MIRROR_DIV) will be mirrored.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_IGMIRDIVr 0x00000214

#define BCM6300_A0_IGMIRDIVr_SIZE 2

/*
 * This structure should be used to declare and program IGMIRDIV.
 *
 */
typedef union BCM6300_A0_IGMIRDIVr_s {
	uint32_t v[1];
	uint32_t igmirdiv[1];
	uint32_t _igmirdiv;
} BCM6300_A0_IGMIRDIVr_t;

#define BCM6300_A0_IGMIRDIVr_CLR(r) (r).igmirdiv[0] = 0
#define BCM6300_A0_IGMIRDIVr_SET(r,d) (r).igmirdiv[0] = d
#define BCM6300_A0_IGMIRDIVr_GET(r) (r).igmirdiv[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_IGMIRDIVr_IN_MIR_DIVf_GET(r) (((r).igmirdiv[0]) & 0x3ff)
#define BCM6300_A0_IGMIRDIVr_IN_MIR_DIVf_SET(r,f) (r).igmirdiv[0]=(((r).igmirdiv[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM6300_A0_IGMIRDIVr_RESERVED_Rf_GET(r) ((((r).igmirdiv[0]) >> 10) & 0x3f)
#define BCM6300_A0_IGMIRDIVr_RESERVED_Rf_SET(r,f) (r).igmirdiv[0]=(((r).igmirdiv[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access IGMIRDIV.
 *
 */
#define BCM6300_A0_READ_IGMIRDIVr(u,r) cdk_robo_reg_read(u,BCM6300_A0_IGMIRDIVr,(r._igmirdiv),2)
#define BCM6300_A0_WRITE_IGMIRDIVr(u,r) cdk_robo_reg_write(u,BCM6300_A0_IGMIRDIVr,&(r._igmirdiv),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IGMIRDIVr BCM6300_A0_IGMIRDIVr
#define IGMIRDIVr_SIZE BCM6300_A0_IGMIRDIVr_SIZE
typedef BCM6300_A0_IGMIRDIVr_t IGMIRDIVr_t;
#define IGMIRDIVr_CLR BCM6300_A0_IGMIRDIVr_CLR
#define IGMIRDIVr_SET BCM6300_A0_IGMIRDIVr_SET
#define IGMIRDIVr_GET BCM6300_A0_IGMIRDIVr_GET
#define IGMIRDIVr_IN_MIR_DIVf_GET BCM6300_A0_IGMIRDIVr_IN_MIR_DIVf_GET
#define IGMIRDIVr_IN_MIR_DIVf_SET BCM6300_A0_IGMIRDIVr_IN_MIR_DIVf_SET
#define IGMIRDIVr_RESERVED_Rf_GET BCM6300_A0_IGMIRDIVr_RESERVED_Rf_GET
#define IGMIRDIVr_RESERVED_Rf_SET BCM6300_A0_IGMIRDIVr_RESERVED_Rf_SET
#define READ_IGMIRDIVr BCM6300_A0_READ_IGMIRDIVr
#define WRITE_IGMIRDIVr BCM6300_A0_WRITE_IGMIRDIVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_IGMIRDIVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  IGMIRMAC
 * BLOCKS:   SYS
 * DESC:     Ingress Mirror Mac Address Register
 * SIZE:     48
 * FIELDS:
 *     IN_MIR_MAC       
 *
 ******************************************************************************/
#define BCM6300_A0_IGMIRMACr 0x00000216

#define BCM6300_A0_IGMIRMACr_SIZE 6

/*
 * This structure should be used to declare and program IGMIRMAC.
 *
 */
typedef union BCM6300_A0_IGMIRMACr_s {
	uint32_t v[2];
	uint32_t igmirmac[2];
	uint32_t _igmirmac;
} BCM6300_A0_IGMIRMACr_t;

#define BCM6300_A0_IGMIRMACr_CLR(r) CDK_MEMSET(&((r)._igmirmac), 0, sizeof(BCM6300_A0_IGMIRMACr_t))
#define BCM6300_A0_IGMIRMACr_SET(r,i,d) (r).igmirmac[i] = d
#define BCM6300_A0_IGMIRMACr_GET(r,i) (r).igmirmac[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_IGMIRMACr_IN_MIR_MACf_GET(r,a) cdk_field_get((r).igmirmac,0,47,a)
#define BCM6300_A0_IGMIRMACr_IN_MIR_MACf_SET(r,a) cdk_field_set((r).igmirmac,0,47,a)

/*
 * These macros can be used to access IGMIRMAC.
 *
 */
#define BCM6300_A0_READ_IGMIRMACr(u,r) cdk_robo_reg_read(u,BCM6300_A0_IGMIRMACr,(r._igmirmac),6)
#define BCM6300_A0_WRITE_IGMIRMACr(u,r) cdk_robo_reg_write(u,BCM6300_A0_IGMIRMACr,&(r._igmirmac),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IGMIRMACr BCM6300_A0_IGMIRMACr
#define IGMIRMACr_SIZE BCM6300_A0_IGMIRMACr_SIZE
typedef BCM6300_A0_IGMIRMACr_t IGMIRMACr_t;
#define IGMIRMACr_CLR BCM6300_A0_IGMIRMACr_CLR
#define IGMIRMACr_SET BCM6300_A0_IGMIRMACr_SET
#define IGMIRMACr_GET BCM6300_A0_IGMIRMACr_GET
#define IGMIRMACr_IN_MIR_MACf_GET BCM6300_A0_IGMIRMACr_IN_MIR_MACf_GET
#define IGMIRMACr_IN_MIR_MACf_SET BCM6300_A0_IGMIRMACr_IN_MIR_MACf_SET
#define READ_IGMIRMACr BCM6300_A0_READ_IGMIRMACr
#define WRITE_IGMIRMACr BCM6300_A0_WRITE_IGMIRMACr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_IGMIRMACr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  ISP_PORT_SEL_PBM
 * BLOCKS:   SYS
 * DESC:     Double Tagging TPID Register
 * SIZE:     16
 * FIELDS:
 *     ISP_PORT_PBMP    Bitmap to define which port as ISP-port.                
 *     RESERVED_R       reserved
 *
 ******************************************************************************/
#define BCM6300_A0_ISP_PORT_SEL_PBMr 0x00003432

#define BCM6300_A0_ISP_PORT_SEL_PBMr_SIZE 2

/*
 * This structure should be used to declare and program ISP_PORT_SEL_PBM.
 *
 */
typedef union BCM6300_A0_ISP_PORT_SEL_PBMr_s {
	uint32_t v[1];
	uint32_t isp_port_sel_pbm[1];
	uint32_t _isp_port_sel_pbm;
} BCM6300_A0_ISP_PORT_SEL_PBMr_t;

#define BCM6300_A0_ISP_PORT_SEL_PBMr_CLR(r) (r).isp_port_sel_pbm[0] = 0
#define BCM6300_A0_ISP_PORT_SEL_PBMr_SET(r,d) (r).isp_port_sel_pbm[0] = d
#define BCM6300_A0_ISP_PORT_SEL_PBMr_GET(r) (r).isp_port_sel_pbm[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_ISP_PORT_SEL_PBMr_ISP_PORT_PBMPf_GET(r) (((r).isp_port_sel_pbm[0]) & 0x1ff)
#define BCM6300_A0_ISP_PORT_SEL_PBMr_ISP_PORT_PBMPf_SET(r,f) (r).isp_port_sel_pbm[0]=(((r).isp_port_sel_pbm[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_ISP_PORT_SEL_PBMr_RESERVED_Rf_GET(r) ((((r).isp_port_sel_pbm[0]) >> 9) & 0x7f)
#define BCM6300_A0_ISP_PORT_SEL_PBMr_RESERVED_Rf_SET(r,f) (r).isp_port_sel_pbm[0]=(((r).isp_port_sel_pbm[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access ISP_PORT_SEL_PBM.
 *
 */
#define BCM6300_A0_READ_ISP_PORT_SEL_PBMr(u,r) cdk_robo_reg_read(u,BCM6300_A0_ISP_PORT_SEL_PBMr,(r._isp_port_sel_pbm),2)
#define BCM6300_A0_WRITE_ISP_PORT_SEL_PBMr(u,r) cdk_robo_reg_write(u,BCM6300_A0_ISP_PORT_SEL_PBMr,&(r._isp_port_sel_pbm),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ISP_PORT_SEL_PBMr BCM6300_A0_ISP_PORT_SEL_PBMr
#define ISP_PORT_SEL_PBMr_SIZE BCM6300_A0_ISP_PORT_SEL_PBMr_SIZE
typedef BCM6300_A0_ISP_PORT_SEL_PBMr_t ISP_PORT_SEL_PBMr_t;
#define ISP_PORT_SEL_PBMr_CLR BCM6300_A0_ISP_PORT_SEL_PBMr_CLR
#define ISP_PORT_SEL_PBMr_SET BCM6300_A0_ISP_PORT_SEL_PBMr_SET
#define ISP_PORT_SEL_PBMr_GET BCM6300_A0_ISP_PORT_SEL_PBMr_GET
#define ISP_PORT_SEL_PBMr_ISP_PORT_PBMPf_GET BCM6300_A0_ISP_PORT_SEL_PBMr_ISP_PORT_PBMPf_GET
#define ISP_PORT_SEL_PBMr_ISP_PORT_PBMPf_SET BCM6300_A0_ISP_PORT_SEL_PBMr_ISP_PORT_PBMPf_SET
#define ISP_PORT_SEL_PBMr_RESERVED_Rf_GET BCM6300_A0_ISP_PORT_SEL_PBMr_RESERVED_Rf_GET
#define ISP_PORT_SEL_PBMr_RESERVED_Rf_SET BCM6300_A0_ISP_PORT_SEL_PBMr_RESERVED_Rf_SET
#define READ_ISP_PORT_SEL_PBMr BCM6300_A0_READ_ISP_PORT_SEL_PBMr
#define WRITE_ISP_PORT_SEL_PBMr BCM6300_A0_WRITE_ISP_PORT_SEL_PBMr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_ISP_PORT_SEL_PBMr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  JUMBO_PORT_MASK
 * BLOCKS:   SYS
 * DESC:     Jumbo Frame Port Mask Registers
 * SIZE:     32
 * FIELDS:
 *     JUMBO_FM_PORT_MASK Jumbo Frame Port Mask.Ports defined in the Jumbo Frame Port Mask Register can Receive/Transmit Jumbo Frame ( Frame Size over 1522 bytes and less than 9728 bytes).Bit8:0 = Port 8-0 in chip 0.0 : Disable Jumbo Frame Capability,1 : Enable Jumbo Frame Capability,Jumbo Frames can be allowed to be delivered among these Ports. Non-Jumbo Frame will not be constrained by the register. 
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM6300_A0_JUMBO_PORT_MASKr 0x00004004

#define BCM6300_A0_JUMBO_PORT_MASKr_SIZE 4

/*
 * This structure should be used to declare and program JUMBO_PORT_MASK.
 *
 */
typedef union BCM6300_A0_JUMBO_PORT_MASKr_s {
	uint32_t v[1];
	uint32_t jumbo_port_mask[1];
	uint32_t _jumbo_port_mask;
} BCM6300_A0_JUMBO_PORT_MASKr_t;

#define BCM6300_A0_JUMBO_PORT_MASKr_CLR(r) (r).jumbo_port_mask[0] = 0
#define BCM6300_A0_JUMBO_PORT_MASKr_SET(r,d) (r).jumbo_port_mask[0] = d
#define BCM6300_A0_JUMBO_PORT_MASKr_GET(r) (r).jumbo_port_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_JUMBO_PORT_MASKr_JUMBO_FM_PORT_MASKf_GET(r) (((r).jumbo_port_mask[0]) & 0x1ff)
#define BCM6300_A0_JUMBO_PORT_MASKr_JUMBO_FM_PORT_MASKf_SET(r,f) (r).jumbo_port_mask[0]=(((r).jumbo_port_mask[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_JUMBO_PORT_MASKr_RESERVED_Rf_GET(r) ((((r).jumbo_port_mask[0]) >> 9) & 0x7fffff)
#define BCM6300_A0_JUMBO_PORT_MASKr_RESERVED_Rf_SET(r,f) (r).jumbo_port_mask[0]=(((r).jumbo_port_mask[0] & ~((uint32_t)0x7fffff << 9)) | ((((uint32_t)f) & 0x7fffff) << 9))

/*
 * These macros can be used to access JUMBO_PORT_MASK.
 *
 */
#define BCM6300_A0_READ_JUMBO_PORT_MASKr(u,r) cdk_robo_reg_read(u,BCM6300_A0_JUMBO_PORT_MASKr,(r._jumbo_port_mask),4)
#define BCM6300_A0_WRITE_JUMBO_PORT_MASKr(u,r) cdk_robo_reg_write(u,BCM6300_A0_JUMBO_PORT_MASKr,&(r._jumbo_port_mask),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define JUMBO_PORT_MASKr BCM6300_A0_JUMBO_PORT_MASKr
#define JUMBO_PORT_MASKr_SIZE BCM6300_A0_JUMBO_PORT_MASKr_SIZE
typedef BCM6300_A0_JUMBO_PORT_MASKr_t JUMBO_PORT_MASKr_t;
#define JUMBO_PORT_MASKr_CLR BCM6300_A0_JUMBO_PORT_MASKr_CLR
#define JUMBO_PORT_MASKr_SET BCM6300_A0_JUMBO_PORT_MASKr_SET
#define JUMBO_PORT_MASKr_GET BCM6300_A0_JUMBO_PORT_MASKr_GET
#define JUMBO_PORT_MASKr_JUMBO_FM_PORT_MASKf_GET BCM6300_A0_JUMBO_PORT_MASKr_JUMBO_FM_PORT_MASKf_GET
#define JUMBO_PORT_MASKr_JUMBO_FM_PORT_MASKf_SET BCM6300_A0_JUMBO_PORT_MASKr_JUMBO_FM_PORT_MASKf_SET
#define JUMBO_PORT_MASKr_RESERVED_Rf_GET BCM6300_A0_JUMBO_PORT_MASKr_RESERVED_Rf_GET
#define JUMBO_PORT_MASKr_RESERVED_Rf_SET BCM6300_A0_JUMBO_PORT_MASKr_RESERVED_Rf_SET
#define READ_JUMBO_PORT_MASKr BCM6300_A0_READ_JUMBO_PORT_MASKr
#define WRITE_JUMBO_PORT_MASKr BCM6300_A0_WRITE_JUMBO_PORT_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_JUMBO_PORT_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * MEMORY:  L2_ARL
 * BLOCKS:   SYS
 * DESC:     ARL Table
 * SIZE:     64
 * FIELDS:
 *     MACADDR_47_12    Source Address[47:12]
 *     VID_R            VLAN ID
 *     PORTID_R         Rx Port Number
 *     PARTIAL_MCAST_PBMP Partial Mcast PBMP for MARL
 *     CONTROL          ARL control :2\'b00 : Normal ARL function.2\'b01 : Drop if MAC_DA match.(Please also set the "Static" bit)2\'b01 : Drop if MAC_SA match.(Please also set the "Static" bit)2\'b11 : Forward the destination port specified by ARL, Also send a copy to CPU.
 *     PRIORITY_R       QPriority
 *     AGE              Age status
 *     STATIC           Static status
 *     VALID_R          Valid status
 *
 ******************************************************************************/
#define BCM6300_A0_L2_ARLm 0x10180810

#define BCM6300_A0_L2_ARLm_MIN 0
#define BCM6300_A0_L2_ARLm_MAX 4095
#define BCM6300_A0_L2_ARLm_SIZE 8

/*
 * This structure should be used to declare and program L2_ARL.
 *
 */
typedef union BCM6300_A0_L2_ARLm_s {
	uint32_t v[2];
	uint32_t l2_arl[2];
	uint32_t _l2_arl;
} BCM6300_A0_L2_ARLm_t;

#define BCM6300_A0_L2_ARLm_CLR(r) CDK_MEMSET(&((r)._l2_arl), 0, sizeof(BCM6300_A0_L2_ARLm_t))
#define BCM6300_A0_L2_ARLm_SET(r,i,d) (r).l2_arl[i] = d
#define BCM6300_A0_L2_ARLm_GET(r,i) (r).l2_arl[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_L2_ARLm_MACADDR_47_12f_GET(r,a) cdk_field_get((r).l2_arl,2,37,a)
#define BCM6300_A0_L2_ARLm_MACADDR_47_12f_SET(r,a) cdk_field_set((r).l2_arl,2,37,a)
#define BCM6300_A0_L2_ARLm_VID_Rf_GET(r) ((((r).l2_arl[1]) >> 4) & 0xfff)
#define BCM6300_A0_L2_ARLm_VID_Rf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))
#define BCM6300_A0_L2_ARLm_PORTID_Rf_GET(r) ((((r).l2_arl[1]) >> 16) & 0xf)
#define BCM6300_A0_L2_ARLm_PORTID_Rf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM6300_A0_L2_ARLm_PARTIAL_MCAST_PBMPf_GET(r) ((((r).l2_arl[1]) >> 20) & 0xf)
#define BCM6300_A0_L2_ARLm_PARTIAL_MCAST_PBMPf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM6300_A0_L2_ARLm_CONTROLf_GET(r) ((((r).l2_arl[1]) >> 24) & 0x3)
#define BCM6300_A0_L2_ARLm_CONTROLf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0x3 << 24)) | ((((uint32_t)f) & 0x3) << 24))
#define BCM6300_A0_L2_ARLm_PRIORITY_Rf_GET(r) ((((r).l2_arl[1]) >> 26) & 0x7)
#define BCM6300_A0_L2_ARLm_PRIORITY_Rf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0x7 << 26)) | ((((uint32_t)f) & 0x7) << 26))
#define BCM6300_A0_L2_ARLm_AGEf_GET(r) ((((r).l2_arl[1]) >> 29) & 0x1)
#define BCM6300_A0_L2_ARLm_AGEf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM6300_A0_L2_ARLm_STATICf_GET(r) ((((r).l2_arl[1]) >> 30) & 0x1)
#define BCM6300_A0_L2_ARLm_STATICf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM6300_A0_L2_ARLm_VALID_Rf_GET(r) ((((r).l2_arl[1]) >> 31) & 0x1)
#define BCM6300_A0_L2_ARLm_VALID_Rf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access L2_ARL.
 *
 */
#define BCM6300_A0_READ_L2_ARLm(u,i,m) cdk_robo_mem_read(u,BCM6300_A0_L2_ARLm,i,(m),8)
#define BCM6300_A0_WRITE_L2_ARLm(u,i,m) cdk_robo_mem_write(u,BCM6300_A0_L2_ARLm,i,&(m),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_ARLm BCM6300_A0_L2_ARLm
#define L2_ARLm_MIN BCM6300_A0_L2_ARLm_MIN
#define L2_ARLm_MAX BCM6300_A0_L2_ARLm_MAX
#define L2_ARLm_SIZE BCM6300_A0_L2_ARLm_SIZE
typedef BCM6300_A0_L2_ARLm_t L2_ARLm_t;
#define L2_ARLm_CLR BCM6300_A0_L2_ARLm_CLR
#define L2_ARLm_SET BCM6300_A0_L2_ARLm_SET
#define L2_ARLm_GET BCM6300_A0_L2_ARLm_GET
#define L2_ARLm_MACADDR_47_12f_GET BCM6300_A0_L2_ARLm_MACADDR_47_12f_GET
#define L2_ARLm_MACADDR_47_12f_SET BCM6300_A0_L2_ARLm_MACADDR_47_12f_SET
#define L2_ARLm_VID_Rf_GET BCM6300_A0_L2_ARLm_VID_Rf_GET
#define L2_ARLm_VID_Rf_SET BCM6300_A0_L2_ARLm_VID_Rf_SET
#define L2_ARLm_PORTID_Rf_GET BCM6300_A0_L2_ARLm_PORTID_Rf_GET
#define L2_ARLm_PORTID_Rf_SET BCM6300_A0_L2_ARLm_PORTID_Rf_SET
#define L2_ARLm_PARTIAL_MCAST_PBMPf_GET BCM6300_A0_L2_ARLm_PARTIAL_MCAST_PBMPf_GET
#define L2_ARLm_PARTIAL_MCAST_PBMPf_SET BCM6300_A0_L2_ARLm_PARTIAL_MCAST_PBMPf_SET
#define L2_ARLm_CONTROLf_GET BCM6300_A0_L2_ARLm_CONTROLf_GET
#define L2_ARLm_CONTROLf_SET BCM6300_A0_L2_ARLm_CONTROLf_SET
#define L2_ARLm_PRIORITY_Rf_GET BCM6300_A0_L2_ARLm_PRIORITY_Rf_GET
#define L2_ARLm_PRIORITY_Rf_SET BCM6300_A0_L2_ARLm_PRIORITY_Rf_SET
#define L2_ARLm_AGEf_GET BCM6300_A0_L2_ARLm_AGEf_GET
#define L2_ARLm_AGEf_SET BCM6300_A0_L2_ARLm_AGEf_SET
#define L2_ARLm_STATICf_GET BCM6300_A0_L2_ARLm_STATICf_GET
#define L2_ARLm_STATICf_SET BCM6300_A0_L2_ARLm_STATICf_SET
#define L2_ARLm_VALID_Rf_GET BCM6300_A0_L2_ARLm_VALID_Rf_GET
#define L2_ARLm_VALID_Rf_SET BCM6300_A0_L2_ARLm_VALID_Rf_SET
#define READ_L2_ARLm BCM6300_A0_READ_L2_ARLm
#define WRITE_L2_ARLm BCM6300_A0_WRITE_L2_ARLm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_L2_ARLm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  LD_FRM_SA
 * BLOCKS:   SYS
 * DESC:     Loop Detect Frame SA Registers
 * SIZE:     48
 * FIELDS:
 *     LD_SA            Loop Detect Frame SA.
 *
 ******************************************************************************/
#define BCM6300_A0_LD_FRM_SAr 0x00007218

#define BCM6300_A0_LD_FRM_SAr_SIZE 6

/*
 * This structure should be used to declare and program LD_FRM_SA.
 *
 */
typedef union BCM6300_A0_LD_FRM_SAr_s {
	uint32_t v[2];
	uint32_t ld_frm_sa[2];
	uint32_t _ld_frm_sa;
} BCM6300_A0_LD_FRM_SAr_t;

#define BCM6300_A0_LD_FRM_SAr_CLR(r) CDK_MEMSET(&((r)._ld_frm_sa), 0, sizeof(BCM6300_A0_LD_FRM_SAr_t))
#define BCM6300_A0_LD_FRM_SAr_SET(r,i,d) (r).ld_frm_sa[i] = d
#define BCM6300_A0_LD_FRM_SAr_GET(r,i) (r).ld_frm_sa[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_LD_FRM_SAr_LD_SAf_GET(r,a) cdk_field_get((r).ld_frm_sa,0,47,a)
#define BCM6300_A0_LD_FRM_SAr_LD_SAf_SET(r,a) cdk_field_set((r).ld_frm_sa,0,47,a)

/*
 * These macros can be used to access LD_FRM_SA.
 *
 */
#define BCM6300_A0_READ_LD_FRM_SAr(u,r) cdk_robo_reg_read(u,BCM6300_A0_LD_FRM_SAr,(r._ld_frm_sa),6)
#define BCM6300_A0_WRITE_LD_FRM_SAr(u,r) cdk_robo_reg_write(u,BCM6300_A0_LD_FRM_SAr,&(r._ld_frm_sa),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LD_FRM_SAr BCM6300_A0_LD_FRM_SAr
#define LD_FRM_SAr_SIZE BCM6300_A0_LD_FRM_SAr_SIZE
typedef BCM6300_A0_LD_FRM_SAr_t LD_FRM_SAr_t;
#define LD_FRM_SAr_CLR BCM6300_A0_LD_FRM_SAr_CLR
#define LD_FRM_SAr_SET BCM6300_A0_LD_FRM_SAr_SET
#define LD_FRM_SAr_GET BCM6300_A0_LD_FRM_SAr_GET
#define LD_FRM_SAr_LD_SAf_GET BCM6300_A0_LD_FRM_SAr_LD_SAf_GET
#define LD_FRM_SAr_LD_SAf_SET BCM6300_A0_LD_FRM_SAr_LD_SAf_SET
#define READ_LD_FRM_SAr BCM6300_A0_READ_LD_FRM_SAr
#define WRITE_LD_FRM_SAr BCM6300_A0_WRITE_LD_FRM_SAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_LD_FRM_SAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  LED_EN_MAP
 * BLOCKS:   SYS
 * DESC:     LED Enable Map register
 * SIZE:     16
 * FIELDS:
 *     LED_EN_MAP       Per port enable function bit,default value : 8+1 : 9'hFF,		5+2 : 9'h9F
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM6300_A0_LED_EN_MAPr 0x00000016

#define BCM6300_A0_LED_EN_MAPr_SIZE 2

/*
 * This structure should be used to declare and program LED_EN_MAP.
 *
 */
typedef union BCM6300_A0_LED_EN_MAPr_s {
	uint32_t v[1];
	uint32_t led_en_map[1];
	uint32_t _led_en_map;
} BCM6300_A0_LED_EN_MAPr_t;

#define BCM6300_A0_LED_EN_MAPr_CLR(r) (r).led_en_map[0] = 0
#define BCM6300_A0_LED_EN_MAPr_SET(r,d) (r).led_en_map[0] = d
#define BCM6300_A0_LED_EN_MAPr_GET(r) (r).led_en_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_LED_EN_MAPr_LED_EN_MAPf_GET(r) (((r).led_en_map[0]) & 0x1ff)
#define BCM6300_A0_LED_EN_MAPr_LED_EN_MAPf_SET(r,f) (r).led_en_map[0]=(((r).led_en_map[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_LED_EN_MAPr_RESERVED_Rf_GET(r) ((((r).led_en_map[0]) >> 9) & 0x7f)
#define BCM6300_A0_LED_EN_MAPr_RESERVED_Rf_SET(r,f) (r).led_en_map[0]=(((r).led_en_map[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access LED_EN_MAP.
 *
 */
#define BCM6300_A0_READ_LED_EN_MAPr(u,r) cdk_robo_reg_read(u,BCM6300_A0_LED_EN_MAPr,(r._led_en_map),2)
#define BCM6300_A0_WRITE_LED_EN_MAPr(u,r) cdk_robo_reg_write(u,BCM6300_A0_LED_EN_MAPr,&(r._led_en_map),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_EN_MAPr BCM6300_A0_LED_EN_MAPr
#define LED_EN_MAPr_SIZE BCM6300_A0_LED_EN_MAPr_SIZE
typedef BCM6300_A0_LED_EN_MAPr_t LED_EN_MAPr_t;
#define LED_EN_MAPr_CLR BCM6300_A0_LED_EN_MAPr_CLR
#define LED_EN_MAPr_SET BCM6300_A0_LED_EN_MAPr_SET
#define LED_EN_MAPr_GET BCM6300_A0_LED_EN_MAPr_GET
#define LED_EN_MAPr_LED_EN_MAPf_GET BCM6300_A0_LED_EN_MAPr_LED_EN_MAPf_GET
#define LED_EN_MAPr_LED_EN_MAPf_SET BCM6300_A0_LED_EN_MAPr_LED_EN_MAPf_SET
#define LED_EN_MAPr_RESERVED_Rf_GET BCM6300_A0_LED_EN_MAPr_RESERVED_Rf_GET
#define LED_EN_MAPr_RESERVED_Rf_SET BCM6300_A0_LED_EN_MAPr_RESERVED_Rf_SET
#define READ_LED_EN_MAPr BCM6300_A0_READ_LED_EN_MAPr
#define WRITE_LED_EN_MAPr BCM6300_A0_WRITE_LED_EN_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_LED_EN_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  LED_FUNC0_CTL
 * BLOCKS:   SYS
 * DESC:     LED Function 0 control register
 * SIZE:     16
 * FIELDS:
 *     LED_FUNC0        15: LNKL/ACTG 14: LNKG/ACTL 13: LNKL/ACTF 12: LNKF/ACTL 11: 1G/ACT 10: 100M/ACT 9: 10M/ACT 8: DPX/COL 7: LNK/ACT 6: COL 5: ACT 4: SPD1G 3: SPD100M 2: SPD10m 1: DPX 0: LNK default : ledmode=00 : 16'h0088;           ledmode=01 : 16'hC180;           ledmode=10 : 16'h008A;           ledmode=11 : 16'h0602;
 *
 ******************************************************************************/
#define BCM6300_A0_LED_FUNC0_CTLr 0x00000010

#define BCM6300_A0_LED_FUNC0_CTLr_SIZE 2

/*
 * This structure should be used to declare and program LED_FUNC0_CTL.
 *
 */
typedef union BCM6300_A0_LED_FUNC0_CTLr_s {
	uint32_t v[1];
	uint32_t led_func0_ctl[1];
	uint32_t _led_func0_ctl;
} BCM6300_A0_LED_FUNC0_CTLr_t;

#define BCM6300_A0_LED_FUNC0_CTLr_CLR(r) (r).led_func0_ctl[0] = 0
#define BCM6300_A0_LED_FUNC0_CTLr_SET(r,d) (r).led_func0_ctl[0] = d
#define BCM6300_A0_LED_FUNC0_CTLr_GET(r) (r).led_func0_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_LED_FUNC0_CTLr_LED_FUNC0f_GET(r) (((r).led_func0_ctl[0]) & 0xffff)
#define BCM6300_A0_LED_FUNC0_CTLr_LED_FUNC0f_SET(r,f) (r).led_func0_ctl[0]=(((r).led_func0_ctl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LED_FUNC0_CTL.
 *
 */
#define BCM6300_A0_READ_LED_FUNC0_CTLr(u,r) cdk_robo_reg_read(u,BCM6300_A0_LED_FUNC0_CTLr,(r._led_func0_ctl),2)
#define BCM6300_A0_WRITE_LED_FUNC0_CTLr(u,r) cdk_robo_reg_write(u,BCM6300_A0_LED_FUNC0_CTLr,&(r._led_func0_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_FUNC0_CTLr BCM6300_A0_LED_FUNC0_CTLr
#define LED_FUNC0_CTLr_SIZE BCM6300_A0_LED_FUNC0_CTLr_SIZE
typedef BCM6300_A0_LED_FUNC0_CTLr_t LED_FUNC0_CTLr_t;
#define LED_FUNC0_CTLr_CLR BCM6300_A0_LED_FUNC0_CTLr_CLR
#define LED_FUNC0_CTLr_SET BCM6300_A0_LED_FUNC0_CTLr_SET
#define LED_FUNC0_CTLr_GET BCM6300_A0_LED_FUNC0_CTLr_GET
#define LED_FUNC0_CTLr_LED_FUNC0f_GET BCM6300_A0_LED_FUNC0_CTLr_LED_FUNC0f_GET
#define LED_FUNC0_CTLr_LED_FUNC0f_SET BCM6300_A0_LED_FUNC0_CTLr_LED_FUNC0f_SET
#define READ_LED_FUNC0_CTLr BCM6300_A0_READ_LED_FUNC0_CTLr
#define WRITE_LED_FUNC0_CTLr BCM6300_A0_WRITE_LED_FUNC0_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_LED_FUNC0_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  LED_FUNC1_CTL
 * BLOCKS:   SYS
 * DESC:     LED Function 1 control register
 * SIZE:     16
 * FIELDS:
 *     LED_FUNC0        15: LNKL/ACTG 14: LNKG/ACTL 13: LNKL/ACTF 12: LNKF/ACTL 11: 1G/ACT 10: 100M/ACT 9: 10M/ACT 8: DPX/COL 7: LNK/ACT 6: COL 5: ACT 4: SPD1G 3: SPD100M 2: SPD10m 1: DPX 0: LNK default : ledmode=00 : 16'h0098;           ledmode=01 : 16'hC100;           ledmode=10 : 16'h009A;           ledmode=11 : 16'h0E02;
 *
 ******************************************************************************/
#define BCM6300_A0_LED_FUNC1_CTLr 0x00000012

#define BCM6300_A0_LED_FUNC1_CTLr_SIZE 2

/*
 * This structure should be used to declare and program LED_FUNC1_CTL.
 *
 */
typedef union BCM6300_A0_LED_FUNC1_CTLr_s {
	uint32_t v[1];
	uint32_t led_func1_ctl[1];
	uint32_t _led_func1_ctl;
} BCM6300_A0_LED_FUNC1_CTLr_t;

#define BCM6300_A0_LED_FUNC1_CTLr_CLR(r) (r).led_func1_ctl[0] = 0
#define BCM6300_A0_LED_FUNC1_CTLr_SET(r,d) (r).led_func1_ctl[0] = d
#define BCM6300_A0_LED_FUNC1_CTLr_GET(r) (r).led_func1_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_LED_FUNC1_CTLr_LED_FUNC0f_GET(r) (((r).led_func1_ctl[0]) & 0xffff)
#define BCM6300_A0_LED_FUNC1_CTLr_LED_FUNC0f_SET(r,f) (r).led_func1_ctl[0]=(((r).led_func1_ctl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LED_FUNC1_CTL.
 *
 */
#define BCM6300_A0_READ_LED_FUNC1_CTLr(u,r) cdk_robo_reg_read(u,BCM6300_A0_LED_FUNC1_CTLr,(r._led_func1_ctl),2)
#define BCM6300_A0_WRITE_LED_FUNC1_CTLr(u,r) cdk_robo_reg_write(u,BCM6300_A0_LED_FUNC1_CTLr,&(r._led_func1_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_FUNC1_CTLr BCM6300_A0_LED_FUNC1_CTLr
#define LED_FUNC1_CTLr_SIZE BCM6300_A0_LED_FUNC1_CTLr_SIZE
typedef BCM6300_A0_LED_FUNC1_CTLr_t LED_FUNC1_CTLr_t;
#define LED_FUNC1_CTLr_CLR BCM6300_A0_LED_FUNC1_CTLr_CLR
#define LED_FUNC1_CTLr_SET BCM6300_A0_LED_FUNC1_CTLr_SET
#define LED_FUNC1_CTLr_GET BCM6300_A0_LED_FUNC1_CTLr_GET
#define LED_FUNC1_CTLr_LED_FUNC0f_GET BCM6300_A0_LED_FUNC1_CTLr_LED_FUNC0f_GET
#define LED_FUNC1_CTLr_LED_FUNC0f_SET BCM6300_A0_LED_FUNC1_CTLr_LED_FUNC0f_SET
#define READ_LED_FUNC1_CTLr BCM6300_A0_READ_LED_FUNC1_CTLr
#define WRITE_LED_FUNC1_CTLr BCM6300_A0_WRITE_LED_FUNC1_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_LED_FUNC1_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  LED_FUNC_MAP
 * BLOCKS:   SYS
 * DESC:     LED Function Map register
 * SIZE:     16
 * FIELDS:
 *     LED_FUNC_MAP     Per port select function bit. 1: select function 1, 0: select function 0.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM6300_A0_LED_FUNC_MAPr 0x00000014

#define BCM6300_A0_LED_FUNC_MAPr_SIZE 2

/*
 * This structure should be used to declare and program LED_FUNC_MAP.
 *
 */
typedef union BCM6300_A0_LED_FUNC_MAPr_s {
	uint32_t v[1];
	uint32_t led_func_map[1];
	uint32_t _led_func_map;
} BCM6300_A0_LED_FUNC_MAPr_t;

#define BCM6300_A0_LED_FUNC_MAPr_CLR(r) (r).led_func_map[0] = 0
#define BCM6300_A0_LED_FUNC_MAPr_SET(r,d) (r).led_func_map[0] = d
#define BCM6300_A0_LED_FUNC_MAPr_GET(r) (r).led_func_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_LED_FUNC_MAPr_LED_FUNC_MAPf_GET(r) (((r).led_func_map[0]) & 0x1ff)
#define BCM6300_A0_LED_FUNC_MAPr_LED_FUNC_MAPf_SET(r,f) (r).led_func_map[0]=(((r).led_func_map[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_LED_FUNC_MAPr_RESERVED_Rf_GET(r) ((((r).led_func_map[0]) >> 9) & 0x7f)
#define BCM6300_A0_LED_FUNC_MAPr_RESERVED_Rf_SET(r,f) (r).led_func_map[0]=(((r).led_func_map[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access LED_FUNC_MAP.
 *
 */
#define BCM6300_A0_READ_LED_FUNC_MAPr(u,r) cdk_robo_reg_read(u,BCM6300_A0_LED_FUNC_MAPr,(r._led_func_map),2)
#define BCM6300_A0_WRITE_LED_FUNC_MAPr(u,r) cdk_robo_reg_write(u,BCM6300_A0_LED_FUNC_MAPr,&(r._led_func_map),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_FUNC_MAPr BCM6300_A0_LED_FUNC_MAPr
#define LED_FUNC_MAPr_SIZE BCM6300_A0_LED_FUNC_MAPr_SIZE
typedef BCM6300_A0_LED_FUNC_MAPr_t LED_FUNC_MAPr_t;
#define LED_FUNC_MAPr_CLR BCM6300_A0_LED_FUNC_MAPr_CLR
#define LED_FUNC_MAPr_SET BCM6300_A0_LED_FUNC_MAPr_SET
#define LED_FUNC_MAPr_GET BCM6300_A0_LED_FUNC_MAPr_GET
#define LED_FUNC_MAPr_LED_FUNC_MAPf_GET BCM6300_A0_LED_FUNC_MAPr_LED_FUNC_MAPf_GET
#define LED_FUNC_MAPr_LED_FUNC_MAPf_SET BCM6300_A0_LED_FUNC_MAPr_LED_FUNC_MAPf_SET
#define LED_FUNC_MAPr_RESERVED_Rf_GET BCM6300_A0_LED_FUNC_MAPr_RESERVED_Rf_GET
#define LED_FUNC_MAPr_RESERVED_Rf_SET BCM6300_A0_LED_FUNC_MAPr_RESERVED_Rf_SET
#define READ_LED_FUNC_MAPr BCM6300_A0_READ_LED_FUNC_MAPr
#define WRITE_LED_FUNC_MAPr BCM6300_A0_WRITE_LED_FUNC_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_LED_FUNC_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  LED_MODE_MAP_0
 * BLOCKS:   SYS
 * DESC:     LED Mode map 0 register
 * SIZE:     16
 * FIELDS:
 *     LED_MODE_MAP     Combine with LED_MODEMAP1 to decide per port LED output,Mode[1:0]00 : OFF, 01 : ON,10 : BLINK,11 : AUTO
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM6300_A0_LED_MODE_MAP_0r 0x00000018

#define BCM6300_A0_LED_MODE_MAP_0r_SIZE 2

/*
 * This structure should be used to declare and program LED_MODE_MAP_0.
 *
 */
typedef union BCM6300_A0_LED_MODE_MAP_0r_s {
	uint32_t v[1];
	uint32_t led_mode_map_0[1];
	uint32_t _led_mode_map_0;
} BCM6300_A0_LED_MODE_MAP_0r_t;

#define BCM6300_A0_LED_MODE_MAP_0r_CLR(r) (r).led_mode_map_0[0] = 0
#define BCM6300_A0_LED_MODE_MAP_0r_SET(r,d) (r).led_mode_map_0[0] = d
#define BCM6300_A0_LED_MODE_MAP_0r_GET(r) (r).led_mode_map_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_LED_MODE_MAP_0r_LED_MODE_MAPf_GET(r) (((r).led_mode_map_0[0]) & 0x1ff)
#define BCM6300_A0_LED_MODE_MAP_0r_LED_MODE_MAPf_SET(r,f) (r).led_mode_map_0[0]=(((r).led_mode_map_0[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_LED_MODE_MAP_0r_RESERVED_Rf_GET(r) ((((r).led_mode_map_0[0]) >> 9) & 0x7f)
#define BCM6300_A0_LED_MODE_MAP_0r_RESERVED_Rf_SET(r,f) (r).led_mode_map_0[0]=(((r).led_mode_map_0[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access LED_MODE_MAP_0.
 *
 */
#define BCM6300_A0_READ_LED_MODE_MAP_0r(u,r) cdk_robo_reg_read(u,BCM6300_A0_LED_MODE_MAP_0r,(r._led_mode_map_0),2)
#define BCM6300_A0_WRITE_LED_MODE_MAP_0r(u,r) cdk_robo_reg_write(u,BCM6300_A0_LED_MODE_MAP_0r,&(r._led_mode_map_0),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_MODE_MAP_0r BCM6300_A0_LED_MODE_MAP_0r
#define LED_MODE_MAP_0r_SIZE BCM6300_A0_LED_MODE_MAP_0r_SIZE
typedef BCM6300_A0_LED_MODE_MAP_0r_t LED_MODE_MAP_0r_t;
#define LED_MODE_MAP_0r_CLR BCM6300_A0_LED_MODE_MAP_0r_CLR
#define LED_MODE_MAP_0r_SET BCM6300_A0_LED_MODE_MAP_0r_SET
#define LED_MODE_MAP_0r_GET BCM6300_A0_LED_MODE_MAP_0r_GET
#define LED_MODE_MAP_0r_LED_MODE_MAPf_GET BCM6300_A0_LED_MODE_MAP_0r_LED_MODE_MAPf_GET
#define LED_MODE_MAP_0r_LED_MODE_MAPf_SET BCM6300_A0_LED_MODE_MAP_0r_LED_MODE_MAPf_SET
#define LED_MODE_MAP_0r_RESERVED_Rf_GET BCM6300_A0_LED_MODE_MAP_0r_RESERVED_Rf_GET
#define LED_MODE_MAP_0r_RESERVED_Rf_SET BCM6300_A0_LED_MODE_MAP_0r_RESERVED_Rf_SET
#define READ_LED_MODE_MAP_0r BCM6300_A0_READ_LED_MODE_MAP_0r
#define WRITE_LED_MODE_MAP_0r BCM6300_A0_WRITE_LED_MODE_MAP_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_LED_MODE_MAP_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  LED_MODE_MAP_1
 * BLOCKS:   SYS
 * DESC:     LED Mode map 1 register
 * SIZE:     16
 * FIELDS:
 *     LED_MODE_MAP     Combine with LED_MODEMAP1 to decide per port LED output,Mode[1:0]00 : OFF, 01 : ON,10 : BLINK,11 : AUTO
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM6300_A0_LED_MODE_MAP_1r 0x0000001a

#define BCM6300_A0_LED_MODE_MAP_1r_SIZE 2

/*
 * This structure should be used to declare and program LED_MODE_MAP_1.
 *
 */
typedef union BCM6300_A0_LED_MODE_MAP_1r_s {
	uint32_t v[1];
	uint32_t led_mode_map_1[1];
	uint32_t _led_mode_map_1;
} BCM6300_A0_LED_MODE_MAP_1r_t;

#define BCM6300_A0_LED_MODE_MAP_1r_CLR(r) (r).led_mode_map_1[0] = 0
#define BCM6300_A0_LED_MODE_MAP_1r_SET(r,d) (r).led_mode_map_1[0] = d
#define BCM6300_A0_LED_MODE_MAP_1r_GET(r) (r).led_mode_map_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_LED_MODE_MAP_1r_LED_MODE_MAPf_GET(r) (((r).led_mode_map_1[0]) & 0x1ff)
#define BCM6300_A0_LED_MODE_MAP_1r_LED_MODE_MAPf_SET(r,f) (r).led_mode_map_1[0]=(((r).led_mode_map_1[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_LED_MODE_MAP_1r_RESERVED_Rf_GET(r) ((((r).led_mode_map_1[0]) >> 9) & 0x7f)
#define BCM6300_A0_LED_MODE_MAP_1r_RESERVED_Rf_SET(r,f) (r).led_mode_map_1[0]=(((r).led_mode_map_1[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access LED_MODE_MAP_1.
 *
 */
#define BCM6300_A0_READ_LED_MODE_MAP_1r(u,r) cdk_robo_reg_read(u,BCM6300_A0_LED_MODE_MAP_1r,(r._led_mode_map_1),2)
#define BCM6300_A0_WRITE_LED_MODE_MAP_1r(u,r) cdk_robo_reg_write(u,BCM6300_A0_LED_MODE_MAP_1r,&(r._led_mode_map_1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_MODE_MAP_1r BCM6300_A0_LED_MODE_MAP_1r
#define LED_MODE_MAP_1r_SIZE BCM6300_A0_LED_MODE_MAP_1r_SIZE
typedef BCM6300_A0_LED_MODE_MAP_1r_t LED_MODE_MAP_1r_t;
#define LED_MODE_MAP_1r_CLR BCM6300_A0_LED_MODE_MAP_1r_CLR
#define LED_MODE_MAP_1r_SET BCM6300_A0_LED_MODE_MAP_1r_SET
#define LED_MODE_MAP_1r_GET BCM6300_A0_LED_MODE_MAP_1r_GET
#define LED_MODE_MAP_1r_LED_MODE_MAPf_GET BCM6300_A0_LED_MODE_MAP_1r_LED_MODE_MAPf_GET
#define LED_MODE_MAP_1r_LED_MODE_MAPf_SET BCM6300_A0_LED_MODE_MAP_1r_LED_MODE_MAPf_SET
#define LED_MODE_MAP_1r_RESERVED_Rf_GET BCM6300_A0_LED_MODE_MAP_1r_RESERVED_Rf_GET
#define LED_MODE_MAP_1r_RESERVED_Rf_SET BCM6300_A0_LED_MODE_MAP_1r_RESERVED_Rf_SET
#define READ_LED_MODE_MAP_1r BCM6300_A0_READ_LED_MODE_MAP_1r
#define WRITE_LED_MODE_MAP_1r BCM6300_A0_WRITE_LED_MODE_MAP_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_LED_MODE_MAP_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  LED_PORTMAP
 * BLOCKS:   SYS
 * DESC:     LED Waming Portmap Registers
 * SIZE:     16
 * FIELDS:
 *     LED_WARNING_PORTMAP 
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_LED_PORTMAPr 0x00007204

#define BCM6300_A0_LED_PORTMAPr_SIZE 2

/*
 * This structure should be used to declare and program LED_PORTMAP.
 *
 */
typedef union BCM6300_A0_LED_PORTMAPr_s {
	uint32_t v[1];
	uint32_t led_portmap[1];
	uint32_t _led_portmap;
} BCM6300_A0_LED_PORTMAPr_t;

#define BCM6300_A0_LED_PORTMAPr_CLR(r) (r).led_portmap[0] = 0
#define BCM6300_A0_LED_PORTMAPr_SET(r,d) (r).led_portmap[0] = d
#define BCM6300_A0_LED_PORTMAPr_GET(r) (r).led_portmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_LED_PORTMAPr_LED_WARNING_PORTMAPf_GET(r) (((r).led_portmap[0]) & 0xff)
#define BCM6300_A0_LED_PORTMAPr_LED_WARNING_PORTMAPf_SET(r,f) (r).led_portmap[0]=(((r).led_portmap[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM6300_A0_LED_PORTMAPr_RESERVED_Rf_GET(r) ((((r).led_portmap[0]) >> 8) & 0xff)
#define BCM6300_A0_LED_PORTMAPr_RESERVED_Rf_SET(r,f) (r).led_portmap[0]=(((r).led_portmap[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access LED_PORTMAP.
 *
 */
#define BCM6300_A0_READ_LED_PORTMAPr(u,r) cdk_robo_reg_read(u,BCM6300_A0_LED_PORTMAPr,(r._led_portmap),2)
#define BCM6300_A0_WRITE_LED_PORTMAPr(u,r) cdk_robo_reg_write(u,BCM6300_A0_LED_PORTMAPr,&(r._led_portmap),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_PORTMAPr BCM6300_A0_LED_PORTMAPr
#define LED_PORTMAPr_SIZE BCM6300_A0_LED_PORTMAPr_SIZE
typedef BCM6300_A0_LED_PORTMAPr_t LED_PORTMAPr_t;
#define LED_PORTMAPr_CLR BCM6300_A0_LED_PORTMAPr_CLR
#define LED_PORTMAPr_SET BCM6300_A0_LED_PORTMAPr_SET
#define LED_PORTMAPr_GET BCM6300_A0_LED_PORTMAPr_GET
#define LED_PORTMAPr_LED_WARNING_PORTMAPf_GET BCM6300_A0_LED_PORTMAPr_LED_WARNING_PORTMAPf_GET
#define LED_PORTMAPr_LED_WARNING_PORTMAPf_SET BCM6300_A0_LED_PORTMAPr_LED_WARNING_PORTMAPf_SET
#define LED_PORTMAPr_RESERVED_Rf_GET BCM6300_A0_LED_PORTMAPr_RESERVED_Rf_GET
#define LED_PORTMAPr_RESERVED_Rf_SET BCM6300_A0_LED_PORTMAPr_RESERVED_Rf_SET
#define READ_LED_PORTMAPr BCM6300_A0_READ_LED_PORTMAPr
#define WRITE_LED_PORTMAPr BCM6300_A0_WRITE_LED_PORTMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_LED_PORTMAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  LED_REFLSH_CTL
 * BLOCKS:   SYS
 * DESC:     LED ReFlash control register
 * SIZE:     8
 * FIELDS:
 *     LED_RFS_STOP     LED reflsh control register.reflsh time = (N+1)*10ns000 : no reflsh;001 : 20ms/25Hz;010 : 30ms/16Hz;011 : 40ms/12Hz;100 : 50ms/10Hz;101 : 60ms/8Hz;110 : 70ms/7Hz;111 : 80ms/6Hz.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM6300_A0_LED_REFLSH_CTLr 0x0000000f

#define BCM6300_A0_LED_REFLSH_CTLr_SIZE 1

/*
 * This structure should be used to declare and program LED_REFLSH_CTL.
 *
 */
typedef union BCM6300_A0_LED_REFLSH_CTLr_s {
	uint32_t v[1];
	uint32_t led_reflsh_ctl[1];
	uint32_t _led_reflsh_ctl;
} BCM6300_A0_LED_REFLSH_CTLr_t;

#define BCM6300_A0_LED_REFLSH_CTLr_CLR(r) (r).led_reflsh_ctl[0] = 0
#define BCM6300_A0_LED_REFLSH_CTLr_SET(r,d) (r).led_reflsh_ctl[0] = d
#define BCM6300_A0_LED_REFLSH_CTLr_GET(r) (r).led_reflsh_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_LED_REFLSH_CTLr_LED_RFS_STOPf_GET(r) (((r).led_reflsh_ctl[0]) & 0x7)
#define BCM6300_A0_LED_REFLSH_CTLr_LED_RFS_STOPf_SET(r,f) (r).led_reflsh_ctl[0]=(((r).led_reflsh_ctl[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM6300_A0_LED_REFLSH_CTLr_RESERVED_Rf_GET(r) ((((r).led_reflsh_ctl[0]) >> 3) & 0x1f)
#define BCM6300_A0_LED_REFLSH_CTLr_RESERVED_Rf_SET(r,f) (r).led_reflsh_ctl[0]=(((r).led_reflsh_ctl[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3))

/*
 * These macros can be used to access LED_REFLSH_CTL.
 *
 */
#define BCM6300_A0_READ_LED_REFLSH_CTLr(u,r) cdk_robo_reg_read(u,BCM6300_A0_LED_REFLSH_CTLr,(r._led_reflsh_ctl),1)
#define BCM6300_A0_WRITE_LED_REFLSH_CTLr(u,r) cdk_robo_reg_write(u,BCM6300_A0_LED_REFLSH_CTLr,&(r._led_reflsh_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_REFLSH_CTLr BCM6300_A0_LED_REFLSH_CTLr
#define LED_REFLSH_CTLr_SIZE BCM6300_A0_LED_REFLSH_CTLr_SIZE
typedef BCM6300_A0_LED_REFLSH_CTLr_t LED_REFLSH_CTLr_t;
#define LED_REFLSH_CTLr_CLR BCM6300_A0_LED_REFLSH_CTLr_CLR
#define LED_REFLSH_CTLr_SET BCM6300_A0_LED_REFLSH_CTLr_SET
#define LED_REFLSH_CTLr_GET BCM6300_A0_LED_REFLSH_CTLr_GET
#define LED_REFLSH_CTLr_LED_RFS_STOPf_GET BCM6300_A0_LED_REFLSH_CTLr_LED_RFS_STOPf_GET
#define LED_REFLSH_CTLr_LED_RFS_STOPf_SET BCM6300_A0_LED_REFLSH_CTLr_LED_RFS_STOPf_SET
#define LED_REFLSH_CTLr_RESERVED_Rf_GET BCM6300_A0_LED_REFLSH_CTLr_RESERVED_Rf_GET
#define LED_REFLSH_CTLr_RESERVED_Rf_SET BCM6300_A0_LED_REFLSH_CTLr_RESERVED_Rf_SET
#define READ_LED_REFLSH_CTLr BCM6300_A0_READ_LED_REFLSH_CTLr
#define WRITE_LED_REFLSH_CTLr BCM6300_A0_WRITE_LED_REFLSH_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_LED_REFLSH_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  LNKSTS
 * BLOCKS:   SYS
 * DESC:     LinkStatus Summary Register
 * SIZE:     16
 * FIELDS:
 *     LNK_STS          Link Status.9bit field indicating the Link Status for each 10/100/1000 BASE-T port, (bits 0-7 = 10/100/1000 BASE-T, bit 8 IMP port ).0 = Link Fail1 = Link Pass
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_LNKSTSr 0x00000100

#define BCM6300_A0_LNKSTSr_SIZE 2

/*
 * This structure should be used to declare and program LNKSTS.
 *
 */
typedef union BCM6300_A0_LNKSTSr_s {
	uint32_t v[1];
	uint32_t lnksts[1];
	uint32_t _lnksts;
} BCM6300_A0_LNKSTSr_t;

#define BCM6300_A0_LNKSTSr_CLR(r) (r).lnksts[0] = 0
#define BCM6300_A0_LNKSTSr_SET(r,d) (r).lnksts[0] = d
#define BCM6300_A0_LNKSTSr_GET(r) (r).lnksts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_LNKSTSr_LNK_STSf_GET(r) (((r).lnksts[0]) & 0x1ff)
#define BCM6300_A0_LNKSTSr_LNK_STSf_SET(r,f) (r).lnksts[0]=(((r).lnksts[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_LNKSTSr_RESERVED_Rf_GET(r) ((((r).lnksts[0]) >> 9) & 0x7f)
#define BCM6300_A0_LNKSTSr_RESERVED_Rf_SET(r,f) (r).lnksts[0]=(((r).lnksts[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access LNKSTS.
 *
 */
#define BCM6300_A0_READ_LNKSTSr(u,r) cdk_robo_reg_read(u,BCM6300_A0_LNKSTSr,(r._lnksts),2)
#define BCM6300_A0_WRITE_LNKSTSr(u,r) cdk_robo_reg_write(u,BCM6300_A0_LNKSTSr,&(r._lnksts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LNKSTSr BCM6300_A0_LNKSTSr
#define LNKSTSr_SIZE BCM6300_A0_LNKSTSr_SIZE
typedef BCM6300_A0_LNKSTSr_t LNKSTSr_t;
#define LNKSTSr_CLR BCM6300_A0_LNKSTSr_CLR
#define LNKSTSr_SET BCM6300_A0_LNKSTSr_SET
#define LNKSTSr_GET BCM6300_A0_LNKSTSr_GET
#define LNKSTSr_LNK_STSf_GET BCM6300_A0_LNKSTSr_LNK_STSf_GET
#define LNKSTSr_LNK_STSf_SET BCM6300_A0_LNKSTSr_LNK_STSf_SET
#define LNKSTSr_RESERVED_Rf_GET BCM6300_A0_LNKSTSr_RESERVED_Rf_GET
#define LNKSTSr_RESERVED_Rf_SET BCM6300_A0_LNKSTSr_RESERVED_Rf_SET
#define READ_LNKSTSr BCM6300_A0_READ_LNKSTSr
#define WRITE_LNKSTSr BCM6300_A0_WRITE_LNKSTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_LNKSTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  LNKSTSCHG
 * BLOCKS:   SYS
 * DESC:     Link Status Change Register
 * SIZE:     16
 * FIELDS:
 *     LNK_STS_CHG      Link Status Change.9 bit field indicating that the Link Status for an individual 10/100/1000BASE-T port had changed since the last read operation (bits 0-23 = 10/100/1000BASE- T ports, bit 8 = IMP port). Upon change of link status, a bit remains set until cleared by a read operation.0 = Link Status Constant,1 = Link Status Change.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_LNKSTSCHGr 0x00000102

#define BCM6300_A0_LNKSTSCHGr_SIZE 2

/*
 * This structure should be used to declare and program LNKSTSCHG.
 *
 */
typedef union BCM6300_A0_LNKSTSCHGr_s {
	uint32_t v[1];
	uint32_t lnkstschg[1];
	uint32_t _lnkstschg;
} BCM6300_A0_LNKSTSCHGr_t;

#define BCM6300_A0_LNKSTSCHGr_CLR(r) (r).lnkstschg[0] = 0
#define BCM6300_A0_LNKSTSCHGr_SET(r,d) (r).lnkstschg[0] = d
#define BCM6300_A0_LNKSTSCHGr_GET(r) (r).lnkstschg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_LNKSTSCHGr_LNK_STS_CHGf_GET(r) (((r).lnkstschg[0]) & 0x1ff)
#define BCM6300_A0_LNKSTSCHGr_LNK_STS_CHGf_SET(r,f) (r).lnkstschg[0]=(((r).lnkstschg[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_LNKSTSCHGr_RESERVED_Rf_GET(r) ((((r).lnkstschg[0]) >> 9) & 0x7f)
#define BCM6300_A0_LNKSTSCHGr_RESERVED_Rf_SET(r,f) (r).lnkstschg[0]=(((r).lnkstschg[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access LNKSTSCHG.
 *
 */
#define BCM6300_A0_READ_LNKSTSCHGr(u,r) cdk_robo_reg_read(u,BCM6300_A0_LNKSTSCHGr,(r._lnkstschg),2)
#define BCM6300_A0_WRITE_LNKSTSCHGr(u,r) cdk_robo_reg_write(u,BCM6300_A0_LNKSTSCHGr,&(r._lnkstschg),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LNKSTSCHGr BCM6300_A0_LNKSTSCHGr
#define LNKSTSCHGr_SIZE BCM6300_A0_LNKSTSCHGr_SIZE
typedef BCM6300_A0_LNKSTSCHGr_t LNKSTSCHGr_t;
#define LNKSTSCHGr_CLR BCM6300_A0_LNKSTSCHGr_CLR
#define LNKSTSCHGr_SET BCM6300_A0_LNKSTSCHGr_SET
#define LNKSTSCHGr_GET BCM6300_A0_LNKSTSCHGr_GET
#define LNKSTSCHGr_LNK_STS_CHGf_GET BCM6300_A0_LNKSTSCHGr_LNK_STS_CHGf_GET
#define LNKSTSCHGr_LNK_STS_CHGf_SET BCM6300_A0_LNKSTSCHGr_LNK_STS_CHGf_SET
#define LNKSTSCHGr_RESERVED_Rf_GET BCM6300_A0_LNKSTSCHGr_RESERVED_Rf_GET
#define LNKSTSCHGr_RESERVED_Rf_SET BCM6300_A0_LNKSTSCHGr_RESERVED_Rf_SET
#define READ_LNKSTSCHGr BCM6300_A0_READ_LNKSTSCHGr
#define WRITE_LNKSTSCHGr BCM6300_A0_WRITE_LNKSTSCHGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_LNKSTSCHGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  LPDET_CFG
 * BLOCKS:   SYS
 * DESC:     Loop Detection Configuration Registers
 * SIZE:     16
 * FIELDS:
 *     DFQ_SEL          
 *     OV_PAUSE_ON      
 *     LED_RST_CTL      
 *     EN_LP_MII        
 *     EN_LPDET         
 *     EN_TXPASS        
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_LPDET_CFGr 0x00007200

#define BCM6300_A0_LPDET_CFGr_SIZE 2

/*
 * This structure should be used to declare and program LPDET_CFG.
 *
 */
typedef union BCM6300_A0_LPDET_CFGr_s {
	uint32_t v[1];
	uint32_t lpdet_cfg[1];
	uint32_t _lpdet_cfg;
} BCM6300_A0_LPDET_CFGr_t;

#define BCM6300_A0_LPDET_CFGr_CLR(r) (r).lpdet_cfg[0] = 0
#define BCM6300_A0_LPDET_CFGr_SET(r,d) (r).lpdet_cfg[0] = d
#define BCM6300_A0_LPDET_CFGr_GET(r) (r).lpdet_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_LPDET_CFGr_DFQ_SELf_GET(r) (((r).lpdet_cfg[0]) & 0x3)
#define BCM6300_A0_LPDET_CFGr_DFQ_SELf_SET(r,f) (r).lpdet_cfg[0]=(((r).lpdet_cfg[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM6300_A0_LPDET_CFGr_OV_PAUSE_ONf_GET(r) ((((r).lpdet_cfg[0]) >> 2) & 0x1)
#define BCM6300_A0_LPDET_CFGr_OV_PAUSE_ONf_SET(r,f) (r).lpdet_cfg[0]=(((r).lpdet_cfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM6300_A0_LPDET_CFGr_LED_RST_CTLf_GET(r) ((((r).lpdet_cfg[0]) >> 3) & 0xff)
#define BCM6300_A0_LPDET_CFGr_LED_RST_CTLf_SET(r,f) (r).lpdet_cfg[0]=(((r).lpdet_cfg[0] & ~((uint32_t)0xff << 3)) | ((((uint32_t)f) & 0xff) << 3))
#define BCM6300_A0_LPDET_CFGr_EN_LP_MIIf_GET(r) ((((r).lpdet_cfg[0]) >> 11) & 0x1)
#define BCM6300_A0_LPDET_CFGr_EN_LP_MIIf_SET(r,f) (r).lpdet_cfg[0]=(((r).lpdet_cfg[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM6300_A0_LPDET_CFGr_EN_LPDETf_GET(r) ((((r).lpdet_cfg[0]) >> 12) & 0x1)
#define BCM6300_A0_LPDET_CFGr_EN_LPDETf_SET(r,f) (r).lpdet_cfg[0]=(((r).lpdet_cfg[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM6300_A0_LPDET_CFGr_EN_TXPASSf_GET(r) ((((r).lpdet_cfg[0]) >> 13) & 0x1)
#define BCM6300_A0_LPDET_CFGr_EN_TXPASSf_SET(r,f) (r).lpdet_cfg[0]=(((r).lpdet_cfg[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM6300_A0_LPDET_CFGr_RESERVED_Rf_GET(r) ((((r).lpdet_cfg[0]) >> 14) & 0x3)
#define BCM6300_A0_LPDET_CFGr_RESERVED_Rf_SET(r,f) (r).lpdet_cfg[0]=(((r).lpdet_cfg[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access LPDET_CFG.
 *
 */
#define BCM6300_A0_READ_LPDET_CFGr(u,r) cdk_robo_reg_read(u,BCM6300_A0_LPDET_CFGr,(r._lpdet_cfg),2)
#define BCM6300_A0_WRITE_LPDET_CFGr(u,r) cdk_robo_reg_write(u,BCM6300_A0_LPDET_CFGr,&(r._lpdet_cfg),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LPDET_CFGr BCM6300_A0_LPDET_CFGr
#define LPDET_CFGr_SIZE BCM6300_A0_LPDET_CFGr_SIZE
typedef BCM6300_A0_LPDET_CFGr_t LPDET_CFGr_t;
#define LPDET_CFGr_CLR BCM6300_A0_LPDET_CFGr_CLR
#define LPDET_CFGr_SET BCM6300_A0_LPDET_CFGr_SET
#define LPDET_CFGr_GET BCM6300_A0_LPDET_CFGr_GET
#define LPDET_CFGr_DFQ_SELf_GET BCM6300_A0_LPDET_CFGr_DFQ_SELf_GET
#define LPDET_CFGr_DFQ_SELf_SET BCM6300_A0_LPDET_CFGr_DFQ_SELf_SET
#define LPDET_CFGr_OV_PAUSE_ONf_GET BCM6300_A0_LPDET_CFGr_OV_PAUSE_ONf_GET
#define LPDET_CFGr_OV_PAUSE_ONf_SET BCM6300_A0_LPDET_CFGr_OV_PAUSE_ONf_SET
#define LPDET_CFGr_LED_RST_CTLf_GET BCM6300_A0_LPDET_CFGr_LED_RST_CTLf_GET
#define LPDET_CFGr_LED_RST_CTLf_SET BCM6300_A0_LPDET_CFGr_LED_RST_CTLf_SET
#define LPDET_CFGr_EN_LP_MIIf_GET BCM6300_A0_LPDET_CFGr_EN_LP_MIIf_GET
#define LPDET_CFGr_EN_LP_MIIf_SET BCM6300_A0_LPDET_CFGr_EN_LP_MIIf_SET
#define LPDET_CFGr_EN_LPDETf_GET BCM6300_A0_LPDET_CFGr_EN_LPDETf_GET
#define LPDET_CFGr_EN_LPDETf_SET BCM6300_A0_LPDET_CFGr_EN_LPDETf_SET
#define LPDET_CFGr_EN_TXPASSf_GET BCM6300_A0_LPDET_CFGr_EN_TXPASSf_GET
#define LPDET_CFGr_EN_TXPASSf_SET BCM6300_A0_LPDET_CFGr_EN_TXPASSf_SET
#define LPDET_CFGr_RESERVED_Rf_GET BCM6300_A0_LPDET_CFGr_RESERVED_Rf_GET
#define LPDET_CFGr_RESERVED_Rf_SET BCM6300_A0_LPDET_CFGr_RESERVED_Rf_SET
#define READ_LPDET_CFGr BCM6300_A0_READ_LPDET_CFGr
#define WRITE_LPDET_CFGr BCM6300_A0_WRITE_LPDET_CFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_LPDET_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  LPNXP
 * BLOCKS:   GPIC0
 * DESC:     Link Partner next Page Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_LPNXPr 0x00001010

#define BCM6300_A0_LPNXPr_SIZE 2

/*
 * This structure should be used to declare and program LPNXP.
 *
 */
typedef union BCM6300_A0_LPNXPr_s {
	uint32_t v[1];
	uint32_t lpnxp[1];
	uint32_t _lpnxp;
} BCM6300_A0_LPNXPr_t;

#define BCM6300_A0_LPNXPr_CLR(r) (r).lpnxp[0] = 0
#define BCM6300_A0_LPNXPr_SET(r,d) (r).lpnxp[0] = d
#define BCM6300_A0_LPNXPr_GET(r) (r).lpnxp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_LPNXPr_RESERVED_Rf_GET(r) (((r).lpnxp[0]) & 0xffff)
#define BCM6300_A0_LPNXPr_RESERVED_Rf_SET(r,f) (r).lpnxp[0]=(((r).lpnxp[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LPNXP.
 *
 */
#define BCM6300_A0_READ_LPNXPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_LPNXPr,(r._lpnxp),2)
#define BCM6300_A0_WRITE_LPNXPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_LPNXPr,&(r._lpnxp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LPNXPr BCM6300_A0_LPNXPr
#define LPNXPr_SIZE BCM6300_A0_LPNXPr_SIZE
typedef BCM6300_A0_LPNXPr_t LPNXPr_t;
#define LPNXPr_CLR BCM6300_A0_LPNXPr_CLR
#define LPNXPr_SET BCM6300_A0_LPNXPr_SET
#define LPNXPr_GET BCM6300_A0_LPNXPr_GET
#define LPNXPr_RESERVED_Rf_GET BCM6300_A0_LPNXPr_RESERVED_Rf_GET
#define LPNXPr_RESERVED_Rf_SET BCM6300_A0_LPNXPr_RESERVED_Rf_SET
#define READ_LPNXPr BCM6300_A0_READ_LPNXPr
#define WRITE_LPNXPr BCM6300_A0_WRITE_LPNXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_LPNXPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  LSA_PORT
 * BLOCKS:   GPIC CPIC
 * DESC:     Last Source Address Port X
 * SIZE:     48
 * FIELDS:
 *     LST_ADDR         Source Address Change.8 bit field indicating that the value loaded into the Last Source Address register was not the same 48-bit value as the previous value. A 1 value indicates a dedicated link degment, a value greater than 1 generally indicates a mixing (repeatered) segment. Upon change of SA, a bit remains set until cleared by a read operation.0 = Source Address Constant1 = Source Address Changed
 *
 ******************************************************************************/
#define BCM6300_A0_LSA_PORTr 0x00000110

#define BCM6300_A0_LSA_PORTr_SIZE 6

/*
 * This structure should be used to declare and program LSA_PORT.
 *
 */
typedef union BCM6300_A0_LSA_PORTr_s {
	uint32_t v[2];
	uint32_t lsa_port[2];
	uint32_t _lsa_port;
} BCM6300_A0_LSA_PORTr_t;

#define BCM6300_A0_LSA_PORTr_CLR(r) CDK_MEMSET(&((r)._lsa_port), 0, sizeof(BCM6300_A0_LSA_PORTr_t))
#define BCM6300_A0_LSA_PORTr_SET(r,i,d) (r).lsa_port[i] = d
#define BCM6300_A0_LSA_PORTr_GET(r,i) (r).lsa_port[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_LSA_PORTr_LST_ADDRf_GET(r,a) cdk_field_get((r).lsa_port,0,47,a)
#define BCM6300_A0_LSA_PORTr_LST_ADDRf_SET(r,a) cdk_field_set((r).lsa_port,0,47,a)

/*
 * These macros can be used to access LSA_PORT.
 *
 */
#define BCM6300_A0_READ_LSA_PORTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_LSA_PORTr,(r._lsa_port),6)
#define BCM6300_A0_WRITE_LSA_PORTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_LSA_PORTr,&(r._lsa_port),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LSA_PORTr BCM6300_A0_LSA_PORTr
#define LSA_PORTr_SIZE BCM6300_A0_LSA_PORTr_SIZE
typedef BCM6300_A0_LSA_PORTr_t LSA_PORTr_t;
#define LSA_PORTr_CLR BCM6300_A0_LSA_PORTr_CLR
#define LSA_PORTr_SET BCM6300_A0_LSA_PORTr_SET
#define LSA_PORTr_GET BCM6300_A0_LSA_PORTr_GET
#define LSA_PORTr_LST_ADDRf_GET BCM6300_A0_LSA_PORTr_LST_ADDRf_GET
#define LSA_PORTr_LST_ADDRf_SET BCM6300_A0_LSA_PORTr_LST_ADDRf_SET
#define READ_LSA_PORTr BCM6300_A0_READ_LSA_PORTr
#define WRITE_LSA_PORTr BCM6300_A0_WRITE_LSA_PORTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_LSA_PORTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  MARLA_FWD_ENTRY0
 * BLOCKS:   SYS
 * DESC:     ARL FWD Entry 0 Register
 * SIZE:     16
 * FIELDS:
 *     FWD_PRT_MAP_0    Multicast Group Forward Portmap.If(MACADDR0[47] ==1) FWD_PRT_MAP[7:0]
 *     ARL_CON          arl control bit for arl cintrol mode enhancement.
 *     ARL_PRI          
 *     FWD_PRT_MAP_1    Multicast Group Forward Portmap.If(MACADDR0[47] ==1) FWD_PRT_MAP[8]
 *     ARL_STATIC       Static.Set to indicate that the entry is controlled by the external management processor, and automatic learning and aging of the entry will not take place.When cleared, the internal learning and aging process will control the validity of the entry.
 *     ARL_VALID        Valid.Set to indicate that a valid MAC address is stored in the MACADDR0 field, and that the entry has not aged out or been freed by the management processor.Reset when an entry is empty, the address has been aged out by the internal aging process, or the external management processor has invalidated the entry. Automatic learning will take place if an address location is not valid and has not been marked as static.
 *
 ******************************************************************************/
#define BCM6300_A0_MARLA_FWD_ENTRY0r 0x00000518

#define BCM6300_A0_MARLA_FWD_ENTRY0r_SIZE 2

/*
 * This structure should be used to declare and program MARLA_FWD_ENTRY0.
 *
 */
typedef union BCM6300_A0_MARLA_FWD_ENTRY0r_s {
	uint32_t v[1];
	uint32_t marla_fwd_entry0[1];
	uint32_t _marla_fwd_entry0;
} BCM6300_A0_MARLA_FWD_ENTRY0r_t;

#define BCM6300_A0_MARLA_FWD_ENTRY0r_CLR(r) (r).marla_fwd_entry0[0] = 0
#define BCM6300_A0_MARLA_FWD_ENTRY0r_SET(r,d) (r).marla_fwd_entry0[0] = d
#define BCM6300_A0_MARLA_FWD_ENTRY0r_GET(r) (r).marla_fwd_entry0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_MARLA_FWD_ENTRY0r_FWD_PRT_MAP_0f_GET(r) (((r).marla_fwd_entry0[0]) & 0xff)
#define BCM6300_A0_MARLA_FWD_ENTRY0r_FWD_PRT_MAP_0f_SET(r,f) (r).marla_fwd_entry0[0]=(((r).marla_fwd_entry0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM6300_A0_MARLA_FWD_ENTRY0r_ARL_CONf_GET(r) ((((r).marla_fwd_entry0[0]) >> 8) & 0x3)
#define BCM6300_A0_MARLA_FWD_ENTRY0r_ARL_CONf_SET(r,f) (r).marla_fwd_entry0[0]=(((r).marla_fwd_entry0[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM6300_A0_MARLA_FWD_ENTRY0r_ARL_PRIf_GET(r) ((((r).marla_fwd_entry0[0]) >> 10) & 0x7)
#define BCM6300_A0_MARLA_FWD_ENTRY0r_ARL_PRIf_SET(r,f) (r).marla_fwd_entry0[0]=(((r).marla_fwd_entry0[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM6300_A0_MARLA_FWD_ENTRY0r_FWD_PRT_MAP_1f_GET(r) ((((r).marla_fwd_entry0[0]) >> 13) & 0x1)
#define BCM6300_A0_MARLA_FWD_ENTRY0r_FWD_PRT_MAP_1f_SET(r,f) (r).marla_fwd_entry0[0]=(((r).marla_fwd_entry0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM6300_A0_MARLA_FWD_ENTRY0r_ARL_STATICf_GET(r) ((((r).marla_fwd_entry0[0]) >> 14) & 0x1)
#define BCM6300_A0_MARLA_FWD_ENTRY0r_ARL_STATICf_SET(r,f) (r).marla_fwd_entry0[0]=(((r).marla_fwd_entry0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM6300_A0_MARLA_FWD_ENTRY0r_ARL_VALIDf_GET(r) ((((r).marla_fwd_entry0[0]) >> 15) & 0x1)
#define BCM6300_A0_MARLA_FWD_ENTRY0r_ARL_VALIDf_SET(r,f) (r).marla_fwd_entry0[0]=(((r).marla_fwd_entry0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MARLA_FWD_ENTRY0.
 *
 */
#define BCM6300_A0_READ_MARLA_FWD_ENTRY0r(u,r) cdk_robo_reg_read(u,BCM6300_A0_MARLA_FWD_ENTRY0r,(r._marla_fwd_entry0),2)
#define BCM6300_A0_WRITE_MARLA_FWD_ENTRY0r(u,r) cdk_robo_reg_write(u,BCM6300_A0_MARLA_FWD_ENTRY0r,&(r._marla_fwd_entry0),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MARLA_FWD_ENTRY0r BCM6300_A0_MARLA_FWD_ENTRY0r
#define MARLA_FWD_ENTRY0r_SIZE BCM6300_A0_MARLA_FWD_ENTRY0r_SIZE
typedef BCM6300_A0_MARLA_FWD_ENTRY0r_t MARLA_FWD_ENTRY0r_t;
#define MARLA_FWD_ENTRY0r_CLR BCM6300_A0_MARLA_FWD_ENTRY0r_CLR
#define MARLA_FWD_ENTRY0r_SET BCM6300_A0_MARLA_FWD_ENTRY0r_SET
#define MARLA_FWD_ENTRY0r_GET BCM6300_A0_MARLA_FWD_ENTRY0r_GET
#define MARLA_FWD_ENTRY0r_FWD_PRT_MAP_0f_GET BCM6300_A0_MARLA_FWD_ENTRY0r_FWD_PRT_MAP_0f_GET
#define MARLA_FWD_ENTRY0r_FWD_PRT_MAP_0f_SET BCM6300_A0_MARLA_FWD_ENTRY0r_FWD_PRT_MAP_0f_SET
#define MARLA_FWD_ENTRY0r_ARL_CONf_GET BCM6300_A0_MARLA_FWD_ENTRY0r_ARL_CONf_GET
#define MARLA_FWD_ENTRY0r_ARL_CONf_SET BCM6300_A0_MARLA_FWD_ENTRY0r_ARL_CONf_SET
#define MARLA_FWD_ENTRY0r_ARL_PRIf_GET BCM6300_A0_MARLA_FWD_ENTRY0r_ARL_PRIf_GET
#define MARLA_FWD_ENTRY0r_ARL_PRIf_SET BCM6300_A0_MARLA_FWD_ENTRY0r_ARL_PRIf_SET
#define MARLA_FWD_ENTRY0r_FWD_PRT_MAP_1f_GET BCM6300_A0_MARLA_FWD_ENTRY0r_FWD_PRT_MAP_1f_GET
#define MARLA_FWD_ENTRY0r_FWD_PRT_MAP_1f_SET BCM6300_A0_MARLA_FWD_ENTRY0r_FWD_PRT_MAP_1f_SET
#define MARLA_FWD_ENTRY0r_ARL_STATICf_GET BCM6300_A0_MARLA_FWD_ENTRY0r_ARL_STATICf_GET
#define MARLA_FWD_ENTRY0r_ARL_STATICf_SET BCM6300_A0_MARLA_FWD_ENTRY0r_ARL_STATICf_SET
#define MARLA_FWD_ENTRY0r_ARL_VALIDf_GET BCM6300_A0_MARLA_FWD_ENTRY0r_ARL_VALIDf_GET
#define MARLA_FWD_ENTRY0r_ARL_VALIDf_SET BCM6300_A0_MARLA_FWD_ENTRY0r_ARL_VALIDf_SET
#define READ_MARLA_FWD_ENTRY0r BCM6300_A0_READ_MARLA_FWD_ENTRY0r
#define WRITE_MARLA_FWD_ENTRY0r BCM6300_A0_WRITE_MARLA_FWD_ENTRY0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_MARLA_FWD_ENTRY0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  MARLA_SRCH_RSLT
 * BLOCKS:   SYS
 * DESC:     ARL Search Result Register
 * SIZE:     16
 * FIELDS:
 *     FWD_PRT_MAP_0    Multicast Group Forward Portmap.If(MACADDR0[47] ==1) FWD_PRT_MAP[7:0]
 *     ARLA_SRCH_RSLT_CON ARL control bit for arl control mode enhancement.
 *     ARLA_SRCH_RSLT_PRI Priority Bit For MAC based QOS.
 *     FWD_PRT_MAP_1    Age.Set to indicate that an address entry has been learned or accessed.Reset by the internal aging algorithm. If the internal aging process detects a Valid entry has remained unused for the period set by the AGE_TIME, and the entry has not been marked as Static, the entry will have the Valid bit cleared. The Age bit is ignored if the entry has been marked as Static.Multicast Group Forward Portmap.If(MACADDR0[47] ==1) FWD_PRT_MAP[8]
 *     ARLA_SRCH_RSLT_STATIC Static.Set to indicate that the entry is controlled by the external management processor, and automatic learning and aging of the entry will not take place.When cleared, the internal learning and aging process will control the validity of the entry.
 *     ARLA_SRCH_RSLT_VLID Valid.Set to indicate that a valid MAC address is stored in the MACADDR field, and that the entry has not aged out or been freed by the management processor.Reset when an entry is empty, the address has been aged out by the internal aging process, or the external management processor has invalidated the entry. Automatic learning will take place if an address location is not valid and has not been marked as static.
 *
 ******************************************************************************/
#define BCM6300_A0_MARLA_SRCH_RSLTr 0x0000053c

#define BCM6300_A0_MARLA_SRCH_RSLTr_SIZE 2

/*
 * This structure should be used to declare and program MARLA_SRCH_RSLT.
 *
 */
typedef union BCM6300_A0_MARLA_SRCH_RSLTr_s {
	uint32_t v[1];
	uint32_t marla_srch_rslt[1];
	uint32_t _marla_srch_rslt;
} BCM6300_A0_MARLA_SRCH_RSLTr_t;

#define BCM6300_A0_MARLA_SRCH_RSLTr_CLR(r) (r).marla_srch_rslt[0] = 0
#define BCM6300_A0_MARLA_SRCH_RSLTr_SET(r,d) (r).marla_srch_rslt[0] = d
#define BCM6300_A0_MARLA_SRCH_RSLTr_GET(r) (r).marla_srch_rslt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_MARLA_SRCH_RSLTr_FWD_PRT_MAP_0f_GET(r) (((r).marla_srch_rslt[0]) & 0xff)
#define BCM6300_A0_MARLA_SRCH_RSLTr_FWD_PRT_MAP_0f_SET(r,f) (r).marla_srch_rslt[0]=(((r).marla_srch_rslt[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM6300_A0_MARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_CONf_GET(r) ((((r).marla_srch_rslt[0]) >> 8) & 0x3)
#define BCM6300_A0_MARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_CONf_SET(r,f) (r).marla_srch_rslt[0]=(((r).marla_srch_rslt[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM6300_A0_MARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIf_GET(r) ((((r).marla_srch_rslt[0]) >> 10) & 0x7)
#define BCM6300_A0_MARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIf_SET(r,f) (r).marla_srch_rslt[0]=(((r).marla_srch_rslt[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM6300_A0_MARLA_SRCH_RSLTr_FWD_PRT_MAP_1f_GET(r) ((((r).marla_srch_rslt[0]) >> 13) & 0x1)
#define BCM6300_A0_MARLA_SRCH_RSLTr_FWD_PRT_MAP_1f_SET(r,f) (r).marla_srch_rslt[0]=(((r).marla_srch_rslt[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM6300_A0_MARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_GET(r) ((((r).marla_srch_rslt[0]) >> 14) & 0x1)
#define BCM6300_A0_MARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_SET(r,f) (r).marla_srch_rslt[0]=(((r).marla_srch_rslt[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM6300_A0_MARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_GET(r) ((((r).marla_srch_rslt[0]) >> 15) & 0x1)
#define BCM6300_A0_MARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_SET(r,f) (r).marla_srch_rslt[0]=(((r).marla_srch_rslt[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MARLA_SRCH_RSLT.
 *
 */
#define BCM6300_A0_READ_MARLA_SRCH_RSLTr(u,r) cdk_robo_reg_read(u,BCM6300_A0_MARLA_SRCH_RSLTr,(r._marla_srch_rslt),2)
#define BCM6300_A0_WRITE_MARLA_SRCH_RSLTr(u,r) cdk_robo_reg_write(u,BCM6300_A0_MARLA_SRCH_RSLTr,&(r._marla_srch_rslt),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MARLA_SRCH_RSLTr BCM6300_A0_MARLA_SRCH_RSLTr
#define MARLA_SRCH_RSLTr_SIZE BCM6300_A0_MARLA_SRCH_RSLTr_SIZE
typedef BCM6300_A0_MARLA_SRCH_RSLTr_t MARLA_SRCH_RSLTr_t;
#define MARLA_SRCH_RSLTr_CLR BCM6300_A0_MARLA_SRCH_RSLTr_CLR
#define MARLA_SRCH_RSLTr_SET BCM6300_A0_MARLA_SRCH_RSLTr_SET
#define MARLA_SRCH_RSLTr_GET BCM6300_A0_MARLA_SRCH_RSLTr_GET
#define MARLA_SRCH_RSLTr_FWD_PRT_MAP_0f_GET BCM6300_A0_MARLA_SRCH_RSLTr_FWD_PRT_MAP_0f_GET
#define MARLA_SRCH_RSLTr_FWD_PRT_MAP_0f_SET BCM6300_A0_MARLA_SRCH_RSLTr_FWD_PRT_MAP_0f_SET
#define MARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_CONf_GET BCM6300_A0_MARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_CONf_GET
#define MARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_CONf_SET BCM6300_A0_MARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_CONf_SET
#define MARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIf_GET BCM6300_A0_MARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIf_GET
#define MARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIf_SET BCM6300_A0_MARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIf_SET
#define MARLA_SRCH_RSLTr_FWD_PRT_MAP_1f_GET BCM6300_A0_MARLA_SRCH_RSLTr_FWD_PRT_MAP_1f_GET
#define MARLA_SRCH_RSLTr_FWD_PRT_MAP_1f_SET BCM6300_A0_MARLA_SRCH_RSLTr_FWD_PRT_MAP_1f_SET
#define MARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_GET BCM6300_A0_MARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_GET
#define MARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_SET BCM6300_A0_MARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_SET
#define MARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_GET BCM6300_A0_MARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_GET
#define MARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_SET BCM6300_A0_MARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_SET
#define READ_MARLA_SRCH_RSLTr BCM6300_A0_READ_MARLA_SRCH_RSLTr
#define WRITE_MARLA_SRCH_RSLTr BCM6300_A0_WRITE_MARLA_SRCH_RSLTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_MARLA_SRCH_RSLTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  MDIO_ADDR_P8
 * BLOCKS:   SYS
 * DESC:     MDIO Port 8 Address Registrer
 * SIZE:     8
 * FIELDS:
 *     ADDR_P8          Port 8 MDIO Scan ADDRESS.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_MDIO_ADDR_P8r 0x00000078

#define BCM6300_A0_MDIO_ADDR_P8r_SIZE 1

/*
 * This structure should be used to declare and program MDIO_ADDR_P8.
 *
 */
typedef union BCM6300_A0_MDIO_ADDR_P8r_s {
	uint32_t v[1];
	uint32_t mdio_addr_p8[1];
	uint32_t _mdio_addr_p8;
} BCM6300_A0_MDIO_ADDR_P8r_t;

#define BCM6300_A0_MDIO_ADDR_P8r_CLR(r) (r).mdio_addr_p8[0] = 0
#define BCM6300_A0_MDIO_ADDR_P8r_SET(r,d) (r).mdio_addr_p8[0] = d
#define BCM6300_A0_MDIO_ADDR_P8r_GET(r) (r).mdio_addr_p8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_MDIO_ADDR_P8r_ADDR_P8f_GET(r) (((r).mdio_addr_p8[0]) & 0x1f)
#define BCM6300_A0_MDIO_ADDR_P8r_ADDR_P8f_SET(r,f) (r).mdio_addr_p8[0]=(((r).mdio_addr_p8[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM6300_A0_MDIO_ADDR_P8r_RESERVED_Rf_GET(r) ((((r).mdio_addr_p8[0]) >> 5) & 0x7)
#define BCM6300_A0_MDIO_ADDR_P8r_RESERVED_Rf_SET(r,f) (r).mdio_addr_p8[0]=(((r).mdio_addr_p8[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access MDIO_ADDR_P8.
 *
 */
#define BCM6300_A0_READ_MDIO_ADDR_P8r(u,r) cdk_robo_reg_read(u,BCM6300_A0_MDIO_ADDR_P8r,(r._mdio_addr_p8),1)
#define BCM6300_A0_WRITE_MDIO_ADDR_P8r(u,r) cdk_robo_reg_write(u,BCM6300_A0_MDIO_ADDR_P8r,&(r._mdio_addr_p8),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MDIO_ADDR_P8r BCM6300_A0_MDIO_ADDR_P8r
#define MDIO_ADDR_P8r_SIZE BCM6300_A0_MDIO_ADDR_P8r_SIZE
typedef BCM6300_A0_MDIO_ADDR_P8r_t MDIO_ADDR_P8r_t;
#define MDIO_ADDR_P8r_CLR BCM6300_A0_MDIO_ADDR_P8r_CLR
#define MDIO_ADDR_P8r_SET BCM6300_A0_MDIO_ADDR_P8r_SET
#define MDIO_ADDR_P8r_GET BCM6300_A0_MDIO_ADDR_P8r_GET
#define MDIO_ADDR_P8r_ADDR_P8f_GET BCM6300_A0_MDIO_ADDR_P8r_ADDR_P8f_GET
#define MDIO_ADDR_P8r_ADDR_P8f_SET BCM6300_A0_MDIO_ADDR_P8r_ADDR_P8f_SET
#define MDIO_ADDR_P8r_RESERVED_Rf_GET BCM6300_A0_MDIO_ADDR_P8r_RESERVED_Rf_GET
#define MDIO_ADDR_P8r_RESERVED_Rf_SET BCM6300_A0_MDIO_ADDR_P8r_RESERVED_Rf_SET
#define READ_MDIO_ADDR_P8r BCM6300_A0_READ_MDIO_ADDR_P8r
#define WRITE_MDIO_ADDR_P8r BCM6300_A0_WRITE_MDIO_ADDR_P8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_MDIO_ADDR_P8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  MDIO_ADDR_WAN
 * BLOCKS:   SYS
 * DESC:     MDIO WAN Port Address Registrer
 * SIZE:     8
 * FIELDS:
 *     ADDR_WAN         Wan-Port MDIO Scan ADDRESS (valid for 5397 only).
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_MDIO_ADDR_WANr 0x00000077

#define BCM6300_A0_MDIO_ADDR_WANr_SIZE 1

/*
 * This structure should be used to declare and program MDIO_ADDR_WAN.
 *
 */
typedef union BCM6300_A0_MDIO_ADDR_WANr_s {
	uint32_t v[1];
	uint32_t mdio_addr_wan[1];
	uint32_t _mdio_addr_wan;
} BCM6300_A0_MDIO_ADDR_WANr_t;

#define BCM6300_A0_MDIO_ADDR_WANr_CLR(r) (r).mdio_addr_wan[0] = 0
#define BCM6300_A0_MDIO_ADDR_WANr_SET(r,d) (r).mdio_addr_wan[0] = d
#define BCM6300_A0_MDIO_ADDR_WANr_GET(r) (r).mdio_addr_wan[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_MDIO_ADDR_WANr_ADDR_WANf_GET(r) (((r).mdio_addr_wan[0]) & 0x1f)
#define BCM6300_A0_MDIO_ADDR_WANr_ADDR_WANf_SET(r,f) (r).mdio_addr_wan[0]=(((r).mdio_addr_wan[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM6300_A0_MDIO_ADDR_WANr_RESERVED_Rf_GET(r) ((((r).mdio_addr_wan[0]) >> 5) & 0x7)
#define BCM6300_A0_MDIO_ADDR_WANr_RESERVED_Rf_SET(r,f) (r).mdio_addr_wan[0]=(((r).mdio_addr_wan[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access MDIO_ADDR_WAN.
 *
 */
#define BCM6300_A0_READ_MDIO_ADDR_WANr(u,r) cdk_robo_reg_read(u,BCM6300_A0_MDIO_ADDR_WANr,(r._mdio_addr_wan),1)
#define BCM6300_A0_WRITE_MDIO_ADDR_WANr(u,r) cdk_robo_reg_write(u,BCM6300_A0_MDIO_ADDR_WANr,&(r._mdio_addr_wan),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MDIO_ADDR_WANr BCM6300_A0_MDIO_ADDR_WANr
#define MDIO_ADDR_WANr_SIZE BCM6300_A0_MDIO_ADDR_WANr_SIZE
typedef BCM6300_A0_MDIO_ADDR_WANr_t MDIO_ADDR_WANr_t;
#define MDIO_ADDR_WANr_CLR BCM6300_A0_MDIO_ADDR_WANr_CLR
#define MDIO_ADDR_WANr_SET BCM6300_A0_MDIO_ADDR_WANr_SET
#define MDIO_ADDR_WANr_GET BCM6300_A0_MDIO_ADDR_WANr_GET
#define MDIO_ADDR_WANr_ADDR_WANf_GET BCM6300_A0_MDIO_ADDR_WANr_ADDR_WANf_GET
#define MDIO_ADDR_WANr_ADDR_WANf_SET BCM6300_A0_MDIO_ADDR_WANr_ADDR_WANf_SET
#define MDIO_ADDR_WANr_RESERVED_Rf_GET BCM6300_A0_MDIO_ADDR_WANr_RESERVED_Rf_GET
#define MDIO_ADDR_WANr_RESERVED_Rf_SET BCM6300_A0_MDIO_ADDR_WANr_RESERVED_Rf_SET
#define READ_MDIO_ADDR_WANr BCM6300_A0_READ_MDIO_ADDR_WANr
#define WRITE_MDIO_ADDR_WANr BCM6300_A0_WRITE_MDIO_ADDR_WANr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_MDIO_ADDR_WANr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  MEM_ADDR
 * BLOCKS:   SYS
 * DESC:     FM Memory Read/Write Control Register
 * SIZE:     16
 * FIELDS:
 *     MEM_ADR          Specifies the next memory address to read or write.
 *     MEM_RW           1' causes a read operation while 0' is for a write operation.
 *     MEM_STDN         Initiates the read/write operation for the Debugged memory.The bit will be clear once the Read/Write Operation is completed.
 *
 ******************************************************************************/
#define BCM6300_A0_MEM_ADDRr 0x00000801

#define BCM6300_A0_MEM_ADDRr_SIZE 2

/*
 * This structure should be used to declare and program MEM_ADDR.
 *
 */
typedef union BCM6300_A0_MEM_ADDRr_s {
	uint32_t v[1];
	uint32_t mem_addr[1];
	uint32_t _mem_addr;
} BCM6300_A0_MEM_ADDRr_t;

#define BCM6300_A0_MEM_ADDRr_CLR(r) (r).mem_addr[0] = 0
#define BCM6300_A0_MEM_ADDRr_SET(r,d) (r).mem_addr[0] = d
#define BCM6300_A0_MEM_ADDRr_GET(r) (r).mem_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_MEM_ADDRr_MEM_ADRf_GET(r) (((r).mem_addr[0]) & 0x3fff)
#define BCM6300_A0_MEM_ADDRr_MEM_ADRf_SET(r,f) (r).mem_addr[0]=(((r).mem_addr[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM6300_A0_MEM_ADDRr_MEM_RWf_GET(r) ((((r).mem_addr[0]) >> 14) & 0x1)
#define BCM6300_A0_MEM_ADDRr_MEM_RWf_SET(r,f) (r).mem_addr[0]=(((r).mem_addr[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM6300_A0_MEM_ADDRr_MEM_STDNf_GET(r) ((((r).mem_addr[0]) >> 15) & 0x1)
#define BCM6300_A0_MEM_ADDRr_MEM_STDNf_SET(r,f) (r).mem_addr[0]=(((r).mem_addr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MEM_ADDR.
 *
 */
#define BCM6300_A0_READ_MEM_ADDRr(u,r) cdk_robo_reg_read(u,BCM6300_A0_MEM_ADDRr,(r._mem_addr),2)
#define BCM6300_A0_WRITE_MEM_ADDRr(u,r) cdk_robo_reg_write(u,BCM6300_A0_MEM_ADDRr,&(r._mem_addr),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_ADDRr BCM6300_A0_MEM_ADDRr
#define MEM_ADDRr_SIZE BCM6300_A0_MEM_ADDRr_SIZE
typedef BCM6300_A0_MEM_ADDRr_t MEM_ADDRr_t;
#define MEM_ADDRr_CLR BCM6300_A0_MEM_ADDRr_CLR
#define MEM_ADDRr_SET BCM6300_A0_MEM_ADDRr_SET
#define MEM_ADDRr_GET BCM6300_A0_MEM_ADDRr_GET
#define MEM_ADDRr_MEM_ADRf_GET BCM6300_A0_MEM_ADDRr_MEM_ADRf_GET
#define MEM_ADDRr_MEM_ADRf_SET BCM6300_A0_MEM_ADDRr_MEM_ADRf_SET
#define MEM_ADDRr_MEM_RWf_GET BCM6300_A0_MEM_ADDRr_MEM_RWf_GET
#define MEM_ADDRr_MEM_RWf_SET BCM6300_A0_MEM_ADDRr_MEM_RWf_SET
#define MEM_ADDRr_MEM_STDNf_GET BCM6300_A0_MEM_ADDRr_MEM_STDNf_GET
#define MEM_ADDRr_MEM_STDNf_SET BCM6300_A0_MEM_ADDRr_MEM_STDNf_SET
#define READ_MEM_ADDRr BCM6300_A0_READ_MEM_ADDRr
#define WRITE_MEM_ADDRr BCM6300_A0_WRITE_MEM_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_MEM_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  MEM_BFC_ADDR
 * BLOCKS:   SYS
 * DESC:     Buffer Control Memory Address Register
 * SIZE:     16
 * FIELDS:
 *     BFC_ADDR         Specifies the next memmory address to read or write.
 *     RW_CTRL          '1' causes read operation while '0' is for write operation.
 *     MEM_REQ          Initiates the read/write operation for the Buffer Control memmory.The bit will clear one the Read/write Operation is completed.
 *
 ******************************************************************************/
#define BCM6300_A0_MEM_BFC_ADDRr 0x0000083a

#define BCM6300_A0_MEM_BFC_ADDRr_SIZE 2

/*
 * This structure should be used to declare and program MEM_BFC_ADDR.
 *
 */
typedef union BCM6300_A0_MEM_BFC_ADDRr_s {
	uint32_t v[1];
	uint32_t mem_bfc_addr[1];
	uint32_t _mem_bfc_addr;
} BCM6300_A0_MEM_BFC_ADDRr_t;

#define BCM6300_A0_MEM_BFC_ADDRr_CLR(r) (r).mem_bfc_addr[0] = 0
#define BCM6300_A0_MEM_BFC_ADDRr_SET(r,d) (r).mem_bfc_addr[0] = d
#define BCM6300_A0_MEM_BFC_ADDRr_GET(r) (r).mem_bfc_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_MEM_BFC_ADDRr_BFC_ADDRf_GET(r) (((r).mem_bfc_addr[0]) & 0x3fff)
#define BCM6300_A0_MEM_BFC_ADDRr_BFC_ADDRf_SET(r,f) (r).mem_bfc_addr[0]=(((r).mem_bfc_addr[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM6300_A0_MEM_BFC_ADDRr_RW_CTRLf_GET(r) ((((r).mem_bfc_addr[0]) >> 14) & 0x1)
#define BCM6300_A0_MEM_BFC_ADDRr_RW_CTRLf_SET(r,f) (r).mem_bfc_addr[0]=(((r).mem_bfc_addr[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM6300_A0_MEM_BFC_ADDRr_MEM_REQf_GET(r) ((((r).mem_bfc_addr[0]) >> 15) & 0x1)
#define BCM6300_A0_MEM_BFC_ADDRr_MEM_REQf_SET(r,f) (r).mem_bfc_addr[0]=(((r).mem_bfc_addr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MEM_BFC_ADDR.
 *
 */
#define BCM6300_A0_READ_MEM_BFC_ADDRr(u,r) cdk_robo_reg_read(u,BCM6300_A0_MEM_BFC_ADDRr,(r._mem_bfc_addr),2)
#define BCM6300_A0_WRITE_MEM_BFC_ADDRr(u,r) cdk_robo_reg_write(u,BCM6300_A0_MEM_BFC_ADDRr,&(r._mem_bfc_addr),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_BFC_ADDRr BCM6300_A0_MEM_BFC_ADDRr
#define MEM_BFC_ADDRr_SIZE BCM6300_A0_MEM_BFC_ADDRr_SIZE
typedef BCM6300_A0_MEM_BFC_ADDRr_t MEM_BFC_ADDRr_t;
#define MEM_BFC_ADDRr_CLR BCM6300_A0_MEM_BFC_ADDRr_CLR
#define MEM_BFC_ADDRr_SET BCM6300_A0_MEM_BFC_ADDRr_SET
#define MEM_BFC_ADDRr_GET BCM6300_A0_MEM_BFC_ADDRr_GET
#define MEM_BFC_ADDRr_BFC_ADDRf_GET BCM6300_A0_MEM_BFC_ADDRr_BFC_ADDRf_GET
#define MEM_BFC_ADDRr_BFC_ADDRf_SET BCM6300_A0_MEM_BFC_ADDRr_BFC_ADDRf_SET
#define MEM_BFC_ADDRr_RW_CTRLf_GET BCM6300_A0_MEM_BFC_ADDRr_RW_CTRLf_GET
#define MEM_BFC_ADDRr_RW_CTRLf_SET BCM6300_A0_MEM_BFC_ADDRr_RW_CTRLf_SET
#define MEM_BFC_ADDRr_MEM_REQf_GET BCM6300_A0_MEM_BFC_ADDRr_MEM_REQf_GET
#define MEM_BFC_ADDRr_MEM_REQf_SET BCM6300_A0_MEM_BFC_ADDRr_MEM_REQf_SET
#define READ_MEM_BFC_ADDRr BCM6300_A0_READ_MEM_BFC_ADDRr
#define WRITE_MEM_BFC_ADDRr BCM6300_A0_WRITE_MEM_BFC_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_MEM_BFC_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  MEM_BFC_DATA
 * BLOCKS:   SYS
 * DESC:     Buffer Control Memory Data Register
 * SIZE:     64
 * FIELDS:
 *     BFC_DATA         Privides the read from the Buffer Control memmory[63:0].
 *
 ******************************************************************************/
#define BCM6300_A0_MEM_BFC_DATAr 0x0000083c

#define BCM6300_A0_MEM_BFC_DATAr_SIZE 8

/*
 * This structure should be used to declare and program MEM_BFC_DATA.
 *
 */
typedef union BCM6300_A0_MEM_BFC_DATAr_s {
	uint32_t v[2];
	uint32_t mem_bfc_data[2];
	uint32_t _mem_bfc_data;
} BCM6300_A0_MEM_BFC_DATAr_t;

#define BCM6300_A0_MEM_BFC_DATAr_CLR(r) CDK_MEMSET(&((r)._mem_bfc_data), 0, sizeof(BCM6300_A0_MEM_BFC_DATAr_t))
#define BCM6300_A0_MEM_BFC_DATAr_SET(r,i,d) (r).mem_bfc_data[i] = d
#define BCM6300_A0_MEM_BFC_DATAr_GET(r,i) (r).mem_bfc_data[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_MEM_BFC_DATAr_BFC_DATAf_GET(r,a) cdk_field_get((r).mem_bfc_data,0,63,a)
#define BCM6300_A0_MEM_BFC_DATAr_BFC_DATAf_SET(r,a) cdk_field_set((r).mem_bfc_data,0,63,a)

/*
 * These macros can be used to access MEM_BFC_DATA.
 *
 */
#define BCM6300_A0_READ_MEM_BFC_DATAr(u,r) cdk_robo_reg_read(u,BCM6300_A0_MEM_BFC_DATAr,(r._mem_bfc_data),8)
#define BCM6300_A0_WRITE_MEM_BFC_DATAr(u,r) cdk_robo_reg_write(u,BCM6300_A0_MEM_BFC_DATAr,&(r._mem_bfc_data),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_BFC_DATAr BCM6300_A0_MEM_BFC_DATAr
#define MEM_BFC_DATAr_SIZE BCM6300_A0_MEM_BFC_DATAr_SIZE
typedef BCM6300_A0_MEM_BFC_DATAr_t MEM_BFC_DATAr_t;
#define MEM_BFC_DATAr_CLR BCM6300_A0_MEM_BFC_DATAr_CLR
#define MEM_BFC_DATAr_SET BCM6300_A0_MEM_BFC_DATAr_SET
#define MEM_BFC_DATAr_GET BCM6300_A0_MEM_BFC_DATAr_GET
#define MEM_BFC_DATAr_BFC_DATAf_GET BCM6300_A0_MEM_BFC_DATAr_BFC_DATAf_GET
#define MEM_BFC_DATAr_BFC_DATAf_SET BCM6300_A0_MEM_BFC_DATAr_BFC_DATAf_SET
#define READ_MEM_BFC_DATAr BCM6300_A0_READ_MEM_BFC_DATAr
#define WRITE_MEM_BFC_DATAr BCM6300_A0_WRITE_MEM_BFC_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_MEM_BFC_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  MEM_BTM_DATA
 * BLOCKS:   SYS
 * DESC:     Buffer Tag Memory Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DATA         Specifies the data to read data from buffer Tag memory[49:0]Note: Buffer Tag Memory Register Only For Read.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM6300_A0_MEM_BTM_DATAr 0x00000832

#define BCM6300_A0_MEM_BTM_DATAr_SIZE 8

/*
 * This structure should be used to declare and program MEM_BTM_DATA.
 *
 */
typedef union BCM6300_A0_MEM_BTM_DATAr_s {
	uint32_t v[2];
	uint32_t mem_btm_data[2];
	uint32_t _mem_btm_data;
} BCM6300_A0_MEM_BTM_DATAr_t;

#define BCM6300_A0_MEM_BTM_DATAr_CLR(r) CDK_MEMSET(&((r)._mem_btm_data), 0, sizeof(BCM6300_A0_MEM_BTM_DATAr_t))
#define BCM6300_A0_MEM_BTM_DATAr_SET(r,i,d) (r).mem_btm_data[i] = d
#define BCM6300_A0_MEM_BTM_DATAr_GET(r,i) (r).mem_btm_data[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_MEM_BTM_DATAr_MEM_DATAf_GET(r,a) cdk_field_get((r).mem_btm_data,0,49,a)
#define BCM6300_A0_MEM_BTM_DATAr_MEM_DATAf_SET(r,a) cdk_field_set((r).mem_btm_data,0,49,a)
#define BCM6300_A0_MEM_BTM_DATAr_RESERVED_Rf_GET(r) ((((r).mem_btm_data[1]) >> 18) & 0x3fff)
#define BCM6300_A0_MEM_BTM_DATAr_RESERVED_Rf_SET(r,f) (r).mem_btm_data[1]=(((r).mem_btm_data[1] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access MEM_BTM_DATA.
 *
 */
#define BCM6300_A0_READ_MEM_BTM_DATAr(u,r) cdk_robo_reg_read(u,BCM6300_A0_MEM_BTM_DATAr,(r._mem_btm_data),8)
#define BCM6300_A0_WRITE_MEM_BTM_DATAr(u,r) cdk_robo_reg_write(u,BCM6300_A0_MEM_BTM_DATAr,&(r._mem_btm_data),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_BTM_DATAr BCM6300_A0_MEM_BTM_DATAr
#define MEM_BTM_DATAr_SIZE BCM6300_A0_MEM_BTM_DATAr_SIZE
typedef BCM6300_A0_MEM_BTM_DATAr_t MEM_BTM_DATAr_t;
#define MEM_BTM_DATAr_CLR BCM6300_A0_MEM_BTM_DATAr_CLR
#define MEM_BTM_DATAr_SET BCM6300_A0_MEM_BTM_DATAr_SET
#define MEM_BTM_DATAr_GET BCM6300_A0_MEM_BTM_DATAr_GET
#define MEM_BTM_DATAr_MEM_DATAf_GET BCM6300_A0_MEM_BTM_DATAr_MEM_DATAf_GET
#define MEM_BTM_DATAr_MEM_DATAf_SET BCM6300_A0_MEM_BTM_DATAr_MEM_DATAf_SET
#define MEM_BTM_DATAr_RESERVED_Rf_GET BCM6300_A0_MEM_BTM_DATAr_RESERVED_Rf_GET
#define MEM_BTM_DATAr_RESERVED_Rf_SET BCM6300_A0_MEM_BTM_DATAr_RESERVED_Rf_SET
#define READ_MEM_BTM_DATAr BCM6300_A0_READ_MEM_BTM_DATAr
#define WRITE_MEM_BTM_DATAr BCM6300_A0_WRITE_MEM_BTM_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_MEM_BTM_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  MEM_CTRL
 * BLOCKS:   SYS
 * DESC:     Memory Debug Control Register
 * SIZE:     8
 * FIELDS:
 *     RESERVED_0R      Reserved
 *     RESERVED_1R      Reserved
 *     MEM_TYPE         Indicate the memory for the Debugged memory.10 : VLAN Memory,11 : ARL Memory.
 *
 ******************************************************************************/
#define BCM6300_A0_MEM_CTRLr 0x00000800

#define BCM6300_A0_MEM_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program MEM_CTRL.
 *
 */
typedef union BCM6300_A0_MEM_CTRLr_s {
	uint32_t v[1];
	uint32_t mem_ctrl[1];
	uint32_t _mem_ctrl;
} BCM6300_A0_MEM_CTRLr_t;

#define BCM6300_A0_MEM_CTRLr_CLR(r) (r).mem_ctrl[0] = 0
#define BCM6300_A0_MEM_CTRLr_SET(r,d) (r).mem_ctrl[0] = d
#define BCM6300_A0_MEM_CTRLr_GET(r) (r).mem_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_MEM_CTRLr_RESERVED_0Rf_GET(r) (((r).mem_ctrl[0]) & 0xf)
#define BCM6300_A0_MEM_CTRLr_RESERVED_0Rf_SET(r,f) (r).mem_ctrl[0]=(((r).mem_ctrl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM6300_A0_MEM_CTRLr_RESERVED_1Rf_GET(r) ((((r).mem_ctrl[0]) >> 4) & 0x3)
#define BCM6300_A0_MEM_CTRLr_RESERVED_1Rf_SET(r,f) (r).mem_ctrl[0]=(((r).mem_ctrl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM6300_A0_MEM_CTRLr_MEM_TYPEf_GET(r) ((((r).mem_ctrl[0]) >> 6) & 0x3)
#define BCM6300_A0_MEM_CTRLr_MEM_TYPEf_SET(r,f) (r).mem_ctrl[0]=(((r).mem_ctrl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access MEM_CTRL.
 *
 */
#define BCM6300_A0_READ_MEM_CTRLr(u,r) cdk_robo_reg_read(u,BCM6300_A0_MEM_CTRLr,(r._mem_ctrl),1)
#define BCM6300_A0_WRITE_MEM_CTRLr(u,r) cdk_robo_reg_write(u,BCM6300_A0_MEM_CTRLr,&(r._mem_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_CTRLr BCM6300_A0_MEM_CTRLr
#define MEM_CTRLr_SIZE BCM6300_A0_MEM_CTRLr_SIZE
typedef BCM6300_A0_MEM_CTRLr_t MEM_CTRLr_t;
#define MEM_CTRLr_CLR BCM6300_A0_MEM_CTRLr_CLR
#define MEM_CTRLr_SET BCM6300_A0_MEM_CTRLr_SET
#define MEM_CTRLr_GET BCM6300_A0_MEM_CTRLr_GET
#define MEM_CTRLr_RESERVED_0Rf_GET BCM6300_A0_MEM_CTRLr_RESERVED_0Rf_GET
#define MEM_CTRLr_RESERVED_0Rf_SET BCM6300_A0_MEM_CTRLr_RESERVED_0Rf_SET
#define MEM_CTRLr_RESERVED_1Rf_GET BCM6300_A0_MEM_CTRLr_RESERVED_1Rf_GET
#define MEM_CTRLr_RESERVED_1Rf_SET BCM6300_A0_MEM_CTRLr_RESERVED_1Rf_SET
#define MEM_CTRLr_MEM_TYPEf_GET BCM6300_A0_MEM_CTRLr_MEM_TYPEf_GET
#define MEM_CTRLr_MEM_TYPEf_SET BCM6300_A0_MEM_CTRLr_MEM_TYPEf_SET
#define READ_MEM_CTRLr BCM6300_A0_READ_MEM_CTRLr
#define WRITE_MEM_CTRLr BCM6300_A0_WRITE_MEM_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_MEM_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  MEM_DATA_LOW
 * BLOCKS:   SYS
 * DESC:     Memory Data Low-Part Debug Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DAT          Specifies the data to write or provides the read data from the debugged memory [63:0]Valid bits of the registers depends on the type of memory.
 *
 ******************************************************************************/
#define BCM6300_A0_MEM_DATA_LOWr 0x00000803

#define BCM6300_A0_MEM_DATA_LOWr_SIZE 8

/*
 * This structure should be used to declare and program MEM_DATA_LOW.
 *
 */
typedef union BCM6300_A0_MEM_DATA_LOWr_s {
	uint32_t v[2];
	uint32_t mem_data_low[2];
	uint32_t _mem_data_low;
} BCM6300_A0_MEM_DATA_LOWr_t;

#define BCM6300_A0_MEM_DATA_LOWr_CLR(r) CDK_MEMSET(&((r)._mem_data_low), 0, sizeof(BCM6300_A0_MEM_DATA_LOWr_t))
#define BCM6300_A0_MEM_DATA_LOWr_SET(r,i,d) (r).mem_data_low[i] = d
#define BCM6300_A0_MEM_DATA_LOWr_GET(r,i) (r).mem_data_low[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_MEM_DATA_LOWr_MEM_DATf_GET(r,a) cdk_field_get((r).mem_data_low,0,63,a)
#define BCM6300_A0_MEM_DATA_LOWr_MEM_DATf_SET(r,a) cdk_field_set((r).mem_data_low,0,63,a)

/*
 * These macros can be used to access MEM_DATA_LOW.
 *
 */
#define BCM6300_A0_READ_MEM_DATA_LOWr(u,r) cdk_robo_reg_read(u,BCM6300_A0_MEM_DATA_LOWr,(r._mem_data_low),8)
#define BCM6300_A0_WRITE_MEM_DATA_LOWr(u,r) cdk_robo_reg_write(u,BCM6300_A0_MEM_DATA_LOWr,&(r._mem_data_low),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_DATA_LOWr BCM6300_A0_MEM_DATA_LOWr
#define MEM_DATA_LOWr_SIZE BCM6300_A0_MEM_DATA_LOWr_SIZE
typedef BCM6300_A0_MEM_DATA_LOWr_t MEM_DATA_LOWr_t;
#define MEM_DATA_LOWr_CLR BCM6300_A0_MEM_DATA_LOWr_CLR
#define MEM_DATA_LOWr_SET BCM6300_A0_MEM_DATA_LOWr_SET
#define MEM_DATA_LOWr_GET BCM6300_A0_MEM_DATA_LOWr_GET
#define MEM_DATA_LOWr_MEM_DATf_GET BCM6300_A0_MEM_DATA_LOWr_MEM_DATf_GET
#define MEM_DATA_LOWr_MEM_DATf_SET BCM6300_A0_MEM_DATA_LOWr_MEM_DATf_SET
#define READ_MEM_DATA_LOWr BCM6300_A0_READ_MEM_DATA_LOWr
#define WRITE_MEM_DATA_LOWr BCM6300_A0_WRITE_MEM_DATA_LOWr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_MEM_DATA_LOWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  MEM_FRM_ADDR
 * BLOCKS:   SYS
 * DESC:     Frame Memory Address Register
 * SIZE:     16
 * FIELDS:
 *     MEM_ADR          Specifies the next memory address to read or write.
 *     MEM_RW           1' causes a read operation while 0' is for a write operation.
 *     MEM_STDN         Initiates the read/write operation for the Debugged memory.The bit will be clear once the Read/Write Operation is completed.
 *
 ******************************************************************************/
#define BCM6300_A0_MEM_FRM_ADDRr 0x00000810

#define BCM6300_A0_MEM_FRM_ADDRr_SIZE 2

/*
 * This structure should be used to declare and program MEM_FRM_ADDR.
 *
 */
typedef union BCM6300_A0_MEM_FRM_ADDRr_s {
	uint32_t v[1];
	uint32_t mem_frm_addr[1];
	uint32_t _mem_frm_addr;
} BCM6300_A0_MEM_FRM_ADDRr_t;

#define BCM6300_A0_MEM_FRM_ADDRr_CLR(r) (r).mem_frm_addr[0] = 0
#define BCM6300_A0_MEM_FRM_ADDRr_SET(r,d) (r).mem_frm_addr[0] = d
#define BCM6300_A0_MEM_FRM_ADDRr_GET(r) (r).mem_frm_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_MEM_FRM_ADDRr_MEM_ADRf_GET(r) (((r).mem_frm_addr[0]) & 0x3fff)
#define BCM6300_A0_MEM_FRM_ADDRr_MEM_ADRf_SET(r,f) (r).mem_frm_addr[0]=(((r).mem_frm_addr[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM6300_A0_MEM_FRM_ADDRr_MEM_RWf_GET(r) ((((r).mem_frm_addr[0]) >> 14) & 0x1)
#define BCM6300_A0_MEM_FRM_ADDRr_MEM_RWf_SET(r,f) (r).mem_frm_addr[0]=(((r).mem_frm_addr[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM6300_A0_MEM_FRM_ADDRr_MEM_STDNf_GET(r) ((((r).mem_frm_addr[0]) >> 15) & 0x1)
#define BCM6300_A0_MEM_FRM_ADDRr_MEM_STDNf_SET(r,f) (r).mem_frm_addr[0]=(((r).mem_frm_addr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MEM_FRM_ADDR.
 *
 */
#define BCM6300_A0_READ_MEM_FRM_ADDRr(u,r) cdk_robo_reg_read(u,BCM6300_A0_MEM_FRM_ADDRr,(r._mem_frm_addr),2)
#define BCM6300_A0_WRITE_MEM_FRM_ADDRr(u,r) cdk_robo_reg_write(u,BCM6300_A0_MEM_FRM_ADDRr,&(r._mem_frm_addr),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_FRM_ADDRr BCM6300_A0_MEM_FRM_ADDRr
#define MEM_FRM_ADDRr_SIZE BCM6300_A0_MEM_FRM_ADDRr_SIZE
typedef BCM6300_A0_MEM_FRM_ADDRr_t MEM_FRM_ADDRr_t;
#define MEM_FRM_ADDRr_CLR BCM6300_A0_MEM_FRM_ADDRr_CLR
#define MEM_FRM_ADDRr_SET BCM6300_A0_MEM_FRM_ADDRr_SET
#define MEM_FRM_ADDRr_GET BCM6300_A0_MEM_FRM_ADDRr_GET
#define MEM_FRM_ADDRr_MEM_ADRf_GET BCM6300_A0_MEM_FRM_ADDRr_MEM_ADRf_GET
#define MEM_FRM_ADDRr_MEM_ADRf_SET BCM6300_A0_MEM_FRM_ADDRr_MEM_ADRf_SET
#define MEM_FRM_ADDRr_MEM_RWf_GET BCM6300_A0_MEM_FRM_ADDRr_MEM_RWf_GET
#define MEM_FRM_ADDRr_MEM_RWf_SET BCM6300_A0_MEM_FRM_ADDRr_MEM_RWf_SET
#define MEM_FRM_ADDRr_MEM_STDNf_GET BCM6300_A0_MEM_FRM_ADDRr_MEM_STDNf_GET
#define MEM_FRM_ADDRr_MEM_STDNf_SET BCM6300_A0_MEM_FRM_ADDRr_MEM_STDNf_SET
#define READ_MEM_FRM_ADDRr BCM6300_A0_READ_MEM_FRM_ADDRr
#define WRITE_MEM_FRM_ADDRr BCM6300_A0_WRITE_MEM_FRM_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_MEM_FRM_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  MEM_FRM_DATA0
 * BLOCKS:   SYS
 * DESC:     Frame Memory Data 1st Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DATA         Specifies the data to write or provides the read data from the Frame memory[63:0].
 *
 ******************************************************************************/
#define BCM6300_A0_MEM_FRM_DATA0r 0x00000812

#define BCM6300_A0_MEM_FRM_DATA0r_SIZE 8

/*
 * This structure should be used to declare and program MEM_FRM_DATA0.
 *
 */
typedef union BCM6300_A0_MEM_FRM_DATA0r_s {
	uint32_t v[2];
	uint32_t mem_frm_data0[2];
	uint32_t _mem_frm_data0;
} BCM6300_A0_MEM_FRM_DATA0r_t;

#define BCM6300_A0_MEM_FRM_DATA0r_CLR(r) CDK_MEMSET(&((r)._mem_frm_data0), 0, sizeof(BCM6300_A0_MEM_FRM_DATA0r_t))
#define BCM6300_A0_MEM_FRM_DATA0r_SET(r,i,d) (r).mem_frm_data0[i] = d
#define BCM6300_A0_MEM_FRM_DATA0r_GET(r,i) (r).mem_frm_data0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_MEM_FRM_DATA0r_MEM_DATAf_GET(r,a) cdk_field_get((r).mem_frm_data0,0,63,a)
#define BCM6300_A0_MEM_FRM_DATA0r_MEM_DATAf_SET(r,a) cdk_field_set((r).mem_frm_data0,0,63,a)

/*
 * These macros can be used to access MEM_FRM_DATA0.
 *
 */
#define BCM6300_A0_READ_MEM_FRM_DATA0r(u,r) cdk_robo_reg_read(u,BCM6300_A0_MEM_FRM_DATA0r,(r._mem_frm_data0),8)
#define BCM6300_A0_WRITE_MEM_FRM_DATA0r(u,r) cdk_robo_reg_write(u,BCM6300_A0_MEM_FRM_DATA0r,&(r._mem_frm_data0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_FRM_DATA0r BCM6300_A0_MEM_FRM_DATA0r
#define MEM_FRM_DATA0r_SIZE BCM6300_A0_MEM_FRM_DATA0r_SIZE
typedef BCM6300_A0_MEM_FRM_DATA0r_t MEM_FRM_DATA0r_t;
#define MEM_FRM_DATA0r_CLR BCM6300_A0_MEM_FRM_DATA0r_CLR
#define MEM_FRM_DATA0r_SET BCM6300_A0_MEM_FRM_DATA0r_SET
#define MEM_FRM_DATA0r_GET BCM6300_A0_MEM_FRM_DATA0r_GET
#define MEM_FRM_DATA0r_MEM_DATAf_GET BCM6300_A0_MEM_FRM_DATA0r_MEM_DATAf_GET
#define MEM_FRM_DATA0r_MEM_DATAf_SET BCM6300_A0_MEM_FRM_DATA0r_MEM_DATAf_SET
#define READ_MEM_FRM_DATA0r BCM6300_A0_READ_MEM_FRM_DATA0r
#define WRITE_MEM_FRM_DATA0r BCM6300_A0_WRITE_MEM_FRM_DATA0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_MEM_FRM_DATA0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  MEM_FRM_DATA1
 * BLOCKS:   SYS
 * DESC:     Frame Memory Data 2st Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DATA         Specifies the data to write or provides the read data from the Frame memory[127:64].
 *
 ******************************************************************************/
#define BCM6300_A0_MEM_FRM_DATA1r 0x0000081a

#define BCM6300_A0_MEM_FRM_DATA1r_SIZE 8

/*
 * This structure should be used to declare and program MEM_FRM_DATA1.
 *
 */
typedef union BCM6300_A0_MEM_FRM_DATA1r_s {
	uint32_t v[2];
	uint32_t mem_frm_data1[2];
	uint32_t _mem_frm_data1;
} BCM6300_A0_MEM_FRM_DATA1r_t;

#define BCM6300_A0_MEM_FRM_DATA1r_CLR(r) CDK_MEMSET(&((r)._mem_frm_data1), 0, sizeof(BCM6300_A0_MEM_FRM_DATA1r_t))
#define BCM6300_A0_MEM_FRM_DATA1r_SET(r,i,d) (r).mem_frm_data1[i] = d
#define BCM6300_A0_MEM_FRM_DATA1r_GET(r,i) (r).mem_frm_data1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_MEM_FRM_DATA1r_MEM_DATAf_GET(r,a) cdk_field_get((r).mem_frm_data1,0,63,a)
#define BCM6300_A0_MEM_FRM_DATA1r_MEM_DATAf_SET(r,a) cdk_field_set((r).mem_frm_data1,0,63,a)

/*
 * These macros can be used to access MEM_FRM_DATA1.
 *
 */
#define BCM6300_A0_READ_MEM_FRM_DATA1r(u,r) cdk_robo_reg_read(u,BCM6300_A0_MEM_FRM_DATA1r,(r._mem_frm_data1),8)
#define BCM6300_A0_WRITE_MEM_FRM_DATA1r(u,r) cdk_robo_reg_write(u,BCM6300_A0_MEM_FRM_DATA1r,&(r._mem_frm_data1),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_FRM_DATA1r BCM6300_A0_MEM_FRM_DATA1r
#define MEM_FRM_DATA1r_SIZE BCM6300_A0_MEM_FRM_DATA1r_SIZE
typedef BCM6300_A0_MEM_FRM_DATA1r_t MEM_FRM_DATA1r_t;
#define MEM_FRM_DATA1r_CLR BCM6300_A0_MEM_FRM_DATA1r_CLR
#define MEM_FRM_DATA1r_SET BCM6300_A0_MEM_FRM_DATA1r_SET
#define MEM_FRM_DATA1r_GET BCM6300_A0_MEM_FRM_DATA1r_GET
#define MEM_FRM_DATA1r_MEM_DATAf_GET BCM6300_A0_MEM_FRM_DATA1r_MEM_DATAf_GET
#define MEM_FRM_DATA1r_MEM_DATAf_SET BCM6300_A0_MEM_FRM_DATA1r_MEM_DATAf_SET
#define READ_MEM_FRM_DATA1r BCM6300_A0_READ_MEM_FRM_DATA1r
#define WRITE_MEM_FRM_DATA1r BCM6300_A0_WRITE_MEM_FRM_DATA1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_MEM_FRM_DATA1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  MEM_FRM_DATA2
 * BLOCKS:   SYS
 * DESC:     Frame Memory Data 3st Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DATA         Specifies the data to write or provides the read data from the Frame memory[191:128].
 *
 ******************************************************************************/
#define BCM6300_A0_MEM_FRM_DATA2r 0x00000822

#define BCM6300_A0_MEM_FRM_DATA2r_SIZE 8

/*
 * This structure should be used to declare and program MEM_FRM_DATA2.
 *
 */
typedef union BCM6300_A0_MEM_FRM_DATA2r_s {
	uint32_t v[2];
	uint32_t mem_frm_data2[2];
	uint32_t _mem_frm_data2;
} BCM6300_A0_MEM_FRM_DATA2r_t;

#define BCM6300_A0_MEM_FRM_DATA2r_CLR(r) CDK_MEMSET(&((r)._mem_frm_data2), 0, sizeof(BCM6300_A0_MEM_FRM_DATA2r_t))
#define BCM6300_A0_MEM_FRM_DATA2r_SET(r,i,d) (r).mem_frm_data2[i] = d
#define BCM6300_A0_MEM_FRM_DATA2r_GET(r,i) (r).mem_frm_data2[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_MEM_FRM_DATA2r_MEM_DATAf_GET(r,a) cdk_field_get((r).mem_frm_data2,0,63,a)
#define BCM6300_A0_MEM_FRM_DATA2r_MEM_DATAf_SET(r,a) cdk_field_set((r).mem_frm_data2,0,63,a)

/*
 * These macros can be used to access MEM_FRM_DATA2.
 *
 */
#define BCM6300_A0_READ_MEM_FRM_DATA2r(u,r) cdk_robo_reg_read(u,BCM6300_A0_MEM_FRM_DATA2r,(r._mem_frm_data2),8)
#define BCM6300_A0_WRITE_MEM_FRM_DATA2r(u,r) cdk_robo_reg_write(u,BCM6300_A0_MEM_FRM_DATA2r,&(r._mem_frm_data2),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_FRM_DATA2r BCM6300_A0_MEM_FRM_DATA2r
#define MEM_FRM_DATA2r_SIZE BCM6300_A0_MEM_FRM_DATA2r_SIZE
typedef BCM6300_A0_MEM_FRM_DATA2r_t MEM_FRM_DATA2r_t;
#define MEM_FRM_DATA2r_CLR BCM6300_A0_MEM_FRM_DATA2r_CLR
#define MEM_FRM_DATA2r_SET BCM6300_A0_MEM_FRM_DATA2r_SET
#define MEM_FRM_DATA2r_GET BCM6300_A0_MEM_FRM_DATA2r_GET
#define MEM_FRM_DATA2r_MEM_DATAf_GET BCM6300_A0_MEM_FRM_DATA2r_MEM_DATAf_GET
#define MEM_FRM_DATA2r_MEM_DATAf_SET BCM6300_A0_MEM_FRM_DATA2r_MEM_DATAf_SET
#define READ_MEM_FRM_DATA2r BCM6300_A0_READ_MEM_FRM_DATA2r
#define WRITE_MEM_FRM_DATA2r BCM6300_A0_WRITE_MEM_FRM_DATA2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_MEM_FRM_DATA2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  MEM_FRM_DATA3
 * BLOCKS:   SYS
 * DESC:     Frame Memory Data 4th Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DATA         Specifies the data to write or provides the read data from the Frame memory[255:192].
 *
 ******************************************************************************/
#define BCM6300_A0_MEM_FRM_DATA3r 0x0000082a

#define BCM6300_A0_MEM_FRM_DATA3r_SIZE 8

/*
 * This structure should be used to declare and program MEM_FRM_DATA3.
 *
 */
typedef union BCM6300_A0_MEM_FRM_DATA3r_s {
	uint32_t v[2];
	uint32_t mem_frm_data3[2];
	uint32_t _mem_frm_data3;
} BCM6300_A0_MEM_FRM_DATA3r_t;

#define BCM6300_A0_MEM_FRM_DATA3r_CLR(r) CDK_MEMSET(&((r)._mem_frm_data3), 0, sizeof(BCM6300_A0_MEM_FRM_DATA3r_t))
#define BCM6300_A0_MEM_FRM_DATA3r_SET(r,i,d) (r).mem_frm_data3[i] = d
#define BCM6300_A0_MEM_FRM_DATA3r_GET(r,i) (r).mem_frm_data3[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_MEM_FRM_DATA3r_MEM_DATAf_GET(r,a) cdk_field_get((r).mem_frm_data3,0,63,a)
#define BCM6300_A0_MEM_FRM_DATA3r_MEM_DATAf_SET(r,a) cdk_field_set((r).mem_frm_data3,0,63,a)

/*
 * These macros can be used to access MEM_FRM_DATA3.
 *
 */
#define BCM6300_A0_READ_MEM_FRM_DATA3r(u,r) cdk_robo_reg_read(u,BCM6300_A0_MEM_FRM_DATA3r,(r._mem_frm_data3),8)
#define BCM6300_A0_WRITE_MEM_FRM_DATA3r(u,r) cdk_robo_reg_write(u,BCM6300_A0_MEM_FRM_DATA3r,&(r._mem_frm_data3),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_FRM_DATA3r BCM6300_A0_MEM_FRM_DATA3r
#define MEM_FRM_DATA3r_SIZE BCM6300_A0_MEM_FRM_DATA3r_SIZE
typedef BCM6300_A0_MEM_FRM_DATA3r_t MEM_FRM_DATA3r_t;
#define MEM_FRM_DATA3r_CLR BCM6300_A0_MEM_FRM_DATA3r_CLR
#define MEM_FRM_DATA3r_SET BCM6300_A0_MEM_FRM_DATA3r_SET
#define MEM_FRM_DATA3r_GET BCM6300_A0_MEM_FRM_DATA3r_GET
#define MEM_FRM_DATA3r_MEM_DATAf_GET BCM6300_A0_MEM_FRM_DATA3r_MEM_DATAf_GET
#define MEM_FRM_DATA3r_MEM_DATAf_SET BCM6300_A0_MEM_FRM_DATA3r_MEM_DATAf_SET
#define READ_MEM_FRM_DATA3r BCM6300_A0_READ_MEM_FRM_DATA3r
#define WRITE_MEM_FRM_DATA3r BCM6300_A0_WRITE_MEM_FRM_DATA3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_MEM_FRM_DATA3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  MEM_TEST_CTL
 * BLOCKS:   SYS
 * DESC:     Memory Test Control Registrer
 * SIZE:     8
 * FIELDS:
 *     CCM_R            Memory Test Pin.
 *     RM_R             Memory Test Pin.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_MEM_TEST_CTLr 0x000000e0

#define BCM6300_A0_MEM_TEST_CTLr_SIZE 1

/*
 * This structure should be used to declare and program MEM_TEST_CTL.
 *
 */
typedef union BCM6300_A0_MEM_TEST_CTLr_s {
	uint32_t v[1];
	uint32_t mem_test_ctl[1];
	uint32_t _mem_test_ctl;
} BCM6300_A0_MEM_TEST_CTLr_t;

#define BCM6300_A0_MEM_TEST_CTLr_CLR(r) (r).mem_test_ctl[0] = 0
#define BCM6300_A0_MEM_TEST_CTLr_SET(r,d) (r).mem_test_ctl[0] = d
#define BCM6300_A0_MEM_TEST_CTLr_GET(r) (r).mem_test_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_MEM_TEST_CTLr_CCM_Rf_GET(r) (((r).mem_test_ctl[0]) & 0x1)
#define BCM6300_A0_MEM_TEST_CTLr_CCM_Rf_SET(r,f) (r).mem_test_ctl[0]=(((r).mem_test_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM6300_A0_MEM_TEST_CTLr_RM_Rf_GET(r) ((((r).mem_test_ctl[0]) >> 1) & 0x1)
#define BCM6300_A0_MEM_TEST_CTLr_RM_Rf_SET(r,f) (r).mem_test_ctl[0]=(((r).mem_test_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM6300_A0_MEM_TEST_CTLr_RESERVED_Rf_GET(r) ((((r).mem_test_ctl[0]) >> 2) & 0x3f)
#define BCM6300_A0_MEM_TEST_CTLr_RESERVED_Rf_SET(r,f) (r).mem_test_ctl[0]=(((r).mem_test_ctl[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))

/*
 * These macros can be used to access MEM_TEST_CTL.
 *
 */
#define BCM6300_A0_READ_MEM_TEST_CTLr(u,r) cdk_robo_reg_read(u,BCM6300_A0_MEM_TEST_CTLr,(r._mem_test_ctl),1)
#define BCM6300_A0_WRITE_MEM_TEST_CTLr(u,r) cdk_robo_reg_write(u,BCM6300_A0_MEM_TEST_CTLr,&(r._mem_test_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_TEST_CTLr BCM6300_A0_MEM_TEST_CTLr
#define MEM_TEST_CTLr_SIZE BCM6300_A0_MEM_TEST_CTLr_SIZE
typedef BCM6300_A0_MEM_TEST_CTLr_t MEM_TEST_CTLr_t;
#define MEM_TEST_CTLr_CLR BCM6300_A0_MEM_TEST_CTLr_CLR
#define MEM_TEST_CTLr_SET BCM6300_A0_MEM_TEST_CTLr_SET
#define MEM_TEST_CTLr_GET BCM6300_A0_MEM_TEST_CTLr_GET
#define MEM_TEST_CTLr_CCM_Rf_GET BCM6300_A0_MEM_TEST_CTLr_CCM_Rf_GET
#define MEM_TEST_CTLr_CCM_Rf_SET BCM6300_A0_MEM_TEST_CTLr_CCM_Rf_SET
#define MEM_TEST_CTLr_RM_Rf_GET BCM6300_A0_MEM_TEST_CTLr_RM_Rf_GET
#define MEM_TEST_CTLr_RM_Rf_SET BCM6300_A0_MEM_TEST_CTLr_RM_Rf_SET
#define MEM_TEST_CTLr_RESERVED_Rf_GET BCM6300_A0_MEM_TEST_CTLr_RESERVED_Rf_GET
#define MEM_TEST_CTLr_RESERVED_Rf_SET BCM6300_A0_MEM_TEST_CTLr_RESERVED_Rf_SET
#define READ_MEM_TEST_CTLr BCM6300_A0_READ_MEM_TEST_CTLr
#define WRITE_MEM_TEST_CTLr BCM6300_A0_WRITE_MEM_TEST_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_MEM_TEST_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  MIB_GD_FM_MAX_SIZE
 * BLOCKS:   SYS
 * DESC:     Jumbo MIB Good Frame Max Size Registers
 * SIZE:     16
 * FIELDS:
 *     MAX_SIZE         Good Frame Max Size.The Register defines the Good Frame Max Size for MIB counter.The Register should be in the range d9724 ~ d1518 Good Frame Length Range in MIBTagged Packets : (Good Frame Max Size + 4) ~ 64 bytesUntagged Packets : Good Frame Max Size ~ 64 bytesThe Register setting will affect those MIB counting includingin RxSAChangeRxGoodOctetsRxUnicastPktsRxMulticastPktsRxBroadcastPktsRxOverSizePkts 
 *     RESERVED_R       Reserved.                
 *
 ******************************************************************************/
#define BCM6300_A0_MIB_GD_FM_MAX_SIZEr 0x00004008

#define BCM6300_A0_MIB_GD_FM_MAX_SIZEr_SIZE 2

/*
 * This structure should be used to declare and program MIB_GD_FM_MAX_SIZE.
 *
 */
typedef union BCM6300_A0_MIB_GD_FM_MAX_SIZEr_s {
	uint32_t v[1];
	uint32_t mib_gd_fm_max_size[1];
	uint32_t _mib_gd_fm_max_size;
} BCM6300_A0_MIB_GD_FM_MAX_SIZEr_t;

#define BCM6300_A0_MIB_GD_FM_MAX_SIZEr_CLR(r) (r).mib_gd_fm_max_size[0] = 0
#define BCM6300_A0_MIB_GD_FM_MAX_SIZEr_SET(r,d) (r).mib_gd_fm_max_size[0] = d
#define BCM6300_A0_MIB_GD_FM_MAX_SIZEr_GET(r) (r).mib_gd_fm_max_size[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_MIB_GD_FM_MAX_SIZEr_MAX_SIZEf_GET(r) (((r).mib_gd_fm_max_size[0]) & 0x3fff)
#define BCM6300_A0_MIB_GD_FM_MAX_SIZEr_MAX_SIZEf_SET(r,f) (r).mib_gd_fm_max_size[0]=(((r).mib_gd_fm_max_size[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM6300_A0_MIB_GD_FM_MAX_SIZEr_RESERVED_Rf_GET(r) ((((r).mib_gd_fm_max_size[0]) >> 14) & 0x3)
#define BCM6300_A0_MIB_GD_FM_MAX_SIZEr_RESERVED_Rf_SET(r,f) (r).mib_gd_fm_max_size[0]=(((r).mib_gd_fm_max_size[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access MIB_GD_FM_MAX_SIZE.
 *
 */
#define BCM6300_A0_READ_MIB_GD_FM_MAX_SIZEr(u,r) cdk_robo_reg_read(u,BCM6300_A0_MIB_GD_FM_MAX_SIZEr,(r._mib_gd_fm_max_size),2)
#define BCM6300_A0_WRITE_MIB_GD_FM_MAX_SIZEr(u,r) cdk_robo_reg_write(u,BCM6300_A0_MIB_GD_FM_MAX_SIZEr,&(r._mib_gd_fm_max_size),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIB_GD_FM_MAX_SIZEr BCM6300_A0_MIB_GD_FM_MAX_SIZEr
#define MIB_GD_FM_MAX_SIZEr_SIZE BCM6300_A0_MIB_GD_FM_MAX_SIZEr_SIZE
typedef BCM6300_A0_MIB_GD_FM_MAX_SIZEr_t MIB_GD_FM_MAX_SIZEr_t;
#define MIB_GD_FM_MAX_SIZEr_CLR BCM6300_A0_MIB_GD_FM_MAX_SIZEr_CLR
#define MIB_GD_FM_MAX_SIZEr_SET BCM6300_A0_MIB_GD_FM_MAX_SIZEr_SET
#define MIB_GD_FM_MAX_SIZEr_GET BCM6300_A0_MIB_GD_FM_MAX_SIZEr_GET
#define MIB_GD_FM_MAX_SIZEr_MAX_SIZEf_GET BCM6300_A0_MIB_GD_FM_MAX_SIZEr_MAX_SIZEf_GET
#define MIB_GD_FM_MAX_SIZEr_MAX_SIZEf_SET BCM6300_A0_MIB_GD_FM_MAX_SIZEr_MAX_SIZEf_SET
#define MIB_GD_FM_MAX_SIZEr_RESERVED_Rf_GET BCM6300_A0_MIB_GD_FM_MAX_SIZEr_RESERVED_Rf_GET
#define MIB_GD_FM_MAX_SIZEr_RESERVED_Rf_SET BCM6300_A0_MIB_GD_FM_MAX_SIZEr_RESERVED_Rf_SET
#define READ_MIB_GD_FM_MAX_SIZEr BCM6300_A0_READ_MIB_GD_FM_MAX_SIZEr
#define WRITE_MIB_GD_FM_MAX_SIZEr BCM6300_A0_WRITE_MIB_GD_FM_MAX_SIZEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_MIB_GD_FM_MAX_SIZEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  MIB_SNAPSHOT_CTL
 * BLOCKS:   SYS
 * DESC:     Loop Detection Configuration Registers
 * SIZE:     8
 * FIELDS:
 *     SNAPSHOT_PORT    Port munber for MIB snapshot function.
 *     RESERVED_R       
 *     SNAPSHOT_MIRROR  1'b1 : enable read address to port MIB, but from MIB snapshot memory.1'b0 : enable to read from port MIB memory.
 *     SNAPSHOT_STDONE  Write 1'b1 to initiate MIB snapshot access clear to 1'b0 when MIB snapshot access is done.
 *
 ******************************************************************************/
#define BCM6300_A0_MIB_SNAPSHOT_CTLr 0x00007000

#define BCM6300_A0_MIB_SNAPSHOT_CTLr_SIZE 1

/*
 * This structure should be used to declare and program MIB_SNAPSHOT_CTL.
 *
 */
typedef union BCM6300_A0_MIB_SNAPSHOT_CTLr_s {
	uint32_t v[1];
	uint32_t mib_snapshot_ctl[1];
	uint32_t _mib_snapshot_ctl;
} BCM6300_A0_MIB_SNAPSHOT_CTLr_t;

#define BCM6300_A0_MIB_SNAPSHOT_CTLr_CLR(r) (r).mib_snapshot_ctl[0] = 0
#define BCM6300_A0_MIB_SNAPSHOT_CTLr_SET(r,d) (r).mib_snapshot_ctl[0] = d
#define BCM6300_A0_MIB_SNAPSHOT_CTLr_GET(r) (r).mib_snapshot_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_GET(r) (((r).mib_snapshot_ctl[0]) & 0xf)
#define BCM6300_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_SET(r,f) (r).mib_snapshot_ctl[0]=(((r).mib_snapshot_ctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM6300_A0_MIB_SNAPSHOT_CTLr_RESERVED_Rf_GET(r) ((((r).mib_snapshot_ctl[0]) >> 4) & 0x3)
#define BCM6300_A0_MIB_SNAPSHOT_CTLr_RESERVED_Rf_SET(r,f) (r).mib_snapshot_ctl[0]=(((r).mib_snapshot_ctl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM6300_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_GET(r) ((((r).mib_snapshot_ctl[0]) >> 6) & 0x1)
#define BCM6300_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_SET(r,f) (r).mib_snapshot_ctl[0]=(((r).mib_snapshot_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM6300_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_STDONEf_GET(r) ((((r).mib_snapshot_ctl[0]) >> 7) & 0x1)
#define BCM6300_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_STDONEf_SET(r,f) (r).mib_snapshot_ctl[0]=(((r).mib_snapshot_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access MIB_SNAPSHOT_CTL.
 *
 */
#define BCM6300_A0_READ_MIB_SNAPSHOT_CTLr(u,r) cdk_robo_reg_read(u,BCM6300_A0_MIB_SNAPSHOT_CTLr,(r._mib_snapshot_ctl),1)
#define BCM6300_A0_WRITE_MIB_SNAPSHOT_CTLr(u,r) cdk_robo_reg_write(u,BCM6300_A0_MIB_SNAPSHOT_CTLr,&(r._mib_snapshot_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIB_SNAPSHOT_CTLr BCM6300_A0_MIB_SNAPSHOT_CTLr
#define MIB_SNAPSHOT_CTLr_SIZE BCM6300_A0_MIB_SNAPSHOT_CTLr_SIZE
typedef BCM6300_A0_MIB_SNAPSHOT_CTLr_t MIB_SNAPSHOT_CTLr_t;
#define MIB_SNAPSHOT_CTLr_CLR BCM6300_A0_MIB_SNAPSHOT_CTLr_CLR
#define MIB_SNAPSHOT_CTLr_SET BCM6300_A0_MIB_SNAPSHOT_CTLr_SET
#define MIB_SNAPSHOT_CTLr_GET BCM6300_A0_MIB_SNAPSHOT_CTLr_GET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_GET BCM6300_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_GET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_SET BCM6300_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_SET
#define MIB_SNAPSHOT_CTLr_RESERVED_Rf_GET BCM6300_A0_MIB_SNAPSHOT_CTLr_RESERVED_Rf_GET
#define MIB_SNAPSHOT_CTLr_RESERVED_Rf_SET BCM6300_A0_MIB_SNAPSHOT_CTLr_RESERVED_Rf_SET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_GET BCM6300_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_GET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_SET BCM6300_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_SET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_STDONEf_GET BCM6300_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_STDONEf_GET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_STDONEf_SET BCM6300_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_STDONEf_SET
#define READ_MIB_SNAPSHOT_CTLr BCM6300_A0_READ_MIB_SNAPSHOT_CTLr
#define WRITE_MIB_SNAPSHOT_CTLr BCM6300_A0_WRITE_MIB_SNAPSHOT_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_MIB_SNAPSHOT_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  MIICTL
 * BLOCKS:   GPIC0
 * DESC:     MII Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_R       Ignore when read.
 *     DUPLEX_MOD       1\'b1: Full Duplex.1\'b0: Half Duplex.
 *     RE_AN            1\'b1: Restart Auto-Negotiation process.1\'b0: Normal operation.
 *     ISOLATE          1\'b1: Electrically isolate PHY from MII 0.1\'b0: Normal operation.
 *     PWR_DOWN         1\'b0:Normal operation.
 *     AN_EN            1\'b1: Auto-Negotiation Enable.1\'b0: Auto-Negotiation disable.
 *     F_SPD_SEL        1\'b1: 100 Mbps1\'b0: 10 Mbps.
 *     LOOPBACK         1\'b1: Loopback mode.1\'b0: Normal operation.
 *     RESET_R          1\'b1: PHY reset.1\'b0: Normal operation.
 *
 ******************************************************************************/
#define BCM6300_A0_MIICTLr 0x00001000

#define BCM6300_A0_MIICTLr_SIZE 2

/*
 * This structure should be used to declare and program MIICTL.
 *
 */
typedef union BCM6300_A0_MIICTLr_s {
	uint32_t v[1];
	uint32_t miictl[1];
	uint32_t _miictl;
} BCM6300_A0_MIICTLr_t;

#define BCM6300_A0_MIICTLr_CLR(r) (r).miictl[0] = 0
#define BCM6300_A0_MIICTLr_SET(r,d) (r).miictl[0] = d
#define BCM6300_A0_MIICTLr_GET(r) (r).miictl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_MIICTLr_RESERVED_Rf_GET(r) (((r).miictl[0]) & 0xff)
#define BCM6300_A0_MIICTLr_RESERVED_Rf_SET(r,f) (r).miictl[0]=(((r).miictl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM6300_A0_MIICTLr_DUPLEX_MODf_GET(r) ((((r).miictl[0]) >> 8) & 0x1)
#define BCM6300_A0_MIICTLr_DUPLEX_MODf_SET(r,f) (r).miictl[0]=(((r).miictl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM6300_A0_MIICTLr_RE_ANf_GET(r) ((((r).miictl[0]) >> 9) & 0x1)
#define BCM6300_A0_MIICTLr_RE_ANf_SET(r,f) (r).miictl[0]=(((r).miictl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM6300_A0_MIICTLr_ISOLATEf_GET(r) ((((r).miictl[0]) >> 10) & 0x1)
#define BCM6300_A0_MIICTLr_ISOLATEf_SET(r,f) (r).miictl[0]=(((r).miictl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM6300_A0_MIICTLr_PWR_DOWNf_GET(r) ((((r).miictl[0]) >> 11) & 0x1)
#define BCM6300_A0_MIICTLr_PWR_DOWNf_SET(r,f) (r).miictl[0]=(((r).miictl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM6300_A0_MIICTLr_AN_ENf_GET(r) ((((r).miictl[0]) >> 12) & 0x1)
#define BCM6300_A0_MIICTLr_AN_ENf_SET(r,f) (r).miictl[0]=(((r).miictl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM6300_A0_MIICTLr_F_SPD_SELf_GET(r) ((((r).miictl[0]) >> 13) & 0x1)
#define BCM6300_A0_MIICTLr_F_SPD_SELf_SET(r,f) (r).miictl[0]=(((r).miictl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM6300_A0_MIICTLr_LOOPBACKf_GET(r) ((((r).miictl[0]) >> 14) & 0x1)
#define BCM6300_A0_MIICTLr_LOOPBACKf_SET(r,f) (r).miictl[0]=(((r).miictl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM6300_A0_MIICTLr_RESET_Rf_GET(r) ((((r).miictl[0]) >> 15) & 0x1)
#define BCM6300_A0_MIICTLr_RESET_Rf_SET(r,f) (r).miictl[0]=(((r).miictl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MIICTL.
 *
 */
#define BCM6300_A0_READ_MIICTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_MIICTLr,(r._miictl),2)
#define BCM6300_A0_WRITE_MIICTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_MIICTLr,&(r._miictl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIICTLr BCM6300_A0_MIICTLr
#define MIICTLr_SIZE BCM6300_A0_MIICTLr_SIZE
typedef BCM6300_A0_MIICTLr_t MIICTLr_t;
#define MIICTLr_CLR BCM6300_A0_MIICTLr_CLR
#define MIICTLr_SET BCM6300_A0_MIICTLr_SET
#define MIICTLr_GET BCM6300_A0_MIICTLr_GET
#define MIICTLr_RESERVED_Rf_GET BCM6300_A0_MIICTLr_RESERVED_Rf_GET
#define MIICTLr_RESERVED_Rf_SET BCM6300_A0_MIICTLr_RESERVED_Rf_SET
#define MIICTLr_DUPLEX_MODf_GET BCM6300_A0_MIICTLr_DUPLEX_MODf_GET
#define MIICTLr_DUPLEX_MODf_SET BCM6300_A0_MIICTLr_DUPLEX_MODf_SET
#define MIICTLr_RE_ANf_GET BCM6300_A0_MIICTLr_RE_ANf_GET
#define MIICTLr_RE_ANf_SET BCM6300_A0_MIICTLr_RE_ANf_SET
#define MIICTLr_ISOLATEf_GET BCM6300_A0_MIICTLr_ISOLATEf_GET
#define MIICTLr_ISOLATEf_SET BCM6300_A0_MIICTLr_ISOLATEf_SET
#define MIICTLr_PWR_DOWNf_GET BCM6300_A0_MIICTLr_PWR_DOWNf_GET
#define MIICTLr_PWR_DOWNf_SET BCM6300_A0_MIICTLr_PWR_DOWNf_SET
#define MIICTLr_AN_ENf_GET BCM6300_A0_MIICTLr_AN_ENf_GET
#define MIICTLr_AN_ENf_SET BCM6300_A0_MIICTLr_AN_ENf_SET
#define MIICTLr_F_SPD_SELf_GET BCM6300_A0_MIICTLr_F_SPD_SELf_GET
#define MIICTLr_F_SPD_SELf_SET BCM6300_A0_MIICTLr_F_SPD_SELf_SET
#define MIICTLr_LOOPBACKf_GET BCM6300_A0_MIICTLr_LOOPBACKf_GET
#define MIICTLr_LOOPBACKf_SET BCM6300_A0_MIICTLr_LOOPBACKf_SET
#define MIICTLr_RESET_Rf_GET BCM6300_A0_MIICTLr_RESET_Rf_GET
#define MIICTLr_RESET_Rf_SET BCM6300_A0_MIICTLr_RESET_Rf_SET
#define READ_MIICTLr BCM6300_A0_READ_MIICTLr
#define WRITE_MIICTLr BCM6300_A0_WRITE_MIICTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_MIICTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  MIISTS
 * BLOCKS:   GPIC0
 * DESC:     MII Status Register
 * SIZE:     16
 * FIELDS:
 *     EXT_CAP          
 *     JABBER_DET       
 *     LINK_STA         
 *     AUTO_NEGO_CAP    
 *     REMOTE_FAULT_R   
 *     AUTO_NEGO_COMP   
 *     MF_PRE_SUP       
 *     RESERVED_R       Reserved
 *     B10T_CAP         
 *     B10T_FDX_CAP     
 *     B100TX_CAP       
 *     B100TX_FDX_CAP   
 *     B100T4_CAP       
 *
 ******************************************************************************/
#define BCM6300_A0_MIISTSr 0x00001002

#define BCM6300_A0_MIISTSr_SIZE 2

/*
 * This structure should be used to declare and program MIISTS.
 *
 */
typedef union BCM6300_A0_MIISTSr_s {
	uint32_t v[1];
	uint32_t miists[1];
	uint32_t _miists;
} BCM6300_A0_MIISTSr_t;

#define BCM6300_A0_MIISTSr_CLR(r) (r).miists[0] = 0
#define BCM6300_A0_MIISTSr_SET(r,d) (r).miists[0] = d
#define BCM6300_A0_MIISTSr_GET(r) (r).miists[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_MIISTSr_EXT_CAPf_GET(r) (((r).miists[0]) & 0x1)
#define BCM6300_A0_MIISTSr_EXT_CAPf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM6300_A0_MIISTSr_JABBER_DETf_GET(r) ((((r).miists[0]) >> 1) & 0x1)
#define BCM6300_A0_MIISTSr_JABBER_DETf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM6300_A0_MIISTSr_LINK_STAf_GET(r) ((((r).miists[0]) >> 2) & 0x1)
#define BCM6300_A0_MIISTSr_LINK_STAf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM6300_A0_MIISTSr_AUTO_NEGO_CAPf_GET(r) ((((r).miists[0]) >> 3) & 0x1)
#define BCM6300_A0_MIISTSr_AUTO_NEGO_CAPf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM6300_A0_MIISTSr_REMOTE_FAULT_Rf_GET(r) ((((r).miists[0]) >> 4) & 0x1)
#define BCM6300_A0_MIISTSr_REMOTE_FAULT_Rf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM6300_A0_MIISTSr_AUTO_NEGO_COMPf_GET(r) ((((r).miists[0]) >> 5) & 0x1)
#define BCM6300_A0_MIISTSr_AUTO_NEGO_COMPf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM6300_A0_MIISTSr_MF_PRE_SUPf_GET(r) ((((r).miists[0]) >> 6) & 0x1)
#define BCM6300_A0_MIISTSr_MF_PRE_SUPf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM6300_A0_MIISTSr_RESERVED_Rf_GET(r) ((((r).miists[0]) >> 7) & 0xf)
#define BCM6300_A0_MIISTSr_RESERVED_Rf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0xf << 7)) | ((((uint32_t)f) & 0xf) << 7))
#define BCM6300_A0_MIISTSr_B10T_CAPf_GET(r) ((((r).miists[0]) >> 11) & 0x1)
#define BCM6300_A0_MIISTSr_B10T_CAPf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM6300_A0_MIISTSr_B10T_FDX_CAPf_GET(r) ((((r).miists[0]) >> 12) & 0x1)
#define BCM6300_A0_MIISTSr_B10T_FDX_CAPf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM6300_A0_MIISTSr_B100TX_CAPf_GET(r) ((((r).miists[0]) >> 13) & 0x1)
#define BCM6300_A0_MIISTSr_B100TX_CAPf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM6300_A0_MIISTSr_B100TX_FDX_CAPf_GET(r) ((((r).miists[0]) >> 14) & 0x1)
#define BCM6300_A0_MIISTSr_B100TX_FDX_CAPf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM6300_A0_MIISTSr_B100T4_CAPf_GET(r) ((((r).miists[0]) >> 15) & 0x1)
#define BCM6300_A0_MIISTSr_B100T4_CAPf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MIISTS.
 *
 */
#define BCM6300_A0_READ_MIISTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_MIISTSr,(r._miists),2)
#define BCM6300_A0_WRITE_MIISTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_MIISTSr,&(r._miists),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIISTSr BCM6300_A0_MIISTSr
#define MIISTSr_SIZE BCM6300_A0_MIISTSr_SIZE
typedef BCM6300_A0_MIISTSr_t MIISTSr_t;
#define MIISTSr_CLR BCM6300_A0_MIISTSr_CLR
#define MIISTSr_SET BCM6300_A0_MIISTSr_SET
#define MIISTSr_GET BCM6300_A0_MIISTSr_GET
#define MIISTSr_EXT_CAPf_GET BCM6300_A0_MIISTSr_EXT_CAPf_GET
#define MIISTSr_EXT_CAPf_SET BCM6300_A0_MIISTSr_EXT_CAPf_SET
#define MIISTSr_JABBER_DETf_GET BCM6300_A0_MIISTSr_JABBER_DETf_GET
#define MIISTSr_JABBER_DETf_SET BCM6300_A0_MIISTSr_JABBER_DETf_SET
#define MIISTSr_LINK_STAf_GET BCM6300_A0_MIISTSr_LINK_STAf_GET
#define MIISTSr_LINK_STAf_SET BCM6300_A0_MIISTSr_LINK_STAf_SET
#define MIISTSr_AUTO_NEGO_CAPf_GET BCM6300_A0_MIISTSr_AUTO_NEGO_CAPf_GET
#define MIISTSr_AUTO_NEGO_CAPf_SET BCM6300_A0_MIISTSr_AUTO_NEGO_CAPf_SET
#define MIISTSr_REMOTE_FAULT_Rf_GET BCM6300_A0_MIISTSr_REMOTE_FAULT_Rf_GET
#define MIISTSr_REMOTE_FAULT_Rf_SET BCM6300_A0_MIISTSr_REMOTE_FAULT_Rf_SET
#define MIISTSr_AUTO_NEGO_COMPf_GET BCM6300_A0_MIISTSr_AUTO_NEGO_COMPf_GET
#define MIISTSr_AUTO_NEGO_COMPf_SET BCM6300_A0_MIISTSr_AUTO_NEGO_COMPf_SET
#define MIISTSr_MF_PRE_SUPf_GET BCM6300_A0_MIISTSr_MF_PRE_SUPf_GET
#define MIISTSr_MF_PRE_SUPf_SET BCM6300_A0_MIISTSr_MF_PRE_SUPf_SET
#define MIISTSr_RESERVED_Rf_GET BCM6300_A0_MIISTSr_RESERVED_Rf_GET
#define MIISTSr_RESERVED_Rf_SET BCM6300_A0_MIISTSr_RESERVED_Rf_SET
#define MIISTSr_B10T_CAPf_GET BCM6300_A0_MIISTSr_B10T_CAPf_GET
#define MIISTSr_B10T_CAPf_SET BCM6300_A0_MIISTSr_B10T_CAPf_SET
#define MIISTSr_B10T_FDX_CAPf_GET BCM6300_A0_MIISTSr_B10T_FDX_CAPf_GET
#define MIISTSr_B10T_FDX_CAPf_SET BCM6300_A0_MIISTSr_B10T_FDX_CAPf_SET
#define MIISTSr_B100TX_CAPf_GET BCM6300_A0_MIISTSr_B100TX_CAPf_GET
#define MIISTSr_B100TX_CAPf_SET BCM6300_A0_MIISTSr_B100TX_CAPf_SET
#define MIISTSr_B100TX_FDX_CAPf_GET BCM6300_A0_MIISTSr_B100TX_FDX_CAPf_GET
#define MIISTSr_B100TX_FDX_CAPf_SET BCM6300_A0_MIISTSr_B100TX_FDX_CAPf_SET
#define MIISTSr_B100T4_CAPf_GET BCM6300_A0_MIISTSr_B100T4_CAPf_GET
#define MIISTSr_B100T4_CAPf_SET BCM6300_A0_MIISTSr_B100T4_CAPf_SET
#define READ_MIISTSr BCM6300_A0_READ_MIISTSr
#define WRITE_MIISTSr BCM6300_A0_WRITE_MIISTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_MIISTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  MII_PCTL
 * BLOCKS:   CPIC
 * DESC:     10/100/1000 IMP Port Control Register
 * SIZE:     8
 * FIELDS:
 *     MIRX_DIS         Disables the receive function of the port at the MAC levelnot release for custom.
 *     MITX_DIS         Disables the transmit function of the port at the MAC levelnot release for custom.
 *     MIRX_BC_EN       Receive Broadcast Enable.Enables the receipt of broadcast frames on the IMP, when the IMP is configured as the Frame Management Port.When cleared, multicast frames that meet the Mirror Ingree/Egress Rules will still be forwarded to the Frame Management Port.Ignored if the IMP is not selected as the Frame Management Port.
 *     MIRX_MC_EN       Receive Multicast Enable.Enables the receipt of multicast frames on the IMP, when the IMP is configured as the Frame Management Port, and the frame was flodded due to no matching address table entry.When cleared, multicast frames that meet the Mirror Ingree/Egress Rules will still be forwarded to the Frame Management Port.Ignored if the IMP is not selected as the Frame Management Port.
 *     MIRX_UC_EN       Receive Unicast Enable.Enables the receipt of unicast frames on the IMP, when the IMP is configured as the Frame Management Port, and the frame was flooded due to no matching address table entry.When cleared, unicast frames that meet the Mirror Ingree/Egress Rules will still be forwarded to the Frame Management Port.Ignored if the IMP is not selected as the Frame Management Port.
 *     STP_STS          Reserved. for engineer dumb/mgmt system.000 for mgmt-mode, and 001 for dumb mode.  Spanning Tree Protocol State. CPU writes the current computed states of its Spanning Tree Algorithm for this port. 000=No Spanning Tree (default for managed mode) 001=Disabled State  (default for unmanaged mode)010=Blocking State 011=Listening State 100=Learning State 101=Forwarding State 110-111=ReservedIgnored when SW_FWDG_MODE = Unmanaged.
 *
 ******************************************************************************/
#define BCM6300_A0_MII_PCTLr 0x00000008

#define BCM6300_A0_MII_PCTLr_SIZE 1

/*
 * This structure should be used to declare and program MII_PCTL.
 *
 */
typedef union BCM6300_A0_MII_PCTLr_s {
	uint32_t v[1];
	uint32_t mii_pctl[1];
	uint32_t _mii_pctl;
} BCM6300_A0_MII_PCTLr_t;

#define BCM6300_A0_MII_PCTLr_CLR(r) (r).mii_pctl[0] = 0
#define BCM6300_A0_MII_PCTLr_SET(r,d) (r).mii_pctl[0] = d
#define BCM6300_A0_MII_PCTLr_GET(r) (r).mii_pctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_MII_PCTLr_MIRX_DISf_GET(r) (((r).mii_pctl[0]) & 0x1)
#define BCM6300_A0_MII_PCTLr_MIRX_DISf_SET(r,f) (r).mii_pctl[0]=(((r).mii_pctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM6300_A0_MII_PCTLr_MITX_DISf_GET(r) ((((r).mii_pctl[0]) >> 1) & 0x1)
#define BCM6300_A0_MII_PCTLr_MITX_DISf_SET(r,f) (r).mii_pctl[0]=(((r).mii_pctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM6300_A0_MII_PCTLr_MIRX_BC_ENf_GET(r) ((((r).mii_pctl[0]) >> 2) & 0x1)
#define BCM6300_A0_MII_PCTLr_MIRX_BC_ENf_SET(r,f) (r).mii_pctl[0]=(((r).mii_pctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM6300_A0_MII_PCTLr_MIRX_MC_ENf_GET(r) ((((r).mii_pctl[0]) >> 3) & 0x1)
#define BCM6300_A0_MII_PCTLr_MIRX_MC_ENf_SET(r,f) (r).mii_pctl[0]=(((r).mii_pctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM6300_A0_MII_PCTLr_MIRX_UC_ENf_GET(r) ((((r).mii_pctl[0]) >> 4) & 0x1)
#define BCM6300_A0_MII_PCTLr_MIRX_UC_ENf_SET(r,f) (r).mii_pctl[0]=(((r).mii_pctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM6300_A0_MII_PCTLr_STP_STSf_GET(r) ((((r).mii_pctl[0]) >> 5) & 0x7)
#define BCM6300_A0_MII_PCTLr_STP_STSf_SET(r,f) (r).mii_pctl[0]=(((r).mii_pctl[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access MII_PCTL.
 *
 */
#define BCM6300_A0_READ_MII_PCTLr(u,r) cdk_robo_reg_read(u,BCM6300_A0_MII_PCTLr,(r._mii_pctl),1)
#define BCM6300_A0_WRITE_MII_PCTLr(u,r) cdk_robo_reg_write(u,BCM6300_A0_MII_PCTLr,&(r._mii_pctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MII_PCTLr BCM6300_A0_MII_PCTLr
#define MII_PCTLr_SIZE BCM6300_A0_MII_PCTLr_SIZE
typedef BCM6300_A0_MII_PCTLr_t MII_PCTLr_t;
#define MII_PCTLr_CLR BCM6300_A0_MII_PCTLr_CLR
#define MII_PCTLr_SET BCM6300_A0_MII_PCTLr_SET
#define MII_PCTLr_GET BCM6300_A0_MII_PCTLr_GET
#define MII_PCTLr_MIRX_DISf_GET BCM6300_A0_MII_PCTLr_MIRX_DISf_GET
#define MII_PCTLr_MIRX_DISf_SET BCM6300_A0_MII_PCTLr_MIRX_DISf_SET
#define MII_PCTLr_MITX_DISf_GET BCM6300_A0_MII_PCTLr_MITX_DISf_GET
#define MII_PCTLr_MITX_DISf_SET BCM6300_A0_MII_PCTLr_MITX_DISf_SET
#define MII_PCTLr_MIRX_BC_ENf_GET BCM6300_A0_MII_PCTLr_MIRX_BC_ENf_GET
#define MII_PCTLr_MIRX_BC_ENf_SET BCM6300_A0_MII_PCTLr_MIRX_BC_ENf_SET
#define MII_PCTLr_MIRX_MC_ENf_GET BCM6300_A0_MII_PCTLr_MIRX_MC_ENf_GET
#define MII_PCTLr_MIRX_MC_ENf_SET BCM6300_A0_MII_PCTLr_MIRX_MC_ENf_SET
#define MII_PCTLr_MIRX_UC_ENf_GET BCM6300_A0_MII_PCTLr_MIRX_UC_ENf_GET
#define MII_PCTLr_MIRX_UC_ENf_SET BCM6300_A0_MII_PCTLr_MIRX_UC_ENf_SET
#define MII_PCTLr_STP_STSf_GET BCM6300_A0_MII_PCTLr_STP_STSf_GET
#define MII_PCTLr_STP_STSf_SET BCM6300_A0_MII_PCTLr_STP_STSf_SET
#define READ_MII_PCTLr BCM6300_A0_READ_MII_PCTLr
#define WRITE_MII_PCTLr BCM6300_A0_WRITE_MII_PCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_MII_PCTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  MIRCAPCTL
 * BLOCKS:   SYS
 * DESC:     Mirror Capture Control Register
 * SIZE:     16
 * FIELDS:
 *     SMIR_CAP_PORT    Mirror Capture Port ID.Port ID which identifies the single unique port which is designated as the port to which all ingress and/or egress traffic is mirrored on this chip/system.
 *     SMIR_CAP_CHIP    Mirror Capture Chip ID.Shoud fixed at 0
 *     RESERVED_R       Reserved
 *     BLK_NOT_MIR      When Enabled, all traffic to Mirror_Capture_Port will be blocked except mirror traffic.
 *     MIR_EN           Global enable/disable for all mirroring on this chip.When reset, mirroring is disabled.When set, mirroring is enabled according to the ingress and egress control rules, to the port designated by the MIRROR_CAPTURE_PORT.
 *
 ******************************************************************************/
#define BCM6300_A0_MIRCAPCTLr 0x00000210

#define BCM6300_A0_MIRCAPCTLr_SIZE 2

/*
 * This structure should be used to declare and program MIRCAPCTL.
 *
 */
typedef union BCM6300_A0_MIRCAPCTLr_s {
	uint32_t v[1];
	uint32_t mircapctl[1];
	uint32_t _mircapctl;
} BCM6300_A0_MIRCAPCTLr_t;

#define BCM6300_A0_MIRCAPCTLr_CLR(r) (r).mircapctl[0] = 0
#define BCM6300_A0_MIRCAPCTLr_SET(r,d) (r).mircapctl[0] = d
#define BCM6300_A0_MIRCAPCTLr_GET(r) (r).mircapctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_MIRCAPCTLr_SMIR_CAP_PORTf_GET(r) (((r).mircapctl[0]) & 0xf)
#define BCM6300_A0_MIRCAPCTLr_SMIR_CAP_PORTf_SET(r,f) (r).mircapctl[0]=(((r).mircapctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM6300_A0_MIRCAPCTLr_SMIR_CAP_CHIPf_GET(r) ((((r).mircapctl[0]) >> 4) & 0x3)
#define BCM6300_A0_MIRCAPCTLr_SMIR_CAP_CHIPf_SET(r,f) (r).mircapctl[0]=(((r).mircapctl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM6300_A0_MIRCAPCTLr_RESERVED_Rf_GET(r) ((((r).mircapctl[0]) >> 6) & 0xff)
#define BCM6300_A0_MIRCAPCTLr_RESERVED_Rf_SET(r,f) (r).mircapctl[0]=(((r).mircapctl[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6))
#define BCM6300_A0_MIRCAPCTLr_BLK_NOT_MIRf_GET(r) ((((r).mircapctl[0]) >> 14) & 0x1)
#define BCM6300_A0_MIRCAPCTLr_BLK_NOT_MIRf_SET(r,f) (r).mircapctl[0]=(((r).mircapctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM6300_A0_MIRCAPCTLr_MIR_ENf_GET(r) ((((r).mircapctl[0]) >> 15) & 0x1)
#define BCM6300_A0_MIRCAPCTLr_MIR_ENf_SET(r,f) (r).mircapctl[0]=(((r).mircapctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MIRCAPCTL.
 *
 */
#define BCM6300_A0_READ_MIRCAPCTLr(u,r) cdk_robo_reg_read(u,BCM6300_A0_MIRCAPCTLr,(r._mircapctl),2)
#define BCM6300_A0_WRITE_MIRCAPCTLr(u,r) cdk_robo_reg_write(u,BCM6300_A0_MIRCAPCTLr,&(r._mircapctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIRCAPCTLr BCM6300_A0_MIRCAPCTLr
#define MIRCAPCTLr_SIZE BCM6300_A0_MIRCAPCTLr_SIZE
typedef BCM6300_A0_MIRCAPCTLr_t MIRCAPCTLr_t;
#define MIRCAPCTLr_CLR BCM6300_A0_MIRCAPCTLr_CLR
#define MIRCAPCTLr_SET BCM6300_A0_MIRCAPCTLr_SET
#define MIRCAPCTLr_GET BCM6300_A0_MIRCAPCTLr_GET
#define MIRCAPCTLr_SMIR_CAP_PORTf_GET BCM6300_A0_MIRCAPCTLr_SMIR_CAP_PORTf_GET
#define MIRCAPCTLr_SMIR_CAP_PORTf_SET BCM6300_A0_MIRCAPCTLr_SMIR_CAP_PORTf_SET
#define MIRCAPCTLr_SMIR_CAP_CHIPf_GET BCM6300_A0_MIRCAPCTLr_SMIR_CAP_CHIPf_GET
#define MIRCAPCTLr_SMIR_CAP_CHIPf_SET BCM6300_A0_MIRCAPCTLr_SMIR_CAP_CHIPf_SET
#define MIRCAPCTLr_RESERVED_Rf_GET BCM6300_A0_MIRCAPCTLr_RESERVED_Rf_GET
#define MIRCAPCTLr_RESERVED_Rf_SET BCM6300_A0_MIRCAPCTLr_RESERVED_Rf_SET
#define MIRCAPCTLr_BLK_NOT_MIRf_GET BCM6300_A0_MIRCAPCTLr_BLK_NOT_MIRf_GET
#define MIRCAPCTLr_BLK_NOT_MIRf_SET BCM6300_A0_MIRCAPCTLr_BLK_NOT_MIRf_SET
#define MIRCAPCTLr_MIR_ENf_GET BCM6300_A0_MIRCAPCTLr_MIR_ENf_GET
#define MIRCAPCTLr_MIR_ENf_SET BCM6300_A0_MIRCAPCTLr_MIR_ENf_SET
#define READ_MIRCAPCTLr BCM6300_A0_READ_MIRCAPCTLr
#define WRITE_MIRCAPCTLr BCM6300_A0_WRITE_MIRCAPCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_MIRCAPCTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  MLF_DROP_MAP
 * BLOCKS:   SYS
 * DESC:     Multicast Lookup Failed Forward Map Registrer
 * SIZE:     16
 * FIELDS:
 *     MUL_LOOKUP_FAIL_FRW_MAP Multicast Lookup Failed Forward Map.When Multicat lookup failed Drop is enabled (Page 00, Offset 21h) and Lookup failure happen, ARL will forward the frame according to the register setting.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_MLF_DROP_MAPr 0x00000034

#define BCM6300_A0_MLF_DROP_MAPr_SIZE 2

/*
 * This structure should be used to declare and program MLF_DROP_MAP.
 *
 */
typedef union BCM6300_A0_MLF_DROP_MAPr_s {
	uint32_t v[1];
	uint32_t mlf_drop_map[1];
	uint32_t _mlf_drop_map;
} BCM6300_A0_MLF_DROP_MAPr_t;

#define BCM6300_A0_MLF_DROP_MAPr_CLR(r) (r).mlf_drop_map[0] = 0
#define BCM6300_A0_MLF_DROP_MAPr_SET(r,d) (r).mlf_drop_map[0] = d
#define BCM6300_A0_MLF_DROP_MAPr_GET(r) (r).mlf_drop_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_MLF_DROP_MAPr_MUL_LOOKUP_FAIL_FRW_MAPf_GET(r) (((r).mlf_drop_map[0]) & 0x1ff)
#define BCM6300_A0_MLF_DROP_MAPr_MUL_LOOKUP_FAIL_FRW_MAPf_SET(r,f) (r).mlf_drop_map[0]=(((r).mlf_drop_map[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_MLF_DROP_MAPr_RESERVED_Rf_GET(r) ((((r).mlf_drop_map[0]) >> 9) & 0x7f)
#define BCM6300_A0_MLF_DROP_MAPr_RESERVED_Rf_SET(r,f) (r).mlf_drop_map[0]=(((r).mlf_drop_map[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access MLF_DROP_MAP.
 *
 */
#define BCM6300_A0_READ_MLF_DROP_MAPr(u,r) cdk_robo_reg_read(u,BCM6300_A0_MLF_DROP_MAPr,(r._mlf_drop_map),2)
#define BCM6300_A0_WRITE_MLF_DROP_MAPr(u,r) cdk_robo_reg_write(u,BCM6300_A0_MLF_DROP_MAPr,&(r._mlf_drop_map),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MLF_DROP_MAPr BCM6300_A0_MLF_DROP_MAPr
#define MLF_DROP_MAPr_SIZE BCM6300_A0_MLF_DROP_MAPr_SIZE
typedef BCM6300_A0_MLF_DROP_MAPr_t MLF_DROP_MAPr_t;
#define MLF_DROP_MAPr_CLR BCM6300_A0_MLF_DROP_MAPr_CLR
#define MLF_DROP_MAPr_SET BCM6300_A0_MLF_DROP_MAPr_SET
#define MLF_DROP_MAPr_GET BCM6300_A0_MLF_DROP_MAPr_GET
#define MLF_DROP_MAPr_MUL_LOOKUP_FAIL_FRW_MAPf_GET BCM6300_A0_MLF_DROP_MAPr_MUL_LOOKUP_FAIL_FRW_MAPf_GET
#define MLF_DROP_MAPr_MUL_LOOKUP_FAIL_FRW_MAPf_SET BCM6300_A0_MLF_DROP_MAPr_MUL_LOOKUP_FAIL_FRW_MAPf_SET
#define MLF_DROP_MAPr_RESERVED_Rf_GET BCM6300_A0_MLF_DROP_MAPr_RESERVED_Rf_GET
#define MLF_DROP_MAPr_RESERVED_Rf_SET BCM6300_A0_MLF_DROP_MAPr_RESERVED_Rf_SET
#define READ_MLF_DROP_MAPr BCM6300_A0_READ_MLF_DROP_MAPr
#define WRITE_MLF_DROP_MAPr BCM6300_A0_WRITE_MLF_DROP_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_MLF_DROP_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  MLF_IMPC_FWD_MAP
 * BLOCKS:   SYS
 * DESC:     IMPC Forward Map Registrer
 * SIZE:     16
 * FIELDS:
 *     MLF_IMPC_FWD_MAP IMPC Forward map.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_MLF_IMPC_FWD_MAPr 0x00000036

#define BCM6300_A0_MLF_IMPC_FWD_MAPr_SIZE 2

/*
 * This structure should be used to declare and program MLF_IMPC_FWD_MAP.
 *
 */
typedef union BCM6300_A0_MLF_IMPC_FWD_MAPr_s {
	uint32_t v[1];
	uint32_t mlf_impc_fwd_map[1];
	uint32_t _mlf_impc_fwd_map;
} BCM6300_A0_MLF_IMPC_FWD_MAPr_t;

#define BCM6300_A0_MLF_IMPC_FWD_MAPr_CLR(r) (r).mlf_impc_fwd_map[0] = 0
#define BCM6300_A0_MLF_IMPC_FWD_MAPr_SET(r,d) (r).mlf_impc_fwd_map[0] = d
#define BCM6300_A0_MLF_IMPC_FWD_MAPr_GET(r) (r).mlf_impc_fwd_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_MLF_IMPC_FWD_MAPr_MLF_IMPC_FWD_MAPf_GET(r) (((r).mlf_impc_fwd_map[0]) & 0x1ff)
#define BCM6300_A0_MLF_IMPC_FWD_MAPr_MLF_IMPC_FWD_MAPf_SET(r,f) (r).mlf_impc_fwd_map[0]=(((r).mlf_impc_fwd_map[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_MLF_IMPC_FWD_MAPr_RESERVED_Rf_GET(r) ((((r).mlf_impc_fwd_map[0]) >> 9) & 0x7f)
#define BCM6300_A0_MLF_IMPC_FWD_MAPr_RESERVED_Rf_SET(r,f) (r).mlf_impc_fwd_map[0]=(((r).mlf_impc_fwd_map[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access MLF_IMPC_FWD_MAP.
 *
 */
#define BCM6300_A0_READ_MLF_IMPC_FWD_MAPr(u,r) cdk_robo_reg_read(u,BCM6300_A0_MLF_IMPC_FWD_MAPr,(r._mlf_impc_fwd_map),2)
#define BCM6300_A0_WRITE_MLF_IMPC_FWD_MAPr(u,r) cdk_robo_reg_write(u,BCM6300_A0_MLF_IMPC_FWD_MAPr,&(r._mlf_impc_fwd_map),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MLF_IMPC_FWD_MAPr BCM6300_A0_MLF_IMPC_FWD_MAPr
#define MLF_IMPC_FWD_MAPr_SIZE BCM6300_A0_MLF_IMPC_FWD_MAPr_SIZE
typedef BCM6300_A0_MLF_IMPC_FWD_MAPr_t MLF_IMPC_FWD_MAPr_t;
#define MLF_IMPC_FWD_MAPr_CLR BCM6300_A0_MLF_IMPC_FWD_MAPr_CLR
#define MLF_IMPC_FWD_MAPr_SET BCM6300_A0_MLF_IMPC_FWD_MAPr_SET
#define MLF_IMPC_FWD_MAPr_GET BCM6300_A0_MLF_IMPC_FWD_MAPr_GET
#define MLF_IMPC_FWD_MAPr_MLF_IMPC_FWD_MAPf_GET BCM6300_A0_MLF_IMPC_FWD_MAPr_MLF_IMPC_FWD_MAPf_GET
#define MLF_IMPC_FWD_MAPr_MLF_IMPC_FWD_MAPf_SET BCM6300_A0_MLF_IMPC_FWD_MAPr_MLF_IMPC_FWD_MAPf_SET
#define MLF_IMPC_FWD_MAPr_RESERVED_Rf_GET BCM6300_A0_MLF_IMPC_FWD_MAPr_RESERVED_Rf_GET
#define MLF_IMPC_FWD_MAPr_RESERVED_Rf_SET BCM6300_A0_MLF_IMPC_FWD_MAPr_RESERVED_Rf_SET
#define READ_MLF_IMPC_FWD_MAPr BCM6300_A0_READ_MLF_IMPC_FWD_MAPr
#define WRITE_MLF_IMPC_FWD_MAPr BCM6300_A0_WRITE_MLF_IMPC_FWD_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_MLF_IMPC_FWD_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  MODEL_ID
 * BLOCKS:   SYS
 * DESC:     Model ID Register
 * SIZE:     8
 * FIELDS:
 *     MODELID          Chip Model IDBy bondingFor 8+1 will be 98hFor 5+2 will be 97h
 *
 ******************************************************************************/
#define BCM6300_A0_MODEL_IDr 0x00000230

#define BCM6300_A0_MODEL_IDr_SIZE 1

/*
 * This structure should be used to declare and program MODEL_ID.
 *
 */
typedef union BCM6300_A0_MODEL_IDr_s {
	uint32_t v[1];
	uint32_t model_id[1];
	uint32_t _model_id;
} BCM6300_A0_MODEL_IDr_t;

#define BCM6300_A0_MODEL_IDr_CLR(r) (r).model_id[0] = 0
#define BCM6300_A0_MODEL_IDr_SET(r,d) (r).model_id[0] = d
#define BCM6300_A0_MODEL_IDr_GET(r) (r).model_id[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_MODEL_IDr_MODELIDf_GET(r) (((r).model_id[0]) & 0xff)
#define BCM6300_A0_MODEL_IDr_MODELIDf_SET(r,f) (r).model_id[0]=(((r).model_id[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MODEL_ID.
 *
 */
#define BCM6300_A0_READ_MODEL_IDr(u,r) cdk_robo_reg_read(u,BCM6300_A0_MODEL_IDr,(r._model_id),1)
#define BCM6300_A0_WRITE_MODEL_IDr(u,r) cdk_robo_reg_write(u,BCM6300_A0_MODEL_IDr,&(r._model_id),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MODEL_IDr BCM6300_A0_MODEL_IDr
#define MODEL_IDr_SIZE BCM6300_A0_MODEL_IDr_SIZE
typedef BCM6300_A0_MODEL_IDr_t MODEL_IDr_t;
#define MODEL_IDr_CLR BCM6300_A0_MODEL_IDr_CLR
#define MODEL_IDr_SET BCM6300_A0_MODEL_IDr_SET
#define MODEL_IDr_GET BCM6300_A0_MODEL_IDr_GET
#define MODEL_IDr_MODELIDf_GET BCM6300_A0_MODEL_IDr_MODELIDf_GET
#define MODEL_IDr_MODELIDf_SET BCM6300_A0_MODEL_IDr_MODELIDf_SET
#define READ_MODEL_IDr BCM6300_A0_READ_MODEL_IDr
#define WRITE_MODEL_IDr BCM6300_A0_WRITE_MODEL_IDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_MODEL_IDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  MODULE_ID0
 * BLOCKS:   SYS
 * DESC:     Module ID 0 Registers
 * SIZE:     48
 * FIELDS:
 *     MID_SA           
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_MODULE_ID0r 0x00007208

#define BCM6300_A0_MODULE_ID0r_SIZE 6

/*
 * This structure should be used to declare and program MODULE_ID0.
 *
 */
typedef union BCM6300_A0_MODULE_ID0r_s {
	uint32_t v[2];
	uint32_t module_id0[2];
	uint32_t _module_id0;
} BCM6300_A0_MODULE_ID0r_t;

#define BCM6300_A0_MODULE_ID0r_CLR(r) CDK_MEMSET(&((r)._module_id0), 0, sizeof(BCM6300_A0_MODULE_ID0r_t))
#define BCM6300_A0_MODULE_ID0r_SET(r,i,d) (r).module_id0[i] = d
#define BCM6300_A0_MODULE_ID0r_GET(r,i) (r).module_id0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_MODULE_ID0r_MID_SAf_GET(r,a) cdk_field_get((r).module_id0,0,47,a)
#define BCM6300_A0_MODULE_ID0r_MID_SAf_SET(r,a) cdk_field_set((r).module_id0,0,47,a)
#define BCM6300_A0_MODULE_ID0r_RESERVED_Rf_GET(r) ((((r).module_id0[0]) >> 8) & 0xff)
#define BCM6300_A0_MODULE_ID0r_RESERVED_Rf_SET(r,f) (r).module_id0[0]=(((r).module_id0[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access MODULE_ID0.
 *
 */
#define BCM6300_A0_READ_MODULE_ID0r(u,r) cdk_robo_reg_read(u,BCM6300_A0_MODULE_ID0r,(r._module_id0),6)
#define BCM6300_A0_WRITE_MODULE_ID0r(u,r) cdk_robo_reg_write(u,BCM6300_A0_MODULE_ID0r,&(r._module_id0),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MODULE_ID0r BCM6300_A0_MODULE_ID0r
#define MODULE_ID0r_SIZE BCM6300_A0_MODULE_ID0r_SIZE
typedef BCM6300_A0_MODULE_ID0r_t MODULE_ID0r_t;
#define MODULE_ID0r_CLR BCM6300_A0_MODULE_ID0r_CLR
#define MODULE_ID0r_SET BCM6300_A0_MODULE_ID0r_SET
#define MODULE_ID0r_GET BCM6300_A0_MODULE_ID0r_GET
#define MODULE_ID0r_MID_SAf_GET BCM6300_A0_MODULE_ID0r_MID_SAf_GET
#define MODULE_ID0r_MID_SAf_SET BCM6300_A0_MODULE_ID0r_MID_SAf_SET
#define MODULE_ID0r_RESERVED_Rf_GET BCM6300_A0_MODULE_ID0r_RESERVED_Rf_GET
#define MODULE_ID0r_RESERVED_Rf_SET BCM6300_A0_MODULE_ID0r_RESERVED_Rf_SET
#define READ_MODULE_ID0r BCM6300_A0_READ_MODULE_ID0r
#define WRITE_MODULE_ID0r BCM6300_A0_WRITE_MODULE_ID0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_MODULE_ID0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  MODULE_ID1
 * BLOCKS:   SYS
 * DESC:     Module ID 1 Registers
 * SIZE:     48
 * FIELDS:
 *     MID_CRC          32 bits CRC for module ID.
 *     MID_PORTMUN      8 bit portnum for module ID.
 *     RESERVED_R       Reserved.
 *     MID_AVAIL        module ID available , once 1 st packet received.1 : available.0 : unavailable, wait for 1st packet.
 *
 ******************************************************************************/
#define BCM6300_A0_MODULE_ID1r 0x00007210

#define BCM6300_A0_MODULE_ID1r_SIZE 6

/*
 * This structure should be used to declare and program MODULE_ID1.
 *
 */
typedef union BCM6300_A0_MODULE_ID1r_s {
	uint32_t v[2];
	uint32_t module_id1[2];
	uint32_t _module_id1;
} BCM6300_A0_MODULE_ID1r_t;

#define BCM6300_A0_MODULE_ID1r_CLR(r) CDK_MEMSET(&((r)._module_id1), 0, sizeof(BCM6300_A0_MODULE_ID1r_t))
#define BCM6300_A0_MODULE_ID1r_SET(r,i,d) (r).module_id1[i] = d
#define BCM6300_A0_MODULE_ID1r_GET(r,i) (r).module_id1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_MODULE_ID1r_MID_CRCf_GET(r) ((r).module_id1[0])
#define BCM6300_A0_MODULE_ID1r_MID_CRCf_SET(r,f) (r).module_id1[0]=((uint32_t)f)
#define BCM6300_A0_MODULE_ID1r_MID_PORTMUNf_GET(r) (((r).module_id1[1]) & 0xff)
#define BCM6300_A0_MODULE_ID1r_MID_PORTMUNf_SET(r,f) (r).module_id1[1]=(((r).module_id1[1] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM6300_A0_MODULE_ID1r_RESERVED_Rf_GET(r) ((((r).module_id1[1]) >> 8) & 0x7f)
#define BCM6300_A0_MODULE_ID1r_RESERVED_Rf_SET(r,f) (r).module_id1[1]=(((r).module_id1[1] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8))
#define BCM6300_A0_MODULE_ID1r_MID_AVAILf_GET(r) ((((r).module_id1[1]) >> 15) & 0x1)
#define BCM6300_A0_MODULE_ID1r_MID_AVAILf_SET(r,f) (r).module_id1[1]=(((r).module_id1[1] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MODULE_ID1.
 *
 */
#define BCM6300_A0_READ_MODULE_ID1r(u,r) cdk_robo_reg_read(u,BCM6300_A0_MODULE_ID1r,(r._module_id1),6)
#define BCM6300_A0_WRITE_MODULE_ID1r(u,r) cdk_robo_reg_write(u,BCM6300_A0_MODULE_ID1r,&(r._module_id1),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MODULE_ID1r BCM6300_A0_MODULE_ID1r
#define MODULE_ID1r_SIZE BCM6300_A0_MODULE_ID1r_SIZE
typedef BCM6300_A0_MODULE_ID1r_t MODULE_ID1r_t;
#define MODULE_ID1r_CLR BCM6300_A0_MODULE_ID1r_CLR
#define MODULE_ID1r_SET BCM6300_A0_MODULE_ID1r_SET
#define MODULE_ID1r_GET BCM6300_A0_MODULE_ID1r_GET
#define MODULE_ID1r_MID_CRCf_GET BCM6300_A0_MODULE_ID1r_MID_CRCf_GET
#define MODULE_ID1r_MID_CRCf_SET BCM6300_A0_MODULE_ID1r_MID_CRCf_SET
#define MODULE_ID1r_MID_PORTMUNf_GET BCM6300_A0_MODULE_ID1r_MID_PORTMUNf_GET
#define MODULE_ID1r_MID_PORTMUNf_SET BCM6300_A0_MODULE_ID1r_MID_PORTMUNf_SET
#define MODULE_ID1r_RESERVED_Rf_GET BCM6300_A0_MODULE_ID1r_RESERVED_Rf_GET
#define MODULE_ID1r_RESERVED_Rf_SET BCM6300_A0_MODULE_ID1r_RESERVED_Rf_SET
#define MODULE_ID1r_MID_AVAILf_GET BCM6300_A0_MODULE_ID1r_MID_AVAILf_GET
#define MODULE_ID1r_MID_AVAILf_SET BCM6300_A0_MODULE_ID1r_MID_AVAILf_SET
#define READ_MODULE_ID1r BCM6300_A0_READ_MODULE_ID1r
#define WRITE_MODULE_ID1r BCM6300_A0_WRITE_MODULE_ID1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_MODULE_ID1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * MEMORY:  MSPT_TAB
 * BLOCKS:   SYS
 * DESC:     Multiple Spanning Tree Table
 * SIZE:     27
 * FIELDS:
 *     MSP_TREE_PORT0   Port 0 SPT status
 *     MSP_TREE_PORT1   Port 1 SPT status
 *     MSP_TREE_PORT2   Port 2 SPT status
 *     MSP_TREE_PORT3   Port 3 SPT status
 *     MSP_TREE_PORT4   Port 4 SPT status
 *     MSP_TREE_PORT5   Port 5 SPT status
 *     MSP_TREE_PORT6   Port 6 SPT status
 *     MSP_TREE_PORT7   Port 7 SPT status
 *     MSP_TREE_PORT8   Port 8 SPT status
 *
 ******************************************************************************/
#define BCM6300_A0_MSPT_TABm 0x00004310

#define BCM6300_A0_MSPT_TABm_MIN 0
#define BCM6300_A0_MSPT_TABm_MAX 15
#define BCM6300_A0_MSPT_TABm_SIZE 4

/*
 * This structure should be used to declare and program MSPT_TAB.
 *
 */
typedef union BCM6300_A0_MSPT_TABm_s {
	uint32_t v[1];
	uint32_t mspt_tab[1];
	uint32_t _mspt_tab;
} BCM6300_A0_MSPT_TABm_t;

#define BCM6300_A0_MSPT_TABm_CLR(r) (r).mspt_tab[0] = 0
#define BCM6300_A0_MSPT_TABm_SET(r,d) (r).mspt_tab[0] = d
#define BCM6300_A0_MSPT_TABm_GET(r) (r).mspt_tab[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_MSPT_TABm_MSP_TREE_PORT0f_GET(r) (((r).mspt_tab[0]) & 0x7)
#define BCM6300_A0_MSPT_TABm_MSP_TREE_PORT0f_SET(r,f) (r).mspt_tab[0]=(((r).mspt_tab[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM6300_A0_MSPT_TABm_MSP_TREE_PORT1f_GET(r) ((((r).mspt_tab[0]) >> 3) & 0x7)
#define BCM6300_A0_MSPT_TABm_MSP_TREE_PORT1f_SET(r,f) (r).mspt_tab[0]=(((r).mspt_tab[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM6300_A0_MSPT_TABm_MSP_TREE_PORT2f_GET(r) ((((r).mspt_tab[0]) >> 6) & 0x7)
#define BCM6300_A0_MSPT_TABm_MSP_TREE_PORT2f_SET(r,f) (r).mspt_tab[0]=(((r).mspt_tab[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM6300_A0_MSPT_TABm_MSP_TREE_PORT3f_GET(r) ((((r).mspt_tab[0]) >> 9) & 0x7)
#define BCM6300_A0_MSPT_TABm_MSP_TREE_PORT3f_SET(r,f) (r).mspt_tab[0]=(((r).mspt_tab[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM6300_A0_MSPT_TABm_MSP_TREE_PORT4f_GET(r) ((((r).mspt_tab[0]) >> 12) & 0x7)
#define BCM6300_A0_MSPT_TABm_MSP_TREE_PORT4f_SET(r,f) (r).mspt_tab[0]=(((r).mspt_tab[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM6300_A0_MSPT_TABm_MSP_TREE_PORT5f_GET(r) ((((r).mspt_tab[0]) >> 15) & 0x7)
#define BCM6300_A0_MSPT_TABm_MSP_TREE_PORT5f_SET(r,f) (r).mspt_tab[0]=(((r).mspt_tab[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM6300_A0_MSPT_TABm_MSP_TREE_PORT6f_GET(r) ((((r).mspt_tab[0]) >> 18) & 0x7)
#define BCM6300_A0_MSPT_TABm_MSP_TREE_PORT6f_SET(r,f) (r).mspt_tab[0]=(((r).mspt_tab[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM6300_A0_MSPT_TABm_MSP_TREE_PORT7f_GET(r) ((((r).mspt_tab[0]) >> 21) & 0x7)
#define BCM6300_A0_MSPT_TABm_MSP_TREE_PORT7f_SET(r,f) (r).mspt_tab[0]=(((r).mspt_tab[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM6300_A0_MSPT_TABm_MSP_TREE_PORT8f_GET(r) ((((r).mspt_tab[0]) >> 24) & 0x7)
#define BCM6300_A0_MSPT_TABm_MSP_TREE_PORT8f_SET(r,f) (r).mspt_tab[0]=(((r).mspt_tab[0] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))

/*
 * These macros can be used to access MSPT_TAB.
 *
 */
#define BCM6300_A0_READ_MSPT_TABm(u,i,m) cdk_robo_mem_read(u,BCM6300_A0_MSPT_TABm,i,(m),4)
#define BCM6300_A0_WRITE_MSPT_TABm(u,i,m) cdk_robo_mem_write(u,BCM6300_A0_MSPT_TABm,i,&(m),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MSPT_TABm BCM6300_A0_MSPT_TABm
#define MSPT_TABm_MIN BCM6300_A0_MSPT_TABm_MIN
#define MSPT_TABm_MAX BCM6300_A0_MSPT_TABm_MAX
#define MSPT_TABm_SIZE BCM6300_A0_MSPT_TABm_SIZE
typedef BCM6300_A0_MSPT_TABm_t MSPT_TABm_t;
#define MSPT_TABm_CLR BCM6300_A0_MSPT_TABm_CLR
#define MSPT_TABm_SET BCM6300_A0_MSPT_TABm_SET
#define MSPT_TABm_GET BCM6300_A0_MSPT_TABm_GET
#define MSPT_TABm_MSP_TREE_PORT0f_GET BCM6300_A0_MSPT_TABm_MSP_TREE_PORT0f_GET
#define MSPT_TABm_MSP_TREE_PORT0f_SET BCM6300_A0_MSPT_TABm_MSP_TREE_PORT0f_SET
#define MSPT_TABm_MSP_TREE_PORT1f_GET BCM6300_A0_MSPT_TABm_MSP_TREE_PORT1f_GET
#define MSPT_TABm_MSP_TREE_PORT1f_SET BCM6300_A0_MSPT_TABm_MSP_TREE_PORT1f_SET
#define MSPT_TABm_MSP_TREE_PORT2f_GET BCM6300_A0_MSPT_TABm_MSP_TREE_PORT2f_GET
#define MSPT_TABm_MSP_TREE_PORT2f_SET BCM6300_A0_MSPT_TABm_MSP_TREE_PORT2f_SET
#define MSPT_TABm_MSP_TREE_PORT3f_GET BCM6300_A0_MSPT_TABm_MSP_TREE_PORT3f_GET
#define MSPT_TABm_MSP_TREE_PORT3f_SET BCM6300_A0_MSPT_TABm_MSP_TREE_PORT3f_SET
#define MSPT_TABm_MSP_TREE_PORT4f_GET BCM6300_A0_MSPT_TABm_MSP_TREE_PORT4f_GET
#define MSPT_TABm_MSP_TREE_PORT4f_SET BCM6300_A0_MSPT_TABm_MSP_TREE_PORT4f_SET
#define MSPT_TABm_MSP_TREE_PORT5f_GET BCM6300_A0_MSPT_TABm_MSP_TREE_PORT5f_GET
#define MSPT_TABm_MSP_TREE_PORT5f_SET BCM6300_A0_MSPT_TABm_MSP_TREE_PORT5f_SET
#define MSPT_TABm_MSP_TREE_PORT6f_GET BCM6300_A0_MSPT_TABm_MSP_TREE_PORT6f_GET
#define MSPT_TABm_MSP_TREE_PORT6f_SET BCM6300_A0_MSPT_TABm_MSP_TREE_PORT6f_SET
#define MSPT_TABm_MSP_TREE_PORT7f_GET BCM6300_A0_MSPT_TABm_MSP_TREE_PORT7f_GET
#define MSPT_TABm_MSP_TREE_PORT7f_SET BCM6300_A0_MSPT_TABm_MSP_TREE_PORT7f_SET
#define MSPT_TABm_MSP_TREE_PORT8f_GET BCM6300_A0_MSPT_TABm_MSP_TREE_PORT8f_GET
#define MSPT_TABm_MSP_TREE_PORT8f_SET BCM6300_A0_MSPT_TABm_MSP_TREE_PORT8f_SET
#define READ_MSPT_TABm BCM6300_A0_READ_MSPT_TABm
#define WRITE_MSPT_TABm BCM6300_A0_WRITE_MSPT_TABm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_MSPT_TABm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  MST_AGE
 * BLOCKS:   SYS
 * DESC:     MST Ageing Control Register
 * SIZE:     32
 * FIELDS:
 *     AGE_EN_PRT       Per-spannibg tree aging enable.
 *     CHIP0_PORT_AGE_RSRV0 Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_MST_AGEr 0x00004304

#define BCM6300_A0_MST_AGEr_SIZE 4

/*
 * This structure should be used to declare and program MST_AGE.
 *
 */
typedef union BCM6300_A0_MST_AGEr_s {
	uint32_t v[1];
	uint32_t mst_age[1];
	uint32_t _mst_age;
} BCM6300_A0_MST_AGEr_t;

#define BCM6300_A0_MST_AGEr_CLR(r) (r).mst_age[0] = 0
#define BCM6300_A0_MST_AGEr_SET(r,d) (r).mst_age[0] = d
#define BCM6300_A0_MST_AGEr_GET(r) (r).mst_age[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_MST_AGEr_AGE_EN_PRTf_GET(r) (((r).mst_age[0]) & 0xffff)
#define BCM6300_A0_MST_AGEr_AGE_EN_PRTf_SET(r,f) (r).mst_age[0]=(((r).mst_age[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))
#define BCM6300_A0_MST_AGEr_CHIP0_PORT_AGE_RSRV0f_GET(r) ((((r).mst_age[0]) >> 16) & 0xffff)
#define BCM6300_A0_MST_AGEr_CHIP0_PORT_AGE_RSRV0f_SET(r,f) (r).mst_age[0]=(((r).mst_age[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access MST_AGE.
 *
 */
#define BCM6300_A0_READ_MST_AGEr(u,r) cdk_robo_reg_read(u,BCM6300_A0_MST_AGEr,(r._mst_age),4)
#define BCM6300_A0_WRITE_MST_AGEr(u,r) cdk_robo_reg_write(u,BCM6300_A0_MST_AGEr,&(r._mst_age),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MST_AGEr BCM6300_A0_MST_AGEr
#define MST_AGEr_SIZE BCM6300_A0_MST_AGEr_SIZE
typedef BCM6300_A0_MST_AGEr_t MST_AGEr_t;
#define MST_AGEr_CLR BCM6300_A0_MST_AGEr_CLR
#define MST_AGEr_SET BCM6300_A0_MST_AGEr_SET
#define MST_AGEr_GET BCM6300_A0_MST_AGEr_GET
#define MST_AGEr_AGE_EN_PRTf_GET BCM6300_A0_MST_AGEr_AGE_EN_PRTf_GET
#define MST_AGEr_AGE_EN_PRTf_SET BCM6300_A0_MST_AGEr_AGE_EN_PRTf_SET
#define MST_AGEr_CHIP0_PORT_AGE_RSRV0f_GET BCM6300_A0_MST_AGEr_CHIP0_PORT_AGE_RSRV0f_GET
#define MST_AGEr_CHIP0_PORT_AGE_RSRV0f_SET BCM6300_A0_MST_AGEr_CHIP0_PORT_AGE_RSRV0f_SET
#define READ_MST_AGEr BCM6300_A0_READ_MST_AGEr
#define WRITE_MST_AGEr BCM6300_A0_WRITE_MST_AGEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_MST_AGEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  MST_CON
 * BLOCKS:   SYS
 * DESC:     MST Control Registers
 * SIZE:     8
 * FIELDS:
 *     EN_802_1S        
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_MST_CONr 0x00004300

#define BCM6300_A0_MST_CONr_SIZE 1

/*
 * This structure should be used to declare and program MST_CON.
 *
 */
typedef union BCM6300_A0_MST_CONr_s {
	uint32_t v[1];
	uint32_t mst_con[1];
	uint32_t _mst_con;
} BCM6300_A0_MST_CONr_t;

#define BCM6300_A0_MST_CONr_CLR(r) (r).mst_con[0] = 0
#define BCM6300_A0_MST_CONr_SET(r,d) (r).mst_con[0] = d
#define BCM6300_A0_MST_CONr_GET(r) (r).mst_con[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_MST_CONr_EN_802_1Sf_GET(r) (((r).mst_con[0]) & 0x1)
#define BCM6300_A0_MST_CONr_EN_802_1Sf_SET(r,f) (r).mst_con[0]=(((r).mst_con[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM6300_A0_MST_CONr_RESERVED_Rf_GET(r) ((((r).mst_con[0]) >> 1) & 0x7f)
#define BCM6300_A0_MST_CONr_RESERVED_Rf_SET(r,f) (r).mst_con[0]=(((r).mst_con[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access MST_CON.
 *
 */
#define BCM6300_A0_READ_MST_CONr(u,r) cdk_robo_reg_read(u,BCM6300_A0_MST_CONr,(r._mst_con),1)
#define BCM6300_A0_WRITE_MST_CONr(u,r) cdk_robo_reg_write(u,BCM6300_A0_MST_CONr,&(r._mst_con),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MST_CONr BCM6300_A0_MST_CONr
#define MST_CONr_SIZE BCM6300_A0_MST_CONr_SIZE
typedef BCM6300_A0_MST_CONr_t MST_CONr_t;
#define MST_CONr_CLR BCM6300_A0_MST_CONr_CLR
#define MST_CONr_SET BCM6300_A0_MST_CONr_SET
#define MST_CONr_GET BCM6300_A0_MST_CONr_GET
#define MST_CONr_EN_802_1Sf_GET BCM6300_A0_MST_CONr_EN_802_1Sf_GET
#define MST_CONr_EN_802_1Sf_SET BCM6300_A0_MST_CONr_EN_802_1Sf_SET
#define MST_CONr_RESERVED_Rf_GET BCM6300_A0_MST_CONr_RESERVED_Rf_GET
#define MST_CONr_RESERVED_Rf_SET BCM6300_A0_MST_CONr_RESERVED_Rf_SET
#define READ_MST_CONr BCM6300_A0_READ_MST_CONr
#define WRITE_MST_CONr BCM6300_A0_WRITE_MST_CONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_MST_CONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  MST_TBL
 * BLOCKS:   SYS
 * DESC:     MST Table N Enable Registers
 * SIZE:     32
 * FIELDS:
 *     SPT_STA0         Spanning tree state for port 0.000 : no spanning tree,001 : disable,010 : blocking,011 : listening,100 : learning,101 : forwarding,110-111 : reserved.
 *     SPT_STA1         Spanning tree state for port 1.000 : no spanning tree,001 : disable,010 : blocking,011 : listening,100 : learning,101 : forwarding,110-111 : reserved.
 *     SPT_STA2         Spanning tree state for port 2.000 : no spanning tree,001 : disable,010 : blocking,011 : listening,100 : learning,101 : forwarding,110-111 : reserved.
 *     SPT_STA3         Spanning tree state for port 3.000 : no spanning tree,001 : disable,010 : blocking,011 : listening,100 : learning,101 : forwarding,110-111 : reserved.
 *     SPT_STA4         Spanning tree state for port 4.000 : no spanning tree,001 : disable,010 : blocking,011 : listening,100 : learning,101 : forwarding,110-111 : reserved.
 *     SPT_STA5         Spanning tree state for port 5.000 : no spanning tree,001 : disable,010 : blocking,011 : listening,100 : learning,101 : forwarding,110-111 : reserved.
 *     SPT_STA6         Spanning tree state for port 6.000 : no spanning tree,001 : disable,010 : blocking,011 : listening,100 : learning,101 : forwarding,110-111 : reserved.
 *     SPT_STA7         Spanning tree state for port7.000 : no spanning tree,001 : disable,010 : blocking,011 : listening,100 : learning,101 : forwarding,110-111 : reserved.
 *     SPT_STA8         Spanning tree state for port8 (IMP).000 : no spanning tree,001 : disable,010 : blocking,011 : listening,100 : learning,101 : forwarding,110-111 : reserved.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_MST_TBLr 0x00004310

#define BCM6300_A0_MST_TBLr_SIZE 4

/*
 * This structure should be used to declare and program MST_TBL.
 *
 */
typedef union BCM6300_A0_MST_TBLr_s {
	uint32_t v[1];
	uint32_t mst_tbl[1];
	uint32_t _mst_tbl;
} BCM6300_A0_MST_TBLr_t;

#define BCM6300_A0_MST_TBLr_CLR(r) (r).mst_tbl[0] = 0
#define BCM6300_A0_MST_TBLr_SET(r,d) (r).mst_tbl[0] = d
#define BCM6300_A0_MST_TBLr_GET(r) (r).mst_tbl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_MST_TBLr_SPT_STA0f_GET(r) (((r).mst_tbl[0]) & 0x7)
#define BCM6300_A0_MST_TBLr_SPT_STA0f_SET(r,f) (r).mst_tbl[0]=(((r).mst_tbl[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM6300_A0_MST_TBLr_SPT_STA1f_GET(r) ((((r).mst_tbl[0]) >> 3) & 0x7)
#define BCM6300_A0_MST_TBLr_SPT_STA1f_SET(r,f) (r).mst_tbl[0]=(((r).mst_tbl[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM6300_A0_MST_TBLr_SPT_STA2f_GET(r) ((((r).mst_tbl[0]) >> 6) & 0x7)
#define BCM6300_A0_MST_TBLr_SPT_STA2f_SET(r,f) (r).mst_tbl[0]=(((r).mst_tbl[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM6300_A0_MST_TBLr_SPT_STA3f_GET(r) ((((r).mst_tbl[0]) >> 9) & 0x7)
#define BCM6300_A0_MST_TBLr_SPT_STA3f_SET(r,f) (r).mst_tbl[0]=(((r).mst_tbl[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM6300_A0_MST_TBLr_SPT_STA4f_GET(r) ((((r).mst_tbl[0]) >> 12) & 0x7)
#define BCM6300_A0_MST_TBLr_SPT_STA4f_SET(r,f) (r).mst_tbl[0]=(((r).mst_tbl[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM6300_A0_MST_TBLr_SPT_STA5f_GET(r) ((((r).mst_tbl[0]) >> 15) & 0x7)
#define BCM6300_A0_MST_TBLr_SPT_STA5f_SET(r,f) (r).mst_tbl[0]=(((r).mst_tbl[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM6300_A0_MST_TBLr_SPT_STA6f_GET(r) ((((r).mst_tbl[0]) >> 18) & 0x7)
#define BCM6300_A0_MST_TBLr_SPT_STA6f_SET(r,f) (r).mst_tbl[0]=(((r).mst_tbl[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM6300_A0_MST_TBLr_SPT_STA7f_GET(r) ((((r).mst_tbl[0]) >> 21) & 0x7)
#define BCM6300_A0_MST_TBLr_SPT_STA7f_SET(r,f) (r).mst_tbl[0]=(((r).mst_tbl[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM6300_A0_MST_TBLr_SPT_STA8f_GET(r) ((((r).mst_tbl[0]) >> 24) & 0x7)
#define BCM6300_A0_MST_TBLr_SPT_STA8f_SET(r,f) (r).mst_tbl[0]=(((r).mst_tbl[0] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM6300_A0_MST_TBLr_RESERVED_Rf_GET(r) ((((r).mst_tbl[0]) >> 27) & 0x1f)
#define BCM6300_A0_MST_TBLr_RESERVED_Rf_SET(r,f) (r).mst_tbl[0]=(((r).mst_tbl[0] & ~((uint32_t)0x1f << 27)) | ((((uint32_t)f) & 0x1f) << 27))

/*
 * These macros can be used to access MST_TBL.
 *
 */
#define BCM6300_A0_READ_MST_TBLr(u,i,r) cdk_robo_reg_read(u,BCM6300_A0_MST_TBLr+(4*(i)),(r._mst_tbl),4)
#define BCM6300_A0_WRITE_MST_TBLr(u,i,r) cdk_robo_reg_write(u,BCM6300_A0_MST_TBLr+(4*(i)),&(r._mst_tbl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MST_TBLr BCM6300_A0_MST_TBLr
#define MST_TBLr_SIZE BCM6300_A0_MST_TBLr_SIZE
typedef BCM6300_A0_MST_TBLr_t MST_TBLr_t;
#define MST_TBLr_CLR BCM6300_A0_MST_TBLr_CLR
#define MST_TBLr_SET BCM6300_A0_MST_TBLr_SET
#define MST_TBLr_GET BCM6300_A0_MST_TBLr_GET
#define MST_TBLr_SPT_STA0f_GET BCM6300_A0_MST_TBLr_SPT_STA0f_GET
#define MST_TBLr_SPT_STA0f_SET BCM6300_A0_MST_TBLr_SPT_STA0f_SET
#define MST_TBLr_SPT_STA1f_GET BCM6300_A0_MST_TBLr_SPT_STA1f_GET
#define MST_TBLr_SPT_STA1f_SET BCM6300_A0_MST_TBLr_SPT_STA1f_SET
#define MST_TBLr_SPT_STA2f_GET BCM6300_A0_MST_TBLr_SPT_STA2f_GET
#define MST_TBLr_SPT_STA2f_SET BCM6300_A0_MST_TBLr_SPT_STA2f_SET
#define MST_TBLr_SPT_STA3f_GET BCM6300_A0_MST_TBLr_SPT_STA3f_GET
#define MST_TBLr_SPT_STA3f_SET BCM6300_A0_MST_TBLr_SPT_STA3f_SET
#define MST_TBLr_SPT_STA4f_GET BCM6300_A0_MST_TBLr_SPT_STA4f_GET
#define MST_TBLr_SPT_STA4f_SET BCM6300_A0_MST_TBLr_SPT_STA4f_SET
#define MST_TBLr_SPT_STA5f_GET BCM6300_A0_MST_TBLr_SPT_STA5f_GET
#define MST_TBLr_SPT_STA5f_SET BCM6300_A0_MST_TBLr_SPT_STA5f_SET
#define MST_TBLr_SPT_STA6f_GET BCM6300_A0_MST_TBLr_SPT_STA6f_GET
#define MST_TBLr_SPT_STA6f_SET BCM6300_A0_MST_TBLr_SPT_STA6f_SET
#define MST_TBLr_SPT_STA7f_GET BCM6300_A0_MST_TBLr_SPT_STA7f_GET
#define MST_TBLr_SPT_STA7f_SET BCM6300_A0_MST_TBLr_SPT_STA7f_SET
#define MST_TBLr_SPT_STA8f_GET BCM6300_A0_MST_TBLr_SPT_STA8f_GET
#define MST_TBLr_SPT_STA8f_SET BCM6300_A0_MST_TBLr_SPT_STA8f_SET
#define MST_TBLr_RESERVED_Rf_GET BCM6300_A0_MST_TBLr_RESERVED_Rf_GET
#define MST_TBLr_RESERVED_Rf_SET BCM6300_A0_MST_TBLr_RESERVED_Rf_SET
#define READ_MST_TBLr BCM6300_A0_READ_MST_TBLr
#define WRITE_MST_TBLr BCM6300_A0_WRITE_MST_TBLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_MST_TBLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  NEW_CONTROL
 * BLOCKS:   SYS
 * DESC:     New Control Register
 * SIZE:     8
 * FIELDS:
 *     IP_MULTICAST     b1: Enable IP multicast address scheme.b0: Disable IP multicast address scheme.
 *     RESERVED_R       Reserved
 *     UC_DROP_EN       Unicast Forward Enable when ARL Miss.1: To enable DFL packet with unicast destination address to foward to ports defined as page 0,offset 34h.
 *     MC_DLF_FWD       Multicast Foward Enable when ARL Miss.1: To enable DFL packet with multicast destination address to foward to the ports defined as page 0,offset 34h.
 *
 ******************************************************************************/
#define BCM6300_A0_NEW_CONTROLr 0x00000021

#define BCM6300_A0_NEW_CONTROLr_SIZE 1

/*
 * This structure should be used to declare and program NEW_CONTROL.
 *
 */
typedef union BCM6300_A0_NEW_CONTROLr_s {
	uint32_t v[1];
	uint32_t new_control[1];
	uint32_t _new_control;
} BCM6300_A0_NEW_CONTROLr_t;

#define BCM6300_A0_NEW_CONTROLr_CLR(r) (r).new_control[0] = 0
#define BCM6300_A0_NEW_CONTROLr_SET(r,d) (r).new_control[0] = d
#define BCM6300_A0_NEW_CONTROLr_GET(r) (r).new_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_NEW_CONTROLr_IP_MULTICASTf_GET(r) (((r).new_control[0]) & 0x1)
#define BCM6300_A0_NEW_CONTROLr_IP_MULTICASTf_SET(r,f) (r).new_control[0]=(((r).new_control[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM6300_A0_NEW_CONTROLr_RESERVED_Rf_GET(r) ((((r).new_control[0]) >> 1) & 0x1f)
#define BCM6300_A0_NEW_CONTROLr_RESERVED_Rf_SET(r,f) (r).new_control[0]=(((r).new_control[0] & ~((uint32_t)0x1f << 1)) | ((((uint32_t)f) & 0x1f) << 1))
#define BCM6300_A0_NEW_CONTROLr_UC_DROP_ENf_GET(r) ((((r).new_control[0]) >> 6) & 0x1)
#define BCM6300_A0_NEW_CONTROLr_UC_DROP_ENf_SET(r,f) (r).new_control[0]=(((r).new_control[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM6300_A0_NEW_CONTROLr_MC_DLF_FWDf_GET(r) ((((r).new_control[0]) >> 7) & 0x1)
#define BCM6300_A0_NEW_CONTROLr_MC_DLF_FWDf_SET(r,f) (r).new_control[0]=(((r).new_control[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access NEW_CONTROL.
 *
 */
#define BCM6300_A0_READ_NEW_CONTROLr(u,r) cdk_robo_reg_read(u,BCM6300_A0_NEW_CONTROLr,(r._new_control),1)
#define BCM6300_A0_WRITE_NEW_CONTROLr(u,r) cdk_robo_reg_write(u,BCM6300_A0_NEW_CONTROLr,&(r._new_control),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define NEW_CONTROLr BCM6300_A0_NEW_CONTROLr
#define NEW_CONTROLr_SIZE BCM6300_A0_NEW_CONTROLr_SIZE
typedef BCM6300_A0_NEW_CONTROLr_t NEW_CONTROLr_t;
#define NEW_CONTROLr_CLR BCM6300_A0_NEW_CONTROLr_CLR
#define NEW_CONTROLr_SET BCM6300_A0_NEW_CONTROLr_SET
#define NEW_CONTROLr_GET BCM6300_A0_NEW_CONTROLr_GET
#define NEW_CONTROLr_IP_MULTICASTf_GET BCM6300_A0_NEW_CONTROLr_IP_MULTICASTf_GET
#define NEW_CONTROLr_IP_MULTICASTf_SET BCM6300_A0_NEW_CONTROLr_IP_MULTICASTf_SET
#define NEW_CONTROLr_RESERVED_Rf_GET BCM6300_A0_NEW_CONTROLr_RESERVED_Rf_GET
#define NEW_CONTROLr_RESERVED_Rf_SET BCM6300_A0_NEW_CONTROLr_RESERVED_Rf_SET
#define NEW_CONTROLr_UC_DROP_ENf_GET BCM6300_A0_NEW_CONTROLr_UC_DROP_ENf_GET
#define NEW_CONTROLr_UC_DROP_ENf_SET BCM6300_A0_NEW_CONTROLr_UC_DROP_ENf_SET
#define NEW_CONTROLr_MC_DLF_FWDf_GET BCM6300_A0_NEW_CONTROLr_MC_DLF_FWDf_GET
#define NEW_CONTROLr_MC_DLF_FWDf_SET BCM6300_A0_NEW_CONTROLr_MC_DLF_FWDf_SET
#define READ_NEW_CONTROLr BCM6300_A0_READ_NEW_CONTROLr
#define WRITE_NEW_CONTROLr BCM6300_A0_WRITE_NEW_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_NEW_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  NEW_PRI_MAP
 * BLOCKS:   SYS
 * DESC:     New Priority Map Register
 * SIZE:     32
 * FIELDS:
 *     RE_MAP           When 1) global_1Q_control1[8]=1 and 2) control0[0]=1 and 3) control0[2] =1 .Then we will remap the original frames's pri to the one in re_map_reg[23:0] . The mapping rule are:OLD PRI NEW PRI------------------------------------000 re_map_reg[2:0]001 re_map_reg[5:3]010 re_map_reg[8:6]011 re_map_reg[11:9]100 re_map_reg[14:12]101 re_map_reg[17:15]110 re_map_reg[20:18]111 re_map_reg[23:21]** If incomming frame is pri_tagged frame, or tagged frame, Then we will re_mapped it's pri field if re_maping feature is enabled.** If incoming frame is an un_tagged frame, then we will use pri in default_tag as new pri.              
 *     RESERVED_R       Reserved.                
 *
 ******************************************************************************/
#define BCM6300_A0_NEW_PRI_MAPr 0x0000340c

#define BCM6300_A0_NEW_PRI_MAPr_SIZE 4

/*
 * This structure should be used to declare and program NEW_PRI_MAP.
 *
 */
typedef union BCM6300_A0_NEW_PRI_MAPr_s {
	uint32_t v[1];
	uint32_t new_pri_map[1];
	uint32_t _new_pri_map;
} BCM6300_A0_NEW_PRI_MAPr_t;

#define BCM6300_A0_NEW_PRI_MAPr_CLR(r) (r).new_pri_map[0] = 0
#define BCM6300_A0_NEW_PRI_MAPr_SET(r,d) (r).new_pri_map[0] = d
#define BCM6300_A0_NEW_PRI_MAPr_GET(r) (r).new_pri_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_NEW_PRI_MAPr_RE_MAPf_GET(r) (((r).new_pri_map[0]) & 0xffffff)
#define BCM6300_A0_NEW_PRI_MAPr_RE_MAPf_SET(r,f) (r).new_pri_map[0]=(((r).new_pri_map[0] & ~((uint32_t)0xffffff)) | (((uint32_t)f) & 0xffffff))
#define BCM6300_A0_NEW_PRI_MAPr_RESERVED_Rf_GET(r) ((((r).new_pri_map[0]) >> 24) & 0xff)
#define BCM6300_A0_NEW_PRI_MAPr_RESERVED_Rf_SET(r,f) (r).new_pri_map[0]=(((r).new_pri_map[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access NEW_PRI_MAP.
 *
 */
#define BCM6300_A0_READ_NEW_PRI_MAPr(u,r) cdk_robo_reg_read(u,BCM6300_A0_NEW_PRI_MAPr,(r._new_pri_map),4)
#define BCM6300_A0_WRITE_NEW_PRI_MAPr(u,r) cdk_robo_reg_write(u,BCM6300_A0_NEW_PRI_MAPr,&(r._new_pri_map),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define NEW_PRI_MAPr BCM6300_A0_NEW_PRI_MAPr
#define NEW_PRI_MAPr_SIZE BCM6300_A0_NEW_PRI_MAPr_SIZE
typedef BCM6300_A0_NEW_PRI_MAPr_t NEW_PRI_MAPr_t;
#define NEW_PRI_MAPr_CLR BCM6300_A0_NEW_PRI_MAPr_CLR
#define NEW_PRI_MAPr_SET BCM6300_A0_NEW_PRI_MAPr_SET
#define NEW_PRI_MAPr_GET BCM6300_A0_NEW_PRI_MAPr_GET
#define NEW_PRI_MAPr_RE_MAPf_GET BCM6300_A0_NEW_PRI_MAPr_RE_MAPf_GET
#define NEW_PRI_MAPr_RE_MAPf_SET BCM6300_A0_NEW_PRI_MAPr_RE_MAPf_SET
#define NEW_PRI_MAPr_RESERVED_Rf_GET BCM6300_A0_NEW_PRI_MAPr_RESERVED_Rf_GET
#define NEW_PRI_MAPr_RESERVED_Rf_SET BCM6300_A0_NEW_PRI_MAPr_RESERVED_Rf_SET
#define READ_NEW_PRI_MAPr BCM6300_A0_READ_NEW_PRI_MAPr
#define WRITE_NEW_PRI_MAPr BCM6300_A0_WRITE_NEW_PRI_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_NEW_PRI_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  PAUSESTS
 * BLOCKS:   SYS
 * DESC:     Pause Status Summary Register
 * SIZE:     32
 * FIELDS:
 *     TXPAUSE_STS      TxPAUSE State.indicating the PAUSE state for each 10/100/1000BASE-T port.Bit 7- 0 = Port 7 - Port 0 Transmit Pause Capability0 = Disabled1 = Enabled
 *     RXPAUSE_STS      RxPAUSE State.indicating the PAUSE state for each 10/100/1000BASE-T port.Bit 16 - 9 = Port 7 - Port 0 Receive Pause Capability0 = Disabled1 = Enabled
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_PAUSESTSr 0x00000108

#define BCM6300_A0_PAUSESTSr_SIZE 4

/*
 * This structure should be used to declare and program PAUSESTS.
 *
 */
typedef union BCM6300_A0_PAUSESTSr_s {
	uint32_t v[1];
	uint32_t pausests[1];
	uint32_t _pausests;
} BCM6300_A0_PAUSESTSr_t;

#define BCM6300_A0_PAUSESTSr_CLR(r) (r).pausests[0] = 0
#define BCM6300_A0_PAUSESTSr_SET(r,d) (r).pausests[0] = d
#define BCM6300_A0_PAUSESTSr_GET(r) (r).pausests[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_PAUSESTSr_TXPAUSE_STSf_GET(r) (((r).pausests[0]) & 0x1ff)
#define BCM6300_A0_PAUSESTSr_TXPAUSE_STSf_SET(r,f) (r).pausests[0]=(((r).pausests[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_PAUSESTSr_RXPAUSE_STSf_GET(r) ((((r).pausests[0]) >> 9) & 0x1ff)
#define BCM6300_A0_PAUSESTSr_RXPAUSE_STSf_SET(r,f) (r).pausests[0]=(((r).pausests[0] & ~((uint32_t)0x1ff << 9)) | ((((uint32_t)f) & 0x1ff) << 9))
#define BCM6300_A0_PAUSESTSr_RESERVED_Rf_GET(r) ((((r).pausests[0]) >> 18) & 0x3fff)
#define BCM6300_A0_PAUSESTSr_RESERVED_Rf_SET(r,f) (r).pausests[0]=(((r).pausests[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access PAUSESTS.
 *
 */
#define BCM6300_A0_READ_PAUSESTSr(u,r) cdk_robo_reg_read(u,BCM6300_A0_PAUSESTSr,(r._pausests),4)
#define BCM6300_A0_WRITE_PAUSESTSr(u,r) cdk_robo_reg_write(u,BCM6300_A0_PAUSESTSr,&(r._pausests),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PAUSESTSr BCM6300_A0_PAUSESTSr
#define PAUSESTSr_SIZE BCM6300_A0_PAUSESTSr_SIZE
typedef BCM6300_A0_PAUSESTSr_t PAUSESTSr_t;
#define PAUSESTSr_CLR BCM6300_A0_PAUSESTSr_CLR
#define PAUSESTSr_SET BCM6300_A0_PAUSESTSr_SET
#define PAUSESTSr_GET BCM6300_A0_PAUSESTSr_GET
#define PAUSESTSr_TXPAUSE_STSf_GET BCM6300_A0_PAUSESTSr_TXPAUSE_STSf_GET
#define PAUSESTSr_TXPAUSE_STSf_SET BCM6300_A0_PAUSESTSr_TXPAUSE_STSf_SET
#define PAUSESTSr_RXPAUSE_STSf_GET BCM6300_A0_PAUSESTSr_RXPAUSE_STSf_GET
#define PAUSESTSr_RXPAUSE_STSf_SET BCM6300_A0_PAUSESTSr_RXPAUSE_STSf_SET
#define PAUSESTSr_RESERVED_Rf_GET BCM6300_A0_PAUSESTSr_RESERVED_Rf_GET
#define PAUSESTSr_RESERVED_Rf_SET BCM6300_A0_PAUSESTSr_RESERVED_Rf_SET
#define READ_PAUSESTSr BCM6300_A0_READ_PAUSESTSr
#define WRITE_PAUSESTSr BCM6300_A0_WRITE_PAUSESTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_PAUSESTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  PAUSE_CAP
 * BLOCKS:   SYS
 * DESC:     PAUSE Capability Register
 * SIZE:     32
 * FIELDS:
 *     TX_PAUSE_CAP     Software setting for the capability of Transmitting Pause Frame.Bit 8 = MII Port.Bits 7:0 = Port 8 - Port 0.
 *     RX_PAUSE_CAP     Software setting for the capability of Receiving Pause Frame.Bit 17 = MII Port 1,Bits 16:9 = Port 7- Port 0.
 *     RESERVED_R       Reserved
 *     EN_OVERRIDE      Force the contents of the register to be used.
 *
 ******************************************************************************/
#define BCM6300_A0_PAUSE_CAPr 0x00000028

#define BCM6300_A0_PAUSE_CAPr_SIZE 4

/*
 * This structure should be used to declare and program PAUSE_CAP.
 *
 */
typedef union BCM6300_A0_PAUSE_CAPr_s {
	uint32_t v[1];
	uint32_t pause_cap[1];
	uint32_t _pause_cap;
} BCM6300_A0_PAUSE_CAPr_t;

#define BCM6300_A0_PAUSE_CAPr_CLR(r) (r).pause_cap[0] = 0
#define BCM6300_A0_PAUSE_CAPr_SET(r,d) (r).pause_cap[0] = d
#define BCM6300_A0_PAUSE_CAPr_GET(r) (r).pause_cap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_PAUSE_CAPr_TX_PAUSE_CAPf_GET(r) (((r).pause_cap[0]) & 0x1ff)
#define BCM6300_A0_PAUSE_CAPr_TX_PAUSE_CAPf_SET(r,f) (r).pause_cap[0]=(((r).pause_cap[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_PAUSE_CAPr_RX_PAUSE_CAPf_GET(r) ((((r).pause_cap[0]) >> 9) & 0x1ff)
#define BCM6300_A0_PAUSE_CAPr_RX_PAUSE_CAPf_SET(r,f) (r).pause_cap[0]=(((r).pause_cap[0] & ~((uint32_t)0x1ff << 9)) | ((((uint32_t)f) & 0x1ff) << 9))
#define BCM6300_A0_PAUSE_CAPr_RESERVED_Rf_GET(r) ((((r).pause_cap[0]) >> 18) & 0x1f)
#define BCM6300_A0_PAUSE_CAPr_RESERVED_Rf_SET(r,f) (r).pause_cap[0]=(((r).pause_cap[0] & ~((uint32_t)0x1f << 18)) | ((((uint32_t)f) & 0x1f) << 18))
#define BCM6300_A0_PAUSE_CAPr_EN_OVERRIDEf_GET(r) ((((r).pause_cap[0]) >> 23) & 0x1)
#define BCM6300_A0_PAUSE_CAPr_EN_OVERRIDEf_SET(r,f) (r).pause_cap[0]=(((r).pause_cap[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))

/*
 * These macros can be used to access PAUSE_CAP.
 *
 */
#define BCM6300_A0_READ_PAUSE_CAPr(u,r) cdk_robo_reg_read(u,BCM6300_A0_PAUSE_CAPr,(r._pause_cap),4)
#define BCM6300_A0_WRITE_PAUSE_CAPr(u,r) cdk_robo_reg_write(u,BCM6300_A0_PAUSE_CAPr,&(r._pause_cap),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PAUSE_CAPr BCM6300_A0_PAUSE_CAPr
#define PAUSE_CAPr_SIZE BCM6300_A0_PAUSE_CAPr_SIZE
typedef BCM6300_A0_PAUSE_CAPr_t PAUSE_CAPr_t;
#define PAUSE_CAPr_CLR BCM6300_A0_PAUSE_CAPr_CLR
#define PAUSE_CAPr_SET BCM6300_A0_PAUSE_CAPr_SET
#define PAUSE_CAPr_GET BCM6300_A0_PAUSE_CAPr_GET
#define PAUSE_CAPr_TX_PAUSE_CAPf_GET BCM6300_A0_PAUSE_CAPr_TX_PAUSE_CAPf_GET
#define PAUSE_CAPr_TX_PAUSE_CAPf_SET BCM6300_A0_PAUSE_CAPr_TX_PAUSE_CAPf_SET
#define PAUSE_CAPr_RX_PAUSE_CAPf_GET BCM6300_A0_PAUSE_CAPr_RX_PAUSE_CAPf_GET
#define PAUSE_CAPr_RX_PAUSE_CAPf_SET BCM6300_A0_PAUSE_CAPr_RX_PAUSE_CAPf_SET
#define PAUSE_CAPr_RESERVED_Rf_GET BCM6300_A0_PAUSE_CAPr_RESERVED_Rf_GET
#define PAUSE_CAPr_RESERVED_Rf_SET BCM6300_A0_PAUSE_CAPr_RESERVED_Rf_SET
#define PAUSE_CAPr_EN_OVERRIDEf_GET BCM6300_A0_PAUSE_CAPr_EN_OVERRIDEf_GET
#define PAUSE_CAPr_EN_OVERRIDEf_SET BCM6300_A0_PAUSE_CAPr_EN_OVERRIDEf_SET
#define READ_PAUSE_CAPr BCM6300_A0_READ_PAUSE_CAPr
#define WRITE_PAUSE_CAPr BCM6300_A0_WRITE_PAUSE_CAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_PAUSE_CAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  PAUSE_FRM_CTRL
 * BLOCKS:   SYS
 * DESC:     Pause Frame Detection Control Registrer
 * SIZE:     8
 * FIELDS:
 *     PAUSE_IGNORE_DA  Pause_ignore_Da0: Check DA field on Pause Frame detection1: Ignore DA field on Pause Frame detection
 *     RESERVED_1R      Reserved
 *     RESERVED_2R      Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_PAUSE_FRM_CTRLr 0x00000080

#define BCM6300_A0_PAUSE_FRM_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program PAUSE_FRM_CTRL.
 *
 */
typedef union BCM6300_A0_PAUSE_FRM_CTRLr_s {
	uint32_t v[1];
	uint32_t pause_frm_ctrl[1];
	uint32_t _pause_frm_ctrl;
} BCM6300_A0_PAUSE_FRM_CTRLr_t;

#define BCM6300_A0_PAUSE_FRM_CTRLr_CLR(r) (r).pause_frm_ctrl[0] = 0
#define BCM6300_A0_PAUSE_FRM_CTRLr_SET(r,d) (r).pause_frm_ctrl[0] = d
#define BCM6300_A0_PAUSE_FRM_CTRLr_GET(r) (r).pause_frm_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_PAUSE_FRM_CTRLr_PAUSE_IGNORE_DAf_GET(r) (((r).pause_frm_ctrl[0]) & 0x1)
#define BCM6300_A0_PAUSE_FRM_CTRLr_PAUSE_IGNORE_DAf_SET(r,f) (r).pause_frm_ctrl[0]=(((r).pause_frm_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM6300_A0_PAUSE_FRM_CTRLr_RESERVED_1Rf_GET(r) ((((r).pause_frm_ctrl[0]) >> 1) & 0x3)
#define BCM6300_A0_PAUSE_FRM_CTRLr_RESERVED_1Rf_SET(r,f) (r).pause_frm_ctrl[0]=(((r).pause_frm_ctrl[0] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM6300_A0_PAUSE_FRM_CTRLr_RESERVED_2Rf_GET(r) ((((r).pause_frm_ctrl[0]) >> 3) & 0x1f)
#define BCM6300_A0_PAUSE_FRM_CTRLr_RESERVED_2Rf_SET(r,f) (r).pause_frm_ctrl[0]=(((r).pause_frm_ctrl[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3))

/*
 * These macros can be used to access PAUSE_FRM_CTRL.
 *
 */
#define BCM6300_A0_READ_PAUSE_FRM_CTRLr(u,r) cdk_robo_reg_read(u,BCM6300_A0_PAUSE_FRM_CTRLr,(r._pause_frm_ctrl),1)
#define BCM6300_A0_WRITE_PAUSE_FRM_CTRLr(u,r) cdk_robo_reg_write(u,BCM6300_A0_PAUSE_FRM_CTRLr,&(r._pause_frm_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PAUSE_FRM_CTRLr BCM6300_A0_PAUSE_FRM_CTRLr
#define PAUSE_FRM_CTRLr_SIZE BCM6300_A0_PAUSE_FRM_CTRLr_SIZE
typedef BCM6300_A0_PAUSE_FRM_CTRLr_t PAUSE_FRM_CTRLr_t;
#define PAUSE_FRM_CTRLr_CLR BCM6300_A0_PAUSE_FRM_CTRLr_CLR
#define PAUSE_FRM_CTRLr_SET BCM6300_A0_PAUSE_FRM_CTRLr_SET
#define PAUSE_FRM_CTRLr_GET BCM6300_A0_PAUSE_FRM_CTRLr_GET
#define PAUSE_FRM_CTRLr_PAUSE_IGNORE_DAf_GET BCM6300_A0_PAUSE_FRM_CTRLr_PAUSE_IGNORE_DAf_GET
#define PAUSE_FRM_CTRLr_PAUSE_IGNORE_DAf_SET BCM6300_A0_PAUSE_FRM_CTRLr_PAUSE_IGNORE_DAf_SET
#define PAUSE_FRM_CTRLr_RESERVED_1Rf_GET BCM6300_A0_PAUSE_FRM_CTRLr_RESERVED_1Rf_GET
#define PAUSE_FRM_CTRLr_RESERVED_1Rf_SET BCM6300_A0_PAUSE_FRM_CTRLr_RESERVED_1Rf_SET
#define PAUSE_FRM_CTRLr_RESERVED_2Rf_GET BCM6300_A0_PAUSE_FRM_CTRLr_RESERVED_2Rf_GET
#define PAUSE_FRM_CTRLr_RESERVED_2Rf_SET BCM6300_A0_PAUSE_FRM_CTRLr_RESERVED_2Rf_SET
#define READ_PAUSE_FRM_CTRLr BCM6300_A0_READ_PAUSE_FRM_CTRLr
#define WRITE_PAUSE_FRM_CTRLr BCM6300_A0_WRITE_PAUSE_FRM_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_PAUSE_FRM_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  PAUSE_QUANTA
 * BLOCKS:   SYS
 * DESC:     PAUSE Quanta register
 * SIZE:     16
 * FIELDS:
 *     PAUSE_QUANTA     The number of slot times that the transmitter wishes the link partner to suspend its transmission. The same value is common to all ports which have Auto-Negotiated to full duplex with flow control enabled.
 *
 ******************************************************************************/
#define BCM6300_A0_PAUSE_QUANTAr 0x0000000c

#define BCM6300_A0_PAUSE_QUANTAr_SIZE 2

/*
 * This structure should be used to declare and program PAUSE_QUANTA.
 *
 */
typedef union BCM6300_A0_PAUSE_QUANTAr_s {
	uint32_t v[1];
	uint32_t pause_quanta[1];
	uint32_t _pause_quanta;
} BCM6300_A0_PAUSE_QUANTAr_t;

#define BCM6300_A0_PAUSE_QUANTAr_CLR(r) (r).pause_quanta[0] = 0
#define BCM6300_A0_PAUSE_QUANTAr_SET(r,d) (r).pause_quanta[0] = d
#define BCM6300_A0_PAUSE_QUANTAr_GET(r) (r).pause_quanta[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_PAUSE_QUANTAr_PAUSE_QUANTAf_GET(r) (((r).pause_quanta[0]) & 0xffff)
#define BCM6300_A0_PAUSE_QUANTAr_PAUSE_QUANTAf_SET(r,f) (r).pause_quanta[0]=(((r).pause_quanta[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PAUSE_QUANTA.
 *
 */
#define BCM6300_A0_READ_PAUSE_QUANTAr(u,r) cdk_robo_reg_read(u,BCM6300_A0_PAUSE_QUANTAr,(r._pause_quanta),2)
#define BCM6300_A0_WRITE_PAUSE_QUANTAr(u,r) cdk_robo_reg_write(u,BCM6300_A0_PAUSE_QUANTAr,&(r._pause_quanta),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PAUSE_QUANTAr BCM6300_A0_PAUSE_QUANTAr
#define PAUSE_QUANTAr_SIZE BCM6300_A0_PAUSE_QUANTAr_SIZE
typedef BCM6300_A0_PAUSE_QUANTAr_t PAUSE_QUANTAr_t;
#define PAUSE_QUANTAr_CLR BCM6300_A0_PAUSE_QUANTAr_CLR
#define PAUSE_QUANTAr_SET BCM6300_A0_PAUSE_QUANTAr_SET
#define PAUSE_QUANTAr_GET BCM6300_A0_PAUSE_QUANTAr_GET
#define PAUSE_QUANTAr_PAUSE_QUANTAf_GET BCM6300_A0_PAUSE_QUANTAr_PAUSE_QUANTAf_GET
#define PAUSE_QUANTAr_PAUSE_QUANTAf_SET BCM6300_A0_PAUSE_QUANTAr_PAUSE_QUANTAf_SET
#define READ_PAUSE_QUANTAr BCM6300_A0_READ_PAUSE_QUANTAr
#define WRITE_PAUSE_QUANTAr BCM6300_A0_WRITE_PAUSE_QUANTAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_PAUSE_QUANTAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  PHYIDH
 * BLOCKS:   GPIC0
 * DESC:     PHY ID High Register
 * SIZE:     16
 * FIELDS:
 *     MII_ADDR         
 *
 ******************************************************************************/
#define BCM6300_A0_PHYIDHr 0x00001004

#define BCM6300_A0_PHYIDHr_SIZE 2

/*
 * This structure should be used to declare and program PHYIDH.
 *
 */
typedef union BCM6300_A0_PHYIDHr_s {
	uint32_t v[1];
	uint32_t phyidh[1];
	uint32_t _phyidh;
} BCM6300_A0_PHYIDHr_t;

#define BCM6300_A0_PHYIDHr_CLR(r) (r).phyidh[0] = 0
#define BCM6300_A0_PHYIDHr_SET(r,d) (r).phyidh[0] = d
#define BCM6300_A0_PHYIDHr_GET(r) (r).phyidh[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_PHYIDHr_MII_ADDRf_GET(r) (((r).phyidh[0]) & 0xffff)
#define BCM6300_A0_PHYIDHr_MII_ADDRf_SET(r,f) (r).phyidh[0]=(((r).phyidh[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PHYIDH.
 *
 */
#define BCM6300_A0_READ_PHYIDHr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_PHYIDHr,(r._phyidh),2)
#define BCM6300_A0_WRITE_PHYIDHr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_PHYIDHr,&(r._phyidh),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PHYIDHr BCM6300_A0_PHYIDHr
#define PHYIDHr_SIZE BCM6300_A0_PHYIDHr_SIZE
typedef BCM6300_A0_PHYIDHr_t PHYIDHr_t;
#define PHYIDHr_CLR BCM6300_A0_PHYIDHr_CLR
#define PHYIDHr_SET BCM6300_A0_PHYIDHr_SET
#define PHYIDHr_GET BCM6300_A0_PHYIDHr_GET
#define PHYIDHr_MII_ADDRf_GET BCM6300_A0_PHYIDHr_MII_ADDRf_GET
#define PHYIDHr_MII_ADDRf_SET BCM6300_A0_PHYIDHr_MII_ADDRf_SET
#define READ_PHYIDHr BCM6300_A0_READ_PHYIDHr
#define WRITE_PHYIDHr BCM6300_A0_WRITE_PHYIDHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_PHYIDHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  PHYIDL
 * BLOCKS:   GPIC0
 * DESC:     PHY ID LOW Register
 * SIZE:     16
 * FIELDS:
 *     MII_ADDR         
 *
 ******************************************************************************/
#define BCM6300_A0_PHYIDLr 0x00001006

#define BCM6300_A0_PHYIDLr_SIZE 2

/*
 * This structure should be used to declare and program PHYIDL.
 *
 */
typedef union BCM6300_A0_PHYIDLr_s {
	uint32_t v[1];
	uint32_t phyidl[1];
	uint32_t _phyidl;
} BCM6300_A0_PHYIDLr_t;

#define BCM6300_A0_PHYIDLr_CLR(r) (r).phyidl[0] = 0
#define BCM6300_A0_PHYIDLr_SET(r,d) (r).phyidl[0] = d
#define BCM6300_A0_PHYIDLr_GET(r) (r).phyidl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_PHYIDLr_MII_ADDRf_GET(r) (((r).phyidl[0]) & 0xffff)
#define BCM6300_A0_PHYIDLr_MII_ADDRf_SET(r,f) (r).phyidl[0]=(((r).phyidl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PHYIDL.
 *
 */
#define BCM6300_A0_READ_PHYIDLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_PHYIDLr,(r._phyidl),2)
#define BCM6300_A0_WRITE_PHYIDLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_PHYIDLr,&(r._phyidl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PHYIDLr BCM6300_A0_PHYIDLr
#define PHYIDLr_SIZE BCM6300_A0_PHYIDLr_SIZE
typedef BCM6300_A0_PHYIDLr_t PHYIDLr_t;
#define PHYIDLr_CLR BCM6300_A0_PHYIDLr_CLR
#define PHYIDLr_SET BCM6300_A0_PHYIDLr_SET
#define PHYIDLr_GET BCM6300_A0_PHYIDLr_GET
#define PHYIDLr_MII_ADDRf_GET BCM6300_A0_PHYIDLr_MII_ADDRf_GET
#define PHYIDLr_MII_ADDRf_SET BCM6300_A0_PHYIDLr_MII_ADDRf_SET
#define READ_PHYIDLr BCM6300_A0_READ_PHYIDLr
#define WRITE_PHYIDLr BCM6300_A0_WRITE_PHYIDLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_PHYIDLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  PLL_TEST
 * BLOCKS:   SYS
 * DESC:     PLL test Registrer
 * SIZE:     16
 * FIELDS:
 *     VCO_RANGE0       VCO frequency range control.0 : VCO Fout = 500 ~ 1100M.1 : VCO Fout = 600 ~ 1200M.
 *     ICP              Change pump bias current setting.001 : 1qp = 4uA.100 : 1qp = 8uA.101 : 1qp = 12uA.110 : 1qp = 16uA.111 : 1qp = 20uA.
 *     TSTSEL           Test Signal Select.00 : PLLTEST = CLK1.01 : PLLTEST = CLK2.10 : PLLTEST = VC Sense11 : PLLTEST = VC Force.
 *     TEST_EN          Enable control for test function. 1 : Enable test function.0 : Disable test function.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_PLL_TESTr 0x0000004a

#define BCM6300_A0_PLL_TESTr_SIZE 2

/*
 * This structure should be used to declare and program PLL_TEST.
 *
 */
typedef union BCM6300_A0_PLL_TESTr_s {
	uint32_t v[1];
	uint32_t pll_test[1];
	uint32_t _pll_test;
} BCM6300_A0_PLL_TESTr_t;

#define BCM6300_A0_PLL_TESTr_CLR(r) (r).pll_test[0] = 0
#define BCM6300_A0_PLL_TESTr_SET(r,d) (r).pll_test[0] = d
#define BCM6300_A0_PLL_TESTr_GET(r) (r).pll_test[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_PLL_TESTr_VCO_RANGE0f_GET(r) (((r).pll_test[0]) & 0x1)
#define BCM6300_A0_PLL_TESTr_VCO_RANGE0f_SET(r,f) (r).pll_test[0]=(((r).pll_test[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM6300_A0_PLL_TESTr_ICPf_GET(r) ((((r).pll_test[0]) >> 1) & 0x7)
#define BCM6300_A0_PLL_TESTr_ICPf_SET(r,f) (r).pll_test[0]=(((r).pll_test[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM6300_A0_PLL_TESTr_TSTSELf_GET(r) ((((r).pll_test[0]) >> 4) & 0x3)
#define BCM6300_A0_PLL_TESTr_TSTSELf_SET(r,f) (r).pll_test[0]=(((r).pll_test[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM6300_A0_PLL_TESTr_TEST_ENf_GET(r) ((((r).pll_test[0]) >> 6) & 0x1)
#define BCM6300_A0_PLL_TESTr_TEST_ENf_SET(r,f) (r).pll_test[0]=(((r).pll_test[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM6300_A0_PLL_TESTr_RESERVED_Rf_GET(r) ((((r).pll_test[0]) >> 7) & 0x1ff)
#define BCM6300_A0_PLL_TESTr_RESERVED_Rf_SET(r,f) (r).pll_test[0]=(((r).pll_test[0] & ~((uint32_t)0x1ff << 7)) | ((((uint32_t)f) & 0x1ff) << 7))

/*
 * These macros can be used to access PLL_TEST.
 *
 */
#define BCM6300_A0_READ_PLL_TESTr(u,r) cdk_robo_reg_read(u,BCM6300_A0_PLL_TESTr,(r._pll_test),2)
#define BCM6300_A0_WRITE_PLL_TESTr(u,r) cdk_robo_reg_write(u,BCM6300_A0_PLL_TESTr,&(r._pll_test),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PLL_TESTr BCM6300_A0_PLL_TESTr
#define PLL_TESTr_SIZE BCM6300_A0_PLL_TESTr_SIZE
typedef BCM6300_A0_PLL_TESTr_t PLL_TESTr_t;
#define PLL_TESTr_CLR BCM6300_A0_PLL_TESTr_CLR
#define PLL_TESTr_SET BCM6300_A0_PLL_TESTr_SET
#define PLL_TESTr_GET BCM6300_A0_PLL_TESTr_GET
#define PLL_TESTr_VCO_RANGE0f_GET BCM6300_A0_PLL_TESTr_VCO_RANGE0f_GET
#define PLL_TESTr_VCO_RANGE0f_SET BCM6300_A0_PLL_TESTr_VCO_RANGE0f_SET
#define PLL_TESTr_ICPf_GET BCM6300_A0_PLL_TESTr_ICPf_GET
#define PLL_TESTr_ICPf_SET BCM6300_A0_PLL_TESTr_ICPf_SET
#define PLL_TESTr_TSTSELf_GET BCM6300_A0_PLL_TESTr_TSTSELf_GET
#define PLL_TESTr_TSTSELf_SET BCM6300_A0_PLL_TESTr_TSTSELf_SET
#define PLL_TESTr_TEST_ENf_GET BCM6300_A0_PLL_TESTr_TEST_ENf_GET
#define PLL_TESTr_TEST_ENf_SET BCM6300_A0_PLL_TESTr_TEST_ENf_SET
#define PLL_TESTr_RESERVED_Rf_GET BCM6300_A0_PLL_TESTr_RESERVED_Rf_GET
#define PLL_TESTr_RESERVED_Rf_SET BCM6300_A0_PLL_TESTr_RESERVED_Rf_SET
#define READ_PLL_TESTr BCM6300_A0_READ_PLL_TESTr
#define WRITE_PLL_TESTr BCM6300_A0_WRITE_PLL_TESTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_PLL_TESTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  PORTVEC1
 * BLOCKS:   SYS
 * DESC:     Multiport Vector 1 Register
 * SIZE:     32
 * FIELDS:
 *     PORT_VCTR        Multiport Vector 1A bit mask corresponding to the physical ports on the chip.A frame with a DA matching the content of the Multiport Address 1 register will be forwarded to each port with a bit set in the Multiport Vector 1 bit map.Bit 8: Management Port (MII Management )
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_PORTVEC1r 0x00000418

#define BCM6300_A0_PORTVEC1r_SIZE 4

/*
 * This structure should be used to declare and program PORTVEC1.
 *
 */
typedef union BCM6300_A0_PORTVEC1r_s {
	uint32_t v[1];
	uint32_t portvec1[1];
	uint32_t _portvec1;
} BCM6300_A0_PORTVEC1r_t;

#define BCM6300_A0_PORTVEC1r_CLR(r) (r).portvec1[0] = 0
#define BCM6300_A0_PORTVEC1r_SET(r,d) (r).portvec1[0] = d
#define BCM6300_A0_PORTVEC1r_GET(r) (r).portvec1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_PORTVEC1r_PORT_VCTRf_GET(r) (((r).portvec1[0]) & 0x1ff)
#define BCM6300_A0_PORTVEC1r_PORT_VCTRf_SET(r,f) (r).portvec1[0]=(((r).portvec1[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_PORTVEC1r_RESERVED_Rf_GET(r) ((((r).portvec1[0]) >> 9) & 0x7fffff)
#define BCM6300_A0_PORTVEC1r_RESERVED_Rf_SET(r,f) (r).portvec1[0]=(((r).portvec1[0] & ~((uint32_t)0x7fffff << 9)) | ((((uint32_t)f) & 0x7fffff) << 9))

/*
 * These macros can be used to access PORTVEC1.
 *
 */
#define BCM6300_A0_READ_PORTVEC1r(u,r) cdk_robo_reg_read(u,BCM6300_A0_PORTVEC1r,(r._portvec1),4)
#define BCM6300_A0_WRITE_PORTVEC1r(u,r) cdk_robo_reg_write(u,BCM6300_A0_PORTVEC1r,&(r._portvec1),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORTVEC1r BCM6300_A0_PORTVEC1r
#define PORTVEC1r_SIZE BCM6300_A0_PORTVEC1r_SIZE
typedef BCM6300_A0_PORTVEC1r_t PORTVEC1r_t;
#define PORTVEC1r_CLR BCM6300_A0_PORTVEC1r_CLR
#define PORTVEC1r_SET BCM6300_A0_PORTVEC1r_SET
#define PORTVEC1r_GET BCM6300_A0_PORTVEC1r_GET
#define PORTVEC1r_PORT_VCTRf_GET BCM6300_A0_PORTVEC1r_PORT_VCTRf_GET
#define PORTVEC1r_PORT_VCTRf_SET BCM6300_A0_PORTVEC1r_PORT_VCTRf_SET
#define PORTVEC1r_RESERVED_Rf_GET BCM6300_A0_PORTVEC1r_RESERVED_Rf_GET
#define PORTVEC1r_RESERVED_Rf_SET BCM6300_A0_PORTVEC1r_RESERVED_Rf_SET
#define READ_PORTVEC1r BCM6300_A0_READ_PORTVEC1r
#define WRITE_PORTVEC1r BCM6300_A0_WRITE_PORTVEC1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_PORTVEC1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  PORTVEC2
 * BLOCKS:   SYS
 * DESC:     Multiport Vector 2 Register
 * SIZE:     32
 * FIELDS:
 *     PORT_VCTR        Multiport Vector 2.A bit mask corresponding to the physical ports on the chip.A frame with a DA matching the content of the Multiport Address 2 register will be forwarded to each port with a bit set in the Multiport Vector 2 bit map.Bits 0-7: Port 0-7 in chip 0.Bit 8: Management Port ( MII Management ).
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_PORTVEC2r 0x00000428

#define BCM6300_A0_PORTVEC2r_SIZE 4

/*
 * This structure should be used to declare and program PORTVEC2.
 *
 */
typedef union BCM6300_A0_PORTVEC2r_s {
	uint32_t v[1];
	uint32_t portvec2[1];
	uint32_t _portvec2;
} BCM6300_A0_PORTVEC2r_t;

#define BCM6300_A0_PORTVEC2r_CLR(r) (r).portvec2[0] = 0
#define BCM6300_A0_PORTVEC2r_SET(r,d) (r).portvec2[0] = d
#define BCM6300_A0_PORTVEC2r_GET(r) (r).portvec2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_PORTVEC2r_PORT_VCTRf_GET(r) (((r).portvec2[0]) & 0x1ff)
#define BCM6300_A0_PORTVEC2r_PORT_VCTRf_SET(r,f) (r).portvec2[0]=(((r).portvec2[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_PORTVEC2r_RESERVED_Rf_GET(r) ((((r).portvec2[0]) >> 9) & 0x7fffff)
#define BCM6300_A0_PORTVEC2r_RESERVED_Rf_SET(r,f) (r).portvec2[0]=(((r).portvec2[0] & ~((uint32_t)0x7fffff << 9)) | ((((uint32_t)f) & 0x7fffff) << 9))

/*
 * These macros can be used to access PORTVEC2.
 *
 */
#define BCM6300_A0_READ_PORTVEC2r(u,r) cdk_robo_reg_read(u,BCM6300_A0_PORTVEC2r,(r._portvec2),4)
#define BCM6300_A0_WRITE_PORTVEC2r(u,r) cdk_robo_reg_write(u,BCM6300_A0_PORTVEC2r,&(r._portvec2),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORTVEC2r BCM6300_A0_PORTVEC2r
#define PORTVEC2r_SIZE BCM6300_A0_PORTVEC2r_SIZE
typedef BCM6300_A0_PORTVEC2r_t PORTVEC2r_t;
#define PORTVEC2r_CLR BCM6300_A0_PORTVEC2r_CLR
#define PORTVEC2r_SET BCM6300_A0_PORTVEC2r_SET
#define PORTVEC2r_GET BCM6300_A0_PORTVEC2r_GET
#define PORTVEC2r_PORT_VCTRf_GET BCM6300_A0_PORTVEC2r_PORT_VCTRf_GET
#define PORTVEC2r_PORT_VCTRf_SET BCM6300_A0_PORTVEC2r_PORT_VCTRf_SET
#define PORTVEC2r_RESERVED_Rf_GET BCM6300_A0_PORTVEC2r_RESERVED_Rf_GET
#define PORTVEC2r_RESERVED_Rf_SET BCM6300_A0_PORTVEC2r_RESERVED_Rf_SET
#define READ_PORTVEC2r BCM6300_A0_READ_PORTVEC2r
#define WRITE_PORTVEC2r BCM6300_A0_WRITE_PORTVEC2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_PORTVEC2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  PORT_EAP_CON
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Port EAP Configuration Registers
 * SIZE:     64
 * FIELDS:
 *     EAP_UNI_DA       EAP frame DA register.
 *     EAP_EN_UNI_DA    enable EAP frame with DA.
 *     EAP_BLK_MODE     When set, only frame defined in EAP_GCFG qill be received; otherwise frame will be drop.
 *     EAP_MODE         00 : Basic mode, do not check SA,01 : Reserved.10 : Extend mode, check SA & port-number. Drop if SA is unknown.11 : Simplified mode, check SA & port-number. Trap to mgnt-port if SA is unknown.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_PORT_EAP_CONr 0x00004220

#define BCM6300_A0_PORT_EAP_CONr_SIZE 8

/*
 * This structure should be used to declare and program PORT_EAP_CON.
 *
 */
typedef union BCM6300_A0_PORT_EAP_CONr_s {
	uint32_t v[2];
	uint32_t port_eap_con[2];
	uint32_t _port_eap_con;
} BCM6300_A0_PORT_EAP_CONr_t;

#define BCM6300_A0_PORT_EAP_CONr_CLR(r) CDK_MEMSET(&((r)._port_eap_con), 0, sizeof(BCM6300_A0_PORT_EAP_CONr_t))
#define BCM6300_A0_PORT_EAP_CONr_SET(r,i,d) (r).port_eap_con[i] = d
#define BCM6300_A0_PORT_EAP_CONr_GET(r,i) (r).port_eap_con[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_PORT_EAP_CONr_EAP_UNI_DAf_GET(r,a) cdk_field_get((r).port_eap_con,0,47,a)
#define BCM6300_A0_PORT_EAP_CONr_EAP_UNI_DAf_SET(r,a) cdk_field_set((r).port_eap_con,0,47,a)
#define BCM6300_A0_PORT_EAP_CONr_EAP_EN_UNI_DAf_GET(r) ((((r).port_eap_con[1]) >> 16) & 0x1)
#define BCM6300_A0_PORT_EAP_CONr_EAP_EN_UNI_DAf_SET(r,f) (r).port_eap_con[1]=(((r).port_eap_con[1] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM6300_A0_PORT_EAP_CONr_EAP_BLK_MODEf_GET(r) ((((r).port_eap_con[1]) >> 17) & 0x1)
#define BCM6300_A0_PORT_EAP_CONr_EAP_BLK_MODEf_SET(r,f) (r).port_eap_con[1]=(((r).port_eap_con[1] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM6300_A0_PORT_EAP_CONr_EAP_MODEf_GET(r) ((((r).port_eap_con[1]) >> 18) & 0x3)
#define BCM6300_A0_PORT_EAP_CONr_EAP_MODEf_SET(r,f) (r).port_eap_con[1]=(((r).port_eap_con[1] & ~((uint32_t)0x3 << 18)) | ((((uint32_t)f) & 0x3) << 18))
#define BCM6300_A0_PORT_EAP_CONr_RESERVED_Rf_GET(r) ((((r).port_eap_con[1]) >> 20) & 0xfff)
#define BCM6300_A0_PORT_EAP_CONr_RESERVED_Rf_SET(r,f) (r).port_eap_con[1]=(((r).port_eap_con[1] & ~((uint32_t)0xfff << 20)) | ((((uint32_t)f) & 0xfff) << 20))

/*
 * These macros can be used to access PORT_EAP_CON.
 *
 */
#define BCM6300_A0_READ_PORT_EAP_CONr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_PORT_EAP_CONr,(r._port_eap_con),8)
#define BCM6300_A0_WRITE_PORT_EAP_CONr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_PORT_EAP_CONr,&(r._port_eap_con),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_EAP_CONr BCM6300_A0_PORT_EAP_CONr
#define PORT_EAP_CONr_SIZE BCM6300_A0_PORT_EAP_CONr_SIZE
typedef BCM6300_A0_PORT_EAP_CONr_t PORT_EAP_CONr_t;
#define PORT_EAP_CONr_CLR BCM6300_A0_PORT_EAP_CONr_CLR
#define PORT_EAP_CONr_SET BCM6300_A0_PORT_EAP_CONr_SET
#define PORT_EAP_CONr_GET BCM6300_A0_PORT_EAP_CONr_GET
#define PORT_EAP_CONr_EAP_UNI_DAf_GET BCM6300_A0_PORT_EAP_CONr_EAP_UNI_DAf_GET
#define PORT_EAP_CONr_EAP_UNI_DAf_SET BCM6300_A0_PORT_EAP_CONr_EAP_UNI_DAf_SET
#define PORT_EAP_CONr_EAP_EN_UNI_DAf_GET BCM6300_A0_PORT_EAP_CONr_EAP_EN_UNI_DAf_GET
#define PORT_EAP_CONr_EAP_EN_UNI_DAf_SET BCM6300_A0_PORT_EAP_CONr_EAP_EN_UNI_DAf_SET
#define PORT_EAP_CONr_EAP_BLK_MODEf_GET BCM6300_A0_PORT_EAP_CONr_EAP_BLK_MODEf_GET
#define PORT_EAP_CONr_EAP_BLK_MODEf_SET BCM6300_A0_PORT_EAP_CONr_EAP_BLK_MODEf_SET
#define PORT_EAP_CONr_EAP_MODEf_GET BCM6300_A0_PORT_EAP_CONr_EAP_MODEf_GET
#define PORT_EAP_CONr_EAP_MODEf_SET BCM6300_A0_PORT_EAP_CONr_EAP_MODEf_SET
#define PORT_EAP_CONr_RESERVED_Rf_GET BCM6300_A0_PORT_EAP_CONr_RESERVED_Rf_GET
#define PORT_EAP_CONr_RESERVED_Rf_SET BCM6300_A0_PORT_EAP_CONr_RESERVED_Rf_SET
#define READ_PORT_EAP_CONr BCM6300_A0_READ_PORT_EAP_CONr
#define WRITE_PORT_EAP_CONr BCM6300_A0_WRITE_PORT_EAP_CONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_PORT_EAP_CONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  PORT_ERC_CON
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Port Ingress Rate Control Configuration Registers
 * SIZE:     16
 * FIELDS:
 *     REF_CNTS         Refresh count for bucket.
 *     BUCKET_SIZE      Bucket Size.000 : 16KB001 : 20KB,010 : 28KB,011 : 40KB,100 : 76KB,101 : 140KB,110 : 268KB,111 : 500KB.
 *     ENG_RC_EN        Egress Rate control Enable.
 *     PORT_ERC_CON_RSRV1 Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_PORT_ERC_CONr 0x00004180

#define BCM6300_A0_PORT_ERC_CONr_SIZE 2

/*
 * This structure should be used to declare and program PORT_ERC_CON.
 *
 */
typedef union BCM6300_A0_PORT_ERC_CONr_s {
	uint32_t v[1];
	uint32_t port_erc_con[1];
	uint32_t _port_erc_con;
} BCM6300_A0_PORT_ERC_CONr_t;

#define BCM6300_A0_PORT_ERC_CONr_CLR(r) (r).port_erc_con[0] = 0
#define BCM6300_A0_PORT_ERC_CONr_SET(r,d) (r).port_erc_con[0] = d
#define BCM6300_A0_PORT_ERC_CONr_GET(r) (r).port_erc_con[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_PORT_ERC_CONr_REF_CNTSf_GET(r) (((r).port_erc_con[0]) & 0xff)
#define BCM6300_A0_PORT_ERC_CONr_REF_CNTSf_SET(r,f) (r).port_erc_con[0]=(((r).port_erc_con[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM6300_A0_PORT_ERC_CONr_BUCKET_SIZEf_GET(r) ((((r).port_erc_con[0]) >> 8) & 0x7)
#define BCM6300_A0_PORT_ERC_CONr_BUCKET_SIZEf_SET(r,f) (r).port_erc_con[0]=(((r).port_erc_con[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCM6300_A0_PORT_ERC_CONr_ENG_RC_ENf_GET(r) ((((r).port_erc_con[0]) >> 11) & 0x1)
#define BCM6300_A0_PORT_ERC_CONr_ENG_RC_ENf_SET(r,f) (r).port_erc_con[0]=(((r).port_erc_con[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM6300_A0_PORT_ERC_CONr_PORT_ERC_CON_RSRV1f_GET(r) ((((r).port_erc_con[0]) >> 12) & 0xf)
#define BCM6300_A0_PORT_ERC_CONr_PORT_ERC_CON_RSRV1f_SET(r,f) (r).port_erc_con[0]=(((r).port_erc_con[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access PORT_ERC_CON.
 *
 */
#define BCM6300_A0_READ_PORT_ERC_CONr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_PORT_ERC_CONr,(r._port_erc_con),2)
#define BCM6300_A0_WRITE_PORT_ERC_CONr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_PORT_ERC_CONr,&(r._port_erc_con),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_ERC_CONr BCM6300_A0_PORT_ERC_CONr
#define PORT_ERC_CONr_SIZE BCM6300_A0_PORT_ERC_CONr_SIZE
typedef BCM6300_A0_PORT_ERC_CONr_t PORT_ERC_CONr_t;
#define PORT_ERC_CONr_CLR BCM6300_A0_PORT_ERC_CONr_CLR
#define PORT_ERC_CONr_SET BCM6300_A0_PORT_ERC_CONr_SET
#define PORT_ERC_CONr_GET BCM6300_A0_PORT_ERC_CONr_GET
#define PORT_ERC_CONr_REF_CNTSf_GET BCM6300_A0_PORT_ERC_CONr_REF_CNTSf_GET
#define PORT_ERC_CONr_REF_CNTSf_SET BCM6300_A0_PORT_ERC_CONr_REF_CNTSf_SET
#define PORT_ERC_CONr_BUCKET_SIZEf_GET BCM6300_A0_PORT_ERC_CONr_BUCKET_SIZEf_GET
#define PORT_ERC_CONr_BUCKET_SIZEf_SET BCM6300_A0_PORT_ERC_CONr_BUCKET_SIZEf_SET
#define PORT_ERC_CONr_ENG_RC_ENf_GET BCM6300_A0_PORT_ERC_CONr_ENG_RC_ENf_GET
#define PORT_ERC_CONr_ENG_RC_ENf_SET BCM6300_A0_PORT_ERC_CONr_ENG_RC_ENf_SET
#define PORT_ERC_CONr_PORT_ERC_CON_RSRV1f_GET BCM6300_A0_PORT_ERC_CONr_PORT_ERC_CON_RSRV1f_GET
#define PORT_ERC_CONr_PORT_ERC_CON_RSRV1f_SET BCM6300_A0_PORT_ERC_CONr_PORT_ERC_CON_RSRV1f_SET
#define READ_PORT_ERC_CONr BCM6300_A0_READ_PORT_ERC_CONr
#define WRITE_PORT_ERC_CONr BCM6300_A0_WRITE_PORT_ERC_CONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_PORT_ERC_CONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  PORT_IRC_CON
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Port N Recive Rate Control Registers
 * SIZE:     32
 * FIELDS:
 *     REF_CNT0         Refresh Count Define allowing Incoming Packet Bit Rate.For those Packets Defined in Suppressed Packet Type Mask in Suppression Control Register When Bit Rate Mode Selection is 0(Absolute Bit Rate Mode)1~28 :Bit Rate = Refresh Count*8*1024/125, that'sBit Rate is 64Kb ~1.792Mb with Resolution 64Kb29~127:Bit Rate = (Refresh Count-27)*1024, that'sBit Rate is 2Mb~100Mb with Resolution 1Mb128~240:Bit Rate = (Refresh Count - 115)*1024*8, that'sBit Rate is 104Mb~1000Mb with Resolution 8MbWhen Bit Rate Mode Selection is 1(Bit Rate Related to Link Speed Mode)1~125: when 10M speedBit Rate = Refresh Count * 8 * 1024 /100, that'sBit Rate is 0.08Mb~10Mb with Resolution 0.08Mb 1~125: when 100M speedBit Rate = Refresh Count * 8 * 1024/10, that'sBit Rate is 0.8Mb~100Mb with Resolution 0.8Mb 1~125: when 1000M SpeedBit Rate = Refresh Count * 8 * 1024, that'sBit Rate is 8Mb~1000Mb with Resoultion 8Mbdefault by {3'b0,bc_sup,4'b0}.
 *     BUCKET_SIZE0     Bucket Size.Bucket Size will affect the burst traffic.3'b000: 16K Byte(valid 4K bytes),3'b001:20K Byte (valid 8K bytes),3'b010:28K Byte (Valid 16K bytes),3'b011:40K Byte (Valid 28K bytes),3'b100:76K Byte (Valid 64K bytes),3'b101:140K Byte(Valid 128K bytes),3'b110:268K Byte(Valid 256K bytes),3'b111:500K Byte(Valid 488K bytes).
 *     REF_CNT1         Refresh Count.Refresh Count Define allowing Incoming Packet Bit Rate For those Packets Defined in Suppressed Packet Type Mask in Suppression Control RegisterWhen Bit Rate Mode Selection is 0(Absolute Bit Rate Mode)1~28 :Bit Rate = Refresh Count*8*1024/125, that'sBit Rate is 64Kb ~1.792Mb with Resolution 64Kb 29~127:Bit Rate = (Refresh Count-27)*1024, that'sBit Rate is 2Mb~100Mb with Resolution 1Mb 128~240:Bit Rate = (Refresh Count - 115)*1024*8, that'sBit Rate is 104Mb~1000Mb with Resolution 8MbWhen Bit Rate Mode Selection is 1(Bit Rate Related to Link Speed Mode)1~125: when 10M speedBit Rate = Refresh Count * 8 * 1024 /100, that'sBit Rate is 0.08Mb~10Mb with Resolution 0.08Mb 1~125: when 100M speedBit Rate = Refresh Count * 8 * 1024/10, that'sBit Rate is 0.8Mb~100Mb with Resolution 0.8Mb 1~125: when 1000M SpeedBit Rate = Refresh Count * 8 * 1024, that'sBit Rate is 8Mb~1000Mb with Resoultion 8Mb
 *     BUCKET_SIZE1     Bucket Size.Bucket Size will affect the burst traffic.3'b000: 16K Byte(Valid 4K bytes),3'b001:20K Byte(Valid 8K bytes),3'b010:28K Byte(Valid 16K bytes),3'b011:40K Byte(Valid 28K bytes),3'b100:76K Byte(Valid 64K bytes),3'b101:140K Byte(Valid 128K bytes),3'b110:268K Byte(Valid 256K bytes),3'b111:500K Byte(Valid 488K bytes).
 *     ING_RC_EN        Enable Rate Control of the Ingress Port, Bucket 1.Default by Strap pin bc_supp_en            
 *     ING_RC_EN1       Enable Rate Control of the Ingress Port, Bucket 11:Enable,0:Disable.            
 *     EN_DLF_SUP       Enable DLF Strom Suppression.1:Enable,0:Disable.            
 *     EN_MCAST_SUP     Enable Multicast Strom Suppression.1:Enable,0:Disable.            
 *     EN_BCAST_SUP     Enable Broadcast Strom Suppression.1:Enable,0:Disable.            
 *     EN_STORM_SUP     Enable Broadcast/Multicast/DLF Strom Suppression.1:Enable,0:Disable.            
 *     RESERVED_R       Reserved.                
 *
 ******************************************************************************/
#define BCM6300_A0_PORT_IRC_CONr 0x00004110

#define BCM6300_A0_PORT_IRC_CONr_SIZE 4

/*
 * This structure should be used to declare and program PORT_IRC_CON.
 *
 */
typedef union BCM6300_A0_PORT_IRC_CONr_s {
	uint32_t v[1];
	uint32_t port_irc_con[1];
	uint32_t _port_irc_con;
} BCM6300_A0_PORT_IRC_CONr_t;

#define BCM6300_A0_PORT_IRC_CONr_CLR(r) (r).port_irc_con[0] = 0
#define BCM6300_A0_PORT_IRC_CONr_SET(r,d) (r).port_irc_con[0] = d
#define BCM6300_A0_PORT_IRC_CONr_GET(r) (r).port_irc_con[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_PORT_IRC_CONr_REF_CNT0f_GET(r) (((r).port_irc_con[0]) & 0xff)
#define BCM6300_A0_PORT_IRC_CONr_REF_CNT0f_SET(r,f) (r).port_irc_con[0]=(((r).port_irc_con[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM6300_A0_PORT_IRC_CONr_BUCKET_SIZE0f_GET(r) ((((r).port_irc_con[0]) >> 8) & 0x7)
#define BCM6300_A0_PORT_IRC_CONr_BUCKET_SIZE0f_SET(r,f) (r).port_irc_con[0]=(((r).port_irc_con[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCM6300_A0_PORT_IRC_CONr_REF_CNT1f_GET(r) ((((r).port_irc_con[0]) >> 11) & 0xff)
#define BCM6300_A0_PORT_IRC_CONr_REF_CNT1f_SET(r,f) (r).port_irc_con[0]=(((r).port_irc_con[0] & ~((uint32_t)0xff << 11)) | ((((uint32_t)f) & 0xff) << 11))
#define BCM6300_A0_PORT_IRC_CONr_BUCKET_SIZE1f_GET(r) ((((r).port_irc_con[0]) >> 19) & 0x7)
#define BCM6300_A0_PORT_IRC_CONr_BUCKET_SIZE1f_SET(r,f) (r).port_irc_con[0]=(((r).port_irc_con[0] & ~((uint32_t)0x7 << 19)) | ((((uint32_t)f) & 0x7) << 19))
#define BCM6300_A0_PORT_IRC_CONr_ING_RC_ENf_GET(r) ((((r).port_irc_con[0]) >> 22) & 0x1)
#define BCM6300_A0_PORT_IRC_CONr_ING_RC_ENf_SET(r,f) (r).port_irc_con[0]=(((r).port_irc_con[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM6300_A0_PORT_IRC_CONr_ING_RC_EN1f_GET(r) ((((r).port_irc_con[0]) >> 23) & 0x1)
#define BCM6300_A0_PORT_IRC_CONr_ING_RC_EN1f_SET(r,f) (r).port_irc_con[0]=(((r).port_irc_con[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM6300_A0_PORT_IRC_CONr_EN_DLF_SUPf_GET(r) ((((r).port_irc_con[0]) >> 24) & 0x1)
#define BCM6300_A0_PORT_IRC_CONr_EN_DLF_SUPf_SET(r,f) (r).port_irc_con[0]=(((r).port_irc_con[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM6300_A0_PORT_IRC_CONr_EN_MCAST_SUPf_GET(r) ((((r).port_irc_con[0]) >> 25) & 0x1)
#define BCM6300_A0_PORT_IRC_CONr_EN_MCAST_SUPf_SET(r,f) (r).port_irc_con[0]=(((r).port_irc_con[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM6300_A0_PORT_IRC_CONr_EN_BCAST_SUPf_GET(r) ((((r).port_irc_con[0]) >> 26) & 0x1)
#define BCM6300_A0_PORT_IRC_CONr_EN_BCAST_SUPf_SET(r,f) (r).port_irc_con[0]=(((r).port_irc_con[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM6300_A0_PORT_IRC_CONr_EN_STORM_SUPf_GET(r) ((((r).port_irc_con[0]) >> 27) & 0x1)
#define BCM6300_A0_PORT_IRC_CONr_EN_STORM_SUPf_SET(r,f) (r).port_irc_con[0]=(((r).port_irc_con[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM6300_A0_PORT_IRC_CONr_RESERVED_Rf_GET(r) ((((r).port_irc_con[0]) >> 28) & 0xf)
#define BCM6300_A0_PORT_IRC_CONr_RESERVED_Rf_SET(r,f) (r).port_irc_con[0]=(((r).port_irc_con[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access PORT_IRC_CON.
 *
 */
#define BCM6300_A0_READ_PORT_IRC_CONr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_PORT_IRC_CONr,(r._port_irc_con),4)
#define BCM6300_A0_WRITE_PORT_IRC_CONr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_PORT_IRC_CONr,&(r._port_irc_con),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_IRC_CONr BCM6300_A0_PORT_IRC_CONr
#define PORT_IRC_CONr_SIZE BCM6300_A0_PORT_IRC_CONr_SIZE
typedef BCM6300_A0_PORT_IRC_CONr_t PORT_IRC_CONr_t;
#define PORT_IRC_CONr_CLR BCM6300_A0_PORT_IRC_CONr_CLR
#define PORT_IRC_CONr_SET BCM6300_A0_PORT_IRC_CONr_SET
#define PORT_IRC_CONr_GET BCM6300_A0_PORT_IRC_CONr_GET
#define PORT_IRC_CONr_REF_CNT0f_GET BCM6300_A0_PORT_IRC_CONr_REF_CNT0f_GET
#define PORT_IRC_CONr_REF_CNT0f_SET BCM6300_A0_PORT_IRC_CONr_REF_CNT0f_SET
#define PORT_IRC_CONr_BUCKET_SIZE0f_GET BCM6300_A0_PORT_IRC_CONr_BUCKET_SIZE0f_GET
#define PORT_IRC_CONr_BUCKET_SIZE0f_SET BCM6300_A0_PORT_IRC_CONr_BUCKET_SIZE0f_SET
#define PORT_IRC_CONr_REF_CNT1f_GET BCM6300_A0_PORT_IRC_CONr_REF_CNT1f_GET
#define PORT_IRC_CONr_REF_CNT1f_SET BCM6300_A0_PORT_IRC_CONr_REF_CNT1f_SET
#define PORT_IRC_CONr_BUCKET_SIZE1f_GET BCM6300_A0_PORT_IRC_CONr_BUCKET_SIZE1f_GET
#define PORT_IRC_CONr_BUCKET_SIZE1f_SET BCM6300_A0_PORT_IRC_CONr_BUCKET_SIZE1f_SET
#define PORT_IRC_CONr_ING_RC_ENf_GET BCM6300_A0_PORT_IRC_CONr_ING_RC_ENf_GET
#define PORT_IRC_CONr_ING_RC_ENf_SET BCM6300_A0_PORT_IRC_CONr_ING_RC_ENf_SET
#define PORT_IRC_CONr_ING_RC_EN1f_GET BCM6300_A0_PORT_IRC_CONr_ING_RC_EN1f_GET
#define PORT_IRC_CONr_ING_RC_EN1f_SET BCM6300_A0_PORT_IRC_CONr_ING_RC_EN1f_SET
#define PORT_IRC_CONr_EN_DLF_SUPf_GET BCM6300_A0_PORT_IRC_CONr_EN_DLF_SUPf_GET
#define PORT_IRC_CONr_EN_DLF_SUPf_SET BCM6300_A0_PORT_IRC_CONr_EN_DLF_SUPf_SET
#define PORT_IRC_CONr_EN_MCAST_SUPf_GET BCM6300_A0_PORT_IRC_CONr_EN_MCAST_SUPf_GET
#define PORT_IRC_CONr_EN_MCAST_SUPf_SET BCM6300_A0_PORT_IRC_CONr_EN_MCAST_SUPf_SET
#define PORT_IRC_CONr_EN_BCAST_SUPf_GET BCM6300_A0_PORT_IRC_CONr_EN_BCAST_SUPf_GET
#define PORT_IRC_CONr_EN_BCAST_SUPf_SET BCM6300_A0_PORT_IRC_CONr_EN_BCAST_SUPf_SET
#define PORT_IRC_CONr_EN_STORM_SUPf_GET BCM6300_A0_PORT_IRC_CONr_EN_STORM_SUPf_GET
#define PORT_IRC_CONr_EN_STORM_SUPf_SET BCM6300_A0_PORT_IRC_CONr_EN_STORM_SUPf_SET
#define PORT_IRC_CONr_RESERVED_Rf_GET BCM6300_A0_PORT_IRC_CONr_RESERVED_Rf_GET
#define PORT_IRC_CONr_RESERVED_Rf_SET BCM6300_A0_PORT_IRC_CONr_RESERVED_Rf_SET
#define READ_PORT_IRC_CONr BCM6300_A0_READ_PORT_IRC_CONr
#define WRITE_PORT_IRC_CONr BCM6300_A0_WRITE_PORT_IRC_CONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_PORT_IRC_CONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  PORT_VLAN_CTL
 * BLOCKS:   GPIC0 CPIC
 * DESC:     PORT X VLAN Control Register
 * SIZE:     16
 * FIELDS:
 *     PORT_EGRESS_EN   Per bit per port VLAN forwarding vector.A bit mask corresponding to the physical ports on the chip.Set corresponding bit to 1' to enable forwarding to the egress port. Set 0' inhibit the forwarding.Bit 8: mask for MII port.Bit 0-7: Port 0-7.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_PORT_VLAN_CTLr 0x00003100

#define BCM6300_A0_PORT_VLAN_CTLr_SIZE 2

/*
 * This structure should be used to declare and program PORT_VLAN_CTL.
 *
 */
typedef union BCM6300_A0_PORT_VLAN_CTLr_s {
	uint32_t v[1];
	uint32_t port_vlan_ctl[1];
	uint32_t _port_vlan_ctl;
} BCM6300_A0_PORT_VLAN_CTLr_t;

#define BCM6300_A0_PORT_VLAN_CTLr_CLR(r) (r).port_vlan_ctl[0] = 0
#define BCM6300_A0_PORT_VLAN_CTLr_SET(r,d) (r).port_vlan_ctl[0] = d
#define BCM6300_A0_PORT_VLAN_CTLr_GET(r) (r).port_vlan_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_PORT_VLAN_CTLr_PORT_EGRESS_ENf_GET(r) (((r).port_vlan_ctl[0]) & 0x1ff)
#define BCM6300_A0_PORT_VLAN_CTLr_PORT_EGRESS_ENf_SET(r,f) (r).port_vlan_ctl[0]=(((r).port_vlan_ctl[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_PORT_VLAN_CTLr_RESERVED_Rf_GET(r) ((((r).port_vlan_ctl[0]) >> 9) & 0x7f)
#define BCM6300_A0_PORT_VLAN_CTLr_RESERVED_Rf_SET(r,f) (r).port_vlan_ctl[0]=(((r).port_vlan_ctl[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access PORT_VLAN_CTL.
 *
 */
#define BCM6300_A0_READ_PORT_VLAN_CTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_PORT_VLAN_CTLr,(r._port_vlan_ctl),2)
#define BCM6300_A0_WRITE_PORT_VLAN_CTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_PORT_VLAN_CTLr,&(r._port_vlan_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_VLAN_CTLr BCM6300_A0_PORT_VLAN_CTLr
#define PORT_VLAN_CTLr_SIZE BCM6300_A0_PORT_VLAN_CTLr_SIZE
typedef BCM6300_A0_PORT_VLAN_CTLr_t PORT_VLAN_CTLr_t;
#define PORT_VLAN_CTLr_CLR BCM6300_A0_PORT_VLAN_CTLr_CLR
#define PORT_VLAN_CTLr_SET BCM6300_A0_PORT_VLAN_CTLr_SET
#define PORT_VLAN_CTLr_GET BCM6300_A0_PORT_VLAN_CTLr_GET
#define PORT_VLAN_CTLr_PORT_EGRESS_ENf_GET BCM6300_A0_PORT_VLAN_CTLr_PORT_EGRESS_ENf_GET
#define PORT_VLAN_CTLr_PORT_EGRESS_ENf_SET BCM6300_A0_PORT_VLAN_CTLr_PORT_EGRESS_ENf_SET
#define PORT_VLAN_CTLr_RESERVED_Rf_GET BCM6300_A0_PORT_VLAN_CTLr_RESERVED_Rf_GET
#define PORT_VLAN_CTLr_RESERVED_Rf_SET BCM6300_A0_PORT_VLAN_CTLr_RESERVED_Rf_SET
#define READ_PORT_VLAN_CTLr BCM6300_A0_READ_PORT_VLAN_CTLr
#define WRITE_PORT_VLAN_CTLr BCM6300_A0_WRITE_PORT_VLAN_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_PORT_VLAN_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  PROTECTED_SEL
 * BLOCKS:   SYS
 * DESC:     Protected Port Select Register
 * SIZE:     16
 * FIELDS:
 *     PORT_SEL         Protected Port Selection.When set, the Port will be the protected Port Protected Ports will not be able to Transmit/Receive Frame to/from each other.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_PROTECTED_SELr 0x00000024

#define BCM6300_A0_PROTECTED_SELr_SIZE 2

/*
 * This structure should be used to declare and program PROTECTED_SEL.
 *
 */
typedef union BCM6300_A0_PROTECTED_SELr_s {
	uint32_t v[1];
	uint32_t protected_sel[1];
	uint32_t _protected_sel;
} BCM6300_A0_PROTECTED_SELr_t;

#define BCM6300_A0_PROTECTED_SELr_CLR(r) (r).protected_sel[0] = 0
#define BCM6300_A0_PROTECTED_SELr_SET(r,d) (r).protected_sel[0] = d
#define BCM6300_A0_PROTECTED_SELr_GET(r) (r).protected_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_PROTECTED_SELr_PORT_SELf_GET(r) (((r).protected_sel[0]) & 0x1ff)
#define BCM6300_A0_PROTECTED_SELr_PORT_SELf_SET(r,f) (r).protected_sel[0]=(((r).protected_sel[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_PROTECTED_SELr_RESERVED_Rf_GET(r) ((((r).protected_sel[0]) >> 9) & 0x7f)
#define BCM6300_A0_PROTECTED_SELr_RESERVED_Rf_SET(r,f) (r).protected_sel[0]=(((r).protected_sel[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access PROTECTED_SEL.
 *
 */
#define BCM6300_A0_READ_PROTECTED_SELr(u,r) cdk_robo_reg_read(u,BCM6300_A0_PROTECTED_SELr,(r._protected_sel),2)
#define BCM6300_A0_WRITE_PROTECTED_SELr(u,r) cdk_robo_reg_write(u,BCM6300_A0_PROTECTED_SELr,&(r._protected_sel),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PROTECTED_SELr BCM6300_A0_PROTECTED_SELr
#define PROTECTED_SELr_SIZE BCM6300_A0_PROTECTED_SELr_SIZE
typedef BCM6300_A0_PROTECTED_SELr_t PROTECTED_SELr_t;
#define PROTECTED_SELr_CLR BCM6300_A0_PROTECTED_SELr_CLR
#define PROTECTED_SELr_SET BCM6300_A0_PROTECTED_SELr_SET
#define PROTECTED_SELr_GET BCM6300_A0_PROTECTED_SELr_GET
#define PROTECTED_SELr_PORT_SELf_GET BCM6300_A0_PROTECTED_SELr_PORT_SELf_GET
#define PROTECTED_SELr_PORT_SELf_SET BCM6300_A0_PROTECTED_SELr_PORT_SELf_SET
#define PROTECTED_SELr_RESERVED_Rf_GET BCM6300_A0_PROTECTED_SELr_RESERVED_Rf_GET
#define PROTECTED_SELr_RESERVED_Rf_SET BCM6300_A0_PROTECTED_SELr_RESERVED_Rf_SET
#define READ_PROTECTED_SELr BCM6300_A0_READ_PROTECTED_SELr
#define WRITE_PROTECTED_SELr BCM6300_A0_WRITE_PROTECTED_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_PROTECTED_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  Pkts1024to1522Octets
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx 1024 to 1522 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM6300_A0_PKTS1024TO1522OCTETSr 0x00002068

#define BCM6300_A0_PKTS1024TO1522OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program Pkts1024to1522Octets.
 *
 */
typedef union BCM6300_A0_PKTS1024TO1522OCTETSr_s {
	uint32_t v[1];
	uint32_t pkts1024to1522octets[1];
	uint32_t _pkts1024to1522octets;
} BCM6300_A0_PKTS1024TO1522OCTETSr_t;

#define BCM6300_A0_PKTS1024TO1522OCTETSr_CLR(r) (r).pkts1024to1522octets[0] = 0
#define BCM6300_A0_PKTS1024TO1522OCTETSr_SET(r,d) (r).pkts1024to1522octets[0] = d
#define BCM6300_A0_PKTS1024TO1522OCTETSr_GET(r) (r).pkts1024to1522octets[0]


/*
 * These macros can be used to access Pkts1024to1522Octets.
 *
 */
#define BCM6300_A0_READ_PKTS1024TO1522OCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_PKTS1024TO1522OCTETSr,(r._pkts1024to1522octets),4)
#define BCM6300_A0_WRITE_PKTS1024TO1522OCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_PKTS1024TO1522OCTETSr,&(r._pkts1024to1522octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS1024TO1522OCTETSr BCM6300_A0_PKTS1024TO1522OCTETSr
#define PKTS1024TO1522OCTETSr_SIZE BCM6300_A0_PKTS1024TO1522OCTETSr_SIZE
typedef BCM6300_A0_PKTS1024TO1522OCTETSr_t PKTS1024TO1522OCTETSr_t;
#define PKTS1024TO1522OCTETSr_CLR BCM6300_A0_PKTS1024TO1522OCTETSr_CLR
#define PKTS1024TO1522OCTETSr_SET BCM6300_A0_PKTS1024TO1522OCTETSr_SET
#define PKTS1024TO1522OCTETSr_GET BCM6300_A0_PKTS1024TO1522OCTETSr_GET
#define READ_PKTS1024TO1522OCTETSr BCM6300_A0_READ_PKTS1024TO1522OCTETSr
#define WRITE_PKTS1024TO1522OCTETSr BCM6300_A0_WRITE_PKTS1024TO1522OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_PKTS1024TO1522OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  Pkts128to255Octets
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx 128 to 255 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM6300_A0_PKTS128TO255OCTETSr 0x0000205c

#define BCM6300_A0_PKTS128TO255OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program Pkts128to255Octets.
 *
 */
typedef union BCM6300_A0_PKTS128TO255OCTETSr_s {
	uint32_t v[1];
	uint32_t pkts128to255octets[1];
	uint32_t _pkts128to255octets;
} BCM6300_A0_PKTS128TO255OCTETSr_t;

#define BCM6300_A0_PKTS128TO255OCTETSr_CLR(r) (r).pkts128to255octets[0] = 0
#define BCM6300_A0_PKTS128TO255OCTETSr_SET(r,d) (r).pkts128to255octets[0] = d
#define BCM6300_A0_PKTS128TO255OCTETSr_GET(r) (r).pkts128to255octets[0]


/*
 * These macros can be used to access Pkts128to255Octets.
 *
 */
#define BCM6300_A0_READ_PKTS128TO255OCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_PKTS128TO255OCTETSr,(r._pkts128to255octets),4)
#define BCM6300_A0_WRITE_PKTS128TO255OCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_PKTS128TO255OCTETSr,&(r._pkts128to255octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS128TO255OCTETSr BCM6300_A0_PKTS128TO255OCTETSr
#define PKTS128TO255OCTETSr_SIZE BCM6300_A0_PKTS128TO255OCTETSr_SIZE
typedef BCM6300_A0_PKTS128TO255OCTETSr_t PKTS128TO255OCTETSr_t;
#define PKTS128TO255OCTETSr_CLR BCM6300_A0_PKTS128TO255OCTETSr_CLR
#define PKTS128TO255OCTETSr_SET BCM6300_A0_PKTS128TO255OCTETSr_SET
#define PKTS128TO255OCTETSr_GET BCM6300_A0_PKTS128TO255OCTETSr_GET
#define READ_PKTS128TO255OCTETSr BCM6300_A0_READ_PKTS128TO255OCTETSr
#define WRITE_PKTS128TO255OCTETSr BCM6300_A0_WRITE_PKTS128TO255OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_PKTS128TO255OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  Pkts1523to2047
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Packet Length 1523 to 2047 Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM6300_A0_PKTS1523TO2047r 0x000020b0

#define BCM6300_A0_PKTS1523TO2047r_SIZE 4

/*
 * This structure should be used to declare and program Pkts1523to2047.
 *
 */
typedef union BCM6300_A0_PKTS1523TO2047r_s {
	uint32_t v[1];
	uint32_t pkts1523to2047[1];
	uint32_t _pkts1523to2047;
} BCM6300_A0_PKTS1523TO2047r_t;

#define BCM6300_A0_PKTS1523TO2047r_CLR(r) (r).pkts1523to2047[0] = 0
#define BCM6300_A0_PKTS1523TO2047r_SET(r,d) (r).pkts1523to2047[0] = d
#define BCM6300_A0_PKTS1523TO2047r_GET(r) (r).pkts1523to2047[0]


/*
 * These macros can be used to access Pkts1523to2047.
 *
 */
#define BCM6300_A0_READ_PKTS1523TO2047r(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_PKTS1523TO2047r,(r._pkts1523to2047),4)
#define BCM6300_A0_WRITE_PKTS1523TO2047r(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_PKTS1523TO2047r,&(r._pkts1523to2047),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS1523TO2047r BCM6300_A0_PKTS1523TO2047r
#define PKTS1523TO2047r_SIZE BCM6300_A0_PKTS1523TO2047r_SIZE
typedef BCM6300_A0_PKTS1523TO2047r_t PKTS1523TO2047r_t;
#define PKTS1523TO2047r_CLR BCM6300_A0_PKTS1523TO2047r_CLR
#define PKTS1523TO2047r_SET BCM6300_A0_PKTS1523TO2047r_SET
#define PKTS1523TO2047r_GET BCM6300_A0_PKTS1523TO2047r_GET
#define READ_PKTS1523TO2047r BCM6300_A0_READ_PKTS1523TO2047r
#define WRITE_PKTS1523TO2047r BCM6300_A0_WRITE_PKTS1523TO2047r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_PKTS1523TO2047r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  Pkts2048to4095
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Packet Length 2048 to 4095 Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM6300_A0_PKTS2048TO4095r 0x000020b4

#define BCM6300_A0_PKTS2048TO4095r_SIZE 4

/*
 * This structure should be used to declare and program Pkts2048to4095.
 *
 */
typedef union BCM6300_A0_PKTS2048TO4095r_s {
	uint32_t v[1];
	uint32_t pkts2048to4095[1];
	uint32_t _pkts2048to4095;
} BCM6300_A0_PKTS2048TO4095r_t;

#define BCM6300_A0_PKTS2048TO4095r_CLR(r) (r).pkts2048to4095[0] = 0
#define BCM6300_A0_PKTS2048TO4095r_SET(r,d) (r).pkts2048to4095[0] = d
#define BCM6300_A0_PKTS2048TO4095r_GET(r) (r).pkts2048to4095[0]


/*
 * These macros can be used to access Pkts2048to4095.
 *
 */
#define BCM6300_A0_READ_PKTS2048TO4095r(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_PKTS2048TO4095r,(r._pkts2048to4095),4)
#define BCM6300_A0_WRITE_PKTS2048TO4095r(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_PKTS2048TO4095r,&(r._pkts2048to4095),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS2048TO4095r BCM6300_A0_PKTS2048TO4095r
#define PKTS2048TO4095r_SIZE BCM6300_A0_PKTS2048TO4095r_SIZE
typedef BCM6300_A0_PKTS2048TO4095r_t PKTS2048TO4095r_t;
#define PKTS2048TO4095r_CLR BCM6300_A0_PKTS2048TO4095r_CLR
#define PKTS2048TO4095r_SET BCM6300_A0_PKTS2048TO4095r_SET
#define PKTS2048TO4095r_GET BCM6300_A0_PKTS2048TO4095r_GET
#define READ_PKTS2048TO4095r BCM6300_A0_READ_PKTS2048TO4095r
#define WRITE_PKTS2048TO4095r BCM6300_A0_WRITE_PKTS2048TO4095r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_PKTS2048TO4095r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  Pkts256to511Octets
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx 256 to 511 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM6300_A0_PKTS256TO511OCTETSr 0x00002060

#define BCM6300_A0_PKTS256TO511OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program Pkts256to511Octets.
 *
 */
typedef union BCM6300_A0_PKTS256TO511OCTETSr_s {
	uint32_t v[1];
	uint32_t pkts256to511octets[1];
	uint32_t _pkts256to511octets;
} BCM6300_A0_PKTS256TO511OCTETSr_t;

#define BCM6300_A0_PKTS256TO511OCTETSr_CLR(r) (r).pkts256to511octets[0] = 0
#define BCM6300_A0_PKTS256TO511OCTETSr_SET(r,d) (r).pkts256to511octets[0] = d
#define BCM6300_A0_PKTS256TO511OCTETSr_GET(r) (r).pkts256to511octets[0]


/*
 * These macros can be used to access Pkts256to511Octets.
 *
 */
#define BCM6300_A0_READ_PKTS256TO511OCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_PKTS256TO511OCTETSr,(r._pkts256to511octets),4)
#define BCM6300_A0_WRITE_PKTS256TO511OCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_PKTS256TO511OCTETSr,&(r._pkts256to511octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS256TO511OCTETSr BCM6300_A0_PKTS256TO511OCTETSr
#define PKTS256TO511OCTETSr_SIZE BCM6300_A0_PKTS256TO511OCTETSr_SIZE
typedef BCM6300_A0_PKTS256TO511OCTETSr_t PKTS256TO511OCTETSr_t;
#define PKTS256TO511OCTETSr_CLR BCM6300_A0_PKTS256TO511OCTETSr_CLR
#define PKTS256TO511OCTETSr_SET BCM6300_A0_PKTS256TO511OCTETSr_SET
#define PKTS256TO511OCTETSr_GET BCM6300_A0_PKTS256TO511OCTETSr_GET
#define READ_PKTS256TO511OCTETSr BCM6300_A0_READ_PKTS256TO511OCTETSr
#define WRITE_PKTS256TO511OCTETSr BCM6300_A0_WRITE_PKTS256TO511OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_PKTS256TO511OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  Pkts4096to8191
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Packet Length 4096 to 8191 Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM6300_A0_PKTS4096TO8191r 0x000020b8

#define BCM6300_A0_PKTS4096TO8191r_SIZE 4

/*
 * This structure should be used to declare and program Pkts4096to8191.
 *
 */
typedef union BCM6300_A0_PKTS4096TO8191r_s {
	uint32_t v[1];
	uint32_t pkts4096to8191[1];
	uint32_t _pkts4096to8191;
} BCM6300_A0_PKTS4096TO8191r_t;

#define BCM6300_A0_PKTS4096TO8191r_CLR(r) (r).pkts4096to8191[0] = 0
#define BCM6300_A0_PKTS4096TO8191r_SET(r,d) (r).pkts4096to8191[0] = d
#define BCM6300_A0_PKTS4096TO8191r_GET(r) (r).pkts4096to8191[0]


/*
 * These macros can be used to access Pkts4096to8191.
 *
 */
#define BCM6300_A0_READ_PKTS4096TO8191r(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_PKTS4096TO8191r,(r._pkts4096to8191),4)
#define BCM6300_A0_WRITE_PKTS4096TO8191r(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_PKTS4096TO8191r,&(r._pkts4096to8191),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS4096TO8191r BCM6300_A0_PKTS4096TO8191r
#define PKTS4096TO8191r_SIZE BCM6300_A0_PKTS4096TO8191r_SIZE
typedef BCM6300_A0_PKTS4096TO8191r_t PKTS4096TO8191r_t;
#define PKTS4096TO8191r_CLR BCM6300_A0_PKTS4096TO8191r_CLR
#define PKTS4096TO8191r_SET BCM6300_A0_PKTS4096TO8191r_SET
#define PKTS4096TO8191r_GET BCM6300_A0_PKTS4096TO8191r_GET
#define READ_PKTS4096TO8191r BCM6300_A0_READ_PKTS4096TO8191r
#define WRITE_PKTS4096TO8191r BCM6300_A0_WRITE_PKTS4096TO8191r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_PKTS4096TO8191r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  Pkts512to1023Octets
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx 512 to 1023 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM6300_A0_PKTS512TO1023OCTETSr 0x00002064

#define BCM6300_A0_PKTS512TO1023OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program Pkts512to1023Octets.
 *
 */
typedef union BCM6300_A0_PKTS512TO1023OCTETSr_s {
	uint32_t v[1];
	uint32_t pkts512to1023octets[1];
	uint32_t _pkts512to1023octets;
} BCM6300_A0_PKTS512TO1023OCTETSr_t;

#define BCM6300_A0_PKTS512TO1023OCTETSr_CLR(r) (r).pkts512to1023octets[0] = 0
#define BCM6300_A0_PKTS512TO1023OCTETSr_SET(r,d) (r).pkts512to1023octets[0] = d
#define BCM6300_A0_PKTS512TO1023OCTETSr_GET(r) (r).pkts512to1023octets[0]


/*
 * These macros can be used to access Pkts512to1023Octets.
 *
 */
#define BCM6300_A0_READ_PKTS512TO1023OCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_PKTS512TO1023OCTETSr,(r._pkts512to1023octets),4)
#define BCM6300_A0_WRITE_PKTS512TO1023OCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_PKTS512TO1023OCTETSr,&(r._pkts512to1023octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS512TO1023OCTETSr BCM6300_A0_PKTS512TO1023OCTETSr
#define PKTS512TO1023OCTETSr_SIZE BCM6300_A0_PKTS512TO1023OCTETSr_SIZE
typedef BCM6300_A0_PKTS512TO1023OCTETSr_t PKTS512TO1023OCTETSr_t;
#define PKTS512TO1023OCTETSr_CLR BCM6300_A0_PKTS512TO1023OCTETSr_CLR
#define PKTS512TO1023OCTETSr_SET BCM6300_A0_PKTS512TO1023OCTETSr_SET
#define PKTS512TO1023OCTETSr_GET BCM6300_A0_PKTS512TO1023OCTETSr_GET
#define READ_PKTS512TO1023OCTETSr BCM6300_A0_READ_PKTS512TO1023OCTETSr
#define WRITE_PKTS512TO1023OCTETSr BCM6300_A0_WRITE_PKTS512TO1023OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_PKTS512TO1023OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  Pkts64Octets
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx 64 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM6300_A0_PKTS64OCTETSr 0x00002054

#define BCM6300_A0_PKTS64OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program Pkts64Octets.
 *
 */
typedef union BCM6300_A0_PKTS64OCTETSr_s {
	uint32_t v[1];
	uint32_t pkts64octets[1];
	uint32_t _pkts64octets;
} BCM6300_A0_PKTS64OCTETSr_t;

#define BCM6300_A0_PKTS64OCTETSr_CLR(r) (r).pkts64octets[0] = 0
#define BCM6300_A0_PKTS64OCTETSr_SET(r,d) (r).pkts64octets[0] = d
#define BCM6300_A0_PKTS64OCTETSr_GET(r) (r).pkts64octets[0]


/*
 * These macros can be used to access Pkts64Octets.
 *
 */
#define BCM6300_A0_READ_PKTS64OCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_PKTS64OCTETSr,(r._pkts64octets),4)
#define BCM6300_A0_WRITE_PKTS64OCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_PKTS64OCTETSr,&(r._pkts64octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS64OCTETSr BCM6300_A0_PKTS64OCTETSr
#define PKTS64OCTETSr_SIZE BCM6300_A0_PKTS64OCTETSr_SIZE
typedef BCM6300_A0_PKTS64OCTETSr_t PKTS64OCTETSr_t;
#define PKTS64OCTETSr_CLR BCM6300_A0_PKTS64OCTETSr_CLR
#define PKTS64OCTETSr_SET BCM6300_A0_PKTS64OCTETSr_SET
#define PKTS64OCTETSr_GET BCM6300_A0_PKTS64OCTETSr_GET
#define READ_PKTS64OCTETSr BCM6300_A0_READ_PKTS64OCTETSr
#define WRITE_PKTS64OCTETSr BCM6300_A0_WRITE_PKTS64OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_PKTS64OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  Pkts65to127Octets
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx 65 to 127 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM6300_A0_PKTS65TO127OCTETSr 0x00002058

#define BCM6300_A0_PKTS65TO127OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program Pkts65to127Octets.
 *
 */
typedef union BCM6300_A0_PKTS65TO127OCTETSr_s {
	uint32_t v[1];
	uint32_t pkts65to127octets[1];
	uint32_t _pkts65to127octets;
} BCM6300_A0_PKTS65TO127OCTETSr_t;

#define BCM6300_A0_PKTS65TO127OCTETSr_CLR(r) (r).pkts65to127octets[0] = 0
#define BCM6300_A0_PKTS65TO127OCTETSr_SET(r,d) (r).pkts65to127octets[0] = d
#define BCM6300_A0_PKTS65TO127OCTETSr_GET(r) (r).pkts65to127octets[0]


/*
 * These macros can be used to access Pkts65to127Octets.
 *
 */
#define BCM6300_A0_READ_PKTS65TO127OCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_PKTS65TO127OCTETSr,(r._pkts65to127octets),4)
#define BCM6300_A0_WRITE_PKTS65TO127OCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_PKTS65TO127OCTETSr,&(r._pkts65to127octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS65TO127OCTETSr BCM6300_A0_PKTS65TO127OCTETSr
#define PKTS65TO127OCTETSr_SIZE BCM6300_A0_PKTS65TO127OCTETSr_SIZE
typedef BCM6300_A0_PKTS65TO127OCTETSr_t PKTS65TO127OCTETSr_t;
#define PKTS65TO127OCTETSr_CLR BCM6300_A0_PKTS65TO127OCTETSr_CLR
#define PKTS65TO127OCTETSr_SET BCM6300_A0_PKTS65TO127OCTETSr_SET
#define PKTS65TO127OCTETSr_GET BCM6300_A0_PKTS65TO127OCTETSr_GET
#define READ_PKTS65TO127OCTETSr BCM6300_A0_READ_PKTS65TO127OCTETSr
#define WRITE_PKTS65TO127OCTETSr BCM6300_A0_WRITE_PKTS65TO127OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_PKTS65TO127OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  Pkts8192to9728
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Packet Length 8192 to 9728 Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM6300_A0_PKTS8192TO9728r 0x000020bc

#define BCM6300_A0_PKTS8192TO9728r_SIZE 4

/*
 * This structure should be used to declare and program Pkts8192to9728.
 *
 */
typedef union BCM6300_A0_PKTS8192TO9728r_s {
	uint32_t v[1];
	uint32_t pkts8192to9728[1];
	uint32_t _pkts8192to9728;
} BCM6300_A0_PKTS8192TO9728r_t;

#define BCM6300_A0_PKTS8192TO9728r_CLR(r) (r).pkts8192to9728[0] = 0
#define BCM6300_A0_PKTS8192TO9728r_SET(r,d) (r).pkts8192to9728[0] = d
#define BCM6300_A0_PKTS8192TO9728r_GET(r) (r).pkts8192to9728[0]


/*
 * These macros can be used to access Pkts8192to9728.
 *
 */
#define BCM6300_A0_READ_PKTS8192TO9728r(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_PKTS8192TO9728r,(r._pkts8192to9728),4)
#define BCM6300_A0_WRITE_PKTS8192TO9728r(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_PKTS8192TO9728r,&(r._pkts8192to9728),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS8192TO9728r BCM6300_A0_PKTS8192TO9728r
#define PKTS8192TO9728r_SIZE BCM6300_A0_PKTS8192TO9728r_SIZE
typedef BCM6300_A0_PKTS8192TO9728r_t PKTS8192TO9728r_t;
#define PKTS8192TO9728r_CLR BCM6300_A0_PKTS8192TO9728r_CLR
#define PKTS8192TO9728r_SET BCM6300_A0_PKTS8192TO9728r_SET
#define PKTS8192TO9728r_GET BCM6300_A0_PKTS8192TO9728r_GET
#define READ_PKTS8192TO9728r BCM6300_A0_READ_PKTS8192TO9728r
#define WRITE_PKTS8192TO9728r BCM6300_A0_WRITE_PKTS8192TO9728r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_PKTS8192TO9728r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  QOS_1P1Q_PRI_MAP
 * BLOCKS:   SYS
 * DESC:     1P/1Q Priority Map Register
 * SIZE:     32
 * FIELDS:
 *     TAG000_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 000 to Priority ID map Register
 *     TAG001_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 001 to Priority ID map Register
 *     TAG010_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 010 to Priority ID map Register
 *     TAG011_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 011 to Priority ID map Register
 *     TAG100_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 100 to Priority ID map Register
 *     TAG101_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 101 to Priority ID map Register
 *     TAG110_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 110 to Priority ID map Register
 *     TAG111_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 111 to Priority ID map Register
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_QOS_1P1Q_PRI_MAPr 0x00003010

#define BCM6300_A0_QOS_1P1Q_PRI_MAPr_SIZE 4

/*
 * This structure should be used to declare and program QOS_1P1Q_PRI_MAP.
 *
 */
typedef union BCM6300_A0_QOS_1P1Q_PRI_MAPr_s {
	uint32_t v[1];
	uint32_t qos_1p1q_pri_map[1];
	uint32_t _qos_1p1q_pri_map;
} BCM6300_A0_QOS_1P1Q_PRI_MAPr_t;

#define BCM6300_A0_QOS_1P1Q_PRI_MAPr_CLR(r) (r).qos_1p1q_pri_map[0] = 0
#define BCM6300_A0_QOS_1P1Q_PRI_MAPr_SET(r,d) (r).qos_1p1q_pri_map[0] = d
#define BCM6300_A0_QOS_1P1Q_PRI_MAPr_GET(r) (r).qos_1p1q_pri_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_QOS_1P1Q_PRI_MAPr_TAG000_PRI_MAPf_GET(r) (((r).qos_1p1q_pri_map[0]) & 0x7)
#define BCM6300_A0_QOS_1P1Q_PRI_MAPr_TAG000_PRI_MAPf_SET(r,f) (r).qos_1p1q_pri_map[0]=(((r).qos_1p1q_pri_map[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM6300_A0_QOS_1P1Q_PRI_MAPr_TAG001_PRI_MAPf_GET(r) ((((r).qos_1p1q_pri_map[0]) >> 3) & 0x7)
#define BCM6300_A0_QOS_1P1Q_PRI_MAPr_TAG001_PRI_MAPf_SET(r,f) (r).qos_1p1q_pri_map[0]=(((r).qos_1p1q_pri_map[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM6300_A0_QOS_1P1Q_PRI_MAPr_TAG010_PRI_MAPf_GET(r) ((((r).qos_1p1q_pri_map[0]) >> 6) & 0x7)
#define BCM6300_A0_QOS_1P1Q_PRI_MAPr_TAG010_PRI_MAPf_SET(r,f) (r).qos_1p1q_pri_map[0]=(((r).qos_1p1q_pri_map[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM6300_A0_QOS_1P1Q_PRI_MAPr_TAG011_PRI_MAPf_GET(r) ((((r).qos_1p1q_pri_map[0]) >> 9) & 0x7)
#define BCM6300_A0_QOS_1P1Q_PRI_MAPr_TAG011_PRI_MAPf_SET(r,f) (r).qos_1p1q_pri_map[0]=(((r).qos_1p1q_pri_map[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM6300_A0_QOS_1P1Q_PRI_MAPr_TAG100_PRI_MAPf_GET(r) ((((r).qos_1p1q_pri_map[0]) >> 12) & 0x7)
#define BCM6300_A0_QOS_1P1Q_PRI_MAPr_TAG100_PRI_MAPf_SET(r,f) (r).qos_1p1q_pri_map[0]=(((r).qos_1p1q_pri_map[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM6300_A0_QOS_1P1Q_PRI_MAPr_TAG101_PRI_MAPf_GET(r) ((((r).qos_1p1q_pri_map[0]) >> 15) & 0x7)
#define BCM6300_A0_QOS_1P1Q_PRI_MAPr_TAG101_PRI_MAPf_SET(r,f) (r).qos_1p1q_pri_map[0]=(((r).qos_1p1q_pri_map[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM6300_A0_QOS_1P1Q_PRI_MAPr_TAG110_PRI_MAPf_GET(r) ((((r).qos_1p1q_pri_map[0]) >> 18) & 0x7)
#define BCM6300_A0_QOS_1P1Q_PRI_MAPr_TAG110_PRI_MAPf_SET(r,f) (r).qos_1p1q_pri_map[0]=(((r).qos_1p1q_pri_map[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM6300_A0_QOS_1P1Q_PRI_MAPr_TAG111_PRI_MAPf_GET(r) ((((r).qos_1p1q_pri_map[0]) >> 21) & 0x7)
#define BCM6300_A0_QOS_1P1Q_PRI_MAPr_TAG111_PRI_MAPf_SET(r,f) (r).qos_1p1q_pri_map[0]=(((r).qos_1p1q_pri_map[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM6300_A0_QOS_1P1Q_PRI_MAPr_RESERVED_Rf_GET(r) ((((r).qos_1p1q_pri_map[0]) >> 24) & 0xff)
#define BCM6300_A0_QOS_1P1Q_PRI_MAPr_RESERVED_Rf_SET(r,f) (r).qos_1p1q_pri_map[0]=(((r).qos_1p1q_pri_map[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access QOS_1P1Q_PRI_MAP.
 *
 */
#define BCM6300_A0_READ_QOS_1P1Q_PRI_MAPr(u,r) cdk_robo_reg_read(u,BCM6300_A0_QOS_1P1Q_PRI_MAPr,(r._qos_1p1q_pri_map),4)
#define BCM6300_A0_WRITE_QOS_1P1Q_PRI_MAPr(u,r) cdk_robo_reg_write(u,BCM6300_A0_QOS_1P1Q_PRI_MAPr,&(r._qos_1p1q_pri_map),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_1P1Q_PRI_MAPr BCM6300_A0_QOS_1P1Q_PRI_MAPr
#define QOS_1P1Q_PRI_MAPr_SIZE BCM6300_A0_QOS_1P1Q_PRI_MAPr_SIZE
typedef BCM6300_A0_QOS_1P1Q_PRI_MAPr_t QOS_1P1Q_PRI_MAPr_t;
#define QOS_1P1Q_PRI_MAPr_CLR BCM6300_A0_QOS_1P1Q_PRI_MAPr_CLR
#define QOS_1P1Q_PRI_MAPr_SET BCM6300_A0_QOS_1P1Q_PRI_MAPr_SET
#define QOS_1P1Q_PRI_MAPr_GET BCM6300_A0_QOS_1P1Q_PRI_MAPr_GET
#define QOS_1P1Q_PRI_MAPr_TAG000_PRI_MAPf_GET BCM6300_A0_QOS_1P1Q_PRI_MAPr_TAG000_PRI_MAPf_GET
#define QOS_1P1Q_PRI_MAPr_TAG000_PRI_MAPf_SET BCM6300_A0_QOS_1P1Q_PRI_MAPr_TAG000_PRI_MAPf_SET
#define QOS_1P1Q_PRI_MAPr_TAG001_PRI_MAPf_GET BCM6300_A0_QOS_1P1Q_PRI_MAPr_TAG001_PRI_MAPf_GET
#define QOS_1P1Q_PRI_MAPr_TAG001_PRI_MAPf_SET BCM6300_A0_QOS_1P1Q_PRI_MAPr_TAG001_PRI_MAPf_SET
#define QOS_1P1Q_PRI_MAPr_TAG010_PRI_MAPf_GET BCM6300_A0_QOS_1P1Q_PRI_MAPr_TAG010_PRI_MAPf_GET
#define QOS_1P1Q_PRI_MAPr_TAG010_PRI_MAPf_SET BCM6300_A0_QOS_1P1Q_PRI_MAPr_TAG010_PRI_MAPf_SET
#define QOS_1P1Q_PRI_MAPr_TAG011_PRI_MAPf_GET BCM6300_A0_QOS_1P1Q_PRI_MAPr_TAG011_PRI_MAPf_GET
#define QOS_1P1Q_PRI_MAPr_TAG011_PRI_MAPf_SET BCM6300_A0_QOS_1P1Q_PRI_MAPr_TAG011_PRI_MAPf_SET
#define QOS_1P1Q_PRI_MAPr_TAG100_PRI_MAPf_GET BCM6300_A0_QOS_1P1Q_PRI_MAPr_TAG100_PRI_MAPf_GET
#define QOS_1P1Q_PRI_MAPr_TAG100_PRI_MAPf_SET BCM6300_A0_QOS_1P1Q_PRI_MAPr_TAG100_PRI_MAPf_SET
#define QOS_1P1Q_PRI_MAPr_TAG101_PRI_MAPf_GET BCM6300_A0_QOS_1P1Q_PRI_MAPr_TAG101_PRI_MAPf_GET
#define QOS_1P1Q_PRI_MAPr_TAG101_PRI_MAPf_SET BCM6300_A0_QOS_1P1Q_PRI_MAPr_TAG101_PRI_MAPf_SET
#define QOS_1P1Q_PRI_MAPr_TAG110_PRI_MAPf_GET BCM6300_A0_QOS_1P1Q_PRI_MAPr_TAG110_PRI_MAPf_GET
#define QOS_1P1Q_PRI_MAPr_TAG110_PRI_MAPf_SET BCM6300_A0_QOS_1P1Q_PRI_MAPr_TAG110_PRI_MAPf_SET
#define QOS_1P1Q_PRI_MAPr_TAG111_PRI_MAPf_GET BCM6300_A0_QOS_1P1Q_PRI_MAPr_TAG111_PRI_MAPf_GET
#define QOS_1P1Q_PRI_MAPr_TAG111_PRI_MAPf_SET BCM6300_A0_QOS_1P1Q_PRI_MAPr_TAG111_PRI_MAPf_SET
#define QOS_1P1Q_PRI_MAPr_RESERVED_Rf_GET BCM6300_A0_QOS_1P1Q_PRI_MAPr_RESERVED_Rf_GET
#define QOS_1P1Q_PRI_MAPr_RESERVED_Rf_SET BCM6300_A0_QOS_1P1Q_PRI_MAPr_RESERVED_Rf_SET
#define READ_QOS_1P1Q_PRI_MAPr BCM6300_A0_READ_QOS_1P1Q_PRI_MAPr
#define WRITE_QOS_1P1Q_PRI_MAPr BCM6300_A0_WRITE_QOS_1P1Q_PRI_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_QOS_1P1Q_PRI_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  QOS_1P_EN
 * BLOCKS:   SYS
 * DESC:     QoS 802.1P Enable Register
 * SIZE:     16
 * FIELDS:
 *     QOS_1P_EN        Enable 802.1p priority for individual ports.Bit 8:0 = Port 8~ Port 0.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_QOS_1P_ENr 0x00003004

#define BCM6300_A0_QOS_1P_ENr_SIZE 2

/*
 * This structure should be used to declare and program QOS_1P_EN.
 *
 */
typedef union BCM6300_A0_QOS_1P_ENr_s {
	uint32_t v[1];
	uint32_t qos_1p_en[1];
	uint32_t _qos_1p_en;
} BCM6300_A0_QOS_1P_ENr_t;

#define BCM6300_A0_QOS_1P_ENr_CLR(r) (r).qos_1p_en[0] = 0
#define BCM6300_A0_QOS_1P_ENr_SET(r,d) (r).qos_1p_en[0] = d
#define BCM6300_A0_QOS_1P_ENr_GET(r) (r).qos_1p_en[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_QOS_1P_ENr_QOS_1P_ENf_GET(r) (((r).qos_1p_en[0]) & 0x1ff)
#define BCM6300_A0_QOS_1P_ENr_QOS_1P_ENf_SET(r,f) (r).qos_1p_en[0]=(((r).qos_1p_en[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_QOS_1P_ENr_RESERVED_Rf_GET(r) ((((r).qos_1p_en[0]) >> 9) & 0x7f)
#define BCM6300_A0_QOS_1P_ENr_RESERVED_Rf_SET(r,f) (r).qos_1p_en[0]=(((r).qos_1p_en[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access QOS_1P_EN.
 *
 */
#define BCM6300_A0_READ_QOS_1P_ENr(u,r) cdk_robo_reg_read(u,BCM6300_A0_QOS_1P_ENr,(r._qos_1p_en),2)
#define BCM6300_A0_WRITE_QOS_1P_ENr(u,r) cdk_robo_reg_write(u,BCM6300_A0_QOS_1P_ENr,&(r._qos_1p_en),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_1P_ENr BCM6300_A0_QOS_1P_ENr
#define QOS_1P_ENr_SIZE BCM6300_A0_QOS_1P_ENr_SIZE
typedef BCM6300_A0_QOS_1P_ENr_t QOS_1P_ENr_t;
#define QOS_1P_ENr_CLR BCM6300_A0_QOS_1P_ENr_CLR
#define QOS_1P_ENr_SET BCM6300_A0_QOS_1P_ENr_SET
#define QOS_1P_ENr_GET BCM6300_A0_QOS_1P_ENr_GET
#define QOS_1P_ENr_QOS_1P_ENf_GET BCM6300_A0_QOS_1P_ENr_QOS_1P_ENf_GET
#define QOS_1P_ENr_QOS_1P_ENf_SET BCM6300_A0_QOS_1P_ENr_QOS_1P_ENf_SET
#define QOS_1P_ENr_RESERVED_Rf_GET BCM6300_A0_QOS_1P_ENr_RESERVED_Rf_GET
#define QOS_1P_ENr_RESERVED_Rf_SET BCM6300_A0_QOS_1P_ENr_RESERVED_Rf_SET
#define READ_QOS_1P_ENr BCM6300_A0_READ_QOS_1P_ENr
#define WRITE_QOS_1P_ENr BCM6300_A0_WRITE_QOS_1P_ENr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_QOS_1P_ENr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  QOS_CTL
 * BLOCKS:   SYS
 * DESC:     QoS Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED_0R      Reserved
 *     EN_ACAST_QOSREG  Enable Auto Set QoS Threshold Register.When QOS mode change, the threshold value will be reload automatically if En_AutoSet_QoSreg.
 *     RESERVED_1R      Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_QOS_CTLr 0x00003002

#define BCM6300_A0_QOS_CTLr_SIZE 2

/*
 * This structure should be used to declare and program QOS_CTL.
 *
 */
typedef union BCM6300_A0_QOS_CTLr_s {
	uint32_t v[1];
	uint32_t qos_ctl[1];
	uint32_t _qos_ctl;
} BCM6300_A0_QOS_CTLr_t;

#define BCM6300_A0_QOS_CTLr_CLR(r) (r).qos_ctl[0] = 0
#define BCM6300_A0_QOS_CTLr_SET(r,d) (r).qos_ctl[0] = d
#define BCM6300_A0_QOS_CTLr_GET(r) (r).qos_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_QOS_CTLr_RESERVED_0Rf_GET(r) (((r).qos_ctl[0]) & 0x1fff)
#define BCM6300_A0_QOS_CTLr_RESERVED_0Rf_SET(r,f) (r).qos_ctl[0]=(((r).qos_ctl[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff))
#define BCM6300_A0_QOS_CTLr_EN_ACAST_QOSREGf_GET(r) ((((r).qos_ctl[0]) >> 13) & 0x1)
#define BCM6300_A0_QOS_CTLr_EN_ACAST_QOSREGf_SET(r,f) (r).qos_ctl[0]=(((r).qos_ctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM6300_A0_QOS_CTLr_RESERVED_1Rf_GET(r) ((((r).qos_ctl[0]) >> 14) & 0x3)
#define BCM6300_A0_QOS_CTLr_RESERVED_1Rf_SET(r,f) (r).qos_ctl[0]=(((r).qos_ctl[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access QOS_CTL.
 *
 */
#define BCM6300_A0_READ_QOS_CTLr(u,r) cdk_robo_reg_read(u,BCM6300_A0_QOS_CTLr,(r._qos_ctl),2)
#define BCM6300_A0_WRITE_QOS_CTLr(u,r) cdk_robo_reg_write(u,BCM6300_A0_QOS_CTLr,&(r._qos_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_CTLr BCM6300_A0_QOS_CTLr
#define QOS_CTLr_SIZE BCM6300_A0_QOS_CTLr_SIZE
typedef BCM6300_A0_QOS_CTLr_t QOS_CTLr_t;
#define QOS_CTLr_CLR BCM6300_A0_QOS_CTLr_CLR
#define QOS_CTLr_SET BCM6300_A0_QOS_CTLr_SET
#define QOS_CTLr_GET BCM6300_A0_QOS_CTLr_GET
#define QOS_CTLr_RESERVED_0Rf_GET BCM6300_A0_QOS_CTLr_RESERVED_0Rf_GET
#define QOS_CTLr_RESERVED_0Rf_SET BCM6300_A0_QOS_CTLr_RESERVED_0Rf_SET
#define QOS_CTLr_EN_ACAST_QOSREGf_GET BCM6300_A0_QOS_CTLr_EN_ACAST_QOSREGf_GET
#define QOS_CTLr_EN_ACAST_QOSREGf_SET BCM6300_A0_QOS_CTLr_EN_ACAST_QOSREGf_SET
#define QOS_CTLr_RESERVED_1Rf_GET BCM6300_A0_QOS_CTLr_RESERVED_1Rf_GET
#define QOS_CTLr_RESERVED_1Rf_SET BCM6300_A0_QOS_CTLr_RESERVED_1Rf_SET
#define READ_QOS_CTLr BCM6300_A0_READ_QOS_CTLr
#define WRITE_QOS_CTLr BCM6300_A0_WRITE_QOS_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_QOS_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  QOS_DIFF_DSCP0
 * BLOCKS:   SYS
 * DESC:     DiffServ Priority Map 0 Register
 * SIZE:     48
 * FIELDS:
 *     PRI_DSCP_000000  DiffServ DSCP== 000000 to Priority ID map Register.
 *     PRI_DSCP_000001  DiffServ DSCP== 000001 to Priority ID map Register.
 *     PRI_DSCP_000010  DiffServ DSCP== 000010 to Priority ID map Register.
 *     PRI_DSCP_000011  DiffServ DSCP== 000011 to Priority ID map Register.
 *     PRI_DSCP_000100  DiffServ DSCP== 000100 to Priority ID map Register.
 *     PRI_DSCP_000101  DiffServ DSCP== 000101 to Priority ID map Register.
 *     PRI_DSCP_000110  DiffServ DSCP== 000110 to Priority ID map Register.
 *     PRI_DSCP_000111  DiffServ DSCP== 000111 to Priority ID map Register.
 *     PRI_DSCP_001000  DiffServ DSCP== 001000 to Priority ID map Register.
 *     PRI_DSCP_001001  DiffServ DSCP== 001001 to Priority ID map Register.
 *     PRI_DSCP_001010  DiffServ DSCP== 001010 to Priority ID map Register.
 *     PRI_DSCP_001011  DiffServ DSCP== 001011 to Priority ID map Register.
 *     PRI_DSCP_001100  DiffServ DSCP== 001100 to Priority ID map Register.
 *     PRI_DSCP_001101  DiffServ DSCP== 001101 to Priority ID map Register.
 *     PRI_DSCP_001110  DiffServ DSCP== 001110 to Priority ID map Register.
 *     PRI_DSCP_001111  DiffServ DSCP== 001111 to Priority ID map Register.
 *
 ******************************************************************************/
#define BCM6300_A0_QOS_DIFF_DSCP0r 0x00003030

#define BCM6300_A0_QOS_DIFF_DSCP0r_SIZE 6

/*
 * This structure should be used to declare and program QOS_DIFF_DSCP0.
 *
 */
typedef union BCM6300_A0_QOS_DIFF_DSCP0r_s {
	uint32_t v[2];
	uint32_t qos_diff_dscp0[2];
	uint32_t _qos_diff_dscp0;
} BCM6300_A0_QOS_DIFF_DSCP0r_t;

#define BCM6300_A0_QOS_DIFF_DSCP0r_CLR(r) CDK_MEMSET(&((r)._qos_diff_dscp0), 0, sizeof(BCM6300_A0_QOS_DIFF_DSCP0r_t))
#define BCM6300_A0_QOS_DIFF_DSCP0r_SET(r,i,d) (r).qos_diff_dscp0[i] = d
#define BCM6300_A0_QOS_DIFF_DSCP0r_GET(r,i) (r).qos_diff_dscp0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000000f_GET(r) (((r).qos_diff_dscp0[0]) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000000f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000001f_GET(r) ((((r).qos_diff_dscp0[0]) >> 3) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000001f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000010f_GET(r) ((((r).qos_diff_dscp0[0]) >> 6) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000010f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000011f_GET(r) ((((r).qos_diff_dscp0[0]) >> 9) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000011f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000100f_GET(r) ((((r).qos_diff_dscp0[0]) >> 12) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000100f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000101f_GET(r) ((((r).qos_diff_dscp0[0]) >> 15) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000101f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000110f_GET(r) ((((r).qos_diff_dscp0[0]) >> 18) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000110f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000111f_GET(r) ((((r).qos_diff_dscp0[0]) >> 21) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000111f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001000f_GET(r) ((((r).qos_diff_dscp0[0]) >> 24) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001000f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001001f_GET(r) ((((r).qos_diff_dscp0[0]) >> 27) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001001f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 27)) | ((((uint32_t)f) & 0x7) << 27))
#define BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001010f_GET(r) cdk_field32_get((r).qos_diff_dscp0,30,32)
#define BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001010f_SET(r,f) cdk_field32_set((r).qos_diff_dscp0,30,32,f)
#define BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001011f_GET(r) ((((r).qos_diff_dscp0[1]) >> 1) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001011f_SET(r,f) (r).qos_diff_dscp0[1]=(((r).qos_diff_dscp0[1] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001100f_GET(r) ((((r).qos_diff_dscp0[1]) >> 4) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001100f_SET(r,f) (r).qos_diff_dscp0[1]=(((r).qos_diff_dscp0[1] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001101f_GET(r) ((((r).qos_diff_dscp0[1]) >> 7) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001101f_SET(r,f) (r).qos_diff_dscp0[1]=(((r).qos_diff_dscp0[1] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001110f_GET(r) ((((r).qos_diff_dscp0[1]) >> 10) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001110f_SET(r,f) (r).qos_diff_dscp0[1]=(((r).qos_diff_dscp0[1] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001111f_GET(r) ((((r).qos_diff_dscp0[1]) >> 13) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001111f_SET(r,f) (r).qos_diff_dscp0[1]=(((r).qos_diff_dscp0[1] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access QOS_DIFF_DSCP0.
 *
 */
#define BCM6300_A0_READ_QOS_DIFF_DSCP0r(u,r) cdk_robo_reg_read(u,BCM6300_A0_QOS_DIFF_DSCP0r,(r._qos_diff_dscp0),6)
#define BCM6300_A0_WRITE_QOS_DIFF_DSCP0r(u,r) cdk_robo_reg_write(u,BCM6300_A0_QOS_DIFF_DSCP0r,&(r._qos_diff_dscp0),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_DIFF_DSCP0r BCM6300_A0_QOS_DIFF_DSCP0r
#define QOS_DIFF_DSCP0r_SIZE BCM6300_A0_QOS_DIFF_DSCP0r_SIZE
typedef BCM6300_A0_QOS_DIFF_DSCP0r_t QOS_DIFF_DSCP0r_t;
#define QOS_DIFF_DSCP0r_CLR BCM6300_A0_QOS_DIFF_DSCP0r_CLR
#define QOS_DIFF_DSCP0r_SET BCM6300_A0_QOS_DIFF_DSCP0r_SET
#define QOS_DIFF_DSCP0r_GET BCM6300_A0_QOS_DIFF_DSCP0r_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000000f_GET BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000000f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000000f_SET BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000000f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000001f_GET BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000001f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000001f_SET BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000001f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000010f_GET BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000010f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000010f_SET BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000010f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000011f_GET BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000011f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000011f_SET BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000011f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000100f_GET BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000100f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000100f_SET BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000100f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000101f_GET BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000101f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000101f_SET BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000101f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000110f_GET BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000110f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000110f_SET BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000110f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000111f_GET BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000111f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000111f_SET BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000111f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001000f_GET BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001000f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001000f_SET BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001000f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001001f_GET BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001001f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001001f_SET BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001001f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001010f_GET BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001010f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001010f_SET BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001010f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001011f_GET BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001011f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001011f_SET BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001011f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001100f_GET BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001100f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001100f_SET BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001100f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001101f_GET BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001101f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001101f_SET BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001101f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001110f_GET BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001110f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001110f_SET BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001110f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001111f_GET BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001111f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001111f_SET BCM6300_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001111f_SET
#define READ_QOS_DIFF_DSCP0r BCM6300_A0_READ_QOS_DIFF_DSCP0r
#define WRITE_QOS_DIFF_DSCP0r BCM6300_A0_WRITE_QOS_DIFF_DSCP0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_QOS_DIFF_DSCP0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  QOS_DIFF_DSCP1
 * BLOCKS:   SYS
 * DESC:     DiffServ Priority Map 1 Register
 * SIZE:     48
 * FIELDS:
 *     PRI_DSCP_010000  DiffServ DSCP== 010000 to Priority ID map Register.
 *     PRI_DSCP_010001  DiffServ DSCP== 010001 to Priority ID map Register.
 *     PRI_DSCP_010010  DiffServ DSCP== 010010 to Priority ID map Register.
 *     PRI_DSCP_010011  DiffServ DSCP== 010011 to Priority ID map Register.
 *     PRI_DSCP_010100  DiffServ DSCP== 010100 to Priority ID map Register.
 *     PRI_DSCP_010101  DiffServ DSCP== 010101 to Priority ID map Register.
 *     PRI_DSCP_010110  DiffServ DSCP== 010110 to Priority ID map Register.
 *     PRI_DSCP_010111  DiffServ DSCP== 010111 to Priority ID map Register.
 *     PRI_DSCP_011000  DiffServ DSCP== 011000 to Priority ID map Register.
 *     PRI_DSCP_011001  DiffServ DSCP== 011001 to Priority ID map Register.
 *     PRI_DSCP_011010  DiffServ DSCP== 011010 to Priority ID map Register.
 *     PRI_DSCP_011011  DiffServ DSCP== 011011 to Priority ID map Register.
 *     PRI_DSCP_011100  DiffServ DSCP== 011100 to Priority ID map Register.
 *     PRI_DSCP_011101  DiffServ DSCP== 011101 to Priority ID map Register.
 *     PRI_DSCP_011110  DiffServ DSCP== 011110 to Priority ID map Register.
 *     PRI_DSCP_011111  DiffServ DSCP== 011111 to Priority ID map Register.
 *
 ******************************************************************************/
#define BCM6300_A0_QOS_DIFF_DSCP1r 0x00003036

#define BCM6300_A0_QOS_DIFF_DSCP1r_SIZE 6

/*
 * This structure should be used to declare and program QOS_DIFF_DSCP1.
 *
 */
typedef union BCM6300_A0_QOS_DIFF_DSCP1r_s {
	uint32_t v[2];
	uint32_t qos_diff_dscp1[2];
	uint32_t _qos_diff_dscp1;
} BCM6300_A0_QOS_DIFF_DSCP1r_t;

#define BCM6300_A0_QOS_DIFF_DSCP1r_CLR(r) CDK_MEMSET(&((r)._qos_diff_dscp1), 0, sizeof(BCM6300_A0_QOS_DIFF_DSCP1r_t))
#define BCM6300_A0_QOS_DIFF_DSCP1r_SET(r,i,d) (r).qos_diff_dscp1[i] = d
#define BCM6300_A0_QOS_DIFF_DSCP1r_GET(r,i) (r).qos_diff_dscp1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010000f_GET(r) (((r).qos_diff_dscp1[0]) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010000f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010001f_GET(r) ((((r).qos_diff_dscp1[0]) >> 3) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010001f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010010f_GET(r) ((((r).qos_diff_dscp1[0]) >> 6) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010010f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010011f_GET(r) ((((r).qos_diff_dscp1[0]) >> 9) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010011f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010100f_GET(r) ((((r).qos_diff_dscp1[0]) >> 12) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010100f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010101f_GET(r) ((((r).qos_diff_dscp1[0]) >> 15) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010101f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010110f_GET(r) ((((r).qos_diff_dscp1[0]) >> 18) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010110f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010111f_GET(r) ((((r).qos_diff_dscp1[0]) >> 21) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010111f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011000f_GET(r) ((((r).qos_diff_dscp1[0]) >> 24) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011000f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011001f_GET(r) ((((r).qos_diff_dscp1[0]) >> 27) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011001f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 27)) | ((((uint32_t)f) & 0x7) << 27))
#define BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011010f_GET(r) cdk_field32_get((r).qos_diff_dscp1,30,32)
#define BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011010f_SET(r,f) cdk_field32_set((r).qos_diff_dscp1,30,32,f)
#define BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011011f_GET(r) ((((r).qos_diff_dscp1[1]) >> 1) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011011f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011100f_GET(r) ((((r).qos_diff_dscp1[1]) >> 4) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011100f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011101f_GET(r) ((((r).qos_diff_dscp1[1]) >> 7) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011101f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011110f_GET(r) ((((r).qos_diff_dscp1[1]) >> 10) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011110f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011111f_GET(r) ((((r).qos_diff_dscp1[1]) >> 13) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011111f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access QOS_DIFF_DSCP1.
 *
 */
#define BCM6300_A0_READ_QOS_DIFF_DSCP1r(u,r) cdk_robo_reg_read(u,BCM6300_A0_QOS_DIFF_DSCP1r,(r._qos_diff_dscp1),6)
#define BCM6300_A0_WRITE_QOS_DIFF_DSCP1r(u,r) cdk_robo_reg_write(u,BCM6300_A0_QOS_DIFF_DSCP1r,&(r._qos_diff_dscp1),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_DIFF_DSCP1r BCM6300_A0_QOS_DIFF_DSCP1r
#define QOS_DIFF_DSCP1r_SIZE BCM6300_A0_QOS_DIFF_DSCP1r_SIZE
typedef BCM6300_A0_QOS_DIFF_DSCP1r_t QOS_DIFF_DSCP1r_t;
#define QOS_DIFF_DSCP1r_CLR BCM6300_A0_QOS_DIFF_DSCP1r_CLR
#define QOS_DIFF_DSCP1r_SET BCM6300_A0_QOS_DIFF_DSCP1r_SET
#define QOS_DIFF_DSCP1r_GET BCM6300_A0_QOS_DIFF_DSCP1r_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010000f_GET BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010000f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010000f_SET BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010000f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010001f_GET BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010001f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010001f_SET BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010001f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010010f_GET BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010010f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010010f_SET BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010010f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010011f_GET BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010011f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010011f_SET BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010011f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010100f_GET BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010100f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010100f_SET BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010100f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010101f_GET BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010101f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010101f_SET BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010101f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010110f_GET BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010110f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010110f_SET BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010110f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010111f_GET BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010111f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010111f_SET BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010111f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011000f_GET BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011000f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011000f_SET BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011000f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011001f_GET BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011001f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011001f_SET BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011001f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011010f_GET BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011010f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011010f_SET BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011010f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011011f_GET BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011011f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011011f_SET BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011011f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011100f_GET BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011100f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011100f_SET BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011100f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011101f_GET BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011101f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011101f_SET BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011101f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011110f_GET BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011110f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011110f_SET BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011110f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011111f_GET BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011111f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011111f_SET BCM6300_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011111f_SET
#define READ_QOS_DIFF_DSCP1r BCM6300_A0_READ_QOS_DIFF_DSCP1r
#define WRITE_QOS_DIFF_DSCP1r BCM6300_A0_WRITE_QOS_DIFF_DSCP1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_QOS_DIFF_DSCP1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  QOS_DIFF_DSCP2
 * BLOCKS:   SYS
 * DESC:     DiffServ Priority Map 2 Register
 * SIZE:     48
 * FIELDS:
 *     PRI_DSCP_100000  DiffServ DSCP== 100000 to Priority ID map Register.
 *     PRI_DSCP_100001  DiffServ DSCP== 100001 to Priority ID map Register.
 *     PRI_DSCP_100010  DiffServ DSCP== 100010 to Priority ID map Register.
 *     PRI_DSCP_100011  DiffServ DSCP== 100011 to Priority ID map Register.
 *     PRI_DSCP_100100  DiffServ DSCP== 100100 to Priority ID map Register.
 *     PRI_DSCP_100101  DiffServ DSCP== 100101 to Priority ID map Register.
 *     PRI_DSCP_100110  DiffServ DSCP== 100110 to Priority ID map Register.
 *     PRI_DSCP_100111  DiffServ DSCP== 000111 to Priority ID map Register.
 *     PRI_DSCP_101000  DiffServ DSCP== 101000 to Priority ID map Register.
 *     PRI_DSCP_101001  DiffServ DSCP== 101001 to Priority ID map Register.
 *     PRI_DSCP_101010  DiffServ DSCP== 101010 to Priority ID map Register.
 *     PRI_DSCP_101011  DiffServ DSCP== 101011 to Priority ID map Register.
 *     PRI_DSCP_101100  DiffServ DSCP== 101100 to Priority ID map Register.
 *     PRI_DSCP_101101  DiffServ DSCP== 001101 to Priority ID map Register.
 *     PRI_DSCP_101110  DiffServ DSCP== 001110 to Priority ID map Register.
 *     PRI_DSCP_101111  DiffServ DSCP== 001111 to Priority ID map Register.
 *
 ******************************************************************************/
#define BCM6300_A0_QOS_DIFF_DSCP2r 0x0000303c

#define BCM6300_A0_QOS_DIFF_DSCP2r_SIZE 6

/*
 * This structure should be used to declare and program QOS_DIFF_DSCP2.
 *
 */
typedef union BCM6300_A0_QOS_DIFF_DSCP2r_s {
	uint32_t v[2];
	uint32_t qos_diff_dscp2[2];
	uint32_t _qos_diff_dscp2;
} BCM6300_A0_QOS_DIFF_DSCP2r_t;

#define BCM6300_A0_QOS_DIFF_DSCP2r_CLR(r) CDK_MEMSET(&((r)._qos_diff_dscp2), 0, sizeof(BCM6300_A0_QOS_DIFF_DSCP2r_t))
#define BCM6300_A0_QOS_DIFF_DSCP2r_SET(r,i,d) (r).qos_diff_dscp2[i] = d
#define BCM6300_A0_QOS_DIFF_DSCP2r_GET(r,i) (r).qos_diff_dscp2[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100000f_GET(r) (((r).qos_diff_dscp2[0]) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100000f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100001f_GET(r) ((((r).qos_diff_dscp2[0]) >> 3) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100001f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100010f_GET(r) ((((r).qos_diff_dscp2[0]) >> 6) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100010f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100011f_GET(r) ((((r).qos_diff_dscp2[0]) >> 9) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100011f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100100f_GET(r) ((((r).qos_diff_dscp2[0]) >> 12) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100100f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100101f_GET(r) ((((r).qos_diff_dscp2[0]) >> 15) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100101f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100110f_GET(r) ((((r).qos_diff_dscp2[0]) >> 18) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100110f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100111f_GET(r) ((((r).qos_diff_dscp2[0]) >> 21) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100111f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101000f_GET(r) ((((r).qos_diff_dscp2[0]) >> 24) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101000f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101001f_GET(r) ((((r).qos_diff_dscp2[0]) >> 27) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101001f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 27)) | ((((uint32_t)f) & 0x7) << 27))
#define BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101010f_GET(r) cdk_field32_get((r).qos_diff_dscp2,30,32)
#define BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101010f_SET(r,f) cdk_field32_set((r).qos_diff_dscp2,30,32,f)
#define BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101011f_GET(r) ((((r).qos_diff_dscp2[1]) >> 1) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101011f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101100f_GET(r) ((((r).qos_diff_dscp2[1]) >> 4) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101100f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101101f_GET(r) ((((r).qos_diff_dscp2[1]) >> 7) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101101f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101110f_GET(r) ((((r).qos_diff_dscp2[1]) >> 10) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101110f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101111f_GET(r) ((((r).qos_diff_dscp2[1]) >> 13) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101111f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access QOS_DIFF_DSCP2.
 *
 */
#define BCM6300_A0_READ_QOS_DIFF_DSCP2r(u,r) cdk_robo_reg_read(u,BCM6300_A0_QOS_DIFF_DSCP2r,(r._qos_diff_dscp2),6)
#define BCM6300_A0_WRITE_QOS_DIFF_DSCP2r(u,r) cdk_robo_reg_write(u,BCM6300_A0_QOS_DIFF_DSCP2r,&(r._qos_diff_dscp2),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_DIFF_DSCP2r BCM6300_A0_QOS_DIFF_DSCP2r
#define QOS_DIFF_DSCP2r_SIZE BCM6300_A0_QOS_DIFF_DSCP2r_SIZE
typedef BCM6300_A0_QOS_DIFF_DSCP2r_t QOS_DIFF_DSCP2r_t;
#define QOS_DIFF_DSCP2r_CLR BCM6300_A0_QOS_DIFF_DSCP2r_CLR
#define QOS_DIFF_DSCP2r_SET BCM6300_A0_QOS_DIFF_DSCP2r_SET
#define QOS_DIFF_DSCP2r_GET BCM6300_A0_QOS_DIFF_DSCP2r_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100000f_GET BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100000f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100000f_SET BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100000f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100001f_GET BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100001f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100001f_SET BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100001f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100010f_GET BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100010f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100010f_SET BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100010f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100011f_GET BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100011f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100011f_SET BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100011f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100100f_GET BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100100f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100100f_SET BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100100f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100101f_GET BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100101f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100101f_SET BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100101f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100110f_GET BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100110f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100110f_SET BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100110f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100111f_GET BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100111f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100111f_SET BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100111f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101000f_GET BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101000f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101000f_SET BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101000f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101001f_GET BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101001f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101001f_SET BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101001f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101010f_GET BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101010f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101010f_SET BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101010f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101011f_GET BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101011f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101011f_SET BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101011f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101100f_GET BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101100f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101100f_SET BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101100f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101101f_GET BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101101f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101101f_SET BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101101f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101110f_GET BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101110f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101110f_SET BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101110f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101111f_GET BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101111f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101111f_SET BCM6300_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101111f_SET
#define READ_QOS_DIFF_DSCP2r BCM6300_A0_READ_QOS_DIFF_DSCP2r
#define WRITE_QOS_DIFF_DSCP2r BCM6300_A0_WRITE_QOS_DIFF_DSCP2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_QOS_DIFF_DSCP2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  QOS_DIFF_DSCP3
 * BLOCKS:   SYS
 * DESC:     DiffServ Priority Map 3 Register
 * SIZE:     48
 * FIELDS:
 *     PRI_DSCP_110000  DiffServ DSCP== 110000 to Priority ID map Register.
 *     PRI_DSCP_110001  DiffServ DSCP== 110001 to Priority ID map Register.
 *     PRI_DSCP_110010  DiffServ DSCP== 110010 to Priority ID map Register.
 *     PRI_DSCP_110011  DiffServ DSCP== 110011 to Priority ID map Register.
 *     PRI_DSCP_110100  DiffServ DSCP== 110100 to Priority ID map Register.
 *     PRI_DSCP_110101  DiffServ DSCP== 110101 to Priority ID map Register.
 *     PRI_DSCP_110110  DiffServ DSCP== 110110 to Priority ID map Register.
 *     PRI_DSCP_110111  DiffServ DSCP== 110111 to Priority ID map Register.
 *     PRI_DSCP_111000  DiffServ DSCP== 111000 to Priority ID map Register.
 *     PRI_DSCP_111001  DiffServ DSCP== 111001 to Priority ID map Register.
 *     PRI_DSCP_111010  DiffServ DSCP== 111010 to Priority ID map Register.
 *     PRI_DSCP_111011  DiffServ DSCP== 111011 to Priority ID map Register.
 *     PRI_DSCP_111100  DiffServ DSCP== 111100 to Priority ID map Register.
 *     PRI_DSCP_111101  DiffServ DSCP== 111101 to Priority ID map Register.
 *     PRI_DSCP_111110  DiffServ DSCP== 111110 to Priority ID map Register.
 *     PRI_DSCP_111111  DiffServ DSCP== 111111 to Priority ID map Register.
 *
 ******************************************************************************/
#define BCM6300_A0_QOS_DIFF_DSCP3r 0x00003042

#define BCM6300_A0_QOS_DIFF_DSCP3r_SIZE 6

/*
 * This structure should be used to declare and program QOS_DIFF_DSCP3.
 *
 */
typedef union BCM6300_A0_QOS_DIFF_DSCP3r_s {
	uint32_t v[2];
	uint32_t qos_diff_dscp3[2];
	uint32_t _qos_diff_dscp3;
} BCM6300_A0_QOS_DIFF_DSCP3r_t;

#define BCM6300_A0_QOS_DIFF_DSCP3r_CLR(r) CDK_MEMSET(&((r)._qos_diff_dscp3), 0, sizeof(BCM6300_A0_QOS_DIFF_DSCP3r_t))
#define BCM6300_A0_QOS_DIFF_DSCP3r_SET(r,i,d) (r).qos_diff_dscp3[i] = d
#define BCM6300_A0_QOS_DIFF_DSCP3r_GET(r,i) (r).qos_diff_dscp3[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110000f_GET(r) (((r).qos_diff_dscp3[0]) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110000f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110001f_GET(r) ((((r).qos_diff_dscp3[0]) >> 3) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110001f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110010f_GET(r) ((((r).qos_diff_dscp3[0]) >> 6) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110010f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110011f_GET(r) ((((r).qos_diff_dscp3[0]) >> 9) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110011f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110100f_GET(r) ((((r).qos_diff_dscp3[0]) >> 12) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110100f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110101f_GET(r) ((((r).qos_diff_dscp3[0]) >> 15) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110101f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110110f_GET(r) ((((r).qos_diff_dscp3[0]) >> 18) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110110f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110111f_GET(r) ((((r).qos_diff_dscp3[0]) >> 21) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110111f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111000f_GET(r) ((((r).qos_diff_dscp3[0]) >> 24) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111000f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111001f_GET(r) ((((r).qos_diff_dscp3[0]) >> 27) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111001f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 27)) | ((((uint32_t)f) & 0x7) << 27))
#define BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111010f_GET(r) cdk_field32_get((r).qos_diff_dscp3,30,32)
#define BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111010f_SET(r,f) cdk_field32_set((r).qos_diff_dscp3,30,32,f)
#define BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111011f_GET(r) ((((r).qos_diff_dscp3[1]) >> 1) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111011f_SET(r,f) (r).qos_diff_dscp3[1]=(((r).qos_diff_dscp3[1] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111100f_GET(r) ((((r).qos_diff_dscp3[1]) >> 4) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111100f_SET(r,f) (r).qos_diff_dscp3[1]=(((r).qos_diff_dscp3[1] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111101f_GET(r) ((((r).qos_diff_dscp3[1]) >> 7) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111101f_SET(r,f) (r).qos_diff_dscp3[1]=(((r).qos_diff_dscp3[1] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111110f_GET(r) ((((r).qos_diff_dscp3[1]) >> 10) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111110f_SET(r,f) (r).qos_diff_dscp3[1]=(((r).qos_diff_dscp3[1] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111111f_GET(r) ((((r).qos_diff_dscp3[1]) >> 13) & 0x7)
#define BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111111f_SET(r,f) (r).qos_diff_dscp3[1]=(((r).qos_diff_dscp3[1] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access QOS_DIFF_DSCP3.
 *
 */
#define BCM6300_A0_READ_QOS_DIFF_DSCP3r(u,r) cdk_robo_reg_read(u,BCM6300_A0_QOS_DIFF_DSCP3r,(r._qos_diff_dscp3),6)
#define BCM6300_A0_WRITE_QOS_DIFF_DSCP3r(u,r) cdk_robo_reg_write(u,BCM6300_A0_QOS_DIFF_DSCP3r,&(r._qos_diff_dscp3),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_DIFF_DSCP3r BCM6300_A0_QOS_DIFF_DSCP3r
#define QOS_DIFF_DSCP3r_SIZE BCM6300_A0_QOS_DIFF_DSCP3r_SIZE
typedef BCM6300_A0_QOS_DIFF_DSCP3r_t QOS_DIFF_DSCP3r_t;
#define QOS_DIFF_DSCP3r_CLR BCM6300_A0_QOS_DIFF_DSCP3r_CLR
#define QOS_DIFF_DSCP3r_SET BCM6300_A0_QOS_DIFF_DSCP3r_SET
#define QOS_DIFF_DSCP3r_GET BCM6300_A0_QOS_DIFF_DSCP3r_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110000f_GET BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110000f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110000f_SET BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110000f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110001f_GET BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110001f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110001f_SET BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110001f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110010f_GET BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110010f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110010f_SET BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110010f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110011f_GET BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110011f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110011f_SET BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110011f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110100f_GET BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110100f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110100f_SET BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110100f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110101f_GET BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110101f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110101f_SET BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110101f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110110f_GET BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110110f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110110f_SET BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110110f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110111f_GET BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110111f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110111f_SET BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110111f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111000f_GET BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111000f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111000f_SET BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111000f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111001f_GET BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111001f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111001f_SET BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111001f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111010f_GET BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111010f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111010f_SET BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111010f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111011f_GET BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111011f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111011f_SET BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111011f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111100f_GET BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111100f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111100f_SET BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111100f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111101f_GET BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111101f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111101f_SET BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111101f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111110f_GET BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111110f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111110f_SET BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111110f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111111f_GET BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111111f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111111f_SET BCM6300_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111111f_SET
#define READ_QOS_DIFF_DSCP3r BCM6300_A0_READ_QOS_DIFF_DSCP3r
#define WRITE_QOS_DIFF_DSCP3r BCM6300_A0_WRITE_QOS_DIFF_DSCP3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_QOS_DIFF_DSCP3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  QOS_EN_DIFFSERV
 * BLOCKS:   SYS
 * DESC:     QOS DiffServ Enable Register
 * SIZE:     16
 * FIELDS:
 *     QOS_EN_DIFFSERV  Enable DiffServ priority for individual ports.Bit 8:0 = Port 8~ Port 0.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_QOS_EN_DIFFSERVr 0x00003006

#define BCM6300_A0_QOS_EN_DIFFSERVr_SIZE 2

/*
 * This structure should be used to declare and program QOS_EN_DIFFSERV.
 *
 */
typedef union BCM6300_A0_QOS_EN_DIFFSERVr_s {
	uint32_t v[1];
	uint32_t qos_en_diffserv[1];
	uint32_t _qos_en_diffserv;
} BCM6300_A0_QOS_EN_DIFFSERVr_t;

#define BCM6300_A0_QOS_EN_DIFFSERVr_CLR(r) (r).qos_en_diffserv[0] = 0
#define BCM6300_A0_QOS_EN_DIFFSERVr_SET(r,d) (r).qos_en_diffserv[0] = d
#define BCM6300_A0_QOS_EN_DIFFSERVr_GET(r) (r).qos_en_diffserv[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_QOS_EN_DIFFSERVr_QOS_EN_DIFFSERVf_GET(r) (((r).qos_en_diffserv[0]) & 0x1ff)
#define BCM6300_A0_QOS_EN_DIFFSERVr_QOS_EN_DIFFSERVf_SET(r,f) (r).qos_en_diffserv[0]=(((r).qos_en_diffserv[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_QOS_EN_DIFFSERVr_RESERVED_Rf_GET(r) ((((r).qos_en_diffserv[0]) >> 9) & 0x7f)
#define BCM6300_A0_QOS_EN_DIFFSERVr_RESERVED_Rf_SET(r,f) (r).qos_en_diffserv[0]=(((r).qos_en_diffserv[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access QOS_EN_DIFFSERV.
 *
 */
#define BCM6300_A0_READ_QOS_EN_DIFFSERVr(u,r) cdk_robo_reg_read(u,BCM6300_A0_QOS_EN_DIFFSERVr,(r._qos_en_diffserv),2)
#define BCM6300_A0_WRITE_QOS_EN_DIFFSERVr(u,r) cdk_robo_reg_write(u,BCM6300_A0_QOS_EN_DIFFSERVr,&(r._qos_en_diffserv),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_EN_DIFFSERVr BCM6300_A0_QOS_EN_DIFFSERVr
#define QOS_EN_DIFFSERVr_SIZE BCM6300_A0_QOS_EN_DIFFSERVr_SIZE
typedef BCM6300_A0_QOS_EN_DIFFSERVr_t QOS_EN_DIFFSERVr_t;
#define QOS_EN_DIFFSERVr_CLR BCM6300_A0_QOS_EN_DIFFSERVr_CLR
#define QOS_EN_DIFFSERVr_SET BCM6300_A0_QOS_EN_DIFFSERVr_SET
#define QOS_EN_DIFFSERVr_GET BCM6300_A0_QOS_EN_DIFFSERVr_GET
#define QOS_EN_DIFFSERVr_QOS_EN_DIFFSERVf_GET BCM6300_A0_QOS_EN_DIFFSERVr_QOS_EN_DIFFSERVf_GET
#define QOS_EN_DIFFSERVr_QOS_EN_DIFFSERVf_SET BCM6300_A0_QOS_EN_DIFFSERVr_QOS_EN_DIFFSERVf_SET
#define QOS_EN_DIFFSERVr_RESERVED_Rf_GET BCM6300_A0_QOS_EN_DIFFSERVr_RESERVED_Rf_GET
#define QOS_EN_DIFFSERVr_RESERVED_Rf_SET BCM6300_A0_QOS_EN_DIFFSERVr_RESERVED_Rf_SET
#define READ_QOS_EN_DIFFSERVr BCM6300_A0_READ_QOS_EN_DIFFSERVr
#define WRITE_QOS_EN_DIFFSERVr BCM6300_A0_WRITE_QOS_EN_DIFFSERVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_QOS_EN_DIFFSERVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  QOS_EN_TRAFFIC_PRI_REMAP
 * BLOCKS:   SYS
 * DESC:     Enable Traffic Priority Remap Control Register
 * SIZE:     16
 * FIELDS:
 *     EN_TRAFFIC_PRI_REMAP Enable Traffic Priority RemapBit8:0 = Port 8~ Port 0When Enabled, the Priority of Different traffic will re-map according to Traffic Priority Remap Register [Page 30H, Offset A1H].
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_QOS_EN_TRAFFIC_PRI_REMAPr 0x000030a0

#define BCM6300_A0_QOS_EN_TRAFFIC_PRI_REMAPr_SIZE 2

/*
 * This structure should be used to declare and program QOS_EN_TRAFFIC_PRI_REMAP.
 *
 */
typedef union BCM6300_A0_QOS_EN_TRAFFIC_PRI_REMAPr_s {
	uint32_t v[1];
	uint32_t qos_en_traffic_pri_remap[1];
	uint32_t _qos_en_traffic_pri_remap;
} BCM6300_A0_QOS_EN_TRAFFIC_PRI_REMAPr_t;

#define BCM6300_A0_QOS_EN_TRAFFIC_PRI_REMAPr_CLR(r) (r).qos_en_traffic_pri_remap[0] = 0
#define BCM6300_A0_QOS_EN_TRAFFIC_PRI_REMAPr_SET(r,d) (r).qos_en_traffic_pri_remap[0] = d
#define BCM6300_A0_QOS_EN_TRAFFIC_PRI_REMAPr_GET(r) (r).qos_en_traffic_pri_remap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_QOS_EN_TRAFFIC_PRI_REMAPr_EN_TRAFFIC_PRI_REMAPf_GET(r) (((r).qos_en_traffic_pri_remap[0]) & 0x1ff)
#define BCM6300_A0_QOS_EN_TRAFFIC_PRI_REMAPr_EN_TRAFFIC_PRI_REMAPf_SET(r,f) (r).qos_en_traffic_pri_remap[0]=(((r).qos_en_traffic_pri_remap[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_QOS_EN_TRAFFIC_PRI_REMAPr_RESERVED_Rf_GET(r) ((((r).qos_en_traffic_pri_remap[0]) >> 9) & 0x7f)
#define BCM6300_A0_QOS_EN_TRAFFIC_PRI_REMAPr_RESERVED_Rf_SET(r,f) (r).qos_en_traffic_pri_remap[0]=(((r).qos_en_traffic_pri_remap[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access QOS_EN_TRAFFIC_PRI_REMAP.
 *
 */
#define BCM6300_A0_READ_QOS_EN_TRAFFIC_PRI_REMAPr(u,r) cdk_robo_reg_read(u,BCM6300_A0_QOS_EN_TRAFFIC_PRI_REMAPr,(r._qos_en_traffic_pri_remap),2)
#define BCM6300_A0_WRITE_QOS_EN_TRAFFIC_PRI_REMAPr(u,r) cdk_robo_reg_write(u,BCM6300_A0_QOS_EN_TRAFFIC_PRI_REMAPr,&(r._qos_en_traffic_pri_remap),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_EN_TRAFFIC_PRI_REMAPr BCM6300_A0_QOS_EN_TRAFFIC_PRI_REMAPr
#define QOS_EN_TRAFFIC_PRI_REMAPr_SIZE BCM6300_A0_QOS_EN_TRAFFIC_PRI_REMAPr_SIZE
typedef BCM6300_A0_QOS_EN_TRAFFIC_PRI_REMAPr_t QOS_EN_TRAFFIC_PRI_REMAPr_t;
#define QOS_EN_TRAFFIC_PRI_REMAPr_CLR BCM6300_A0_QOS_EN_TRAFFIC_PRI_REMAPr_CLR
#define QOS_EN_TRAFFIC_PRI_REMAPr_SET BCM6300_A0_QOS_EN_TRAFFIC_PRI_REMAPr_SET
#define QOS_EN_TRAFFIC_PRI_REMAPr_GET BCM6300_A0_QOS_EN_TRAFFIC_PRI_REMAPr_GET
#define QOS_EN_TRAFFIC_PRI_REMAPr_EN_TRAFFIC_PRI_REMAPf_GET BCM6300_A0_QOS_EN_TRAFFIC_PRI_REMAPr_EN_TRAFFIC_PRI_REMAPf_GET
#define QOS_EN_TRAFFIC_PRI_REMAPr_EN_TRAFFIC_PRI_REMAPf_SET BCM6300_A0_QOS_EN_TRAFFIC_PRI_REMAPr_EN_TRAFFIC_PRI_REMAPf_SET
#define QOS_EN_TRAFFIC_PRI_REMAPr_RESERVED_Rf_GET BCM6300_A0_QOS_EN_TRAFFIC_PRI_REMAPr_RESERVED_Rf_GET
#define QOS_EN_TRAFFIC_PRI_REMAPr_RESERVED_Rf_SET BCM6300_A0_QOS_EN_TRAFFIC_PRI_REMAPr_RESERVED_Rf_SET
#define READ_QOS_EN_TRAFFIC_PRI_REMAPr BCM6300_A0_READ_QOS_EN_TRAFFIC_PRI_REMAPr
#define WRITE_QOS_EN_TRAFFIC_PRI_REMAPr BCM6300_A0_WRITE_QOS_EN_TRAFFIC_PRI_REMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_QOS_EN_TRAFFIC_PRI_REMAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  QOS_GLOBAL_CTRL
 * BLOCKS:   SYS
 * DESC:     QOS Global Control Register
 * SIZE:     8
 * FIELDS:
 *     MIB_QOS_MON_SEL  SelMIB QOS Monitor Selection2'b00: Queue 02'b01: Queue 12'b10: Queue 22'b11: Queue 3
 *     QOS_LAYER_SEL    QOS IP Layer/Mac Layer Selection.2'b00: Layer 2 QOS only.       Select 802.1p if enabled and the RX frame is tagged, otherwise select mac-based2'b01: IP QOS only Select Diffserv if enabled, otherwise priority=0.2'b10: If (IP) then IP QOS ELSE LAYER2 QOS For IP frame, select Diffserv (0 if Diffserv is off), for L2 frames, select 802.1p if enabled and tagged, otherwise mac-based2'b11: Max Priority of All QOS algorithm Select max priority from port-based, Diffserv if enabled, 802.1p if enabled,
 *     RESERVED_0R      Reserved
 *     PORT_QOS_EN      Port Based QOS Enable.When Set, Priority of Packet of individual Port can be assigned by Default Priority bits in Defualt 802.1Q Tag Register (Page:34h Address 10h-21h,26-27h)If Port-based QOS is enabled, it overrides all other priorities except the case of qos_layer_sel=11.Default value by Strap pin qos_en.
 *     RESERVED_1R      Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_QOS_GLOBAL_CTRLr 0x00003000

#define BCM6300_A0_QOS_GLOBAL_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program QOS_GLOBAL_CTRL.
 *
 */
typedef union BCM6300_A0_QOS_GLOBAL_CTRLr_s {
	uint32_t v[1];
	uint32_t qos_global_ctrl[1];
	uint32_t _qos_global_ctrl;
} BCM6300_A0_QOS_GLOBAL_CTRLr_t;

#define BCM6300_A0_QOS_GLOBAL_CTRLr_CLR(r) (r).qos_global_ctrl[0] = 0
#define BCM6300_A0_QOS_GLOBAL_CTRLr_SET(r,d) (r).qos_global_ctrl[0] = d
#define BCM6300_A0_QOS_GLOBAL_CTRLr_GET(r) (r).qos_global_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_QOS_GLOBAL_CTRLr_MIB_QOS_MON_SELf_GET(r) (((r).qos_global_ctrl[0]) & 0x3)
#define BCM6300_A0_QOS_GLOBAL_CTRLr_MIB_QOS_MON_SELf_SET(r,f) (r).qos_global_ctrl[0]=(((r).qos_global_ctrl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM6300_A0_QOS_GLOBAL_CTRLr_QOS_LAYER_SELf_GET(r) ((((r).qos_global_ctrl[0]) >> 2) & 0x3)
#define BCM6300_A0_QOS_GLOBAL_CTRLr_QOS_LAYER_SELf_SET(r,f) (r).qos_global_ctrl[0]=(((r).qos_global_ctrl[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM6300_A0_QOS_GLOBAL_CTRLr_RESERVED_0Rf_GET(r) ((((r).qos_global_ctrl[0]) >> 4) & 0x3)
#define BCM6300_A0_QOS_GLOBAL_CTRLr_RESERVED_0Rf_SET(r,f) (r).qos_global_ctrl[0]=(((r).qos_global_ctrl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM6300_A0_QOS_GLOBAL_CTRLr_PORT_QOS_ENf_GET(r) ((((r).qos_global_ctrl[0]) >> 6) & 0x1)
#define BCM6300_A0_QOS_GLOBAL_CTRLr_PORT_QOS_ENf_SET(r,f) (r).qos_global_ctrl[0]=(((r).qos_global_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM6300_A0_QOS_GLOBAL_CTRLr_RESERVED_1Rf_GET(r) ((((r).qos_global_ctrl[0]) >> 7) & 0x1)
#define BCM6300_A0_QOS_GLOBAL_CTRLr_RESERVED_1Rf_SET(r,f) (r).qos_global_ctrl[0]=(((r).qos_global_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access QOS_GLOBAL_CTRL.
 *
 */
#define BCM6300_A0_READ_QOS_GLOBAL_CTRLr(u,r) cdk_robo_reg_read(u,BCM6300_A0_QOS_GLOBAL_CTRLr,(r._qos_global_ctrl),1)
#define BCM6300_A0_WRITE_QOS_GLOBAL_CTRLr(u,r) cdk_robo_reg_write(u,BCM6300_A0_QOS_GLOBAL_CTRLr,&(r._qos_global_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_GLOBAL_CTRLr BCM6300_A0_QOS_GLOBAL_CTRLr
#define QOS_GLOBAL_CTRLr_SIZE BCM6300_A0_QOS_GLOBAL_CTRLr_SIZE
typedef BCM6300_A0_QOS_GLOBAL_CTRLr_t QOS_GLOBAL_CTRLr_t;
#define QOS_GLOBAL_CTRLr_CLR BCM6300_A0_QOS_GLOBAL_CTRLr_CLR
#define QOS_GLOBAL_CTRLr_SET BCM6300_A0_QOS_GLOBAL_CTRLr_SET
#define QOS_GLOBAL_CTRLr_GET BCM6300_A0_QOS_GLOBAL_CTRLr_GET
#define QOS_GLOBAL_CTRLr_MIB_QOS_MON_SELf_GET BCM6300_A0_QOS_GLOBAL_CTRLr_MIB_QOS_MON_SELf_GET
#define QOS_GLOBAL_CTRLr_MIB_QOS_MON_SELf_SET BCM6300_A0_QOS_GLOBAL_CTRLr_MIB_QOS_MON_SELf_SET
#define QOS_GLOBAL_CTRLr_QOS_LAYER_SELf_GET BCM6300_A0_QOS_GLOBAL_CTRLr_QOS_LAYER_SELf_GET
#define QOS_GLOBAL_CTRLr_QOS_LAYER_SELf_SET BCM6300_A0_QOS_GLOBAL_CTRLr_QOS_LAYER_SELf_SET
#define QOS_GLOBAL_CTRLr_RESERVED_0Rf_GET BCM6300_A0_QOS_GLOBAL_CTRLr_RESERVED_0Rf_GET
#define QOS_GLOBAL_CTRLr_RESERVED_0Rf_SET BCM6300_A0_QOS_GLOBAL_CTRLr_RESERVED_0Rf_SET
#define QOS_GLOBAL_CTRLr_PORT_QOS_ENf_GET BCM6300_A0_QOS_GLOBAL_CTRLr_PORT_QOS_ENf_GET
#define QOS_GLOBAL_CTRLr_PORT_QOS_ENf_SET BCM6300_A0_QOS_GLOBAL_CTRLr_PORT_QOS_ENf_SET
#define QOS_GLOBAL_CTRLr_RESERVED_1Rf_GET BCM6300_A0_QOS_GLOBAL_CTRLr_RESERVED_1Rf_GET
#define QOS_GLOBAL_CTRLr_RESERVED_1Rf_SET BCM6300_A0_QOS_GLOBAL_CTRLr_RESERVED_1Rf_SET
#define READ_QOS_GLOBAL_CTRLr BCM6300_A0_READ_QOS_GLOBAL_CTRLr
#define WRITE_QOS_GLOBAL_CTRLr BCM6300_A0_WRITE_QOS_GLOBAL_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_QOS_GLOBAL_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  QOS_RX_CTRL_P
 * BLOCKS:   GPIC CPIC
 * DESC:     QOS RX Port Control N Register
 * SIZE:     16
 * FIELDS:
 *     PRT000_TO_QID    Priority ID 000 mapped to TX Queue ID.if (N ==0~3 && strap qos_en) 2'b11 else2'b00
 *     PRT001_TO_QID    Priority ID 001 mapped to TX Queue ID.if (N ==0~3 && strap qos_en) 2'b11 else2'b00
 *     PRT010_TO_QID    Priority ID 010 mapped to TX Queue ID.if (N ==0~3 && strap qos_en) 2'b11 else2'b00
 *     PRT011_TO_QID    Priority ID 011 mapped to TX Queue ID.if (N ==0~3 && strap qos_en) 2'b11 else2'b00
 *     PRT100_TO_QID    Priority ID 100 mapped to TX Queue ID.if (N ==0~3 && strap qos_en) 2'b11 else2'b00
 *     PRT101_TO_QID    Priority ID 101 mapped to TX Queue ID.if (N ==0~3 && strap qos_en) 2'b11 else2'b00
 *     PRT110_TO_QID    Priority ID 110 mapped to TX Queue ID.if (N ==0~3 && strap qos_en) 2'b11 else2'b00
 *     PRT111_TO_QID    Priority ID 111 mapped to TX Queue ID.if (N ==0~3 && strap qos_en) 2'b11 else2'b00
 *
 ******************************************************************************/
#define BCM6300_A0_QOS_RX_CTRL_Pr 0x00003050

#define BCM6300_A0_QOS_RX_CTRL_Pr_SIZE 2

/*
 * This structure should be used to declare and program QOS_RX_CTRL_P.
 *
 */
typedef union BCM6300_A0_QOS_RX_CTRL_Pr_s {
	uint32_t v[1];
	uint32_t qos_rx_ctrl_p[1];
	uint32_t _qos_rx_ctrl_p;
} BCM6300_A0_QOS_RX_CTRL_Pr_t;

#define BCM6300_A0_QOS_RX_CTRL_Pr_CLR(r) (r).qos_rx_ctrl_p[0] = 0
#define BCM6300_A0_QOS_RX_CTRL_Pr_SET(r,d) (r).qos_rx_ctrl_p[0] = d
#define BCM6300_A0_QOS_RX_CTRL_Pr_GET(r) (r).qos_rx_ctrl_p[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_QOS_RX_CTRL_Pr_PRT000_TO_QIDf_GET(r) (((r).qos_rx_ctrl_p[0]) & 0x3)
#define BCM6300_A0_QOS_RX_CTRL_Pr_PRT000_TO_QIDf_SET(r,f) (r).qos_rx_ctrl_p[0]=(((r).qos_rx_ctrl_p[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM6300_A0_QOS_RX_CTRL_Pr_PRT001_TO_QIDf_GET(r) ((((r).qos_rx_ctrl_p[0]) >> 2) & 0x3)
#define BCM6300_A0_QOS_RX_CTRL_Pr_PRT001_TO_QIDf_SET(r,f) (r).qos_rx_ctrl_p[0]=(((r).qos_rx_ctrl_p[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM6300_A0_QOS_RX_CTRL_Pr_PRT010_TO_QIDf_GET(r) ((((r).qos_rx_ctrl_p[0]) >> 4) & 0x3)
#define BCM6300_A0_QOS_RX_CTRL_Pr_PRT010_TO_QIDf_SET(r,f) (r).qos_rx_ctrl_p[0]=(((r).qos_rx_ctrl_p[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM6300_A0_QOS_RX_CTRL_Pr_PRT011_TO_QIDf_GET(r) ((((r).qos_rx_ctrl_p[0]) >> 6) & 0x3)
#define BCM6300_A0_QOS_RX_CTRL_Pr_PRT011_TO_QIDf_SET(r,f) (r).qos_rx_ctrl_p[0]=(((r).qos_rx_ctrl_p[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM6300_A0_QOS_RX_CTRL_Pr_PRT100_TO_QIDf_GET(r) ((((r).qos_rx_ctrl_p[0]) >> 8) & 0x3)
#define BCM6300_A0_QOS_RX_CTRL_Pr_PRT100_TO_QIDf_SET(r,f) (r).qos_rx_ctrl_p[0]=(((r).qos_rx_ctrl_p[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM6300_A0_QOS_RX_CTRL_Pr_PRT101_TO_QIDf_GET(r) ((((r).qos_rx_ctrl_p[0]) >> 10) & 0x3)
#define BCM6300_A0_QOS_RX_CTRL_Pr_PRT101_TO_QIDf_SET(r,f) (r).qos_rx_ctrl_p[0]=(((r).qos_rx_ctrl_p[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM6300_A0_QOS_RX_CTRL_Pr_PRT110_TO_QIDf_GET(r) ((((r).qos_rx_ctrl_p[0]) >> 12) & 0x3)
#define BCM6300_A0_QOS_RX_CTRL_Pr_PRT110_TO_QIDf_SET(r,f) (r).qos_rx_ctrl_p[0]=(((r).qos_rx_ctrl_p[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM6300_A0_QOS_RX_CTRL_Pr_PRT111_TO_QIDf_GET(r) ((((r).qos_rx_ctrl_p[0]) >> 14) & 0x3)
#define BCM6300_A0_QOS_RX_CTRL_Pr_PRT111_TO_QIDf_SET(r,f) (r).qos_rx_ctrl_p[0]=(((r).qos_rx_ctrl_p[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access QOS_RX_CTRL_P.
 *
 */
#define BCM6300_A0_READ_QOS_RX_CTRL_Pr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_QOS_RX_CTRL_Pr,(r._qos_rx_ctrl_p),2)
#define BCM6300_A0_WRITE_QOS_RX_CTRL_Pr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_QOS_RX_CTRL_Pr,&(r._qos_rx_ctrl_p),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_RX_CTRL_Pr BCM6300_A0_QOS_RX_CTRL_Pr
#define QOS_RX_CTRL_Pr_SIZE BCM6300_A0_QOS_RX_CTRL_Pr_SIZE
typedef BCM6300_A0_QOS_RX_CTRL_Pr_t QOS_RX_CTRL_Pr_t;
#define QOS_RX_CTRL_Pr_CLR BCM6300_A0_QOS_RX_CTRL_Pr_CLR
#define QOS_RX_CTRL_Pr_SET BCM6300_A0_QOS_RX_CTRL_Pr_SET
#define QOS_RX_CTRL_Pr_GET BCM6300_A0_QOS_RX_CTRL_Pr_GET
#define QOS_RX_CTRL_Pr_PRT000_TO_QIDf_GET BCM6300_A0_QOS_RX_CTRL_Pr_PRT000_TO_QIDf_GET
#define QOS_RX_CTRL_Pr_PRT000_TO_QIDf_SET BCM6300_A0_QOS_RX_CTRL_Pr_PRT000_TO_QIDf_SET
#define QOS_RX_CTRL_Pr_PRT001_TO_QIDf_GET BCM6300_A0_QOS_RX_CTRL_Pr_PRT001_TO_QIDf_GET
#define QOS_RX_CTRL_Pr_PRT001_TO_QIDf_SET BCM6300_A0_QOS_RX_CTRL_Pr_PRT001_TO_QIDf_SET
#define QOS_RX_CTRL_Pr_PRT010_TO_QIDf_GET BCM6300_A0_QOS_RX_CTRL_Pr_PRT010_TO_QIDf_GET
#define QOS_RX_CTRL_Pr_PRT010_TO_QIDf_SET BCM6300_A0_QOS_RX_CTRL_Pr_PRT010_TO_QIDf_SET
#define QOS_RX_CTRL_Pr_PRT011_TO_QIDf_GET BCM6300_A0_QOS_RX_CTRL_Pr_PRT011_TO_QIDf_GET
#define QOS_RX_CTRL_Pr_PRT011_TO_QIDf_SET BCM6300_A0_QOS_RX_CTRL_Pr_PRT011_TO_QIDf_SET
#define QOS_RX_CTRL_Pr_PRT100_TO_QIDf_GET BCM6300_A0_QOS_RX_CTRL_Pr_PRT100_TO_QIDf_GET
#define QOS_RX_CTRL_Pr_PRT100_TO_QIDf_SET BCM6300_A0_QOS_RX_CTRL_Pr_PRT100_TO_QIDf_SET
#define QOS_RX_CTRL_Pr_PRT101_TO_QIDf_GET BCM6300_A0_QOS_RX_CTRL_Pr_PRT101_TO_QIDf_GET
#define QOS_RX_CTRL_Pr_PRT101_TO_QIDf_SET BCM6300_A0_QOS_RX_CTRL_Pr_PRT101_TO_QIDf_SET
#define QOS_RX_CTRL_Pr_PRT110_TO_QIDf_GET BCM6300_A0_QOS_RX_CTRL_Pr_PRT110_TO_QIDf_GET
#define QOS_RX_CTRL_Pr_PRT110_TO_QIDf_SET BCM6300_A0_QOS_RX_CTRL_Pr_PRT110_TO_QIDf_SET
#define QOS_RX_CTRL_Pr_PRT111_TO_QIDf_GET BCM6300_A0_QOS_RX_CTRL_Pr_PRT111_TO_QIDf_GET
#define QOS_RX_CTRL_Pr_PRT111_TO_QIDf_SET BCM6300_A0_QOS_RX_CTRL_Pr_PRT111_TO_QIDf_SET
#define READ_QOS_RX_CTRL_Pr BCM6300_A0_READ_QOS_RX_CTRL_Pr
#define WRITE_QOS_RX_CTRL_Pr BCM6300_A0_WRITE_QOS_RX_CTRL_Pr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_QOS_RX_CTRL_Pr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  QOS_TRAFFIC_PRI_REMAP
 * BLOCKS:   SYS
 * DESC:     Traffic Priority Remap Registerr
 * SIZE:     16
 * FIELDS:
 *     BROADCAST        BroadcastTraffic Remap Priority Queue ID map.
 *     DLF_REMAP_PRI    Destination Lookup Failed Traffic Remap Priority Queue ID map.
 *     UN_REMAP_PRI     Unicast Traffic Remap Priority Queue ID map.
 *     MU_REMAP_PRI     Multicast Traffic Remap Priority Queue ID map(Except Reserved Multicast Frame).
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_QOS_TRAFFIC_PRI_REMAPr 0x000030a2

#define BCM6300_A0_QOS_TRAFFIC_PRI_REMAPr_SIZE 2

/*
 * This structure should be used to declare and program QOS_TRAFFIC_PRI_REMAP.
 *
 */
typedef union BCM6300_A0_QOS_TRAFFIC_PRI_REMAPr_s {
	uint32_t v[1];
	uint32_t qos_traffic_pri_remap[1];
	uint32_t _qos_traffic_pri_remap;
} BCM6300_A0_QOS_TRAFFIC_PRI_REMAPr_t;

#define BCM6300_A0_QOS_TRAFFIC_PRI_REMAPr_CLR(r) (r).qos_traffic_pri_remap[0] = 0
#define BCM6300_A0_QOS_TRAFFIC_PRI_REMAPr_SET(r,d) (r).qos_traffic_pri_remap[0] = d
#define BCM6300_A0_QOS_TRAFFIC_PRI_REMAPr_GET(r) (r).qos_traffic_pri_remap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_QOS_TRAFFIC_PRI_REMAPr_BROADCASTf_GET(r) (((r).qos_traffic_pri_remap[0]) & 0x3)
#define BCM6300_A0_QOS_TRAFFIC_PRI_REMAPr_BROADCASTf_SET(r,f) (r).qos_traffic_pri_remap[0]=(((r).qos_traffic_pri_remap[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM6300_A0_QOS_TRAFFIC_PRI_REMAPr_DLF_REMAP_PRIf_GET(r) ((((r).qos_traffic_pri_remap[0]) >> 2) & 0x3)
#define BCM6300_A0_QOS_TRAFFIC_PRI_REMAPr_DLF_REMAP_PRIf_SET(r,f) (r).qos_traffic_pri_remap[0]=(((r).qos_traffic_pri_remap[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM6300_A0_QOS_TRAFFIC_PRI_REMAPr_UN_REMAP_PRIf_GET(r) ((((r).qos_traffic_pri_remap[0]) >> 4) & 0x3)
#define BCM6300_A0_QOS_TRAFFIC_PRI_REMAPr_UN_REMAP_PRIf_SET(r,f) (r).qos_traffic_pri_remap[0]=(((r).qos_traffic_pri_remap[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM6300_A0_QOS_TRAFFIC_PRI_REMAPr_MU_REMAP_PRIf_GET(r) ((((r).qos_traffic_pri_remap[0]) >> 6) & 0x3)
#define BCM6300_A0_QOS_TRAFFIC_PRI_REMAPr_MU_REMAP_PRIf_SET(r,f) (r).qos_traffic_pri_remap[0]=(((r).qos_traffic_pri_remap[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM6300_A0_QOS_TRAFFIC_PRI_REMAPr_RESERVED_Rf_GET(r) ((((r).qos_traffic_pri_remap[0]) >> 8) & 0xff)
#define BCM6300_A0_QOS_TRAFFIC_PRI_REMAPr_RESERVED_Rf_SET(r,f) (r).qos_traffic_pri_remap[0]=(((r).qos_traffic_pri_remap[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access QOS_TRAFFIC_PRI_REMAP.
 *
 */
#define BCM6300_A0_READ_QOS_TRAFFIC_PRI_REMAPr(u,r) cdk_robo_reg_read(u,BCM6300_A0_QOS_TRAFFIC_PRI_REMAPr,(r._qos_traffic_pri_remap),2)
#define BCM6300_A0_WRITE_QOS_TRAFFIC_PRI_REMAPr(u,r) cdk_robo_reg_write(u,BCM6300_A0_QOS_TRAFFIC_PRI_REMAPr,&(r._qos_traffic_pri_remap),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_TRAFFIC_PRI_REMAPr BCM6300_A0_QOS_TRAFFIC_PRI_REMAPr
#define QOS_TRAFFIC_PRI_REMAPr_SIZE BCM6300_A0_QOS_TRAFFIC_PRI_REMAPr_SIZE
typedef BCM6300_A0_QOS_TRAFFIC_PRI_REMAPr_t QOS_TRAFFIC_PRI_REMAPr_t;
#define QOS_TRAFFIC_PRI_REMAPr_CLR BCM6300_A0_QOS_TRAFFIC_PRI_REMAPr_CLR
#define QOS_TRAFFIC_PRI_REMAPr_SET BCM6300_A0_QOS_TRAFFIC_PRI_REMAPr_SET
#define QOS_TRAFFIC_PRI_REMAPr_GET BCM6300_A0_QOS_TRAFFIC_PRI_REMAPr_GET
#define QOS_TRAFFIC_PRI_REMAPr_BROADCASTf_GET BCM6300_A0_QOS_TRAFFIC_PRI_REMAPr_BROADCASTf_GET
#define QOS_TRAFFIC_PRI_REMAPr_BROADCASTf_SET BCM6300_A0_QOS_TRAFFIC_PRI_REMAPr_BROADCASTf_SET
#define QOS_TRAFFIC_PRI_REMAPr_DLF_REMAP_PRIf_GET BCM6300_A0_QOS_TRAFFIC_PRI_REMAPr_DLF_REMAP_PRIf_GET
#define QOS_TRAFFIC_PRI_REMAPr_DLF_REMAP_PRIf_SET BCM6300_A0_QOS_TRAFFIC_PRI_REMAPr_DLF_REMAP_PRIf_SET
#define QOS_TRAFFIC_PRI_REMAPr_UN_REMAP_PRIf_GET BCM6300_A0_QOS_TRAFFIC_PRI_REMAPr_UN_REMAP_PRIf_GET
#define QOS_TRAFFIC_PRI_REMAPr_UN_REMAP_PRIf_SET BCM6300_A0_QOS_TRAFFIC_PRI_REMAPr_UN_REMAP_PRIf_SET
#define QOS_TRAFFIC_PRI_REMAPr_MU_REMAP_PRIf_GET BCM6300_A0_QOS_TRAFFIC_PRI_REMAPr_MU_REMAP_PRIf_GET
#define QOS_TRAFFIC_PRI_REMAPr_MU_REMAP_PRIf_SET BCM6300_A0_QOS_TRAFFIC_PRI_REMAPr_MU_REMAP_PRIf_SET
#define QOS_TRAFFIC_PRI_REMAPr_RESERVED_Rf_GET BCM6300_A0_QOS_TRAFFIC_PRI_REMAPr_RESERVED_Rf_GET
#define QOS_TRAFFIC_PRI_REMAPr_RESERVED_Rf_SET BCM6300_A0_QOS_TRAFFIC_PRI_REMAPr_RESERVED_Rf_SET
#define READ_QOS_TRAFFIC_PRI_REMAPr BCM6300_A0_READ_QOS_TRAFFIC_PRI_REMAPr
#define WRITE_QOS_TRAFFIC_PRI_REMAPr BCM6300_A0_WRITE_QOS_TRAFFIC_PRI_REMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_QOS_TRAFFIC_PRI_REMAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  QOS_TX_CTRL
 * BLOCKS:   SYS
 * DESC:     QOS TX Control Register
 * SIZE:     8
 * FIELDS:
 *     RESERVED_0R      Reserved
 *     QOS_MODE         QOS MODE.2'b00: Singe Queue (No QOS)2'b01: Two Queues Mode2'b10: Three Queues Mode2'b11: Four Queues ModeThe bits are used for Multiple Queue Flow Control Threshold Setting.if (strap QOS_en = b1) or strap en_loop_detect =b1) then 2'b01 else 2'b00
 *     HQ_PREEMPT       High Queue PreemptWhen enabled, the highest queue will be served first, whenever it has a frame. If the highest queue is empty, it sends frmaes from the other lower queues in the weight round-robin fashion using the programmed weights.
 *     RESERVED_1R      Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_QOS_TX_CTRLr 0x00003080

#define BCM6300_A0_QOS_TX_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program QOS_TX_CTRL.
 *
 */
typedef union BCM6300_A0_QOS_TX_CTRLr_s {
	uint32_t v[1];
	uint32_t qos_tx_ctrl[1];
	uint32_t _qos_tx_ctrl;
} BCM6300_A0_QOS_TX_CTRLr_t;

#define BCM6300_A0_QOS_TX_CTRLr_CLR(r) (r).qos_tx_ctrl[0] = 0
#define BCM6300_A0_QOS_TX_CTRLr_SET(r,d) (r).qos_tx_ctrl[0] = d
#define BCM6300_A0_QOS_TX_CTRLr_GET(r) (r).qos_tx_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_QOS_TX_CTRLr_RESERVED_0Rf_GET(r) (((r).qos_tx_ctrl[0]) & 0x3)
#define BCM6300_A0_QOS_TX_CTRLr_RESERVED_0Rf_SET(r,f) (r).qos_tx_ctrl[0]=(((r).qos_tx_ctrl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM6300_A0_QOS_TX_CTRLr_QOS_MODEf_GET(r) ((((r).qos_tx_ctrl[0]) >> 2) & 0x3)
#define BCM6300_A0_QOS_TX_CTRLr_QOS_MODEf_SET(r,f) (r).qos_tx_ctrl[0]=(((r).qos_tx_ctrl[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM6300_A0_QOS_TX_CTRLr_HQ_PREEMPTf_GET(r) ((((r).qos_tx_ctrl[0]) >> 4) & 0x1)
#define BCM6300_A0_QOS_TX_CTRLr_HQ_PREEMPTf_SET(r,f) (r).qos_tx_ctrl[0]=(((r).qos_tx_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM6300_A0_QOS_TX_CTRLr_RESERVED_1Rf_GET(r) ((((r).qos_tx_ctrl[0]) >> 5) & 0x7)
#define BCM6300_A0_QOS_TX_CTRLr_RESERVED_1Rf_SET(r,f) (r).qos_tx_ctrl[0]=(((r).qos_tx_ctrl[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access QOS_TX_CTRL.
 *
 */
#define BCM6300_A0_READ_QOS_TX_CTRLr(u,r) cdk_robo_reg_read(u,BCM6300_A0_QOS_TX_CTRLr,(r._qos_tx_ctrl),1)
#define BCM6300_A0_WRITE_QOS_TX_CTRLr(u,r) cdk_robo_reg_write(u,BCM6300_A0_QOS_TX_CTRLr,&(r._qos_tx_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_TX_CTRLr BCM6300_A0_QOS_TX_CTRLr
#define QOS_TX_CTRLr_SIZE BCM6300_A0_QOS_TX_CTRLr_SIZE
typedef BCM6300_A0_QOS_TX_CTRLr_t QOS_TX_CTRLr_t;
#define QOS_TX_CTRLr_CLR BCM6300_A0_QOS_TX_CTRLr_CLR
#define QOS_TX_CTRLr_SET BCM6300_A0_QOS_TX_CTRLr_SET
#define QOS_TX_CTRLr_GET BCM6300_A0_QOS_TX_CTRLr_GET
#define QOS_TX_CTRLr_RESERVED_0Rf_GET BCM6300_A0_QOS_TX_CTRLr_RESERVED_0Rf_GET
#define QOS_TX_CTRLr_RESERVED_0Rf_SET BCM6300_A0_QOS_TX_CTRLr_RESERVED_0Rf_SET
#define QOS_TX_CTRLr_QOS_MODEf_GET BCM6300_A0_QOS_TX_CTRLr_QOS_MODEf_GET
#define QOS_TX_CTRLr_QOS_MODEf_SET BCM6300_A0_QOS_TX_CTRLr_QOS_MODEf_SET
#define QOS_TX_CTRLr_HQ_PREEMPTf_GET BCM6300_A0_QOS_TX_CTRLr_HQ_PREEMPTf_GET
#define QOS_TX_CTRLr_HQ_PREEMPTf_SET BCM6300_A0_QOS_TX_CTRLr_HQ_PREEMPTf_SET
#define QOS_TX_CTRLr_RESERVED_1Rf_GET BCM6300_A0_QOS_TX_CTRLr_RESERVED_1Rf_GET
#define QOS_TX_CTRLr_RESERVED_1Rf_SET BCM6300_A0_QOS_TX_CTRLr_RESERVED_1Rf_SET
#define READ_QOS_TX_CTRLr BCM6300_A0_READ_QOS_TX_CTRLr
#define WRITE_QOS_TX_CTRLr BCM6300_A0_WRITE_QOS_TX_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_QOS_TX_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  QOS_WEIGHT
 * BLOCKS:   SYS
 * DESC:     Queue N Weight Register
 * SIZE:     8
 * FIELDS:
 *     WEIGHTS          Queue N Weight Register.Set to reserve the Service Weight of Queue N.
 *
 ******************************************************************************/
#define BCM6300_A0_QOS_WEIGHTr 0x00003081

#define BCM6300_A0_QOS_WEIGHTr_SIZE 1

/*
 * This structure should be used to declare and program QOS_WEIGHT.
 *
 */
typedef union BCM6300_A0_QOS_WEIGHTr_s {
	uint32_t v[1];
	uint32_t qos_weight[1];
	uint32_t _qos_weight;
} BCM6300_A0_QOS_WEIGHTr_t;

#define BCM6300_A0_QOS_WEIGHTr_CLR(r) (r).qos_weight[0] = 0
#define BCM6300_A0_QOS_WEIGHTr_SET(r,d) (r).qos_weight[0] = d
#define BCM6300_A0_QOS_WEIGHTr_GET(r) (r).qos_weight[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_QOS_WEIGHTr_WEIGHTSf_GET(r) (((r).qos_weight[0]) & 0xff)
#define BCM6300_A0_QOS_WEIGHTr_WEIGHTSf_SET(r,f) (r).qos_weight[0]=(((r).qos_weight[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access QOS_WEIGHT.
 *
 */
#define BCM6300_A0_READ_QOS_WEIGHTr(u,i,r) cdk_robo_reg_read(u,BCM6300_A0_QOS_WEIGHTr+(1*(i)),(r._qos_weight),1)
#define BCM6300_A0_WRITE_QOS_WEIGHTr(u,i,r) cdk_robo_reg_write(u,BCM6300_A0_QOS_WEIGHTr+(1*(i)),&(r._qos_weight),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_WEIGHTr BCM6300_A0_QOS_WEIGHTr
#define QOS_WEIGHTr_SIZE BCM6300_A0_QOS_WEIGHTr_SIZE
typedef BCM6300_A0_QOS_WEIGHTr_t QOS_WEIGHTr_t;
#define QOS_WEIGHTr_CLR BCM6300_A0_QOS_WEIGHTr_CLR
#define QOS_WEIGHTr_SET BCM6300_A0_QOS_WEIGHTr_SET
#define QOS_WEIGHTr_GET BCM6300_A0_QOS_WEIGHTr_GET
#define QOS_WEIGHTr_WEIGHTSf_GET BCM6300_A0_QOS_WEIGHTr_WEIGHTSf_GET
#define QOS_WEIGHTr_WEIGHTSf_SET BCM6300_A0_QOS_WEIGHTr_WEIGHTSf_SET
#define READ_QOS_WEIGHTr BCM6300_A0_READ_QOS_WEIGHTr
#define WRITE_QOS_WEIGHTr BCM6300_A0_WRITE_QOS_WEIGHTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_QOS_WEIGHTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  RGMII_CTL_GP
 * BLOCKS:   GPIC0
 * DESC:     Port RGMII Control register
 * SIZE:     8
 * FIELDS:
 *     TIM_SEL          1: RGMII tx_clk delayed timing mode0: RGMII tx_clk aligned timing modedefault value by strap pin gtx_0_setup.
 *     DLL_RXC_BYPASS   1: clock delay by DLL is enabled0: clock delay by DLL is disabled (Normal Mode)default value by strap pin grx_0_setup.
 *     DLL_IQQD         1: In the IDDQ mode, power is down0: Normal function mode
 *     RESERVED_1R      Reserved
 *     RESERVED_2R      Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_RGMII_CTL_GPr 0x00000064

#define BCM6300_A0_RGMII_CTL_GPr_SIZE 1

/*
 * This structure should be used to declare and program RGMII_CTL_GP.
 *
 */
typedef union BCM6300_A0_RGMII_CTL_GPr_s {
	uint32_t v[1];
	uint32_t rgmii_ctl_gp[1];
	uint32_t _rgmii_ctl_gp;
} BCM6300_A0_RGMII_CTL_GPr_t;

#define BCM6300_A0_RGMII_CTL_GPr_CLR(r) (r).rgmii_ctl_gp[0] = 0
#define BCM6300_A0_RGMII_CTL_GPr_SET(r,d) (r).rgmii_ctl_gp[0] = d
#define BCM6300_A0_RGMII_CTL_GPr_GET(r) (r).rgmii_ctl_gp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_RGMII_CTL_GPr_TIM_SELf_GET(r) (((r).rgmii_ctl_gp[0]) & 0x1)
#define BCM6300_A0_RGMII_CTL_GPr_TIM_SELf_SET(r,f) (r).rgmii_ctl_gp[0]=(((r).rgmii_ctl_gp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM6300_A0_RGMII_CTL_GPr_DLL_RXC_BYPASSf_GET(r) ((((r).rgmii_ctl_gp[0]) >> 1) & 0x1)
#define BCM6300_A0_RGMII_CTL_GPr_DLL_RXC_BYPASSf_SET(r,f) (r).rgmii_ctl_gp[0]=(((r).rgmii_ctl_gp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM6300_A0_RGMII_CTL_GPr_DLL_IQQDf_GET(r) ((((r).rgmii_ctl_gp[0]) >> 2) & 0x1)
#define BCM6300_A0_RGMII_CTL_GPr_DLL_IQQDf_SET(r,f) (r).rgmii_ctl_gp[0]=(((r).rgmii_ctl_gp[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM6300_A0_RGMII_CTL_GPr_RESERVED_1Rf_GET(r) ((((r).rgmii_ctl_gp[0]) >> 3) & 0x7)
#define BCM6300_A0_RGMII_CTL_GPr_RESERVED_1Rf_SET(r,f) (r).rgmii_ctl_gp[0]=(((r).rgmii_ctl_gp[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM6300_A0_RGMII_CTL_GPr_GMII_CLKENf_GET(r) ((((r).rgmii_ctl_gp[0]) >> 7) & 0x1)
#define BCM6300_A0_RGMII_CTL_GPr_GMII_CLKENf_SET(r,f) (r).rgmii_ctl_gp[0]=(((r).rgmii_ctl_gp[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access RGMII_CTL_GP.
 *
 */
#define BCM6300_A0_READ_RGMII_CTL_GPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_RGMII_CTL_GPr,(r._rgmii_ctl_gp),1)
#define BCM6300_A0_WRITE_RGMII_CTL_GPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_RGMII_CTL_GPr,&(r._rgmii_ctl_gp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RGMII_CTL_GPr BCM6300_A0_RGMII_CTL_GPr
#define RGMII_CTL_GPr_SIZE BCM6300_A0_RGMII_CTL_GPr_SIZE
typedef BCM6300_A0_RGMII_CTL_GPr_t RGMII_CTL_GPr_t;
#define RGMII_CTL_GPr_CLR BCM6300_A0_RGMII_CTL_GPr_CLR
#define RGMII_CTL_GPr_SET BCM6300_A0_RGMII_CTL_GPr_SET
#define RGMII_CTL_GPr_GET BCM6300_A0_RGMII_CTL_GPr_GET
#define RGMII_CTL_GPr_TIM_SELf_GET BCM6300_A0_RGMII_CTL_GPr_TIM_SELf_GET
#define RGMII_CTL_GPr_TIM_SELf_SET BCM6300_A0_RGMII_CTL_GPr_TIM_SELf_SET
#define RGMII_CTL_GPr_DLL_RXC_BYPASSf_GET BCM6300_A0_RGMII_CTL_GPr_DLL_RXC_BYPASSf_GET
#define RGMII_CTL_GPr_DLL_RXC_BYPASSf_SET BCM6300_A0_RGMII_CTL_GPr_DLL_RXC_BYPASSf_SET
#define RGMII_CTL_GPr_DLL_IQQDf_GET BCM6300_A0_RGMII_CTL_GPr_DLL_IQQDf_GET
#define RGMII_CTL_GPr_DLL_IQQDf_SET BCM6300_A0_RGMII_CTL_GPr_DLL_IQQDf_SET
#define RGMII_CTL_GPr_RESERVED_1Rf_GET BCM6300_A0_RGMII_CTL_GPr_RESERVED_1Rf_GET
#define RGMII_CTL_GPr_RESERVED_1Rf_SET BCM6300_A0_RGMII_CTL_GPr_RESERVED_1Rf_SET
#define RGMII_CTL_GPr_GMII_CLKENf_GET BCM6300_A0_RGMII_CTL_GPr_GMII_CLKENf_GET
#define RGMII_CTL_GPr_GMII_CLKENf_SET BCM6300_A0_RGMII_CTL_GPr_GMII_CLKENf_SET
#define READ_RGMII_CTL_GPr BCM6300_A0_READ_RGMII_CTL_GPr
#define WRITE_RGMII_CTL_GPr BCM6300_A0_WRITE_RGMII_CTL_GPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_RGMII_CTL_GPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  RGMII_TIME_DLY_GP
 * BLOCKS:   GPIC0
 * DESC:     Giga Port RGMII TIMING DELAY register
 * SIZE:     8
 * FIELDS:
 *     DEL_ADDR         delay timing selection4'b0111 : clk_gtxt = 1'b14'b1000 : clk_gtxg = 1'b14'b1001 : clk_gtxr = 1'b14'b1010 : clk_rxg = 1'b14'b1011 : clk_rxr = 1'b14'b1100 : clk_rbco = 1'b14'b1101 : clk_rbc1 = 1'b1
 *     DEL_VALUE        110 =-1.0x111 = -0.5x000 = 0.0x001 = +0.5x010 = +1.0x
 *     DEL_STRB         Delay Value Write Enable1: CPU over-write Enable, del_value and del_addr will affect the RGMII interface timing adjustment0: Del_value and del_addr will not affect RGMII interface timing adjustment
 *
 ******************************************************************************/
#define BCM6300_A0_RGMII_TIME_DLY_GPr 0x0000006c

#define BCM6300_A0_RGMII_TIME_DLY_GPr_SIZE 1

/*
 * This structure should be used to declare and program RGMII_TIME_DLY_GP.
 *
 */
typedef union BCM6300_A0_RGMII_TIME_DLY_GPr_s {
	uint32_t v[1];
	uint32_t rgmii_time_dly_gp[1];
	uint32_t _rgmii_time_dly_gp;
} BCM6300_A0_RGMII_TIME_DLY_GPr_t;

#define BCM6300_A0_RGMII_TIME_DLY_GPr_CLR(r) (r).rgmii_time_dly_gp[0] = 0
#define BCM6300_A0_RGMII_TIME_DLY_GPr_SET(r,d) (r).rgmii_time_dly_gp[0] = d
#define BCM6300_A0_RGMII_TIME_DLY_GPr_GET(r) (r).rgmii_time_dly_gp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_RGMII_TIME_DLY_GPr_DEL_ADDRf_GET(r) (((r).rgmii_time_dly_gp[0]) & 0xf)
#define BCM6300_A0_RGMII_TIME_DLY_GPr_DEL_ADDRf_SET(r,f) (r).rgmii_time_dly_gp[0]=(((r).rgmii_time_dly_gp[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM6300_A0_RGMII_TIME_DLY_GPr_DEL_VALUEf_GET(r) ((((r).rgmii_time_dly_gp[0]) >> 4) & 0x7)
#define BCM6300_A0_RGMII_TIME_DLY_GPr_DEL_VALUEf_SET(r,f) (r).rgmii_time_dly_gp[0]=(((r).rgmii_time_dly_gp[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM6300_A0_RGMII_TIME_DLY_GPr_DEL_STRBf_GET(r) ((((r).rgmii_time_dly_gp[0]) >> 7) & 0x1)
#define BCM6300_A0_RGMII_TIME_DLY_GPr_DEL_STRBf_SET(r,f) (r).rgmii_time_dly_gp[0]=(((r).rgmii_time_dly_gp[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access RGMII_TIME_DLY_GP.
 *
 */
#define BCM6300_A0_READ_RGMII_TIME_DLY_GPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_RGMII_TIME_DLY_GPr,(r._rgmii_time_dly_gp),1)
#define BCM6300_A0_WRITE_RGMII_TIME_DLY_GPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_RGMII_TIME_DLY_GPr,&(r._rgmii_time_dly_gp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RGMII_TIME_DLY_GPr BCM6300_A0_RGMII_TIME_DLY_GPr
#define RGMII_TIME_DLY_GPr_SIZE BCM6300_A0_RGMII_TIME_DLY_GPr_SIZE
typedef BCM6300_A0_RGMII_TIME_DLY_GPr_t RGMII_TIME_DLY_GPr_t;
#define RGMII_TIME_DLY_GPr_CLR BCM6300_A0_RGMII_TIME_DLY_GPr_CLR
#define RGMII_TIME_DLY_GPr_SET BCM6300_A0_RGMII_TIME_DLY_GPr_SET
#define RGMII_TIME_DLY_GPr_GET BCM6300_A0_RGMII_TIME_DLY_GPr_GET
#define RGMII_TIME_DLY_GPr_DEL_ADDRf_GET BCM6300_A0_RGMII_TIME_DLY_GPr_DEL_ADDRf_GET
#define RGMII_TIME_DLY_GPr_DEL_ADDRf_SET BCM6300_A0_RGMII_TIME_DLY_GPr_DEL_ADDRf_SET
#define RGMII_TIME_DLY_GPr_DEL_VALUEf_GET BCM6300_A0_RGMII_TIME_DLY_GPr_DEL_VALUEf_GET
#define RGMII_TIME_DLY_GPr_DEL_VALUEf_SET BCM6300_A0_RGMII_TIME_DLY_GPr_DEL_VALUEf_SET
#define RGMII_TIME_DLY_GPr_DEL_STRBf_GET BCM6300_A0_RGMII_TIME_DLY_GPr_DEL_STRBf_GET
#define RGMII_TIME_DLY_GPr_DEL_STRBf_SET BCM6300_A0_RGMII_TIME_DLY_GPr_DEL_STRBf_SET
#define READ_RGMII_TIME_DLY_GPr BCM6300_A0_READ_RGMII_TIME_DLY_GPr
#define WRITE_RGMII_TIME_DLY_GPr BCM6300_A0_WRITE_RGMII_TIME_DLY_GPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_RGMII_TIME_DLY_GPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  RMONSTEER
 * BLOCKS:   SYS
 * DESC:     RMON MIB Steering Register
 * SIZE:     16
 * FIELDS:
 *     OR_RMON_RCV      Override RMON Receive.Forces the RMON packet size bucket counters from the normal default of snooping on the receive side of the MAC, to the transmit side. This allows the RMON bucket counters to snoop either transmit or receive, allowing full duplex MAC support.0-7: Port0-7
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_RMONSTEERr 0x00000204

#define BCM6300_A0_RMONSTEERr_SIZE 2

/*
 * This structure should be used to declare and program RMONSTEER.
 *
 */
typedef union BCM6300_A0_RMONSTEERr_s {
	uint32_t v[1];
	uint32_t rmonsteer[1];
	uint32_t _rmonsteer;
} BCM6300_A0_RMONSTEERr_t;

#define BCM6300_A0_RMONSTEERr_CLR(r) (r).rmonsteer[0] = 0
#define BCM6300_A0_RMONSTEERr_SET(r,d) (r).rmonsteer[0] = d
#define BCM6300_A0_RMONSTEERr_GET(r) (r).rmonsteer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_RMONSTEERr_OR_RMON_RCVf_GET(r) (((r).rmonsteer[0]) & 0xff)
#define BCM6300_A0_RMONSTEERr_OR_RMON_RCVf_SET(r,f) (r).rmonsteer[0]=(((r).rmonsteer[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM6300_A0_RMONSTEERr_RESERVED_Rf_GET(r) ((((r).rmonsteer[0]) >> 8) & 0xff)
#define BCM6300_A0_RMONSTEERr_RESERVED_Rf_SET(r,f) (r).rmonsteer[0]=(((r).rmonsteer[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access RMONSTEER.
 *
 */
#define BCM6300_A0_READ_RMONSTEERr(u,r) cdk_robo_reg_read(u,BCM6300_A0_RMONSTEERr,(r._rmonsteer),2)
#define BCM6300_A0_WRITE_RMONSTEERr(u,r) cdk_robo_reg_write(u,BCM6300_A0_RMONSTEERr,&(r._rmonsteer),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RMONSTEERr BCM6300_A0_RMONSTEERr
#define RMONSTEERr_SIZE BCM6300_A0_RMONSTEERr_SIZE
typedef BCM6300_A0_RMONSTEERr_t RMONSTEERr_t;
#define RMONSTEERr_CLR BCM6300_A0_RMONSTEERr_CLR
#define RMONSTEERr_SET BCM6300_A0_RMONSTEERr_SET
#define RMONSTEERr_GET BCM6300_A0_RMONSTEERr_GET
#define RMONSTEERr_OR_RMON_RCVf_GET BCM6300_A0_RMONSTEERr_OR_RMON_RCVf_GET
#define RMONSTEERr_OR_RMON_RCVf_SET BCM6300_A0_RMONSTEERr_OR_RMON_RCVf_SET
#define RMONSTEERr_RESERVED_Rf_GET BCM6300_A0_RMONSTEERr_RESERVED_Rf_GET
#define RMONSTEERr_RESERVED_Rf_SET BCM6300_A0_RMONSTEERr_RESERVED_Rf_SET
#define READ_RMONSTEERr BCM6300_A0_READ_RMONSTEERr
#define WRITE_RMONSTEERr BCM6300_A0_WRITE_RMONSTEERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_RMONSTEERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  RSV_MCAST_CTRL
 * BLOCKS:   SYS
 * DESC:     Reserved Multicast Register
 * SIZE:     8
 * FIELDS:
 *     EN_MUL_0         bit[0] :01-80-C2-00-00-00.0: Forward (default).1: Drop.
 *     EN_MUL_1         bit[1] :01-80-C2-00-00-02 ~ 01-80-C2-00-00-0F.0: Forward1: Drop (default)
 *     EN_MUL_2         bit[2] :01-80-C2-00-00-10.0: Forward (default).1: Drop.
 *     EN_MUL_3         bit[2] :01-80-C2-00-00-11 ~ 01-80-C2-00-00-1F.0: Forward (default).1: Drop.
 *     EN_MUL_4         bit[3] :01-80-C2-00-00-20 ~ 01-80-C2-00-00-2F.0: Forward (default).1: Drop.
 *     RESERVED_R       Reserved
 *     EN_RES_MUL_LEARN bit[7] :en_reserved_McastDA_learn.0: Don't learn (default )1: Learn
 *
 ******************************************************************************/
#define BCM6300_A0_RSV_MCAST_CTRLr 0x0000002f

#define BCM6300_A0_RSV_MCAST_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program RSV_MCAST_CTRL.
 *
 */
typedef union BCM6300_A0_RSV_MCAST_CTRLr_s {
	uint32_t v[1];
	uint32_t rsv_mcast_ctrl[1];
	uint32_t _rsv_mcast_ctrl;
} BCM6300_A0_RSV_MCAST_CTRLr_t;

#define BCM6300_A0_RSV_MCAST_CTRLr_CLR(r) (r).rsv_mcast_ctrl[0] = 0
#define BCM6300_A0_RSV_MCAST_CTRLr_SET(r,d) (r).rsv_mcast_ctrl[0] = d
#define BCM6300_A0_RSV_MCAST_CTRLr_GET(r) (r).rsv_mcast_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_RSV_MCAST_CTRLr_EN_MUL_0f_GET(r) (((r).rsv_mcast_ctrl[0]) & 0x1)
#define BCM6300_A0_RSV_MCAST_CTRLr_EN_MUL_0f_SET(r,f) (r).rsv_mcast_ctrl[0]=(((r).rsv_mcast_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM6300_A0_RSV_MCAST_CTRLr_EN_MUL_1f_GET(r) ((((r).rsv_mcast_ctrl[0]) >> 1) & 0x1)
#define BCM6300_A0_RSV_MCAST_CTRLr_EN_MUL_1f_SET(r,f) (r).rsv_mcast_ctrl[0]=(((r).rsv_mcast_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM6300_A0_RSV_MCAST_CTRLr_EN_MUL_2f_GET(r) ((((r).rsv_mcast_ctrl[0]) >> 2) & 0x1)
#define BCM6300_A0_RSV_MCAST_CTRLr_EN_MUL_2f_SET(r,f) (r).rsv_mcast_ctrl[0]=(((r).rsv_mcast_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM6300_A0_RSV_MCAST_CTRLr_EN_MUL_3f_GET(r) ((((r).rsv_mcast_ctrl[0]) >> 3) & 0x1)
#define BCM6300_A0_RSV_MCAST_CTRLr_EN_MUL_3f_SET(r,f) (r).rsv_mcast_ctrl[0]=(((r).rsv_mcast_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM6300_A0_RSV_MCAST_CTRLr_EN_MUL_4f_GET(r) ((((r).rsv_mcast_ctrl[0]) >> 4) & 0x1)
#define BCM6300_A0_RSV_MCAST_CTRLr_EN_MUL_4f_SET(r,f) (r).rsv_mcast_ctrl[0]=(((r).rsv_mcast_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM6300_A0_RSV_MCAST_CTRLr_RESERVED_Rf_GET(r) ((((r).rsv_mcast_ctrl[0]) >> 5) & 0x3)
#define BCM6300_A0_RSV_MCAST_CTRLr_RESERVED_Rf_SET(r,f) (r).rsv_mcast_ctrl[0]=(((r).rsv_mcast_ctrl[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM6300_A0_RSV_MCAST_CTRLr_EN_RES_MUL_LEARNf_GET(r) ((((r).rsv_mcast_ctrl[0]) >> 7) & 0x1)
#define BCM6300_A0_RSV_MCAST_CTRLr_EN_RES_MUL_LEARNf_SET(r,f) (r).rsv_mcast_ctrl[0]=(((r).rsv_mcast_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access RSV_MCAST_CTRL.
 *
 */
#define BCM6300_A0_READ_RSV_MCAST_CTRLr(u,r) cdk_robo_reg_read(u,BCM6300_A0_RSV_MCAST_CTRLr,(r._rsv_mcast_ctrl),1)
#define BCM6300_A0_WRITE_RSV_MCAST_CTRLr(u,r) cdk_robo_reg_write(u,BCM6300_A0_RSV_MCAST_CTRLr,&(r._rsv_mcast_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RSV_MCAST_CTRLr BCM6300_A0_RSV_MCAST_CTRLr
#define RSV_MCAST_CTRLr_SIZE BCM6300_A0_RSV_MCAST_CTRLr_SIZE
typedef BCM6300_A0_RSV_MCAST_CTRLr_t RSV_MCAST_CTRLr_t;
#define RSV_MCAST_CTRLr_CLR BCM6300_A0_RSV_MCAST_CTRLr_CLR
#define RSV_MCAST_CTRLr_SET BCM6300_A0_RSV_MCAST_CTRLr_SET
#define RSV_MCAST_CTRLr_GET BCM6300_A0_RSV_MCAST_CTRLr_GET
#define RSV_MCAST_CTRLr_EN_MUL_0f_GET BCM6300_A0_RSV_MCAST_CTRLr_EN_MUL_0f_GET
#define RSV_MCAST_CTRLr_EN_MUL_0f_SET BCM6300_A0_RSV_MCAST_CTRLr_EN_MUL_0f_SET
#define RSV_MCAST_CTRLr_EN_MUL_1f_GET BCM6300_A0_RSV_MCAST_CTRLr_EN_MUL_1f_GET
#define RSV_MCAST_CTRLr_EN_MUL_1f_SET BCM6300_A0_RSV_MCAST_CTRLr_EN_MUL_1f_SET
#define RSV_MCAST_CTRLr_EN_MUL_2f_GET BCM6300_A0_RSV_MCAST_CTRLr_EN_MUL_2f_GET
#define RSV_MCAST_CTRLr_EN_MUL_2f_SET BCM6300_A0_RSV_MCAST_CTRLr_EN_MUL_2f_SET
#define RSV_MCAST_CTRLr_EN_MUL_3f_GET BCM6300_A0_RSV_MCAST_CTRLr_EN_MUL_3f_GET
#define RSV_MCAST_CTRLr_EN_MUL_3f_SET BCM6300_A0_RSV_MCAST_CTRLr_EN_MUL_3f_SET
#define RSV_MCAST_CTRLr_EN_MUL_4f_GET BCM6300_A0_RSV_MCAST_CTRLr_EN_MUL_4f_GET
#define RSV_MCAST_CTRLr_EN_MUL_4f_SET BCM6300_A0_RSV_MCAST_CTRLr_EN_MUL_4f_SET
#define RSV_MCAST_CTRLr_RESERVED_Rf_GET BCM6300_A0_RSV_MCAST_CTRLr_RESERVED_Rf_GET
#define RSV_MCAST_CTRLr_RESERVED_Rf_SET BCM6300_A0_RSV_MCAST_CTRLr_RESERVED_Rf_SET
#define RSV_MCAST_CTRLr_EN_RES_MUL_LEARNf_GET BCM6300_A0_RSV_MCAST_CTRLr_EN_RES_MUL_LEARNf_GET
#define RSV_MCAST_CTRLr_EN_RES_MUL_LEARNf_SET BCM6300_A0_RSV_MCAST_CTRLr_EN_RES_MUL_LEARNf_SET
#define READ_RSV_MCAST_CTRLr BCM6300_A0_READ_RSV_MCAST_CTRLr
#define WRITE_RSV_MCAST_CTRLr BCM6300_A0_WRITE_RSV_MCAST_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_RSV_MCAST_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  RXDISCARD
 * BLOCKS:   GPIC0 CPIC
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *
 ******************************************************************************/
#define BCM6300_A0_RXDISCARDr 0x00080000

#define BCM6300_A0_RXDISCARDr_SIZE 4

/*
 * This structure should be used to declare and program RXDISCARD.
 *
 */
typedef union BCM6300_A0_RXDISCARDr_s {
	uint32_t v[1];
	uint32_t rxdiscard[1];
	uint32_t _rxdiscard;
} BCM6300_A0_RXDISCARDr_t;

#define BCM6300_A0_RXDISCARDr_CLR(r) (r).rxdiscard[0] = 0
#define BCM6300_A0_RXDISCARDr_SET(r,d) (r).rxdiscard[0] = d
#define BCM6300_A0_RXDISCARDr_GET(r) (r).rxdiscard[0]

/*
 * These macros can be used to access individual fields.
 *
 */

/*
 * These macros can be used to access RXDISCARD.
 *
 */
#define BCM6300_A0_READ_RXDISCARDr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_RXDISCARDr,(r._rxdiscard),4)
#define BCM6300_A0_WRITE_RXDISCARDr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_RXDISCARDr,&(r._rxdiscard),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXDISCARDr BCM6300_A0_RXDISCARDr
#define RXDISCARDr_SIZE BCM6300_A0_RXDISCARDr_SIZE
typedef BCM6300_A0_RXDISCARDr_t RXDISCARDr_t;
#define RXDISCARDr_CLR BCM6300_A0_RXDISCARDr_CLR
#define RXDISCARDr_SET BCM6300_A0_RXDISCARDr_SET
#define RXDISCARDr_GET BCM6300_A0_RXDISCARDr_GET
#define READ_RXDISCARDr BCM6300_A0_READ_RXDISCARDr
#define WRITE_RXDISCARDr BCM6300_A0_WRITE_RXDISCARDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_RXDISCARDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  RXSymblErr
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Symbol Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM6300_A0_RXSYMBLERRr 0x000020a0

#define BCM6300_A0_RXSYMBLERRr_SIZE 4

/*
 * This structure should be used to declare and program RXSymblErr.
 *
 */
typedef union BCM6300_A0_RXSYMBLERRr_s {
	uint32_t v[1];
	uint32_t rxsymblerr[1];
	uint32_t _rxsymblerr;
} BCM6300_A0_RXSYMBLERRr_t;

#define BCM6300_A0_RXSYMBLERRr_CLR(r) (r).rxsymblerr[0] = 0
#define BCM6300_A0_RXSYMBLERRr_SET(r,d) (r).rxsymblerr[0] = d
#define BCM6300_A0_RXSYMBLERRr_GET(r) (r).rxsymblerr[0]


/*
 * These macros can be used to access RXSymblErr.
 *
 */
#define BCM6300_A0_READ_RXSYMBLERRr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_RXSYMBLERRr,(r._rxsymblerr),4)
#define BCM6300_A0_WRITE_RXSYMBLERRr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_RXSYMBLERRr,&(r._rxsymblerr),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXSYMBLERRr BCM6300_A0_RXSYMBLERRr
#define RXSYMBLERRr_SIZE BCM6300_A0_RXSYMBLERRr_SIZE
typedef BCM6300_A0_RXSYMBLERRr_t RXSYMBLERRr_t;
#define RXSYMBLERRr_CLR BCM6300_A0_RXSYMBLERRr_CLR
#define RXSYMBLERRr_SET BCM6300_A0_RXSYMBLERRr_SET
#define RXSYMBLERRr_GET BCM6300_A0_RXSYMBLERRr_GET
#define READ_RXSYMBLERRr BCM6300_A0_READ_RXSYMBLERRr
#define WRITE_RXSYMBLERRr BCM6300_A0_WRITE_RXSYMBLERRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_RXSYMBLERRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  RX_GLOBAL_CTL
 * BLOCKS:   SYS
 * DESC:     RX Global Control register
 * SIZE:     8
 * FIELDS:
 *     FMOK_LATENCY_CNT fmok latency counter.
 *     DIS_CRC_CHK      Disable crc check.
 *     DIS_ECC_CHK      Disable ecc check.
 *     RESERVED_R       Reserved.
 *
 ******************************************************************************/
#define BCM6300_A0_RX_GLOBAL_CTLr 0x0000000a

#define BCM6300_A0_RX_GLOBAL_CTLr_SIZE 1

/*
 * This structure should be used to declare and program RX_GLOBAL_CTL.
 *
 */
typedef union BCM6300_A0_RX_GLOBAL_CTLr_s {
	uint32_t v[1];
	uint32_t rx_global_ctl[1];
	uint32_t _rx_global_ctl;
} BCM6300_A0_RX_GLOBAL_CTLr_t;

#define BCM6300_A0_RX_GLOBAL_CTLr_CLR(r) (r).rx_global_ctl[0] = 0
#define BCM6300_A0_RX_GLOBAL_CTLr_SET(r,d) (r).rx_global_ctl[0] = d
#define BCM6300_A0_RX_GLOBAL_CTLr_GET(r) (r).rx_global_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_RX_GLOBAL_CTLr_FMOK_LATENCY_CNTf_GET(r) (((r).rx_global_ctl[0]) & 0xf)
#define BCM6300_A0_RX_GLOBAL_CTLr_FMOK_LATENCY_CNTf_SET(r,f) (r).rx_global_ctl[0]=(((r).rx_global_ctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM6300_A0_RX_GLOBAL_CTLr_DIS_CRC_CHKf_GET(r) ((((r).rx_global_ctl[0]) >> 4) & 0x1)
#define BCM6300_A0_RX_GLOBAL_CTLr_DIS_CRC_CHKf_SET(r,f) (r).rx_global_ctl[0]=(((r).rx_global_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM6300_A0_RX_GLOBAL_CTLr_DIS_ECC_CHKf_GET(r) ((((r).rx_global_ctl[0]) >> 5) & 0x1)
#define BCM6300_A0_RX_GLOBAL_CTLr_DIS_ECC_CHKf_SET(r,f) (r).rx_global_ctl[0]=(((r).rx_global_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM6300_A0_RX_GLOBAL_CTLr_RESERVED_Rf_GET(r) ((((r).rx_global_ctl[0]) >> 6) & 0x3)
#define BCM6300_A0_RX_GLOBAL_CTLr_RESERVED_Rf_SET(r,f) (r).rx_global_ctl[0]=(((r).rx_global_ctl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access RX_GLOBAL_CTL.
 *
 */
#define BCM6300_A0_READ_RX_GLOBAL_CTLr(u,r) cdk_robo_reg_read(u,BCM6300_A0_RX_GLOBAL_CTLr,(r._rx_global_ctl),1)
#define BCM6300_A0_WRITE_RX_GLOBAL_CTLr(u,r) cdk_robo_reg_write(u,BCM6300_A0_RX_GLOBAL_CTLr,&(r._rx_global_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_GLOBAL_CTLr BCM6300_A0_RX_GLOBAL_CTLr
#define RX_GLOBAL_CTLr_SIZE BCM6300_A0_RX_GLOBAL_CTLr_SIZE
typedef BCM6300_A0_RX_GLOBAL_CTLr_t RX_GLOBAL_CTLr_t;
#define RX_GLOBAL_CTLr_CLR BCM6300_A0_RX_GLOBAL_CTLr_CLR
#define RX_GLOBAL_CTLr_SET BCM6300_A0_RX_GLOBAL_CTLr_SET
#define RX_GLOBAL_CTLr_GET BCM6300_A0_RX_GLOBAL_CTLr_GET
#define RX_GLOBAL_CTLr_FMOK_LATENCY_CNTf_GET BCM6300_A0_RX_GLOBAL_CTLr_FMOK_LATENCY_CNTf_GET
#define RX_GLOBAL_CTLr_FMOK_LATENCY_CNTf_SET BCM6300_A0_RX_GLOBAL_CTLr_FMOK_LATENCY_CNTf_SET
#define RX_GLOBAL_CTLr_DIS_CRC_CHKf_GET BCM6300_A0_RX_GLOBAL_CTLr_DIS_CRC_CHKf_GET
#define RX_GLOBAL_CTLr_DIS_CRC_CHKf_SET BCM6300_A0_RX_GLOBAL_CTLr_DIS_CRC_CHKf_SET
#define RX_GLOBAL_CTLr_DIS_ECC_CHKf_GET BCM6300_A0_RX_GLOBAL_CTLr_DIS_ECC_CHKf_GET
#define RX_GLOBAL_CTLr_DIS_ECC_CHKf_SET BCM6300_A0_RX_GLOBAL_CTLr_DIS_ECC_CHKf_SET
#define RX_GLOBAL_CTLr_RESERVED_Rf_GET BCM6300_A0_RX_GLOBAL_CTLr_RESERVED_Rf_GET
#define RX_GLOBAL_CTLr_RESERVED_Rf_SET BCM6300_A0_RX_GLOBAL_CTLr_RESERVED_Rf_SET
#define READ_RX_GLOBAL_CTLr BCM6300_A0_READ_RX_GLOBAL_CTLr
#define WRITE_RX_GLOBAL_CTLr BCM6300_A0_WRITE_RX_GLOBAL_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_RX_GLOBAL_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  RX_PAUSE_PASS
 * BLOCKS:   SYS
 * DESC:     Pause pass Through for RX Registrer
 * SIZE:     16
 * FIELDS:
 *     RX_PAUSE_PASS    RX pause pass through map.1 : ignore 802.3x.0 :comply with 802.3x pause frame receiving.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_RX_PAUSE_PASSr 0x00000038

#define BCM6300_A0_RX_PAUSE_PASSr_SIZE 2

/*
 * This structure should be used to declare and program RX_PAUSE_PASS.
 *
 */
typedef union BCM6300_A0_RX_PAUSE_PASSr_s {
	uint32_t v[1];
	uint32_t rx_pause_pass[1];
	uint32_t _rx_pause_pass;
} BCM6300_A0_RX_PAUSE_PASSr_t;

#define BCM6300_A0_RX_PAUSE_PASSr_CLR(r) (r).rx_pause_pass[0] = 0
#define BCM6300_A0_RX_PAUSE_PASSr_SET(r,d) (r).rx_pause_pass[0] = d
#define BCM6300_A0_RX_PAUSE_PASSr_GET(r) (r).rx_pause_pass[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_RX_PAUSE_PASSr_RX_PAUSE_PASSf_GET(r) (((r).rx_pause_pass[0]) & 0x1ff)
#define BCM6300_A0_RX_PAUSE_PASSr_RX_PAUSE_PASSf_SET(r,f) (r).rx_pause_pass[0]=(((r).rx_pause_pass[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_RX_PAUSE_PASSr_RESERVED_Rf_GET(r) ((((r).rx_pause_pass[0]) >> 9) & 0x7f)
#define BCM6300_A0_RX_PAUSE_PASSr_RESERVED_Rf_SET(r,f) (r).rx_pause_pass[0]=(((r).rx_pause_pass[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access RX_PAUSE_PASS.
 *
 */
#define BCM6300_A0_READ_RX_PAUSE_PASSr(u,r) cdk_robo_reg_read(u,BCM6300_A0_RX_PAUSE_PASSr,(r._rx_pause_pass),2)
#define BCM6300_A0_WRITE_RX_PAUSE_PASSr(u,r) cdk_robo_reg_write(u,BCM6300_A0_RX_PAUSE_PASSr,&(r._rx_pause_pass),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_PAUSE_PASSr BCM6300_A0_RX_PAUSE_PASSr
#define RX_PAUSE_PASSr_SIZE BCM6300_A0_RX_PAUSE_PASSr_SIZE
typedef BCM6300_A0_RX_PAUSE_PASSr_t RX_PAUSE_PASSr_t;
#define RX_PAUSE_PASSr_CLR BCM6300_A0_RX_PAUSE_PASSr_CLR
#define RX_PAUSE_PASSr_SET BCM6300_A0_RX_PAUSE_PASSr_SET
#define RX_PAUSE_PASSr_GET BCM6300_A0_RX_PAUSE_PASSr_GET
#define RX_PAUSE_PASSr_RX_PAUSE_PASSf_GET BCM6300_A0_RX_PAUSE_PASSr_RX_PAUSE_PASSf_GET
#define RX_PAUSE_PASSr_RX_PAUSE_PASSf_SET BCM6300_A0_RX_PAUSE_PASSr_RX_PAUSE_PASSf_SET
#define RX_PAUSE_PASSr_RESERVED_Rf_GET BCM6300_A0_RX_PAUSE_PASSr_RESERVED_Rf_GET
#define RX_PAUSE_PASSr_RESERVED_Rf_SET BCM6300_A0_RX_PAUSE_PASSr_RESERVED_Rf_SET
#define READ_RX_PAUSE_PASSr BCM6300_A0_READ_RX_PAUSE_PASSr
#define WRITE_RX_PAUSE_PASSr BCM6300_A0_WRITE_RX_PAUSE_PASSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_RX_PAUSE_PASSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  RxAlignmentErrors
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Alignment Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM6300_A0_RXALIGNMENTERRORSr 0x00002074

#define BCM6300_A0_RXALIGNMENTERRORSr_SIZE 4

/*
 * This structure should be used to declare and program RxAlignmentErrors.
 *
 */
typedef union BCM6300_A0_RXALIGNMENTERRORSr_s {
	uint32_t v[1];
	uint32_t rxalignmenterrors[1];
	uint32_t _rxalignmenterrors;
} BCM6300_A0_RXALIGNMENTERRORSr_t;

#define BCM6300_A0_RXALIGNMENTERRORSr_CLR(r) (r).rxalignmenterrors[0] = 0
#define BCM6300_A0_RXALIGNMENTERRORSr_SET(r,d) (r).rxalignmenterrors[0] = d
#define BCM6300_A0_RXALIGNMENTERRORSr_GET(r) (r).rxalignmenterrors[0]


/*
 * These macros can be used to access RxAlignmentErrors.
 *
 */
#define BCM6300_A0_READ_RXALIGNMENTERRORSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_RXALIGNMENTERRORSr,(r._rxalignmenterrors),4)
#define BCM6300_A0_WRITE_RXALIGNMENTERRORSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_RXALIGNMENTERRORSr,&(r._rxalignmenterrors),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXALIGNMENTERRORSr BCM6300_A0_RXALIGNMENTERRORSr
#define RXALIGNMENTERRORSr_SIZE BCM6300_A0_RXALIGNMENTERRORSr_SIZE
typedef BCM6300_A0_RXALIGNMENTERRORSr_t RXALIGNMENTERRORSr_t;
#define RXALIGNMENTERRORSr_CLR BCM6300_A0_RXALIGNMENTERRORSr_CLR
#define RXALIGNMENTERRORSr_SET BCM6300_A0_RXALIGNMENTERRORSr_SET
#define RXALIGNMENTERRORSr_GET BCM6300_A0_RXALIGNMENTERRORSr_GET
#define READ_RXALIGNMENTERRORSr BCM6300_A0_READ_RXALIGNMENTERRORSr
#define WRITE_RXALIGNMENTERRORSr BCM6300_A0_WRITE_RXALIGNMENTERRORSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_RXALIGNMENTERRORSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  RxBroadcastPkt
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Broadcast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM6300_A0_RXBROADCASTPKTr 0x00002090

#define BCM6300_A0_RXBROADCASTPKTr_SIZE 4

/*
 * This structure should be used to declare and program RxBroadcastPkt.
 *
 */
typedef union BCM6300_A0_RXBROADCASTPKTr_s {
	uint32_t v[1];
	uint32_t rxbroadcastpkt[1];
	uint32_t _rxbroadcastpkt;
} BCM6300_A0_RXBROADCASTPKTr_t;

#define BCM6300_A0_RXBROADCASTPKTr_CLR(r) (r).rxbroadcastpkt[0] = 0
#define BCM6300_A0_RXBROADCASTPKTr_SET(r,d) (r).rxbroadcastpkt[0] = d
#define BCM6300_A0_RXBROADCASTPKTr_GET(r) (r).rxbroadcastpkt[0]


/*
 * These macros can be used to access RxBroadcastPkt.
 *
 */
#define BCM6300_A0_READ_RXBROADCASTPKTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_RXBROADCASTPKTr,(r._rxbroadcastpkt),4)
#define BCM6300_A0_WRITE_RXBROADCASTPKTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_RXBROADCASTPKTr,&(r._rxbroadcastpkt),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXBROADCASTPKTr BCM6300_A0_RXBROADCASTPKTr
#define RXBROADCASTPKTr_SIZE BCM6300_A0_RXBROADCASTPKTr_SIZE
typedef BCM6300_A0_RXBROADCASTPKTr_t RXBROADCASTPKTr_t;
#define RXBROADCASTPKTr_CLR BCM6300_A0_RXBROADCASTPKTr_CLR
#define RXBROADCASTPKTr_SET BCM6300_A0_RXBROADCASTPKTr_SET
#define RXBROADCASTPKTr_GET BCM6300_A0_RXBROADCASTPKTr_GET
#define READ_RXBROADCASTPKTr BCM6300_A0_READ_RXBROADCASTPKTr
#define WRITE_RXBROADCASTPKTr BCM6300_A0_WRITE_RXBROADCASTPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_RXBROADCASTPKTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  RxDropPkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Drop Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM6300_A0_RXDROPPKTSr 0x00002084

#define BCM6300_A0_RXDROPPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxDropPkts.
 *
 */
typedef union BCM6300_A0_RXDROPPKTSr_s {
	uint32_t v[1];
	uint32_t rxdroppkts[1];
	uint32_t _rxdroppkts;
} BCM6300_A0_RXDROPPKTSr_t;

#define BCM6300_A0_RXDROPPKTSr_CLR(r) (r).rxdroppkts[0] = 0
#define BCM6300_A0_RXDROPPKTSr_SET(r,d) (r).rxdroppkts[0] = d
#define BCM6300_A0_RXDROPPKTSr_GET(r) (r).rxdroppkts[0]


/*
 * These macros can be used to access RxDropPkts.
 *
 */
#define BCM6300_A0_READ_RXDROPPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_RXDROPPKTSr,(r._rxdroppkts),4)
#define BCM6300_A0_WRITE_RXDROPPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_RXDROPPKTSr,&(r._rxdroppkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXDROPPKTSr BCM6300_A0_RXDROPPKTSr
#define RXDROPPKTSr_SIZE BCM6300_A0_RXDROPPKTSr_SIZE
typedef BCM6300_A0_RXDROPPKTSr_t RXDROPPKTSr_t;
#define RXDROPPKTSr_CLR BCM6300_A0_RXDROPPKTSr_CLR
#define RXDROPPKTSr_SET BCM6300_A0_RXDROPPKTSr_SET
#define RXDROPPKTSr_GET BCM6300_A0_RXDROPPKTSr_GET
#define READ_RXDROPPKTSr BCM6300_A0_READ_RXDROPPKTSr
#define WRITE_RXDROPPKTSr BCM6300_A0_WRITE_RXDROPPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_RXDROPPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  RxExcessSizeDisc
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Excess Size Disc Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM6300_A0_RXEXCESSSIZEDISCr 0x0000209c

#define BCM6300_A0_RXEXCESSSIZEDISCr_SIZE 4

/*
 * This structure should be used to declare and program RxExcessSizeDisc.
 *
 */
typedef union BCM6300_A0_RXEXCESSSIZEDISCr_s {
	uint32_t v[1];
	uint32_t rxexcesssizedisc[1];
	uint32_t _rxexcesssizedisc;
} BCM6300_A0_RXEXCESSSIZEDISCr_t;

#define BCM6300_A0_RXEXCESSSIZEDISCr_CLR(r) (r).rxexcesssizedisc[0] = 0
#define BCM6300_A0_RXEXCESSSIZEDISCr_SET(r,d) (r).rxexcesssizedisc[0] = d
#define BCM6300_A0_RXEXCESSSIZEDISCr_GET(r) (r).rxexcesssizedisc[0]


/*
 * These macros can be used to access RxExcessSizeDisc.
 *
 */
#define BCM6300_A0_READ_RXEXCESSSIZEDISCr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_RXEXCESSSIZEDISCr,(r._rxexcesssizedisc),4)
#define BCM6300_A0_WRITE_RXEXCESSSIZEDISCr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_RXEXCESSSIZEDISCr,&(r._rxexcesssizedisc),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXEXCESSSIZEDISCr BCM6300_A0_RXEXCESSSIZEDISCr
#define RXEXCESSSIZEDISCr_SIZE BCM6300_A0_RXEXCESSSIZEDISCr_SIZE
typedef BCM6300_A0_RXEXCESSSIZEDISCr_t RXEXCESSSIZEDISCr_t;
#define RXEXCESSSIZEDISCr_CLR BCM6300_A0_RXEXCESSSIZEDISCr_CLR
#define RXEXCESSSIZEDISCr_SET BCM6300_A0_RXEXCESSSIZEDISCr_SET
#define RXEXCESSSIZEDISCr_GET BCM6300_A0_RXEXCESSSIZEDISCr_GET
#define READ_RXEXCESSSIZEDISCr BCM6300_A0_READ_RXEXCESSSIZEDISCr
#define WRITE_RXEXCESSSIZEDISCr BCM6300_A0_WRITE_RXEXCESSSIZEDISCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_RXEXCESSSIZEDISCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  RxFCSErrors
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx FCS Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM6300_A0_RXFCSERRORSr 0x00002078

#define BCM6300_A0_RXFCSERRORSr_SIZE 4

/*
 * This structure should be used to declare and program RxFCSErrors.
 *
 */
typedef union BCM6300_A0_RXFCSERRORSr_s {
	uint32_t v[1];
	uint32_t rxfcserrors[1];
	uint32_t _rxfcserrors;
} BCM6300_A0_RXFCSERRORSr_t;

#define BCM6300_A0_RXFCSERRORSr_CLR(r) (r).rxfcserrors[0] = 0
#define BCM6300_A0_RXFCSERRORSr_SET(r,d) (r).rxfcserrors[0] = d
#define BCM6300_A0_RXFCSERRORSr_GET(r) (r).rxfcserrors[0]


/*
 * These macros can be used to access RxFCSErrors.
 *
 */
#define BCM6300_A0_READ_RXFCSERRORSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_RXFCSERRORSr,(r._rxfcserrors),4)
#define BCM6300_A0_WRITE_RXFCSERRORSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_RXFCSERRORSr,&(r._rxfcserrors),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXFCSERRORSr BCM6300_A0_RXFCSERRORSr
#define RXFCSERRORSr_SIZE BCM6300_A0_RXFCSERRORSr_SIZE
typedef BCM6300_A0_RXFCSERRORSr_t RXFCSERRORSr_t;
#define RXFCSERRORSr_CLR BCM6300_A0_RXFCSERRORSr_CLR
#define RXFCSERRORSr_SET BCM6300_A0_RXFCSERRORSr_SET
#define RXFCSERRORSr_GET BCM6300_A0_RXFCSERRORSr_GET
#define READ_RXFCSERRORSr BCM6300_A0_READ_RXFCSERRORSr
#define WRITE_RXFCSERRORSr BCM6300_A0_WRITE_RXFCSERRORSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_RXFCSERRORSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  RxFragments
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Fragment Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM6300_A0_RXFRAGMENTSr 0x00002098

#define BCM6300_A0_RXFRAGMENTSr_SIZE 4

/*
 * This structure should be used to declare and program RxFragments.
 *
 */
typedef union BCM6300_A0_RXFRAGMENTSr_s {
	uint32_t v[1];
	uint32_t rxfragments[1];
	uint32_t _rxfragments;
} BCM6300_A0_RXFRAGMENTSr_t;

#define BCM6300_A0_RXFRAGMENTSr_CLR(r) (r).rxfragments[0] = 0
#define BCM6300_A0_RXFRAGMENTSr_SET(r,d) (r).rxfragments[0] = d
#define BCM6300_A0_RXFRAGMENTSr_GET(r) (r).rxfragments[0]


/*
 * These macros can be used to access RxFragments.
 *
 */
#define BCM6300_A0_READ_RXFRAGMENTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_RXFRAGMENTSr,(r._rxfragments),4)
#define BCM6300_A0_WRITE_RXFRAGMENTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_RXFRAGMENTSr,&(r._rxfragments),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXFRAGMENTSr BCM6300_A0_RXFRAGMENTSr
#define RXFRAGMENTSr_SIZE BCM6300_A0_RXFRAGMENTSr_SIZE
typedef BCM6300_A0_RXFRAGMENTSr_t RXFRAGMENTSr_t;
#define RXFRAGMENTSr_CLR BCM6300_A0_RXFRAGMENTSr_CLR
#define RXFRAGMENTSr_SET BCM6300_A0_RXFRAGMENTSr_SET
#define RXFRAGMENTSr_GET BCM6300_A0_RXFRAGMENTSr_GET
#define READ_RXFRAGMENTSr BCM6300_A0_READ_RXFRAGMENTSr
#define WRITE_RXFRAGMENTSr BCM6300_A0_WRITE_RXFRAGMENTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_RXFRAGMENTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  RxGoodOctets
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Good Packet Octet Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM6300_A0_RXGOODOCTETSr 0x0000207c

#define BCM6300_A0_RXGOODOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program RxGoodOctets.
 *
 */
typedef union BCM6300_A0_RXGOODOCTETSr_s {
	uint32_t v[2];
	uint32_t rxgoodoctets[2];
	uint32_t _rxgoodoctets;
} BCM6300_A0_RXGOODOCTETSr_t;

#define BCM6300_A0_RXGOODOCTETSr_CLR(r) CDK_MEMSET(&((r)._rxgoodoctets), 0, sizeof(BCM6300_A0_RXGOODOCTETSr_t))
#define BCM6300_A0_RXGOODOCTETSr_SET(r,i,d) (r).rxgoodoctets[i] = d
#define BCM6300_A0_RXGOODOCTETSr_GET(r,i) (r).rxgoodoctets[i]


/*
 * These macros can be used to access RxGoodOctets.
 *
 */
#define BCM6300_A0_READ_RXGOODOCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_RXGOODOCTETSr,(r._rxgoodoctets),8)
#define BCM6300_A0_WRITE_RXGOODOCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_RXGOODOCTETSr,&(r._rxgoodoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXGOODOCTETSr BCM6300_A0_RXGOODOCTETSr
#define RXGOODOCTETSr_SIZE BCM6300_A0_RXGOODOCTETSr_SIZE
typedef BCM6300_A0_RXGOODOCTETSr_t RXGOODOCTETSr_t;
#define RXGOODOCTETSr_CLR BCM6300_A0_RXGOODOCTETSr_CLR
#define RXGOODOCTETSr_SET BCM6300_A0_RXGOODOCTETSr_SET
#define RXGOODOCTETSr_GET BCM6300_A0_RXGOODOCTETSr_GET
#define READ_RXGOODOCTETSr BCM6300_A0_READ_RXGOODOCTETSr
#define WRITE_RXGOODOCTETSr BCM6300_A0_WRITE_RXGOODOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_RXGOODOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  RxJabbers
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Jabber Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM6300_A0_RXJABBERSr 0x00002070

#define BCM6300_A0_RXJABBERSr_SIZE 4

/*
 * This structure should be used to declare and program RxJabbers.
 *
 */
typedef union BCM6300_A0_RXJABBERSr_s {
	uint32_t v[1];
	uint32_t rxjabbers[1];
	uint32_t _rxjabbers;
} BCM6300_A0_RXJABBERSr_t;

#define BCM6300_A0_RXJABBERSr_CLR(r) (r).rxjabbers[0] = 0
#define BCM6300_A0_RXJABBERSr_SET(r,d) (r).rxjabbers[0] = d
#define BCM6300_A0_RXJABBERSr_GET(r) (r).rxjabbers[0]


/*
 * These macros can be used to access RxJabbers.
 *
 */
#define BCM6300_A0_READ_RXJABBERSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_RXJABBERSr,(r._rxjabbers),4)
#define BCM6300_A0_WRITE_RXJABBERSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_RXJABBERSr,&(r._rxjabbers),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXJABBERSr BCM6300_A0_RXJABBERSr
#define RXJABBERSr_SIZE BCM6300_A0_RXJABBERSr_SIZE
typedef BCM6300_A0_RXJABBERSr_t RXJABBERSr_t;
#define RXJABBERSr_CLR BCM6300_A0_RXJABBERSr_CLR
#define RXJABBERSr_SET BCM6300_A0_RXJABBERSr_SET
#define RXJABBERSr_GET BCM6300_A0_RXJABBERSr_GET
#define READ_RXJABBERSr BCM6300_A0_READ_RXJABBERSr
#define WRITE_RXJABBERSr BCM6300_A0_WRITE_RXJABBERSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_RXJABBERSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  RxMulticastPkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Multicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM6300_A0_RXMULTICASTPKTSr 0x0000208c

#define BCM6300_A0_RXMULTICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxMulticastPkts.
 *
 */
typedef union BCM6300_A0_RXMULTICASTPKTSr_s {
	uint32_t v[1];
	uint32_t rxmulticastpkts[1];
	uint32_t _rxmulticastpkts;
} BCM6300_A0_RXMULTICASTPKTSr_t;

#define BCM6300_A0_RXMULTICASTPKTSr_CLR(r) (r).rxmulticastpkts[0] = 0
#define BCM6300_A0_RXMULTICASTPKTSr_SET(r,d) (r).rxmulticastpkts[0] = d
#define BCM6300_A0_RXMULTICASTPKTSr_GET(r) (r).rxmulticastpkts[0]


/*
 * These macros can be used to access RxMulticastPkts.
 *
 */
#define BCM6300_A0_READ_RXMULTICASTPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_RXMULTICASTPKTSr,(r._rxmulticastpkts),4)
#define BCM6300_A0_WRITE_RXMULTICASTPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_RXMULTICASTPKTSr,&(r._rxmulticastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXMULTICASTPKTSr BCM6300_A0_RXMULTICASTPKTSr
#define RXMULTICASTPKTSr_SIZE BCM6300_A0_RXMULTICASTPKTSr_SIZE
typedef BCM6300_A0_RXMULTICASTPKTSr_t RXMULTICASTPKTSr_t;
#define RXMULTICASTPKTSr_CLR BCM6300_A0_RXMULTICASTPKTSr_CLR
#define RXMULTICASTPKTSr_SET BCM6300_A0_RXMULTICASTPKTSr_SET
#define RXMULTICASTPKTSr_GET BCM6300_A0_RXMULTICASTPKTSr_GET
#define READ_RXMULTICASTPKTSr BCM6300_A0_READ_RXMULTICASTPKTSr
#define WRITE_RXMULTICASTPKTSr BCM6300_A0_WRITE_RXMULTICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_RXMULTICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  RxOctets
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Packet Octets Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM6300_A0_RXOCTETSr 0x00002044

#define BCM6300_A0_RXOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program RxOctets.
 *
 */
typedef union BCM6300_A0_RXOCTETSr_s {
	uint32_t v[2];
	uint32_t rxoctets[2];
	uint32_t _rxoctets;
} BCM6300_A0_RXOCTETSr_t;

#define BCM6300_A0_RXOCTETSr_CLR(r) CDK_MEMSET(&((r)._rxoctets), 0, sizeof(BCM6300_A0_RXOCTETSr_t))
#define BCM6300_A0_RXOCTETSr_SET(r,i,d) (r).rxoctets[i] = d
#define BCM6300_A0_RXOCTETSr_GET(r,i) (r).rxoctets[i]


/*
 * These macros can be used to access RxOctets.
 *
 */
#define BCM6300_A0_READ_RXOCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_RXOCTETSr,(r._rxoctets),8)
#define BCM6300_A0_WRITE_RXOCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_RXOCTETSr,&(r._rxoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXOCTETSr BCM6300_A0_RXOCTETSr
#define RXOCTETSr_SIZE BCM6300_A0_RXOCTETSr_SIZE
typedef BCM6300_A0_RXOCTETSr_t RXOCTETSr_t;
#define RXOCTETSr_CLR BCM6300_A0_RXOCTETSr_CLR
#define RXOCTETSr_SET BCM6300_A0_RXOCTETSr_SET
#define RXOCTETSr_GET BCM6300_A0_RXOCTETSr_GET
#define READ_RXOCTETSr BCM6300_A0_READ_RXOCTETSr
#define WRITE_RXOCTETSr BCM6300_A0_WRITE_RXOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_RXOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  RxOversizePkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Over Size Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM6300_A0_RXOVERSIZEPKTSr 0x0000206c

#define BCM6300_A0_RXOVERSIZEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxOversizePkts.
 *
 */
typedef union BCM6300_A0_RXOVERSIZEPKTSr_s {
	uint32_t v[1];
	uint32_t rxoversizepkts[1];
	uint32_t _rxoversizepkts;
} BCM6300_A0_RXOVERSIZEPKTSr_t;

#define BCM6300_A0_RXOVERSIZEPKTSr_CLR(r) (r).rxoversizepkts[0] = 0
#define BCM6300_A0_RXOVERSIZEPKTSr_SET(r,d) (r).rxoversizepkts[0] = d
#define BCM6300_A0_RXOVERSIZEPKTSr_GET(r) (r).rxoversizepkts[0]


/*
 * These macros can be used to access RxOversizePkts.
 *
 */
#define BCM6300_A0_READ_RXOVERSIZEPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_RXOVERSIZEPKTSr,(r._rxoversizepkts),4)
#define BCM6300_A0_WRITE_RXOVERSIZEPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_RXOVERSIZEPKTSr,&(r._rxoversizepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXOVERSIZEPKTSr BCM6300_A0_RXOVERSIZEPKTSr
#define RXOVERSIZEPKTSr_SIZE BCM6300_A0_RXOVERSIZEPKTSr_SIZE
typedef BCM6300_A0_RXOVERSIZEPKTSr_t RXOVERSIZEPKTSr_t;
#define RXOVERSIZEPKTSr_CLR BCM6300_A0_RXOVERSIZEPKTSr_CLR
#define RXOVERSIZEPKTSr_SET BCM6300_A0_RXOVERSIZEPKTSr_SET
#define RXOVERSIZEPKTSr_GET BCM6300_A0_RXOVERSIZEPKTSr_GET
#define READ_RXOVERSIZEPKTSr BCM6300_A0_READ_RXOVERSIZEPKTSr
#define WRITE_RXOVERSIZEPKTSr BCM6300_A0_WRITE_RXOVERSIZEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_RXOVERSIZEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  RxPausePkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Pause Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM6300_A0_RXPAUSEPKTSr 0x00002050

#define BCM6300_A0_RXPAUSEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxPausePkts.
 *
 */
typedef union BCM6300_A0_RXPAUSEPKTSr_s {
	uint32_t v[1];
	uint32_t rxpausepkts[1];
	uint32_t _rxpausepkts;
} BCM6300_A0_RXPAUSEPKTSr_t;

#define BCM6300_A0_RXPAUSEPKTSr_CLR(r) (r).rxpausepkts[0] = 0
#define BCM6300_A0_RXPAUSEPKTSr_SET(r,d) (r).rxpausepkts[0] = d
#define BCM6300_A0_RXPAUSEPKTSr_GET(r) (r).rxpausepkts[0]


/*
 * These macros can be used to access RxPausePkts.
 *
 */
#define BCM6300_A0_READ_RXPAUSEPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_RXPAUSEPKTSr,(r._rxpausepkts),4)
#define BCM6300_A0_WRITE_RXPAUSEPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_RXPAUSEPKTSr,&(r._rxpausepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXPAUSEPKTSr BCM6300_A0_RXPAUSEPKTSr
#define RXPAUSEPKTSr_SIZE BCM6300_A0_RXPAUSEPKTSr_SIZE
typedef BCM6300_A0_RXPAUSEPKTSr_t RXPAUSEPKTSr_t;
#define RXPAUSEPKTSr_CLR BCM6300_A0_RXPAUSEPKTSr_CLR
#define RXPAUSEPKTSr_SET BCM6300_A0_RXPAUSEPKTSr_SET
#define RXPAUSEPKTSr_GET BCM6300_A0_RXPAUSEPKTSr_GET
#define READ_RXPAUSEPKTSr BCM6300_A0_READ_RXPAUSEPKTSr
#define WRITE_RXPAUSEPKTSr BCM6300_A0_WRITE_RXPAUSEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_RXPAUSEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  RxQoSOctets
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx QoS Packet Octet Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM6300_A0_RXQOSOCTETSr 0x000020a8

#define BCM6300_A0_RXQOSOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program RxQoSOctets.
 *
 */
typedef union BCM6300_A0_RXQOSOCTETSr_s {
	uint32_t v[2];
	uint32_t rxqosoctets[2];
	uint32_t _rxqosoctets;
} BCM6300_A0_RXQOSOCTETSr_t;

#define BCM6300_A0_RXQOSOCTETSr_CLR(r) CDK_MEMSET(&((r)._rxqosoctets), 0, sizeof(BCM6300_A0_RXQOSOCTETSr_t))
#define BCM6300_A0_RXQOSOCTETSr_SET(r,i,d) (r).rxqosoctets[i] = d
#define BCM6300_A0_RXQOSOCTETSr_GET(r,i) (r).rxqosoctets[i]


/*
 * These macros can be used to access RxQoSOctets.
 *
 */
#define BCM6300_A0_READ_RXQOSOCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_RXQOSOCTETSr,(r._rxqosoctets),8)
#define BCM6300_A0_WRITE_RXQOSOCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_RXQOSOCTETSr,&(r._rxqosoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXQOSOCTETSr BCM6300_A0_RXQOSOCTETSr
#define RXQOSOCTETSr_SIZE BCM6300_A0_RXQOSOCTETSr_SIZE
typedef BCM6300_A0_RXQOSOCTETSr_t RXQOSOCTETSr_t;
#define RXQOSOCTETSr_CLR BCM6300_A0_RXQOSOCTETSr_CLR
#define RXQOSOCTETSr_SET BCM6300_A0_RXQOSOCTETSr_SET
#define RXQOSOCTETSr_GET BCM6300_A0_RXQOSOCTETSr_GET
#define READ_RXQOSOCTETSr BCM6300_A0_READ_RXQOSOCTETSr
#define WRITE_RXQOSOCTETSr BCM6300_A0_WRITE_RXQOSOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_RXQOSOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  RxQoSPkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx QoS Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM6300_A0_RXQOSPKTSr 0x000020a4

#define BCM6300_A0_RXQOSPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxQoSPkts.
 *
 */
typedef union BCM6300_A0_RXQOSPKTSr_s {
	uint32_t v[1];
	uint32_t rxqospkts[1];
	uint32_t _rxqospkts;
} BCM6300_A0_RXQOSPKTSr_t;

#define BCM6300_A0_RXQOSPKTSr_CLR(r) (r).rxqospkts[0] = 0
#define BCM6300_A0_RXQOSPKTSr_SET(r,d) (r).rxqospkts[0] = d
#define BCM6300_A0_RXQOSPKTSr_GET(r) (r).rxqospkts[0]


/*
 * These macros can be used to access RxQoSPkts.
 *
 */
#define BCM6300_A0_READ_RXQOSPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_RXQOSPKTSr,(r._rxqospkts),4)
#define BCM6300_A0_WRITE_RXQOSPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_RXQOSPKTSr,&(r._rxqospkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXQOSPKTSr BCM6300_A0_RXQOSPKTSr
#define RXQOSPKTSr_SIZE BCM6300_A0_RXQOSPKTSr_SIZE
typedef BCM6300_A0_RXQOSPKTSr_t RXQOSPKTSr_t;
#define RXQOSPKTSr_CLR BCM6300_A0_RXQOSPKTSr_CLR
#define RXQOSPKTSr_SET BCM6300_A0_RXQOSPKTSr_SET
#define RXQOSPKTSr_GET BCM6300_A0_RXQOSPKTSr_GET
#define READ_RXQOSPKTSr BCM6300_A0_READ_RXQOSPKTSr
#define WRITE_RXQOSPKTSr BCM6300_A0_WRITE_RXQOSPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_RXQOSPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  RxSAChanges
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx SA Change Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM6300_A0_RXSACHANGESr 0x00002094

#define BCM6300_A0_RXSACHANGESr_SIZE 4

/*
 * This structure should be used to declare and program RxSAChanges.
 *
 */
typedef union BCM6300_A0_RXSACHANGESr_s {
	uint32_t v[1];
	uint32_t rxsachanges[1];
	uint32_t _rxsachanges;
} BCM6300_A0_RXSACHANGESr_t;

#define BCM6300_A0_RXSACHANGESr_CLR(r) (r).rxsachanges[0] = 0
#define BCM6300_A0_RXSACHANGESr_SET(r,d) (r).rxsachanges[0] = d
#define BCM6300_A0_RXSACHANGESr_GET(r) (r).rxsachanges[0]


/*
 * These macros can be used to access RxSAChanges.
 *
 */
#define BCM6300_A0_READ_RXSACHANGESr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_RXSACHANGESr,(r._rxsachanges),4)
#define BCM6300_A0_WRITE_RXSACHANGESr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_RXSACHANGESr,&(r._rxsachanges),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXSACHANGESr BCM6300_A0_RXSACHANGESr
#define RXSACHANGESr_SIZE BCM6300_A0_RXSACHANGESr_SIZE
typedef BCM6300_A0_RXSACHANGESr_t RXSACHANGESr_t;
#define RXSACHANGESr_CLR BCM6300_A0_RXSACHANGESr_CLR
#define RXSACHANGESr_SET BCM6300_A0_RXSACHANGESr_SET
#define RXSACHANGESr_GET BCM6300_A0_RXSACHANGESr_GET
#define READ_RXSACHANGESr BCM6300_A0_READ_RXSACHANGESr
#define WRITE_RXSACHANGESr BCM6300_A0_WRITE_RXSACHANGESr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_RXSACHANGESr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  RxUndersizePkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Under Size Packet Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM6300_A0_RXUNDERSIZEPKTSr 0x0000204c

#define BCM6300_A0_RXUNDERSIZEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxUndersizePkts.
 *
 */
typedef union BCM6300_A0_RXUNDERSIZEPKTSr_s {
	uint32_t v[1];
	uint32_t rxundersizepkts[1];
	uint32_t _rxundersizepkts;
} BCM6300_A0_RXUNDERSIZEPKTSr_t;

#define BCM6300_A0_RXUNDERSIZEPKTSr_CLR(r) (r).rxundersizepkts[0] = 0
#define BCM6300_A0_RXUNDERSIZEPKTSr_SET(r,d) (r).rxundersizepkts[0] = d
#define BCM6300_A0_RXUNDERSIZEPKTSr_GET(r) (r).rxundersizepkts[0]


/*
 * These macros can be used to access RxUndersizePkts.
 *
 */
#define BCM6300_A0_READ_RXUNDERSIZEPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_RXUNDERSIZEPKTSr,(r._rxundersizepkts),4)
#define BCM6300_A0_WRITE_RXUNDERSIZEPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_RXUNDERSIZEPKTSr,&(r._rxundersizepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXUNDERSIZEPKTSr BCM6300_A0_RXUNDERSIZEPKTSr
#define RXUNDERSIZEPKTSr_SIZE BCM6300_A0_RXUNDERSIZEPKTSr_SIZE
typedef BCM6300_A0_RXUNDERSIZEPKTSr_t RXUNDERSIZEPKTSr_t;
#define RXUNDERSIZEPKTSr_CLR BCM6300_A0_RXUNDERSIZEPKTSr_CLR
#define RXUNDERSIZEPKTSr_SET BCM6300_A0_RXUNDERSIZEPKTSr_SET
#define RXUNDERSIZEPKTSr_GET BCM6300_A0_RXUNDERSIZEPKTSr_GET
#define READ_RXUNDERSIZEPKTSr BCM6300_A0_READ_RXUNDERSIZEPKTSr
#define WRITE_RXUNDERSIZEPKTSr BCM6300_A0_WRITE_RXUNDERSIZEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_RXUNDERSIZEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  RxUnicastPkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Rx Unicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM6300_A0_RXUNICASTPKTSr 0x00002088

#define BCM6300_A0_RXUNICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxUnicastPkts.
 *
 */
typedef union BCM6300_A0_RXUNICASTPKTSr_s {
	uint32_t v[1];
	uint32_t rxunicastpkts[1];
	uint32_t _rxunicastpkts;
} BCM6300_A0_RXUNICASTPKTSr_t;

#define BCM6300_A0_RXUNICASTPKTSr_CLR(r) (r).rxunicastpkts[0] = 0
#define BCM6300_A0_RXUNICASTPKTSr_SET(r,d) (r).rxunicastpkts[0] = d
#define BCM6300_A0_RXUNICASTPKTSr_GET(r) (r).rxunicastpkts[0]


/*
 * These macros can be used to access RxUnicastPkts.
 *
 */
#define BCM6300_A0_READ_RXUNICASTPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_RXUNICASTPKTSr,(r._rxunicastpkts),4)
#define BCM6300_A0_WRITE_RXUNICASTPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_RXUNICASTPKTSr,&(r._rxunicastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXUNICASTPKTSr BCM6300_A0_RXUNICASTPKTSr
#define RXUNICASTPKTSr_SIZE BCM6300_A0_RXUNICASTPKTSr_SIZE
typedef BCM6300_A0_RXUNICASTPKTSr_t RXUNICASTPKTSr_t;
#define RXUNICASTPKTSr_CLR BCM6300_A0_RXUNICASTPKTSr_CLR
#define RXUNICASTPKTSr_SET BCM6300_A0_RXUNICASTPKTSr_SET
#define RXUNICASTPKTSr_GET BCM6300_A0_RXUNICASTPKTSr_GET
#define READ_RXUNICASTPKTSr BCM6300_A0_READ_RXUNICASTPKTSr
#define WRITE_RXUNICASTPKTSr BCM6300_A0_WRITE_RXUNICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_RXUNICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * SWFORMAT:  SOFTWARE_BLOCKMAP
 * BLOCKS:  
 * DESC:     Software Blockmap
 * SIZE:     5
 * FIELDS:
 *     SYS              Software Block Flag for SYS
 *     EXP              Software Block Flag for EXP
 *     GPIC             Software Block Flag for GPIC
 *     CPIC             Software Block Flag for CPIC
 *     SPI              Software Block Flag for SPI
 *
 ******************************************************************************/
#define BCM6300_A0_SOFTWARE_BLOCKMAP 0x00000000

#define BCM6300_A0_SOFTWARE_BLOCKMAP_SIZE 1

/*
 * This structure should be used to declare and program SOFTWARE_BLOCKMAP.
 *
 */
typedef union BCM6300_A0_SOFTWARE_BLOCKMAP_s {
	uint32_t v[1];
	uint32_t software_blockmap[1];
	uint32_t _software_blockmap;
} BCM6300_A0_SOFTWARE_BLOCKMAP_t;

#define BCM6300_A0_SOFTWARE_BLOCKMAP_CLR(r) (r).software_blockmap[0] = 0
#define BCM6300_A0_SOFTWARE_BLOCKMAP_SET(r,d) (r).software_blockmap[0] = d
#define BCM6300_A0_SOFTWARE_BLOCKMAP_GET(r) (r).software_blockmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_SOFTWARE_BLOCKMAP_SYSf_GET(r) (((r).software_blockmap[0]) & 0x1)
#define BCM6300_A0_SOFTWARE_BLOCKMAP_SYSf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM6300_A0_SOFTWARE_BLOCKMAP_EXPf_GET(r) ((((r).software_blockmap[0]) >> 1) & 0x1)
#define BCM6300_A0_SOFTWARE_BLOCKMAP_EXPf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM6300_A0_SOFTWARE_BLOCKMAP_GPICf_GET(r) ((((r).software_blockmap[0]) >> 2) & 0x1)
#define BCM6300_A0_SOFTWARE_BLOCKMAP_GPICf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM6300_A0_SOFTWARE_BLOCKMAP_CPICf_GET(r) ((((r).software_blockmap[0]) >> 3) & 0x1)
#define BCM6300_A0_SOFTWARE_BLOCKMAP_CPICf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM6300_A0_SOFTWARE_BLOCKMAP_SPIf_GET(r) ((((r).software_blockmap[0]) >> 4) & 0x1)
#define BCM6300_A0_SOFTWARE_BLOCKMAP_SPIf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SOFTWARE_BLOCKMAP BCM6300_A0_SOFTWARE_BLOCKMAP
#define SOFTWARE_BLOCKMAP_SIZE BCM6300_A0_SOFTWARE_BLOCKMAP_SIZE
typedef BCM6300_A0_SOFTWARE_BLOCKMAP_t SOFTWARE_BLOCKMAP_t;
#define SOFTWARE_BLOCKMAP_CLR BCM6300_A0_SOFTWARE_BLOCKMAP_CLR
#define SOFTWARE_BLOCKMAP_SET BCM6300_A0_SOFTWARE_BLOCKMAP_SET
#define SOFTWARE_BLOCKMAP_GET BCM6300_A0_SOFTWARE_BLOCKMAP_GET
#define SOFTWARE_BLOCKMAP_SYSf_GET BCM6300_A0_SOFTWARE_BLOCKMAP_SYSf_GET
#define SOFTWARE_BLOCKMAP_SYSf_SET BCM6300_A0_SOFTWARE_BLOCKMAP_SYSf_SET
#define SOFTWARE_BLOCKMAP_EXPf_GET BCM6300_A0_SOFTWARE_BLOCKMAP_EXPf_GET
#define SOFTWARE_BLOCKMAP_EXPf_SET BCM6300_A0_SOFTWARE_BLOCKMAP_EXPf_SET
#define SOFTWARE_BLOCKMAP_GPICf_GET BCM6300_A0_SOFTWARE_BLOCKMAP_GPICf_GET
#define SOFTWARE_BLOCKMAP_GPICf_SET BCM6300_A0_SOFTWARE_BLOCKMAP_GPICf_SET
#define SOFTWARE_BLOCKMAP_CPICf_GET BCM6300_A0_SOFTWARE_BLOCKMAP_CPICf_GET
#define SOFTWARE_BLOCKMAP_CPICf_SET BCM6300_A0_SOFTWARE_BLOCKMAP_CPICf_SET
#define SOFTWARE_BLOCKMAP_SPIf_GET BCM6300_A0_SOFTWARE_BLOCKMAP_SPIf_GET
#define SOFTWARE_BLOCKMAP_SPIf_SET BCM6300_A0_SOFTWARE_BLOCKMAP_SPIf_SET
#define READ_SOFTWARE_BLOCKMAP BCM6300_A0_READ_SOFTWARE_BLOCKMAP
#define WRITE_SOFTWARE_BLOCKMAP BCM6300_A0_WRITE_SOFTWARE_BLOCKMAP

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_SOFTWARE_BLOCKMAP'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  SPDSTS
 * BLOCKS:   SYS
 * DESC:     Port Speed Summary Register
 * SIZE:     32
 * FIELDS:
 *     PORT_SPD         Port Speed.18 bit field indicating the operating speed for each 10/100/1000BASE-T port.Bit 15:0 = Port 7 - Port 0(Bit [1:0] for Port 0, Bit [15:14] for Port 7 and Bit [17:16] for IMP port).00 = 10 Mb/s01 = 100 Mb/s10 = 1000 Mb/s
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_SPDSTSr 0x00000104

#define BCM6300_A0_SPDSTSr_SIZE 4

/*
 * This structure should be used to declare and program SPDSTS.
 *
 */
typedef union BCM6300_A0_SPDSTSr_s {
	uint32_t v[1];
	uint32_t spdsts[1];
	uint32_t _spdsts;
} BCM6300_A0_SPDSTSr_t;

#define BCM6300_A0_SPDSTSr_CLR(r) (r).spdsts[0] = 0
#define BCM6300_A0_SPDSTSr_SET(r,d) (r).spdsts[0] = d
#define BCM6300_A0_SPDSTSr_GET(r) (r).spdsts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_SPDSTSr_PORT_SPDf_GET(r) (((r).spdsts[0]) & 0x3ffff)
#define BCM6300_A0_SPDSTSr_PORT_SPDf_SET(r,f) (r).spdsts[0]=(((r).spdsts[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))
#define BCM6300_A0_SPDSTSr_RESERVED_Rf_GET(r) ((((r).spdsts[0]) >> 18) & 0x3fff)
#define BCM6300_A0_SPDSTSr_RESERVED_Rf_SET(r,f) (r).spdsts[0]=(((r).spdsts[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access SPDSTS.
 *
 */
#define BCM6300_A0_READ_SPDSTSr(u,r) cdk_robo_reg_read(u,BCM6300_A0_SPDSTSr,(r._spdsts),4)
#define BCM6300_A0_WRITE_SPDSTSr(u,r) cdk_robo_reg_write(u,BCM6300_A0_SPDSTSr,&(r._spdsts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPDSTSr BCM6300_A0_SPDSTSr
#define SPDSTSr_SIZE BCM6300_A0_SPDSTSr_SIZE
typedef BCM6300_A0_SPDSTSr_t SPDSTSr_t;
#define SPDSTSr_CLR BCM6300_A0_SPDSTSr_CLR
#define SPDSTSr_SET BCM6300_A0_SPDSTSr_SET
#define SPDSTSr_GET BCM6300_A0_SPDSTSr_GET
#define SPDSTSr_PORT_SPDf_GET BCM6300_A0_SPDSTSr_PORT_SPDf_GET
#define SPDSTSr_PORT_SPDf_SET BCM6300_A0_SPDSTSr_PORT_SPDf_SET
#define SPDSTSr_RESERVED_Rf_GET BCM6300_A0_SPDSTSr_RESERVED_Rf_GET
#define SPDSTSr_RESERVED_Rf_SET BCM6300_A0_SPDSTSr_RESERVED_Rf_SET
#define READ_SPDSTSr BCM6300_A0_READ_SPDSTSr
#define WRITE_SPDSTSr BCM6300_A0_WRITE_SPDSTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_SPDSTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  SPTAGT
 * BLOCKS:   SYS
 * DESC:     Aging Time Control Register
 * SIZE:     32
 * FIELDS:
 *     AGE_TIME         Specifies the aging time in seconds for dynamicallylearned address. Maximum age time is 1,048,575 s. Note that while 802.1D specifies a range of values of 10 - 1,000,000 s, this register does not enforce this range. Setting the AGE_TIME to zero disables the aging process.
 *     AGE_CHANGE_EN    Set 1 to Change Aging Timer by AGE_TIME[19:0].
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_SPTAGTr 0x00000208

#define BCM6300_A0_SPTAGTr_SIZE 4

/*
 * This structure should be used to declare and program SPTAGT.
 *
 */
typedef union BCM6300_A0_SPTAGTr_s {
	uint32_t v[1];
	uint32_t sptagt[1];
	uint32_t _sptagt;
} BCM6300_A0_SPTAGTr_t;

#define BCM6300_A0_SPTAGTr_CLR(r) (r).sptagt[0] = 0
#define BCM6300_A0_SPTAGTr_SET(r,d) (r).sptagt[0] = d
#define BCM6300_A0_SPTAGTr_GET(r) (r).sptagt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_SPTAGTr_AGE_TIMEf_GET(r) (((r).sptagt[0]) & 0xfffff)
#define BCM6300_A0_SPTAGTr_AGE_TIMEf_SET(r,f) (r).sptagt[0]=(((r).sptagt[0] & ~((uint32_t)0xfffff)) | (((uint32_t)f) & 0xfffff))
#define BCM6300_A0_SPTAGTr_AGE_CHANGE_ENf_GET(r) ((((r).sptagt[0]) >> 20) & 0x1)
#define BCM6300_A0_SPTAGTr_AGE_CHANGE_ENf_SET(r,f) (r).sptagt[0]=(((r).sptagt[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM6300_A0_SPTAGTr_RESERVED_Rf_GET(r) ((((r).sptagt[0]) >> 21) & 0x7ff)
#define BCM6300_A0_SPTAGTr_RESERVED_Rf_SET(r,f) (r).sptagt[0]=(((r).sptagt[0] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access SPTAGT.
 *
 */
#define BCM6300_A0_READ_SPTAGTr(u,r) cdk_robo_reg_read(u,BCM6300_A0_SPTAGTr,(r._sptagt),4)
#define BCM6300_A0_WRITE_SPTAGTr(u,r) cdk_robo_reg_write(u,BCM6300_A0_SPTAGTr,&(r._sptagt),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPTAGTr BCM6300_A0_SPTAGTr
#define SPTAGTr_SIZE BCM6300_A0_SPTAGTr_SIZE
typedef BCM6300_A0_SPTAGTr_t SPTAGTr_t;
#define SPTAGTr_CLR BCM6300_A0_SPTAGTr_CLR
#define SPTAGTr_SET BCM6300_A0_SPTAGTr_SET
#define SPTAGTr_GET BCM6300_A0_SPTAGTr_GET
#define SPTAGTr_AGE_TIMEf_GET BCM6300_A0_SPTAGTr_AGE_TIMEf_GET
#define SPTAGTr_AGE_TIMEf_SET BCM6300_A0_SPTAGTr_AGE_TIMEf_SET
#define SPTAGTr_AGE_CHANGE_ENf_GET BCM6300_A0_SPTAGTr_AGE_CHANGE_ENf_GET
#define SPTAGTr_AGE_CHANGE_ENf_SET BCM6300_A0_SPTAGTr_AGE_CHANGE_ENf_SET
#define SPTAGTr_RESERVED_Rf_GET BCM6300_A0_SPTAGTr_RESERVED_Rf_GET
#define SPTAGTr_RESERVED_Rf_SET BCM6300_A0_SPTAGTr_RESERVED_Rf_SET
#define READ_SPTAGTr BCM6300_A0_READ_SPTAGTr
#define WRITE_SPTAGTr BCM6300_A0_WRITE_SPTAGTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_SPTAGTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  SRCADRCHG
 * BLOCKS:   SYS
 * DESC:     Source Address Change Register
 * SIZE:     16
 * FIELDS:
 *     SRC_ADDR_CHANGE  Source Address Change.9 bit field indicating that the value loaded into the Last Source Address register was not the same 48-bit value as the previous value. A 1 value indicates a dedicated link degment, a value greater than 1 generally indicates a mixing (repeatered) segment. Upon change of SA, a bit remains set until cleared by a read operation.0 = Source Address Constant1 = Source Address Changed
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_SRCADRCHGr 0x0000010e

#define BCM6300_A0_SRCADRCHGr_SIZE 2

/*
 * This structure should be used to declare and program SRCADRCHG.
 *
 */
typedef union BCM6300_A0_SRCADRCHGr_s {
	uint32_t v[1];
	uint32_t srcadrchg[1];
	uint32_t _srcadrchg;
} BCM6300_A0_SRCADRCHGr_t;

#define BCM6300_A0_SRCADRCHGr_CLR(r) (r).srcadrchg[0] = 0
#define BCM6300_A0_SRCADRCHGr_SET(r,d) (r).srcadrchg[0] = d
#define BCM6300_A0_SRCADRCHGr_GET(r) (r).srcadrchg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_SRCADRCHGr_SRC_ADDR_CHANGEf_GET(r) (((r).srcadrchg[0]) & 0x1ff)
#define BCM6300_A0_SRCADRCHGr_SRC_ADDR_CHANGEf_SET(r,f) (r).srcadrchg[0]=(((r).srcadrchg[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_SRCADRCHGr_RESERVED_Rf_GET(r) ((((r).srcadrchg[0]) >> 9) & 0x7f)
#define BCM6300_A0_SRCADRCHGr_RESERVED_Rf_SET(r,f) (r).srcadrchg[0]=(((r).srcadrchg[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access SRCADRCHG.
 *
 */
#define BCM6300_A0_READ_SRCADRCHGr(u,r) cdk_robo_reg_read(u,BCM6300_A0_SRCADRCHGr,(r._srcadrchg),2)
#define BCM6300_A0_WRITE_SRCADRCHGr(u,r) cdk_robo_reg_write(u,BCM6300_A0_SRCADRCHGr,&(r._srcadrchg),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SRCADRCHGr BCM6300_A0_SRCADRCHGr
#define SRCADRCHGr_SIZE BCM6300_A0_SRCADRCHGr_SIZE
typedef BCM6300_A0_SRCADRCHGr_t SRCADRCHGr_t;
#define SRCADRCHGr_CLR BCM6300_A0_SRCADRCHGr_CLR
#define SRCADRCHGr_SET BCM6300_A0_SRCADRCHGr_SET
#define SRCADRCHGr_GET BCM6300_A0_SRCADRCHGr_GET
#define SRCADRCHGr_SRC_ADDR_CHANGEf_GET BCM6300_A0_SRCADRCHGr_SRC_ADDR_CHANGEf_GET
#define SRCADRCHGr_SRC_ADDR_CHANGEf_SET BCM6300_A0_SRCADRCHGr_SRC_ADDR_CHANGEf_SET
#define SRCADRCHGr_RESERVED_Rf_GET BCM6300_A0_SRCADRCHGr_RESERVED_Rf_GET
#define SRCADRCHGr_RESERVED_Rf_SET BCM6300_A0_SRCADRCHGr_RESERVED_Rf_SET
#define READ_SRCADRCHGr BCM6300_A0_READ_SRCADRCHGr
#define WRITE_SRCADRCHGr BCM6300_A0_WRITE_SRCADRCHGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_SRCADRCHGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  STRAP_VALUE
 * BLOCKS:   SYS
 * DESC:     Strap Value Register
 * SIZE:     32
 * FIELDS:
 *     BC_SUPP_EN       bc_supp_en_strap,
 *     BIST_CLRMEM      bist_clrmem_sel,
 *     SYSFREQ          clock freq[1:0],
 *     CPU_EPROM        cpu_eprom_sel,
 *     EN_CLK25_OUT     en_clk25_out,
 *     EN_CLK50_OUT     en_clk50_out,
 *     DUMP_EMI         dump_EMI,
 *     ENEXTCLK         enextclk.
 *     EN_LPDET         enable loop detection,
 *     ENFDXFLOW        enfdxflow,
 *     ENHDXFLOW        enhdxflow,
 *     EEPROM_TYPE      eprom_type[1:0],
 *     GRX0_SETUP       grx_0_setup.
 *     GTX0_SETUP       gtx_0_setup.
 *     HW_FWDG_EN       hw_fwdg_en,
 *     IMP_MODE         IMP mode,
 *     LEDMODE          ledmode[1:0],
 *     LP_IMP_SEL       loop IMP select,
 *     MII_DUMP_FWDG    mii_dump_fwdg_en,
 *     QOS_EN           qos_en_strap,
 *     QOS_FC_OFF       qos_fc_off,
 *     SKIP_SRAMBIST    skip_srambist,
 *     WD_CLR_EN        wd_clr_en,
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_STRAP_VALUEr 0x00000170

#define BCM6300_A0_STRAP_VALUEr_SIZE 4

/*
 * This structure should be used to declare and program STRAP_VALUE.
 *
 */
typedef union BCM6300_A0_STRAP_VALUEr_s {
	uint32_t v[1];
	uint32_t strap_value[1];
	uint32_t _strap_value;
} BCM6300_A0_STRAP_VALUEr_t;

#define BCM6300_A0_STRAP_VALUEr_CLR(r) (r).strap_value[0] = 0
#define BCM6300_A0_STRAP_VALUEr_SET(r,d) (r).strap_value[0] = d
#define BCM6300_A0_STRAP_VALUEr_GET(r) (r).strap_value[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_STRAP_VALUEr_BC_SUPP_ENf_GET(r) (((r).strap_value[0]) & 0x1)
#define BCM6300_A0_STRAP_VALUEr_BC_SUPP_ENf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM6300_A0_STRAP_VALUEr_BIST_CLRMEMf_GET(r) ((((r).strap_value[0]) >> 1) & 0x1)
#define BCM6300_A0_STRAP_VALUEr_BIST_CLRMEMf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM6300_A0_STRAP_VALUEr_SYSFREQf_GET(r) ((((r).strap_value[0]) >> 2) & 0x3)
#define BCM6300_A0_STRAP_VALUEr_SYSFREQf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM6300_A0_STRAP_VALUEr_CPU_EPROMf_GET(r) ((((r).strap_value[0]) >> 4) & 0x1)
#define BCM6300_A0_STRAP_VALUEr_CPU_EPROMf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM6300_A0_STRAP_VALUEr_EN_CLK25_OUTf_GET(r) ((((r).strap_value[0]) >> 5) & 0x1)
#define BCM6300_A0_STRAP_VALUEr_EN_CLK25_OUTf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM6300_A0_STRAP_VALUEr_EN_CLK50_OUTf_GET(r) ((((r).strap_value[0]) >> 6) & 0x1)
#define BCM6300_A0_STRAP_VALUEr_EN_CLK50_OUTf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM6300_A0_STRAP_VALUEr_DUMP_EMIf_GET(r) ((((r).strap_value[0]) >> 7) & 0x1)
#define BCM6300_A0_STRAP_VALUEr_DUMP_EMIf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM6300_A0_STRAP_VALUEr_ENEXTCLKf_GET(r) ((((r).strap_value[0]) >> 8) & 0x1)
#define BCM6300_A0_STRAP_VALUEr_ENEXTCLKf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM6300_A0_STRAP_VALUEr_EN_LPDETf_GET(r) ((((r).strap_value[0]) >> 9) & 0x1)
#define BCM6300_A0_STRAP_VALUEr_EN_LPDETf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM6300_A0_STRAP_VALUEr_ENFDXFLOWf_GET(r) ((((r).strap_value[0]) >> 10) & 0x1)
#define BCM6300_A0_STRAP_VALUEr_ENFDXFLOWf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM6300_A0_STRAP_VALUEr_ENHDXFLOWf_GET(r) ((((r).strap_value[0]) >> 11) & 0x1)
#define BCM6300_A0_STRAP_VALUEr_ENHDXFLOWf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM6300_A0_STRAP_VALUEr_EEPROM_TYPEf_GET(r) ((((r).strap_value[0]) >> 12) & 0x3)
#define BCM6300_A0_STRAP_VALUEr_EEPROM_TYPEf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM6300_A0_STRAP_VALUEr_GRX0_SETUPf_GET(r) ((((r).strap_value[0]) >> 14) & 0x1)
#define BCM6300_A0_STRAP_VALUEr_GRX0_SETUPf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM6300_A0_STRAP_VALUEr_GTX0_SETUPf_GET(r) ((((r).strap_value[0]) >> 15) & 0x1)
#define BCM6300_A0_STRAP_VALUEr_GTX0_SETUPf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM6300_A0_STRAP_VALUEr_HW_FWDG_ENf_GET(r) ((((r).strap_value[0]) >> 16) & 0x1)
#define BCM6300_A0_STRAP_VALUEr_HW_FWDG_ENf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM6300_A0_STRAP_VALUEr_IMP_MODEf_GET(r) ((((r).strap_value[0]) >> 17) & 0x3)
#define BCM6300_A0_STRAP_VALUEr_IMP_MODEf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x3 << 17)) | ((((uint32_t)f) & 0x3) << 17))
#define BCM6300_A0_STRAP_VALUEr_LEDMODEf_GET(r) ((((r).strap_value[0]) >> 19) & 0x3)
#define BCM6300_A0_STRAP_VALUEr_LEDMODEf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x3 << 19)) | ((((uint32_t)f) & 0x3) << 19))
#define BCM6300_A0_STRAP_VALUEr_LP_IMP_SELf_GET(r) ((((r).strap_value[0]) >> 21) & 0x1)
#define BCM6300_A0_STRAP_VALUEr_LP_IMP_SELf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM6300_A0_STRAP_VALUEr_MII_DUMP_FWDGf_GET(r) ((((r).strap_value[0]) >> 22) & 0x1)
#define BCM6300_A0_STRAP_VALUEr_MII_DUMP_FWDGf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM6300_A0_STRAP_VALUEr_QOS_ENf_GET(r) ((((r).strap_value[0]) >> 23) & 0x1)
#define BCM6300_A0_STRAP_VALUEr_QOS_ENf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM6300_A0_STRAP_VALUEr_QOS_FC_OFFf_GET(r) ((((r).strap_value[0]) >> 24) & 0x1)
#define BCM6300_A0_STRAP_VALUEr_QOS_FC_OFFf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM6300_A0_STRAP_VALUEr_SKIP_SRAMBISTf_GET(r) ((((r).strap_value[0]) >> 25) & 0x1)
#define BCM6300_A0_STRAP_VALUEr_SKIP_SRAMBISTf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM6300_A0_STRAP_VALUEr_WD_CLR_ENf_GET(r) ((((r).strap_value[0]) >> 26) & 0x1)
#define BCM6300_A0_STRAP_VALUEr_WD_CLR_ENf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM6300_A0_STRAP_VALUEr_RESERVED_Rf_GET(r) ((((r).strap_value[0]) >> 27) & 0x1f)
#define BCM6300_A0_STRAP_VALUEr_RESERVED_Rf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1f << 27)) | ((((uint32_t)f) & 0x1f) << 27))

/*
 * These macros can be used to access STRAP_VALUE.
 *
 */
#define BCM6300_A0_READ_STRAP_VALUEr(u,r) cdk_robo_reg_read(u,BCM6300_A0_STRAP_VALUEr,(r._strap_value),4)
#define BCM6300_A0_WRITE_STRAP_VALUEr(u,r) cdk_robo_reg_write(u,BCM6300_A0_STRAP_VALUEr,&(r._strap_value),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define STRAP_VALUEr BCM6300_A0_STRAP_VALUEr
#define STRAP_VALUEr_SIZE BCM6300_A0_STRAP_VALUEr_SIZE
typedef BCM6300_A0_STRAP_VALUEr_t STRAP_VALUEr_t;
#define STRAP_VALUEr_CLR BCM6300_A0_STRAP_VALUEr_CLR
#define STRAP_VALUEr_SET BCM6300_A0_STRAP_VALUEr_SET
#define STRAP_VALUEr_GET BCM6300_A0_STRAP_VALUEr_GET
#define STRAP_VALUEr_BC_SUPP_ENf_GET BCM6300_A0_STRAP_VALUEr_BC_SUPP_ENf_GET
#define STRAP_VALUEr_BC_SUPP_ENf_SET BCM6300_A0_STRAP_VALUEr_BC_SUPP_ENf_SET
#define STRAP_VALUEr_BIST_CLRMEMf_GET BCM6300_A0_STRAP_VALUEr_BIST_CLRMEMf_GET
#define STRAP_VALUEr_BIST_CLRMEMf_SET BCM6300_A0_STRAP_VALUEr_BIST_CLRMEMf_SET
#define STRAP_VALUEr_SYSFREQf_GET BCM6300_A0_STRAP_VALUEr_SYSFREQf_GET
#define STRAP_VALUEr_SYSFREQf_SET BCM6300_A0_STRAP_VALUEr_SYSFREQf_SET
#define STRAP_VALUEr_CPU_EPROMf_GET BCM6300_A0_STRAP_VALUEr_CPU_EPROMf_GET
#define STRAP_VALUEr_CPU_EPROMf_SET BCM6300_A0_STRAP_VALUEr_CPU_EPROMf_SET
#define STRAP_VALUEr_EN_CLK25_OUTf_GET BCM6300_A0_STRAP_VALUEr_EN_CLK25_OUTf_GET
#define STRAP_VALUEr_EN_CLK25_OUTf_SET BCM6300_A0_STRAP_VALUEr_EN_CLK25_OUTf_SET
#define STRAP_VALUEr_EN_CLK50_OUTf_GET BCM6300_A0_STRAP_VALUEr_EN_CLK50_OUTf_GET
#define STRAP_VALUEr_EN_CLK50_OUTf_SET BCM6300_A0_STRAP_VALUEr_EN_CLK50_OUTf_SET
#define STRAP_VALUEr_DUMP_EMIf_GET BCM6300_A0_STRAP_VALUEr_DUMP_EMIf_GET
#define STRAP_VALUEr_DUMP_EMIf_SET BCM6300_A0_STRAP_VALUEr_DUMP_EMIf_SET
#define STRAP_VALUEr_ENEXTCLKf_GET BCM6300_A0_STRAP_VALUEr_ENEXTCLKf_GET
#define STRAP_VALUEr_ENEXTCLKf_SET BCM6300_A0_STRAP_VALUEr_ENEXTCLKf_SET
#define STRAP_VALUEr_EN_LPDETf_GET BCM6300_A0_STRAP_VALUEr_EN_LPDETf_GET
#define STRAP_VALUEr_EN_LPDETf_SET BCM6300_A0_STRAP_VALUEr_EN_LPDETf_SET
#define STRAP_VALUEr_ENFDXFLOWf_GET BCM6300_A0_STRAP_VALUEr_ENFDXFLOWf_GET
#define STRAP_VALUEr_ENFDXFLOWf_SET BCM6300_A0_STRAP_VALUEr_ENFDXFLOWf_SET
#define STRAP_VALUEr_ENHDXFLOWf_GET BCM6300_A0_STRAP_VALUEr_ENHDXFLOWf_GET
#define STRAP_VALUEr_ENHDXFLOWf_SET BCM6300_A0_STRAP_VALUEr_ENHDXFLOWf_SET
#define STRAP_VALUEr_EEPROM_TYPEf_GET BCM6300_A0_STRAP_VALUEr_EEPROM_TYPEf_GET
#define STRAP_VALUEr_EEPROM_TYPEf_SET BCM6300_A0_STRAP_VALUEr_EEPROM_TYPEf_SET
#define STRAP_VALUEr_GRX0_SETUPf_GET BCM6300_A0_STRAP_VALUEr_GRX0_SETUPf_GET
#define STRAP_VALUEr_GRX0_SETUPf_SET BCM6300_A0_STRAP_VALUEr_GRX0_SETUPf_SET
#define STRAP_VALUEr_GTX0_SETUPf_GET BCM6300_A0_STRAP_VALUEr_GTX0_SETUPf_GET
#define STRAP_VALUEr_GTX0_SETUPf_SET BCM6300_A0_STRAP_VALUEr_GTX0_SETUPf_SET
#define STRAP_VALUEr_HW_FWDG_ENf_GET BCM6300_A0_STRAP_VALUEr_HW_FWDG_ENf_GET
#define STRAP_VALUEr_HW_FWDG_ENf_SET BCM6300_A0_STRAP_VALUEr_HW_FWDG_ENf_SET
#define STRAP_VALUEr_IMP_MODEf_GET BCM6300_A0_STRAP_VALUEr_IMP_MODEf_GET
#define STRAP_VALUEr_IMP_MODEf_SET BCM6300_A0_STRAP_VALUEr_IMP_MODEf_SET
#define STRAP_VALUEr_LEDMODEf_GET BCM6300_A0_STRAP_VALUEr_LEDMODEf_GET
#define STRAP_VALUEr_LEDMODEf_SET BCM6300_A0_STRAP_VALUEr_LEDMODEf_SET
#define STRAP_VALUEr_LP_IMP_SELf_GET BCM6300_A0_STRAP_VALUEr_LP_IMP_SELf_GET
#define STRAP_VALUEr_LP_IMP_SELf_SET BCM6300_A0_STRAP_VALUEr_LP_IMP_SELf_SET
#define STRAP_VALUEr_MII_DUMP_FWDGf_GET BCM6300_A0_STRAP_VALUEr_MII_DUMP_FWDGf_GET
#define STRAP_VALUEr_MII_DUMP_FWDGf_SET BCM6300_A0_STRAP_VALUEr_MII_DUMP_FWDGf_SET
#define STRAP_VALUEr_QOS_ENf_GET BCM6300_A0_STRAP_VALUEr_QOS_ENf_GET
#define STRAP_VALUEr_QOS_ENf_SET BCM6300_A0_STRAP_VALUEr_QOS_ENf_SET
#define STRAP_VALUEr_QOS_FC_OFFf_GET BCM6300_A0_STRAP_VALUEr_QOS_FC_OFFf_GET
#define STRAP_VALUEr_QOS_FC_OFFf_SET BCM6300_A0_STRAP_VALUEr_QOS_FC_OFFf_SET
#define STRAP_VALUEr_SKIP_SRAMBISTf_GET BCM6300_A0_STRAP_VALUEr_SKIP_SRAMBISTf_GET
#define STRAP_VALUEr_SKIP_SRAMBISTf_SET BCM6300_A0_STRAP_VALUEr_SKIP_SRAMBISTf_SET
#define STRAP_VALUEr_WD_CLR_ENf_GET BCM6300_A0_STRAP_VALUEr_WD_CLR_ENf_GET
#define STRAP_VALUEr_WD_CLR_ENf_SET BCM6300_A0_STRAP_VALUEr_WD_CLR_ENf_SET
#define STRAP_VALUEr_RESERVED_Rf_GET BCM6300_A0_STRAP_VALUEr_RESERVED_Rf_GET
#define STRAP_VALUEr_RESERVED_Rf_SET BCM6300_A0_STRAP_VALUEr_RESERVED_Rf_SET
#define READ_STRAP_VALUEr BCM6300_A0_READ_STRAP_VALUEr
#define WRITE_STRAP_VALUEr BCM6300_A0_WRITE_STRAP_VALUEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_STRAP_VALUEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  STS_OVERRIDE_GP
 * BLOCKS:   GPIC0
 * DESC:     Port N GMII Port States Override Register
 * SIZE:     8
 * FIELDS:
 *     LINK_STS         1: Link Up0: Link Down
 *     DUPLX_MODE       Software Duplex Mode Setting0: Half Duplex1: Full Duplex
 *     GIGA_SPEED       Software Port Speed setting2'b10 : 1000M2'b01: 100M2'b00 : 10M
 *     RXFLOW_CNTL      Software Rx Flow Control Enable
 *     TXFLOW_CNTL      Software Tx Flow Control Enable
 *     SW_ORD           CPU set software Override bit to 1 to make bit [5:0] affected.PHY scan register will be override.
 *     RESERVED_1R      Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_STS_OVERRIDE_GPr 0x00000058

#define BCM6300_A0_STS_OVERRIDE_GPr_SIZE 1

/*
 * This structure should be used to declare and program STS_OVERRIDE_GP.
 *
 */
typedef union BCM6300_A0_STS_OVERRIDE_GPr_s {
	uint32_t v[1];
	uint32_t sts_override_gp[1];
	uint32_t _sts_override_gp;
} BCM6300_A0_STS_OVERRIDE_GPr_t;

#define BCM6300_A0_STS_OVERRIDE_GPr_CLR(r) (r).sts_override_gp[0] = 0
#define BCM6300_A0_STS_OVERRIDE_GPr_SET(r,d) (r).sts_override_gp[0] = d
#define BCM6300_A0_STS_OVERRIDE_GPr_GET(r) (r).sts_override_gp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_STS_OVERRIDE_GPr_LINK_STSf_GET(r) (((r).sts_override_gp[0]) & 0x1)
#define BCM6300_A0_STS_OVERRIDE_GPr_LINK_STSf_SET(r,f) (r).sts_override_gp[0]=(((r).sts_override_gp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM6300_A0_STS_OVERRIDE_GPr_DUPLX_MODEf_GET(r) ((((r).sts_override_gp[0]) >> 1) & 0x1)
#define BCM6300_A0_STS_OVERRIDE_GPr_DUPLX_MODEf_SET(r,f) (r).sts_override_gp[0]=(((r).sts_override_gp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM6300_A0_STS_OVERRIDE_GPr_GIGA_SPEEDf_GET(r) ((((r).sts_override_gp[0]) >> 2) & 0x3)
#define BCM6300_A0_STS_OVERRIDE_GPr_GIGA_SPEEDf_SET(r,f) (r).sts_override_gp[0]=(((r).sts_override_gp[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM6300_A0_STS_OVERRIDE_GPr_RXFLOW_CNTLf_GET(r) ((((r).sts_override_gp[0]) >> 4) & 0x1)
#define BCM6300_A0_STS_OVERRIDE_GPr_RXFLOW_CNTLf_SET(r,f) (r).sts_override_gp[0]=(((r).sts_override_gp[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM6300_A0_STS_OVERRIDE_GPr_TXFLOW_CNTLf_GET(r) ((((r).sts_override_gp[0]) >> 5) & 0x1)
#define BCM6300_A0_STS_OVERRIDE_GPr_TXFLOW_CNTLf_SET(r,f) (r).sts_override_gp[0]=(((r).sts_override_gp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM6300_A0_STS_OVERRIDE_GPr_SW_ORDf_GET(r) ((((r).sts_override_gp[0]) >> 6) & 0x1)
#define BCM6300_A0_STS_OVERRIDE_GPr_SW_ORDf_SET(r,f) (r).sts_override_gp[0]=(((r).sts_override_gp[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM6300_A0_STS_OVERRIDE_GPr_RESERVED_1Rf_GET(r) ((((r).sts_override_gp[0]) >> 7) & 0x1)
#define BCM6300_A0_STS_OVERRIDE_GPr_RESERVED_1Rf_SET(r,f) (r).sts_override_gp[0]=(((r).sts_override_gp[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access STS_OVERRIDE_GP.
 *
 */
#define BCM6300_A0_READ_STS_OVERRIDE_GPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_STS_OVERRIDE_GPr,(r._sts_override_gp),1)
#define BCM6300_A0_WRITE_STS_OVERRIDE_GPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_STS_OVERRIDE_GPr,&(r._sts_override_gp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define STS_OVERRIDE_GPr BCM6300_A0_STS_OVERRIDE_GPr
#define STS_OVERRIDE_GPr_SIZE BCM6300_A0_STS_OVERRIDE_GPr_SIZE
typedef BCM6300_A0_STS_OVERRIDE_GPr_t STS_OVERRIDE_GPr_t;
#define STS_OVERRIDE_GPr_CLR BCM6300_A0_STS_OVERRIDE_GPr_CLR
#define STS_OVERRIDE_GPr_SET BCM6300_A0_STS_OVERRIDE_GPr_SET
#define STS_OVERRIDE_GPr_GET BCM6300_A0_STS_OVERRIDE_GPr_GET
#define STS_OVERRIDE_GPr_LINK_STSf_GET BCM6300_A0_STS_OVERRIDE_GPr_LINK_STSf_GET
#define STS_OVERRIDE_GPr_LINK_STSf_SET BCM6300_A0_STS_OVERRIDE_GPr_LINK_STSf_SET
#define STS_OVERRIDE_GPr_DUPLX_MODEf_GET BCM6300_A0_STS_OVERRIDE_GPr_DUPLX_MODEf_GET
#define STS_OVERRIDE_GPr_DUPLX_MODEf_SET BCM6300_A0_STS_OVERRIDE_GPr_DUPLX_MODEf_SET
#define STS_OVERRIDE_GPr_GIGA_SPEEDf_GET BCM6300_A0_STS_OVERRIDE_GPr_GIGA_SPEEDf_GET
#define STS_OVERRIDE_GPr_GIGA_SPEEDf_SET BCM6300_A0_STS_OVERRIDE_GPr_GIGA_SPEEDf_SET
#define STS_OVERRIDE_GPr_RXFLOW_CNTLf_GET BCM6300_A0_STS_OVERRIDE_GPr_RXFLOW_CNTLf_GET
#define STS_OVERRIDE_GPr_RXFLOW_CNTLf_SET BCM6300_A0_STS_OVERRIDE_GPr_RXFLOW_CNTLf_SET
#define STS_OVERRIDE_GPr_TXFLOW_CNTLf_GET BCM6300_A0_STS_OVERRIDE_GPr_TXFLOW_CNTLf_GET
#define STS_OVERRIDE_GPr_TXFLOW_CNTLf_SET BCM6300_A0_STS_OVERRIDE_GPr_TXFLOW_CNTLf_SET
#define STS_OVERRIDE_GPr_SW_ORDf_GET BCM6300_A0_STS_OVERRIDE_GPr_SW_ORDf_GET
#define STS_OVERRIDE_GPr_SW_ORDf_SET BCM6300_A0_STS_OVERRIDE_GPr_SW_ORDf_SET
#define STS_OVERRIDE_GPr_RESERVED_1Rf_GET BCM6300_A0_STS_OVERRIDE_GPr_RESERVED_1Rf_GET
#define STS_OVERRIDE_GPr_RESERVED_1Rf_SET BCM6300_A0_STS_OVERRIDE_GPr_RESERVED_1Rf_SET
#define READ_STS_OVERRIDE_GPr BCM6300_A0_READ_STS_OVERRIDE_GPr
#define WRITE_STS_OVERRIDE_GPr BCM6300_A0_WRITE_STS_OVERRIDE_GPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_STS_OVERRIDE_GPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  STS_OVERRIDE_IMP
 * BLOCKS:   CPIC
 * DESC:     IMP Port States Override Register
 * SIZE:     8
 * FIELDS:
 *     LINK_STS         Link Status0: Link fail1: Link pass
 *     DUPLX_MODE       Software Duplex Mode Setting0: Half Duplex1: Full Duplex
 *     SPEED_R          Speed00: 10 Mbps01: 100 Mbps10: 1000Mbps
 *     RXFLOW_CNTL      Link Partner Flow Control Capability0: Not PAUSE capable1: PAUSE capable
 *     TX_FLOW_CNTL     Link Partner Flow Control Capability0: Not PAUSE capable1: PAUSE capable
 *     RESERVED_1R      Reserved
 *     MII_SW_OR        MII Software Override0: Use MII hardware pin status1: Use contents of this register
 *
 ******************************************************************************/
#define BCM6300_A0_STS_OVERRIDE_IMPr 0x0000000e

#define BCM6300_A0_STS_OVERRIDE_IMPr_SIZE 1

/*
 * This structure should be used to declare and program STS_OVERRIDE_IMP.
 *
 */
typedef union BCM6300_A0_STS_OVERRIDE_IMPr_s {
	uint32_t v[1];
	uint32_t sts_override_imp[1];
	uint32_t _sts_override_imp;
} BCM6300_A0_STS_OVERRIDE_IMPr_t;

#define BCM6300_A0_STS_OVERRIDE_IMPr_CLR(r) (r).sts_override_imp[0] = 0
#define BCM6300_A0_STS_OVERRIDE_IMPr_SET(r,d) (r).sts_override_imp[0] = d
#define BCM6300_A0_STS_OVERRIDE_IMPr_GET(r) (r).sts_override_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_STS_OVERRIDE_IMPr_LINK_STSf_GET(r) (((r).sts_override_imp[0]) & 0x1)
#define BCM6300_A0_STS_OVERRIDE_IMPr_LINK_STSf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM6300_A0_STS_OVERRIDE_IMPr_DUPLX_MODEf_GET(r) ((((r).sts_override_imp[0]) >> 1) & 0x1)
#define BCM6300_A0_STS_OVERRIDE_IMPr_DUPLX_MODEf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM6300_A0_STS_OVERRIDE_IMPr_SPEED_Rf_GET(r) ((((r).sts_override_imp[0]) >> 2) & 0x3)
#define BCM6300_A0_STS_OVERRIDE_IMPr_SPEED_Rf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM6300_A0_STS_OVERRIDE_IMPr_RXFLOW_CNTLf_GET(r) ((((r).sts_override_imp[0]) >> 4) & 0x1)
#define BCM6300_A0_STS_OVERRIDE_IMPr_RXFLOW_CNTLf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM6300_A0_STS_OVERRIDE_IMPr_TX_FLOW_CNTLf_GET(r) ((((r).sts_override_imp[0]) >> 5) & 0x1)
#define BCM6300_A0_STS_OVERRIDE_IMPr_TX_FLOW_CNTLf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM6300_A0_STS_OVERRIDE_IMPr_RESERVED_1Rf_GET(r) ((((r).sts_override_imp[0]) >> 6) & 0x1)
#define BCM6300_A0_STS_OVERRIDE_IMPr_RESERVED_1Rf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM6300_A0_STS_OVERRIDE_IMPr_MII_SW_ORf_GET(r) ((((r).sts_override_imp[0]) >> 7) & 0x1)
#define BCM6300_A0_STS_OVERRIDE_IMPr_MII_SW_ORf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access STS_OVERRIDE_IMP.
 *
 */
#define BCM6300_A0_READ_STS_OVERRIDE_IMPr(u,r) cdk_robo_reg_read(u,BCM6300_A0_STS_OVERRIDE_IMPr,(r._sts_override_imp),1)
#define BCM6300_A0_WRITE_STS_OVERRIDE_IMPr(u,r) cdk_robo_reg_write(u,BCM6300_A0_STS_OVERRIDE_IMPr,&(r._sts_override_imp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define STS_OVERRIDE_IMPr BCM6300_A0_STS_OVERRIDE_IMPr
#define STS_OVERRIDE_IMPr_SIZE BCM6300_A0_STS_OVERRIDE_IMPr_SIZE
typedef BCM6300_A0_STS_OVERRIDE_IMPr_t STS_OVERRIDE_IMPr_t;
#define STS_OVERRIDE_IMPr_CLR BCM6300_A0_STS_OVERRIDE_IMPr_CLR
#define STS_OVERRIDE_IMPr_SET BCM6300_A0_STS_OVERRIDE_IMPr_SET
#define STS_OVERRIDE_IMPr_GET BCM6300_A0_STS_OVERRIDE_IMPr_GET
#define STS_OVERRIDE_IMPr_LINK_STSf_GET BCM6300_A0_STS_OVERRIDE_IMPr_LINK_STSf_GET
#define STS_OVERRIDE_IMPr_LINK_STSf_SET BCM6300_A0_STS_OVERRIDE_IMPr_LINK_STSf_SET
#define STS_OVERRIDE_IMPr_DUPLX_MODEf_GET BCM6300_A0_STS_OVERRIDE_IMPr_DUPLX_MODEf_GET
#define STS_OVERRIDE_IMPr_DUPLX_MODEf_SET BCM6300_A0_STS_OVERRIDE_IMPr_DUPLX_MODEf_SET
#define STS_OVERRIDE_IMPr_SPEED_Rf_GET BCM6300_A0_STS_OVERRIDE_IMPr_SPEED_Rf_GET
#define STS_OVERRIDE_IMPr_SPEED_Rf_SET BCM6300_A0_STS_OVERRIDE_IMPr_SPEED_Rf_SET
#define STS_OVERRIDE_IMPr_RXFLOW_CNTLf_GET BCM6300_A0_STS_OVERRIDE_IMPr_RXFLOW_CNTLf_GET
#define STS_OVERRIDE_IMPr_RXFLOW_CNTLf_SET BCM6300_A0_STS_OVERRIDE_IMPr_RXFLOW_CNTLf_SET
#define STS_OVERRIDE_IMPr_TX_FLOW_CNTLf_GET BCM6300_A0_STS_OVERRIDE_IMPr_TX_FLOW_CNTLf_GET
#define STS_OVERRIDE_IMPr_TX_FLOW_CNTLf_SET BCM6300_A0_STS_OVERRIDE_IMPr_TX_FLOW_CNTLf_SET
#define STS_OVERRIDE_IMPr_RESERVED_1Rf_GET BCM6300_A0_STS_OVERRIDE_IMPr_RESERVED_1Rf_GET
#define STS_OVERRIDE_IMPr_RESERVED_1Rf_SET BCM6300_A0_STS_OVERRIDE_IMPr_RESERVED_1Rf_SET
#define STS_OVERRIDE_IMPr_MII_SW_ORf_GET BCM6300_A0_STS_OVERRIDE_IMPr_MII_SW_ORf_GET
#define STS_OVERRIDE_IMPr_MII_SW_ORf_SET BCM6300_A0_STS_OVERRIDE_IMPr_MII_SW_ORf_SET
#define READ_STS_OVERRIDE_IMPr BCM6300_A0_READ_STS_OVERRIDE_IMPr
#define WRITE_STS_OVERRIDE_IMPr BCM6300_A0_WRITE_STS_OVERRIDE_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_STS_OVERRIDE_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  SWMODE
 * BLOCKS:   SYS
 * DESC:     Switch Mode Register
 * SIZE:     8
 * FIELDS:
 *     SW_FWDG_MODE     Software Forwarding Mode.Strapped from the inverse of the HW_FWDG_EN pin at power-on. Can be overwritten subsequently.0 = Unmanaged Mode.1 = Managed ModeThe ARL treats Reserved Multicast addresses differently dependent on this selection. See Table 3 for a precise definition.
 *     SW_FWDG_EN       Software Forwarding EnableSW_FWDG_EN=1: Frame forwarding is enabled.SW_FWDG_EN=0: Frame forwarding is disabled.Read from HW_FWDG_EN pin on power-on. Can be overwritten subsequently. For managed switch implementations (5388 mode), the switch should be configured to disable forwarding on power-on, to allow the processor to configure the internal address table and other parameters, before frame forwarding is enabled.
 *     PTRY_LMT_DIS     Retry Limit DisableWhen set, disables the Retry limit on all MAC ports (10/100BASE-T and MII ports). Causes a MAC port in half duplex operation, to continue to retry the same packet regardless of the number of collision attempts.
 *     FAST_TXDESC_RERURN Controls which algorithm is used to release packets when a link goes down.
 *     NOBLKCD          Always not to blockcarrier detected signal.1b'b1: Not to block. txport will always defer to crs.1b'b0: Block CD
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_SWMODEr 0x0000000b

#define BCM6300_A0_SWMODEr_SIZE 1

/*
 * This structure should be used to declare and program SWMODE.
 *
 */
typedef union BCM6300_A0_SWMODEr_s {
	uint32_t v[1];
	uint32_t swmode[1];
	uint32_t _swmode;
} BCM6300_A0_SWMODEr_t;

#define BCM6300_A0_SWMODEr_CLR(r) (r).swmode[0] = 0
#define BCM6300_A0_SWMODEr_SET(r,d) (r).swmode[0] = d
#define BCM6300_A0_SWMODEr_GET(r) (r).swmode[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_SWMODEr_SW_FWDG_MODEf_GET(r) (((r).swmode[0]) & 0x1)
#define BCM6300_A0_SWMODEr_SW_FWDG_MODEf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM6300_A0_SWMODEr_SW_FWDG_ENf_GET(r) ((((r).swmode[0]) >> 1) & 0x1)
#define BCM6300_A0_SWMODEr_SW_FWDG_ENf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM6300_A0_SWMODEr_PTRY_LMT_DISf_GET(r) ((((r).swmode[0]) >> 2) & 0x1)
#define BCM6300_A0_SWMODEr_PTRY_LMT_DISf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM6300_A0_SWMODEr_FAST_TXDESC_RERURNf_GET(r) ((((r).swmode[0]) >> 3) & 0x1)
#define BCM6300_A0_SWMODEr_FAST_TXDESC_RERURNf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM6300_A0_SWMODEr_NOBLKCDf_GET(r) ((((r).swmode[0]) >> 4) & 0x1)
#define BCM6300_A0_SWMODEr_NOBLKCDf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM6300_A0_SWMODEr_RESERVED_Rf_GET(r) ((((r).swmode[0]) >> 5) & 0x7)
#define BCM6300_A0_SWMODEr_RESERVED_Rf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access SWMODE.
 *
 */
#define BCM6300_A0_READ_SWMODEr(u,r) cdk_robo_reg_read(u,BCM6300_A0_SWMODEr,(r._swmode),1)
#define BCM6300_A0_WRITE_SWMODEr(u,r) cdk_robo_reg_write(u,BCM6300_A0_SWMODEr,&(r._swmode),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SWMODEr BCM6300_A0_SWMODEr
#define SWMODEr_SIZE BCM6300_A0_SWMODEr_SIZE
typedef BCM6300_A0_SWMODEr_t SWMODEr_t;
#define SWMODEr_CLR BCM6300_A0_SWMODEr_CLR
#define SWMODEr_SET BCM6300_A0_SWMODEr_SET
#define SWMODEr_GET BCM6300_A0_SWMODEr_GET
#define SWMODEr_SW_FWDG_MODEf_GET BCM6300_A0_SWMODEr_SW_FWDG_MODEf_GET
#define SWMODEr_SW_FWDG_MODEf_SET BCM6300_A0_SWMODEr_SW_FWDG_MODEf_SET
#define SWMODEr_SW_FWDG_ENf_GET BCM6300_A0_SWMODEr_SW_FWDG_ENf_GET
#define SWMODEr_SW_FWDG_ENf_SET BCM6300_A0_SWMODEr_SW_FWDG_ENf_SET
#define SWMODEr_PTRY_LMT_DISf_GET BCM6300_A0_SWMODEr_PTRY_LMT_DISf_GET
#define SWMODEr_PTRY_LMT_DISf_SET BCM6300_A0_SWMODEr_PTRY_LMT_DISf_SET
#define SWMODEr_FAST_TXDESC_RERURNf_GET BCM6300_A0_SWMODEr_FAST_TXDESC_RERURNf_GET
#define SWMODEr_FAST_TXDESC_RERURNf_SET BCM6300_A0_SWMODEr_FAST_TXDESC_RERURNf_SET
#define SWMODEr_NOBLKCDf_GET BCM6300_A0_SWMODEr_NOBLKCDf_GET
#define SWMODEr_NOBLKCDf_SET BCM6300_A0_SWMODEr_NOBLKCDf_SET
#define SWMODEr_RESERVED_Rf_GET BCM6300_A0_SWMODEr_RESERVED_Rf_GET
#define SWMODEr_RESERVED_Rf_SET BCM6300_A0_SWMODEr_RESERVED_Rf_SET
#define READ_SWMODEr BCM6300_A0_READ_SWMODEr
#define WRITE_SWMODEr BCM6300_A0_WRITE_SWMODEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_SWMODEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_Pkts1024to1522Octets
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Rx 1024 to 1522 Bytes Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_PKTS1024TO1522OCTETSr 0x00007168

#define BCM6300_A0_S_PKTS1024TO1522OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts1024to1522Octets.
 *
 */
typedef union BCM6300_A0_S_PKTS1024TO1522OCTETSr_s {
	uint32_t v[1];
	uint32_t s_pkts1024to1522octets[1];
	uint32_t _s_pkts1024to1522octets;
} BCM6300_A0_S_PKTS1024TO1522OCTETSr_t;

#define BCM6300_A0_S_PKTS1024TO1522OCTETSr_CLR(r) (r).s_pkts1024to1522octets[0] = 0
#define BCM6300_A0_S_PKTS1024TO1522OCTETSr_SET(r,d) (r).s_pkts1024to1522octets[0] = d
#define BCM6300_A0_S_PKTS1024TO1522OCTETSr_GET(r) (r).s_pkts1024to1522octets[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_PKTS1024TO1522OCTETSr_COUNTSf_GET(r) ((r).s_pkts1024to1522octets[0])
#define BCM6300_A0_S_PKTS1024TO1522OCTETSr_COUNTSf_SET(r,f) (r).s_pkts1024to1522octets[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts1024to1522Octets.
 *
 */
#define BCM6300_A0_READ_S_PKTS1024TO1522OCTETSr(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_PKTS1024TO1522OCTETSr,(r._s_pkts1024to1522octets),4)
#define BCM6300_A0_WRITE_S_PKTS1024TO1522OCTETSr(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_PKTS1024TO1522OCTETSr,&(r._s_pkts1024to1522octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS1024TO1522OCTETSr BCM6300_A0_S_PKTS1024TO1522OCTETSr
#define S_PKTS1024TO1522OCTETSr_SIZE BCM6300_A0_S_PKTS1024TO1522OCTETSr_SIZE
typedef BCM6300_A0_S_PKTS1024TO1522OCTETSr_t S_PKTS1024TO1522OCTETSr_t;
#define S_PKTS1024TO1522OCTETSr_CLR BCM6300_A0_S_PKTS1024TO1522OCTETSr_CLR
#define S_PKTS1024TO1522OCTETSr_SET BCM6300_A0_S_PKTS1024TO1522OCTETSr_SET
#define S_PKTS1024TO1522OCTETSr_GET BCM6300_A0_S_PKTS1024TO1522OCTETSr_GET
#define S_PKTS1024TO1522OCTETSr_COUNTSf_GET BCM6300_A0_S_PKTS1024TO1522OCTETSr_COUNTSf_GET
#define S_PKTS1024TO1522OCTETSr_COUNTSf_SET BCM6300_A0_S_PKTS1024TO1522OCTETSr_COUNTSf_SET
#define READ_S_PKTS1024TO1522OCTETSr BCM6300_A0_READ_S_PKTS1024TO1522OCTETSr
#define WRITE_S_PKTS1024TO1522OCTETSr BCM6300_A0_WRITE_S_PKTS1024TO1522OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_PKTS1024TO1522OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_Pkts128to255Octets
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Rx 128 to 255 Bytes Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_PKTS128TO255OCTETSr 0x0000715c

#define BCM6300_A0_S_PKTS128TO255OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts128to255Octets.
 *
 */
typedef union BCM6300_A0_S_PKTS128TO255OCTETSr_s {
	uint32_t v[1];
	uint32_t s_pkts128to255octets[1];
	uint32_t _s_pkts128to255octets;
} BCM6300_A0_S_PKTS128TO255OCTETSr_t;

#define BCM6300_A0_S_PKTS128TO255OCTETSr_CLR(r) (r).s_pkts128to255octets[0] = 0
#define BCM6300_A0_S_PKTS128TO255OCTETSr_SET(r,d) (r).s_pkts128to255octets[0] = d
#define BCM6300_A0_S_PKTS128TO255OCTETSr_GET(r) (r).s_pkts128to255octets[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_PKTS128TO255OCTETSr_COUNTSf_GET(r) ((r).s_pkts128to255octets[0])
#define BCM6300_A0_S_PKTS128TO255OCTETSr_COUNTSf_SET(r,f) (r).s_pkts128to255octets[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts128to255Octets.
 *
 */
#define BCM6300_A0_READ_S_PKTS128TO255OCTETSr(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_PKTS128TO255OCTETSr,(r._s_pkts128to255octets),4)
#define BCM6300_A0_WRITE_S_PKTS128TO255OCTETSr(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_PKTS128TO255OCTETSr,&(r._s_pkts128to255octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS128TO255OCTETSr BCM6300_A0_S_PKTS128TO255OCTETSr
#define S_PKTS128TO255OCTETSr_SIZE BCM6300_A0_S_PKTS128TO255OCTETSr_SIZE
typedef BCM6300_A0_S_PKTS128TO255OCTETSr_t S_PKTS128TO255OCTETSr_t;
#define S_PKTS128TO255OCTETSr_CLR BCM6300_A0_S_PKTS128TO255OCTETSr_CLR
#define S_PKTS128TO255OCTETSr_SET BCM6300_A0_S_PKTS128TO255OCTETSr_SET
#define S_PKTS128TO255OCTETSr_GET BCM6300_A0_S_PKTS128TO255OCTETSr_GET
#define S_PKTS128TO255OCTETSr_COUNTSf_GET BCM6300_A0_S_PKTS128TO255OCTETSr_COUNTSf_GET
#define S_PKTS128TO255OCTETSr_COUNTSf_SET BCM6300_A0_S_PKTS128TO255OCTETSr_COUNTSf_SET
#define READ_S_PKTS128TO255OCTETSr BCM6300_A0_READ_S_PKTS128TO255OCTETSr
#define WRITE_S_PKTS128TO255OCTETSr BCM6300_A0_WRITE_S_PKTS128TO255OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_PKTS128TO255OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_Pkts1523to2047
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Packet Length 1523 to 2047 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_PKTS1523TO2047r 0x000071b0

#define BCM6300_A0_S_PKTS1523TO2047r_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts1523to2047.
 *
 */
typedef union BCM6300_A0_S_PKTS1523TO2047r_s {
	uint32_t v[1];
	uint32_t s_pkts1523to2047[1];
	uint32_t _s_pkts1523to2047;
} BCM6300_A0_S_PKTS1523TO2047r_t;

#define BCM6300_A0_S_PKTS1523TO2047r_CLR(r) (r).s_pkts1523to2047[0] = 0
#define BCM6300_A0_S_PKTS1523TO2047r_SET(r,d) (r).s_pkts1523to2047[0] = d
#define BCM6300_A0_S_PKTS1523TO2047r_GET(r) (r).s_pkts1523to2047[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_PKTS1523TO2047r_COUNTSf_GET(r) ((r).s_pkts1523to2047[0])
#define BCM6300_A0_S_PKTS1523TO2047r_COUNTSf_SET(r,f) (r).s_pkts1523to2047[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts1523to2047.
 *
 */
#define BCM6300_A0_READ_S_PKTS1523TO2047r(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_PKTS1523TO2047r,(r._s_pkts1523to2047),4)
#define BCM6300_A0_WRITE_S_PKTS1523TO2047r(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_PKTS1523TO2047r,&(r._s_pkts1523to2047),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS1523TO2047r BCM6300_A0_S_PKTS1523TO2047r
#define S_PKTS1523TO2047r_SIZE BCM6300_A0_S_PKTS1523TO2047r_SIZE
typedef BCM6300_A0_S_PKTS1523TO2047r_t S_PKTS1523TO2047r_t;
#define S_PKTS1523TO2047r_CLR BCM6300_A0_S_PKTS1523TO2047r_CLR
#define S_PKTS1523TO2047r_SET BCM6300_A0_S_PKTS1523TO2047r_SET
#define S_PKTS1523TO2047r_GET BCM6300_A0_S_PKTS1523TO2047r_GET
#define S_PKTS1523TO2047r_COUNTSf_GET BCM6300_A0_S_PKTS1523TO2047r_COUNTSf_GET
#define S_PKTS1523TO2047r_COUNTSf_SET BCM6300_A0_S_PKTS1523TO2047r_COUNTSf_SET
#define READ_S_PKTS1523TO2047r BCM6300_A0_READ_S_PKTS1523TO2047r
#define WRITE_S_PKTS1523TO2047r BCM6300_A0_WRITE_S_PKTS1523TO2047r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_PKTS1523TO2047r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_Pkts2048to4095
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Packet Length 2048 to 4095 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_PKTS2048TO4095r 0x000071b4

#define BCM6300_A0_S_PKTS2048TO4095r_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts2048to4095.
 *
 */
typedef union BCM6300_A0_S_PKTS2048TO4095r_s {
	uint32_t v[1];
	uint32_t s_pkts2048to4095[1];
	uint32_t _s_pkts2048to4095;
} BCM6300_A0_S_PKTS2048TO4095r_t;

#define BCM6300_A0_S_PKTS2048TO4095r_CLR(r) (r).s_pkts2048to4095[0] = 0
#define BCM6300_A0_S_PKTS2048TO4095r_SET(r,d) (r).s_pkts2048to4095[0] = d
#define BCM6300_A0_S_PKTS2048TO4095r_GET(r) (r).s_pkts2048to4095[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_PKTS2048TO4095r_COUNTSf_GET(r) ((r).s_pkts2048to4095[0])
#define BCM6300_A0_S_PKTS2048TO4095r_COUNTSf_SET(r,f) (r).s_pkts2048to4095[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts2048to4095.
 *
 */
#define BCM6300_A0_READ_S_PKTS2048TO4095r(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_PKTS2048TO4095r,(r._s_pkts2048to4095),4)
#define BCM6300_A0_WRITE_S_PKTS2048TO4095r(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_PKTS2048TO4095r,&(r._s_pkts2048to4095),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS2048TO4095r BCM6300_A0_S_PKTS2048TO4095r
#define S_PKTS2048TO4095r_SIZE BCM6300_A0_S_PKTS2048TO4095r_SIZE
typedef BCM6300_A0_S_PKTS2048TO4095r_t S_PKTS2048TO4095r_t;
#define S_PKTS2048TO4095r_CLR BCM6300_A0_S_PKTS2048TO4095r_CLR
#define S_PKTS2048TO4095r_SET BCM6300_A0_S_PKTS2048TO4095r_SET
#define S_PKTS2048TO4095r_GET BCM6300_A0_S_PKTS2048TO4095r_GET
#define S_PKTS2048TO4095r_COUNTSf_GET BCM6300_A0_S_PKTS2048TO4095r_COUNTSf_GET
#define S_PKTS2048TO4095r_COUNTSf_SET BCM6300_A0_S_PKTS2048TO4095r_COUNTSf_SET
#define READ_S_PKTS2048TO4095r BCM6300_A0_READ_S_PKTS2048TO4095r
#define WRITE_S_PKTS2048TO4095r BCM6300_A0_WRITE_S_PKTS2048TO4095r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_PKTS2048TO4095r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_Pkts256to511Octets
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Rx 256 to 511 Bytes Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_PKTS256TO511OCTETSr 0x00007160

#define BCM6300_A0_S_PKTS256TO511OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts256to511Octets.
 *
 */
typedef union BCM6300_A0_S_PKTS256TO511OCTETSr_s {
	uint32_t v[1];
	uint32_t s_pkts256to511octets[1];
	uint32_t _s_pkts256to511octets;
} BCM6300_A0_S_PKTS256TO511OCTETSr_t;

#define BCM6300_A0_S_PKTS256TO511OCTETSr_CLR(r) (r).s_pkts256to511octets[0] = 0
#define BCM6300_A0_S_PKTS256TO511OCTETSr_SET(r,d) (r).s_pkts256to511octets[0] = d
#define BCM6300_A0_S_PKTS256TO511OCTETSr_GET(r) (r).s_pkts256to511octets[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_PKTS256TO511OCTETSr_COUNTSf_GET(r) ((r).s_pkts256to511octets[0])
#define BCM6300_A0_S_PKTS256TO511OCTETSr_COUNTSf_SET(r,f) (r).s_pkts256to511octets[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts256to511Octets.
 *
 */
#define BCM6300_A0_READ_S_PKTS256TO511OCTETSr(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_PKTS256TO511OCTETSr,(r._s_pkts256to511octets),4)
#define BCM6300_A0_WRITE_S_PKTS256TO511OCTETSr(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_PKTS256TO511OCTETSr,&(r._s_pkts256to511octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS256TO511OCTETSr BCM6300_A0_S_PKTS256TO511OCTETSr
#define S_PKTS256TO511OCTETSr_SIZE BCM6300_A0_S_PKTS256TO511OCTETSr_SIZE
typedef BCM6300_A0_S_PKTS256TO511OCTETSr_t S_PKTS256TO511OCTETSr_t;
#define S_PKTS256TO511OCTETSr_CLR BCM6300_A0_S_PKTS256TO511OCTETSr_CLR
#define S_PKTS256TO511OCTETSr_SET BCM6300_A0_S_PKTS256TO511OCTETSr_SET
#define S_PKTS256TO511OCTETSr_GET BCM6300_A0_S_PKTS256TO511OCTETSr_GET
#define S_PKTS256TO511OCTETSr_COUNTSf_GET BCM6300_A0_S_PKTS256TO511OCTETSr_COUNTSf_GET
#define S_PKTS256TO511OCTETSr_COUNTSf_SET BCM6300_A0_S_PKTS256TO511OCTETSr_COUNTSf_SET
#define READ_S_PKTS256TO511OCTETSr BCM6300_A0_READ_S_PKTS256TO511OCTETSr
#define WRITE_S_PKTS256TO511OCTETSr BCM6300_A0_WRITE_S_PKTS256TO511OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_PKTS256TO511OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_Pkts4096to8191
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Packet Length 4096 to 8191 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_PKTS4096TO8191r 0x000071b8

#define BCM6300_A0_S_PKTS4096TO8191r_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts4096to8191.
 *
 */
typedef union BCM6300_A0_S_PKTS4096TO8191r_s {
	uint32_t v[1];
	uint32_t s_pkts4096to8191[1];
	uint32_t _s_pkts4096to8191;
} BCM6300_A0_S_PKTS4096TO8191r_t;

#define BCM6300_A0_S_PKTS4096TO8191r_CLR(r) (r).s_pkts4096to8191[0] = 0
#define BCM6300_A0_S_PKTS4096TO8191r_SET(r,d) (r).s_pkts4096to8191[0] = d
#define BCM6300_A0_S_PKTS4096TO8191r_GET(r) (r).s_pkts4096to8191[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_PKTS4096TO8191r_COUNTSf_GET(r) ((r).s_pkts4096to8191[0])
#define BCM6300_A0_S_PKTS4096TO8191r_COUNTSf_SET(r,f) (r).s_pkts4096to8191[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts4096to8191.
 *
 */
#define BCM6300_A0_READ_S_PKTS4096TO8191r(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_PKTS4096TO8191r,(r._s_pkts4096to8191),4)
#define BCM6300_A0_WRITE_S_PKTS4096TO8191r(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_PKTS4096TO8191r,&(r._s_pkts4096to8191),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS4096TO8191r BCM6300_A0_S_PKTS4096TO8191r
#define S_PKTS4096TO8191r_SIZE BCM6300_A0_S_PKTS4096TO8191r_SIZE
typedef BCM6300_A0_S_PKTS4096TO8191r_t S_PKTS4096TO8191r_t;
#define S_PKTS4096TO8191r_CLR BCM6300_A0_S_PKTS4096TO8191r_CLR
#define S_PKTS4096TO8191r_SET BCM6300_A0_S_PKTS4096TO8191r_SET
#define S_PKTS4096TO8191r_GET BCM6300_A0_S_PKTS4096TO8191r_GET
#define S_PKTS4096TO8191r_COUNTSf_GET BCM6300_A0_S_PKTS4096TO8191r_COUNTSf_GET
#define S_PKTS4096TO8191r_COUNTSf_SET BCM6300_A0_S_PKTS4096TO8191r_COUNTSf_SET
#define READ_S_PKTS4096TO8191r BCM6300_A0_READ_S_PKTS4096TO8191r
#define WRITE_S_PKTS4096TO8191r BCM6300_A0_WRITE_S_PKTS4096TO8191r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_PKTS4096TO8191r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_Pkts512to1023Octets
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Rx 512 to 1023 Bytes Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_PKTS512TO1023OCTETSr 0x00007164

#define BCM6300_A0_S_PKTS512TO1023OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts512to1023Octets.
 *
 */
typedef union BCM6300_A0_S_PKTS512TO1023OCTETSr_s {
	uint32_t v[1];
	uint32_t s_pkts512to1023octets[1];
	uint32_t _s_pkts512to1023octets;
} BCM6300_A0_S_PKTS512TO1023OCTETSr_t;

#define BCM6300_A0_S_PKTS512TO1023OCTETSr_CLR(r) (r).s_pkts512to1023octets[0] = 0
#define BCM6300_A0_S_PKTS512TO1023OCTETSr_SET(r,d) (r).s_pkts512to1023octets[0] = d
#define BCM6300_A0_S_PKTS512TO1023OCTETSr_GET(r) (r).s_pkts512to1023octets[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_PKTS512TO1023OCTETSr_COUNTSf_GET(r) ((r).s_pkts512to1023octets[0])
#define BCM6300_A0_S_PKTS512TO1023OCTETSr_COUNTSf_SET(r,f) (r).s_pkts512to1023octets[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts512to1023Octets.
 *
 */
#define BCM6300_A0_READ_S_PKTS512TO1023OCTETSr(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_PKTS512TO1023OCTETSr,(r._s_pkts512to1023octets),4)
#define BCM6300_A0_WRITE_S_PKTS512TO1023OCTETSr(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_PKTS512TO1023OCTETSr,&(r._s_pkts512to1023octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS512TO1023OCTETSr BCM6300_A0_S_PKTS512TO1023OCTETSr
#define S_PKTS512TO1023OCTETSr_SIZE BCM6300_A0_S_PKTS512TO1023OCTETSr_SIZE
typedef BCM6300_A0_S_PKTS512TO1023OCTETSr_t S_PKTS512TO1023OCTETSr_t;
#define S_PKTS512TO1023OCTETSr_CLR BCM6300_A0_S_PKTS512TO1023OCTETSr_CLR
#define S_PKTS512TO1023OCTETSr_SET BCM6300_A0_S_PKTS512TO1023OCTETSr_SET
#define S_PKTS512TO1023OCTETSr_GET BCM6300_A0_S_PKTS512TO1023OCTETSr_GET
#define S_PKTS512TO1023OCTETSr_COUNTSf_GET BCM6300_A0_S_PKTS512TO1023OCTETSr_COUNTSf_GET
#define S_PKTS512TO1023OCTETSr_COUNTSf_SET BCM6300_A0_S_PKTS512TO1023OCTETSr_COUNTSf_SET
#define READ_S_PKTS512TO1023OCTETSr BCM6300_A0_READ_S_PKTS512TO1023OCTETSr
#define WRITE_S_PKTS512TO1023OCTETSr BCM6300_A0_WRITE_S_PKTS512TO1023OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_PKTS512TO1023OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_Pkts64Octets
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Rx 64 Bytes Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_PKTS64OCTETSr 0x00007154

#define BCM6300_A0_S_PKTS64OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts64Octets.
 *
 */
typedef union BCM6300_A0_S_PKTS64OCTETSr_s {
	uint32_t v[1];
	uint32_t s_pkts64octets[1];
	uint32_t _s_pkts64octets;
} BCM6300_A0_S_PKTS64OCTETSr_t;

#define BCM6300_A0_S_PKTS64OCTETSr_CLR(r) (r).s_pkts64octets[0] = 0
#define BCM6300_A0_S_PKTS64OCTETSr_SET(r,d) (r).s_pkts64octets[0] = d
#define BCM6300_A0_S_PKTS64OCTETSr_GET(r) (r).s_pkts64octets[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_PKTS64OCTETSr_COUNTSf_GET(r) ((r).s_pkts64octets[0])
#define BCM6300_A0_S_PKTS64OCTETSr_COUNTSf_SET(r,f) (r).s_pkts64octets[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts64Octets.
 *
 */
#define BCM6300_A0_READ_S_PKTS64OCTETSr(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_PKTS64OCTETSr,(r._s_pkts64octets),4)
#define BCM6300_A0_WRITE_S_PKTS64OCTETSr(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_PKTS64OCTETSr,&(r._s_pkts64octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS64OCTETSr BCM6300_A0_S_PKTS64OCTETSr
#define S_PKTS64OCTETSr_SIZE BCM6300_A0_S_PKTS64OCTETSr_SIZE
typedef BCM6300_A0_S_PKTS64OCTETSr_t S_PKTS64OCTETSr_t;
#define S_PKTS64OCTETSr_CLR BCM6300_A0_S_PKTS64OCTETSr_CLR
#define S_PKTS64OCTETSr_SET BCM6300_A0_S_PKTS64OCTETSr_SET
#define S_PKTS64OCTETSr_GET BCM6300_A0_S_PKTS64OCTETSr_GET
#define S_PKTS64OCTETSr_COUNTSf_GET BCM6300_A0_S_PKTS64OCTETSr_COUNTSf_GET
#define S_PKTS64OCTETSr_COUNTSf_SET BCM6300_A0_S_PKTS64OCTETSr_COUNTSf_SET
#define READ_S_PKTS64OCTETSr BCM6300_A0_READ_S_PKTS64OCTETSr
#define WRITE_S_PKTS64OCTETSr BCM6300_A0_WRITE_S_PKTS64OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_PKTS64OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_Pkts65to127Octets
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Rx 65 to 127 Bytes Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_PKTS65TO127OCTETSr 0x00007158

#define BCM6300_A0_S_PKTS65TO127OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts65to127Octets.
 *
 */
typedef union BCM6300_A0_S_PKTS65TO127OCTETSr_s {
	uint32_t v[1];
	uint32_t s_pkts65to127octets[1];
	uint32_t _s_pkts65to127octets;
} BCM6300_A0_S_PKTS65TO127OCTETSr_t;

#define BCM6300_A0_S_PKTS65TO127OCTETSr_CLR(r) (r).s_pkts65to127octets[0] = 0
#define BCM6300_A0_S_PKTS65TO127OCTETSr_SET(r,d) (r).s_pkts65to127octets[0] = d
#define BCM6300_A0_S_PKTS65TO127OCTETSr_GET(r) (r).s_pkts65to127octets[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_PKTS65TO127OCTETSr_COUNTSf_GET(r) ((r).s_pkts65to127octets[0])
#define BCM6300_A0_S_PKTS65TO127OCTETSr_COUNTSf_SET(r,f) (r).s_pkts65to127octets[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts65to127Octets.
 *
 */
#define BCM6300_A0_READ_S_PKTS65TO127OCTETSr(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_PKTS65TO127OCTETSr,(r._s_pkts65to127octets),4)
#define BCM6300_A0_WRITE_S_PKTS65TO127OCTETSr(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_PKTS65TO127OCTETSr,&(r._s_pkts65to127octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS65TO127OCTETSr BCM6300_A0_S_PKTS65TO127OCTETSr
#define S_PKTS65TO127OCTETSr_SIZE BCM6300_A0_S_PKTS65TO127OCTETSr_SIZE
typedef BCM6300_A0_S_PKTS65TO127OCTETSr_t S_PKTS65TO127OCTETSr_t;
#define S_PKTS65TO127OCTETSr_CLR BCM6300_A0_S_PKTS65TO127OCTETSr_CLR
#define S_PKTS65TO127OCTETSr_SET BCM6300_A0_S_PKTS65TO127OCTETSr_SET
#define S_PKTS65TO127OCTETSr_GET BCM6300_A0_S_PKTS65TO127OCTETSr_GET
#define S_PKTS65TO127OCTETSr_COUNTSf_GET BCM6300_A0_S_PKTS65TO127OCTETSr_COUNTSf_GET
#define S_PKTS65TO127OCTETSr_COUNTSf_SET BCM6300_A0_S_PKTS65TO127OCTETSr_COUNTSf_SET
#define READ_S_PKTS65TO127OCTETSr BCM6300_A0_READ_S_PKTS65TO127OCTETSr
#define WRITE_S_PKTS65TO127OCTETSr BCM6300_A0_WRITE_S_PKTS65TO127OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_PKTS65TO127OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_Pkts8192to9728
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Packet Length 8192 to 9728 Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_PKTS8192TO9728r 0x000071bc

#define BCM6300_A0_S_PKTS8192TO9728r_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts8192to9728.
 *
 */
typedef union BCM6300_A0_S_PKTS8192TO9728r_s {
	uint32_t v[1];
	uint32_t s_pkts8192to9728[1];
	uint32_t _s_pkts8192to9728;
} BCM6300_A0_S_PKTS8192TO9728r_t;

#define BCM6300_A0_S_PKTS8192TO9728r_CLR(r) (r).s_pkts8192to9728[0] = 0
#define BCM6300_A0_S_PKTS8192TO9728r_SET(r,d) (r).s_pkts8192to9728[0] = d
#define BCM6300_A0_S_PKTS8192TO9728r_GET(r) (r).s_pkts8192to9728[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_PKTS8192TO9728r_COUNTSf_GET(r) ((r).s_pkts8192to9728[0])
#define BCM6300_A0_S_PKTS8192TO9728r_COUNTSf_SET(r,f) (r).s_pkts8192to9728[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts8192to9728.
 *
 */
#define BCM6300_A0_READ_S_PKTS8192TO9728r(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_PKTS8192TO9728r,(r._s_pkts8192to9728),4)
#define BCM6300_A0_WRITE_S_PKTS8192TO9728r(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_PKTS8192TO9728r,&(r._s_pkts8192to9728),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS8192TO9728r BCM6300_A0_S_PKTS8192TO9728r
#define S_PKTS8192TO9728r_SIZE BCM6300_A0_S_PKTS8192TO9728r_SIZE
typedef BCM6300_A0_S_PKTS8192TO9728r_t S_PKTS8192TO9728r_t;
#define S_PKTS8192TO9728r_CLR BCM6300_A0_S_PKTS8192TO9728r_CLR
#define S_PKTS8192TO9728r_SET BCM6300_A0_S_PKTS8192TO9728r_SET
#define S_PKTS8192TO9728r_GET BCM6300_A0_S_PKTS8192TO9728r_GET
#define S_PKTS8192TO9728r_COUNTSf_GET BCM6300_A0_S_PKTS8192TO9728r_COUNTSf_GET
#define S_PKTS8192TO9728r_COUNTSf_SET BCM6300_A0_S_PKTS8192TO9728r_COUNTSf_SET
#define READ_S_PKTS8192TO9728r BCM6300_A0_READ_S_PKTS8192TO9728r
#define WRITE_S_PKTS8192TO9728r BCM6300_A0_WRITE_S_PKTS8192TO9728r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_PKTS8192TO9728r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_RXSymblErr
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Rx Symbol Error Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_RXSYMBLERRr 0x000071a0

#define BCM6300_A0_S_RXSYMBLERRr_SIZE 4

/*
 * This structure should be used to declare and program S_RXSymblErr.
 *
 */
typedef union BCM6300_A0_S_RXSYMBLERRr_s {
	uint32_t v[1];
	uint32_t s_rxsymblerr[1];
	uint32_t _s_rxsymblerr;
} BCM6300_A0_S_RXSYMBLERRr_t;

#define BCM6300_A0_S_RXSYMBLERRr_CLR(r) (r).s_rxsymblerr[0] = 0
#define BCM6300_A0_S_RXSYMBLERRr_SET(r,d) (r).s_rxsymblerr[0] = d
#define BCM6300_A0_S_RXSYMBLERRr_GET(r) (r).s_rxsymblerr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_RXSYMBLERRr_COUNTSf_GET(r) ((r).s_rxsymblerr[0])
#define BCM6300_A0_S_RXSYMBLERRr_COUNTSf_SET(r,f) (r).s_rxsymblerr[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RXSymblErr.
 *
 */
#define BCM6300_A0_READ_S_RXSYMBLERRr(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_RXSYMBLERRr,(r._s_rxsymblerr),4)
#define BCM6300_A0_WRITE_S_RXSYMBLERRr(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_RXSYMBLERRr,&(r._s_rxsymblerr),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXSYMBLERRr BCM6300_A0_S_RXSYMBLERRr
#define S_RXSYMBLERRr_SIZE BCM6300_A0_S_RXSYMBLERRr_SIZE
typedef BCM6300_A0_S_RXSYMBLERRr_t S_RXSYMBLERRr_t;
#define S_RXSYMBLERRr_CLR BCM6300_A0_S_RXSYMBLERRr_CLR
#define S_RXSYMBLERRr_SET BCM6300_A0_S_RXSYMBLERRr_SET
#define S_RXSYMBLERRr_GET BCM6300_A0_S_RXSYMBLERRr_GET
#define S_RXSYMBLERRr_COUNTSf_GET BCM6300_A0_S_RXSYMBLERRr_COUNTSf_GET
#define S_RXSYMBLERRr_COUNTSf_SET BCM6300_A0_S_RXSYMBLERRr_COUNTSf_SET
#define READ_S_RXSYMBLERRr BCM6300_A0_READ_S_RXSYMBLERRr
#define WRITE_S_RXSYMBLERRr BCM6300_A0_WRITE_S_RXSYMBLERRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_RXSYMBLERRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_RxAlignmentErrors
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Rx Alignment Error Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_RXALIGNMENTERRORSr 0x00007174

#define BCM6300_A0_S_RXALIGNMENTERRORSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxAlignmentErrors.
 *
 */
typedef union BCM6300_A0_S_RXALIGNMENTERRORSr_s {
	uint32_t v[1];
	uint32_t s_rxalignmenterrors[1];
	uint32_t _s_rxalignmenterrors;
} BCM6300_A0_S_RXALIGNMENTERRORSr_t;

#define BCM6300_A0_S_RXALIGNMENTERRORSr_CLR(r) (r).s_rxalignmenterrors[0] = 0
#define BCM6300_A0_S_RXALIGNMENTERRORSr_SET(r,d) (r).s_rxalignmenterrors[0] = d
#define BCM6300_A0_S_RXALIGNMENTERRORSr_GET(r) (r).s_rxalignmenterrors[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_RXALIGNMENTERRORSr_COUNTSf_GET(r) ((r).s_rxalignmenterrors[0])
#define BCM6300_A0_S_RXALIGNMENTERRORSr_COUNTSf_SET(r,f) (r).s_rxalignmenterrors[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxAlignmentErrors.
 *
 */
#define BCM6300_A0_READ_S_RXALIGNMENTERRORSr(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_RXALIGNMENTERRORSr,(r._s_rxalignmenterrors),4)
#define BCM6300_A0_WRITE_S_RXALIGNMENTERRORSr(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_RXALIGNMENTERRORSr,&(r._s_rxalignmenterrors),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXALIGNMENTERRORSr BCM6300_A0_S_RXALIGNMENTERRORSr
#define S_RXALIGNMENTERRORSr_SIZE BCM6300_A0_S_RXALIGNMENTERRORSr_SIZE
typedef BCM6300_A0_S_RXALIGNMENTERRORSr_t S_RXALIGNMENTERRORSr_t;
#define S_RXALIGNMENTERRORSr_CLR BCM6300_A0_S_RXALIGNMENTERRORSr_CLR
#define S_RXALIGNMENTERRORSr_SET BCM6300_A0_S_RXALIGNMENTERRORSr_SET
#define S_RXALIGNMENTERRORSr_GET BCM6300_A0_S_RXALIGNMENTERRORSr_GET
#define S_RXALIGNMENTERRORSr_COUNTSf_GET BCM6300_A0_S_RXALIGNMENTERRORSr_COUNTSf_GET
#define S_RXALIGNMENTERRORSr_COUNTSf_SET BCM6300_A0_S_RXALIGNMENTERRORSr_COUNTSf_SET
#define READ_S_RXALIGNMENTERRORSr BCM6300_A0_READ_S_RXALIGNMENTERRORSr
#define WRITE_S_RXALIGNMENTERRORSr BCM6300_A0_WRITE_S_RXALIGNMENTERRORSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_RXALIGNMENTERRORSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_RxBroadcastPkt
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Rx Broadcast Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_RXBROADCASTPKTr 0x00007190

#define BCM6300_A0_S_RXBROADCASTPKTr_SIZE 4

/*
 * This structure should be used to declare and program S_RxBroadcastPkt.
 *
 */
typedef union BCM6300_A0_S_RXBROADCASTPKTr_s {
	uint32_t v[1];
	uint32_t s_rxbroadcastpkt[1];
	uint32_t _s_rxbroadcastpkt;
} BCM6300_A0_S_RXBROADCASTPKTr_t;

#define BCM6300_A0_S_RXBROADCASTPKTr_CLR(r) (r).s_rxbroadcastpkt[0] = 0
#define BCM6300_A0_S_RXBROADCASTPKTr_SET(r,d) (r).s_rxbroadcastpkt[0] = d
#define BCM6300_A0_S_RXBROADCASTPKTr_GET(r) (r).s_rxbroadcastpkt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_RXBROADCASTPKTr_COUNTSf_GET(r) ((r).s_rxbroadcastpkt[0])
#define BCM6300_A0_S_RXBROADCASTPKTr_COUNTSf_SET(r,f) (r).s_rxbroadcastpkt[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxBroadcastPkt.
 *
 */
#define BCM6300_A0_READ_S_RXBROADCASTPKTr(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_RXBROADCASTPKTr,(r._s_rxbroadcastpkt),4)
#define BCM6300_A0_WRITE_S_RXBROADCASTPKTr(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_RXBROADCASTPKTr,&(r._s_rxbroadcastpkt),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXBROADCASTPKTr BCM6300_A0_S_RXBROADCASTPKTr
#define S_RXBROADCASTPKTr_SIZE BCM6300_A0_S_RXBROADCASTPKTr_SIZE
typedef BCM6300_A0_S_RXBROADCASTPKTr_t S_RXBROADCASTPKTr_t;
#define S_RXBROADCASTPKTr_CLR BCM6300_A0_S_RXBROADCASTPKTr_CLR
#define S_RXBROADCASTPKTr_SET BCM6300_A0_S_RXBROADCASTPKTr_SET
#define S_RXBROADCASTPKTr_GET BCM6300_A0_S_RXBROADCASTPKTr_GET
#define S_RXBROADCASTPKTr_COUNTSf_GET BCM6300_A0_S_RXBROADCASTPKTr_COUNTSf_GET
#define S_RXBROADCASTPKTr_COUNTSf_SET BCM6300_A0_S_RXBROADCASTPKTr_COUNTSf_SET
#define READ_S_RXBROADCASTPKTr BCM6300_A0_READ_S_RXBROADCASTPKTr
#define WRITE_S_RXBROADCASTPKTr BCM6300_A0_WRITE_S_RXBROADCASTPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_RXBROADCASTPKTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_RxDropPkts
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Rx Drop Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_RXDROPPKTSr 0x00007184

#define BCM6300_A0_S_RXDROPPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxDropPkts.
 *
 */
typedef union BCM6300_A0_S_RXDROPPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxdroppkts[1];
	uint32_t _s_rxdroppkts;
} BCM6300_A0_S_RXDROPPKTSr_t;

#define BCM6300_A0_S_RXDROPPKTSr_CLR(r) (r).s_rxdroppkts[0] = 0
#define BCM6300_A0_S_RXDROPPKTSr_SET(r,d) (r).s_rxdroppkts[0] = d
#define BCM6300_A0_S_RXDROPPKTSr_GET(r) (r).s_rxdroppkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_RXDROPPKTSr_COUNTSf_GET(r) ((r).s_rxdroppkts[0])
#define BCM6300_A0_S_RXDROPPKTSr_COUNTSf_SET(r,f) (r).s_rxdroppkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxDropPkts.
 *
 */
#define BCM6300_A0_READ_S_RXDROPPKTSr(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_RXDROPPKTSr,(r._s_rxdroppkts),4)
#define BCM6300_A0_WRITE_S_RXDROPPKTSr(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_RXDROPPKTSr,&(r._s_rxdroppkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXDROPPKTSr BCM6300_A0_S_RXDROPPKTSr
#define S_RXDROPPKTSr_SIZE BCM6300_A0_S_RXDROPPKTSr_SIZE
typedef BCM6300_A0_S_RXDROPPKTSr_t S_RXDROPPKTSr_t;
#define S_RXDROPPKTSr_CLR BCM6300_A0_S_RXDROPPKTSr_CLR
#define S_RXDROPPKTSr_SET BCM6300_A0_S_RXDROPPKTSr_SET
#define S_RXDROPPKTSr_GET BCM6300_A0_S_RXDROPPKTSr_GET
#define S_RXDROPPKTSr_COUNTSf_GET BCM6300_A0_S_RXDROPPKTSr_COUNTSf_GET
#define S_RXDROPPKTSr_COUNTSf_SET BCM6300_A0_S_RXDROPPKTSr_COUNTSf_SET
#define READ_S_RXDROPPKTSr BCM6300_A0_READ_S_RXDROPPKTSr
#define WRITE_S_RXDROPPKTSr BCM6300_A0_WRITE_S_RXDROPPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_RXDROPPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_RxExcessSizeDisc
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Rx Excess Size Disc Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_RXEXCESSSIZEDISCr 0x0000719c

#define BCM6300_A0_S_RXEXCESSSIZEDISCr_SIZE 4

/*
 * This structure should be used to declare and program S_RxExcessSizeDisc.
 *
 */
typedef union BCM6300_A0_S_RXEXCESSSIZEDISCr_s {
	uint32_t v[1];
	uint32_t s_rxexcesssizedisc[1];
	uint32_t _s_rxexcesssizedisc;
} BCM6300_A0_S_RXEXCESSSIZEDISCr_t;

#define BCM6300_A0_S_RXEXCESSSIZEDISCr_CLR(r) (r).s_rxexcesssizedisc[0] = 0
#define BCM6300_A0_S_RXEXCESSSIZEDISCr_SET(r,d) (r).s_rxexcesssizedisc[0] = d
#define BCM6300_A0_S_RXEXCESSSIZEDISCr_GET(r) (r).s_rxexcesssizedisc[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_RXEXCESSSIZEDISCr_COUNTSf_GET(r) ((r).s_rxexcesssizedisc[0])
#define BCM6300_A0_S_RXEXCESSSIZEDISCr_COUNTSf_SET(r,f) (r).s_rxexcesssizedisc[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxExcessSizeDisc.
 *
 */
#define BCM6300_A0_READ_S_RXEXCESSSIZEDISCr(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_RXEXCESSSIZEDISCr,(r._s_rxexcesssizedisc),4)
#define BCM6300_A0_WRITE_S_RXEXCESSSIZEDISCr(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_RXEXCESSSIZEDISCr,&(r._s_rxexcesssizedisc),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXEXCESSSIZEDISCr BCM6300_A0_S_RXEXCESSSIZEDISCr
#define S_RXEXCESSSIZEDISCr_SIZE BCM6300_A0_S_RXEXCESSSIZEDISCr_SIZE
typedef BCM6300_A0_S_RXEXCESSSIZEDISCr_t S_RXEXCESSSIZEDISCr_t;
#define S_RXEXCESSSIZEDISCr_CLR BCM6300_A0_S_RXEXCESSSIZEDISCr_CLR
#define S_RXEXCESSSIZEDISCr_SET BCM6300_A0_S_RXEXCESSSIZEDISCr_SET
#define S_RXEXCESSSIZEDISCr_GET BCM6300_A0_S_RXEXCESSSIZEDISCr_GET
#define S_RXEXCESSSIZEDISCr_COUNTSf_GET BCM6300_A0_S_RXEXCESSSIZEDISCr_COUNTSf_GET
#define S_RXEXCESSSIZEDISCr_COUNTSf_SET BCM6300_A0_S_RXEXCESSSIZEDISCr_COUNTSf_SET
#define READ_S_RXEXCESSSIZEDISCr BCM6300_A0_READ_S_RXEXCESSSIZEDISCr
#define WRITE_S_RXEXCESSSIZEDISCr BCM6300_A0_WRITE_S_RXEXCESSSIZEDISCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_RXEXCESSSIZEDISCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_RxFCSErrors
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Rx FCS Error Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_RXFCSERRORSr 0x00007178

#define BCM6300_A0_S_RXFCSERRORSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxFCSErrors.
 *
 */
typedef union BCM6300_A0_S_RXFCSERRORSr_s {
	uint32_t v[1];
	uint32_t s_rxfcserrors[1];
	uint32_t _s_rxfcserrors;
} BCM6300_A0_S_RXFCSERRORSr_t;

#define BCM6300_A0_S_RXFCSERRORSr_CLR(r) (r).s_rxfcserrors[0] = 0
#define BCM6300_A0_S_RXFCSERRORSr_SET(r,d) (r).s_rxfcserrors[0] = d
#define BCM6300_A0_S_RXFCSERRORSr_GET(r) (r).s_rxfcserrors[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_RXFCSERRORSr_COUNTSf_GET(r) ((r).s_rxfcserrors[0])
#define BCM6300_A0_S_RXFCSERRORSr_COUNTSf_SET(r,f) (r).s_rxfcserrors[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxFCSErrors.
 *
 */
#define BCM6300_A0_READ_S_RXFCSERRORSr(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_RXFCSERRORSr,(r._s_rxfcserrors),4)
#define BCM6300_A0_WRITE_S_RXFCSERRORSr(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_RXFCSERRORSr,&(r._s_rxfcserrors),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXFCSERRORSr BCM6300_A0_S_RXFCSERRORSr
#define S_RXFCSERRORSr_SIZE BCM6300_A0_S_RXFCSERRORSr_SIZE
typedef BCM6300_A0_S_RXFCSERRORSr_t S_RXFCSERRORSr_t;
#define S_RXFCSERRORSr_CLR BCM6300_A0_S_RXFCSERRORSr_CLR
#define S_RXFCSERRORSr_SET BCM6300_A0_S_RXFCSERRORSr_SET
#define S_RXFCSERRORSr_GET BCM6300_A0_S_RXFCSERRORSr_GET
#define S_RXFCSERRORSr_COUNTSf_GET BCM6300_A0_S_RXFCSERRORSr_COUNTSf_GET
#define S_RXFCSERRORSr_COUNTSf_SET BCM6300_A0_S_RXFCSERRORSr_COUNTSf_SET
#define READ_S_RXFCSERRORSr BCM6300_A0_READ_S_RXFCSERRORSr
#define WRITE_S_RXFCSERRORSr BCM6300_A0_WRITE_S_RXFCSERRORSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_RXFCSERRORSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_RxFragments
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Rx Fragment Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_RXFRAGMENTSr 0x00007198

#define BCM6300_A0_S_RXFRAGMENTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxFragments.
 *
 */
typedef union BCM6300_A0_S_RXFRAGMENTSr_s {
	uint32_t v[1];
	uint32_t s_rxfragments[1];
	uint32_t _s_rxfragments;
} BCM6300_A0_S_RXFRAGMENTSr_t;

#define BCM6300_A0_S_RXFRAGMENTSr_CLR(r) (r).s_rxfragments[0] = 0
#define BCM6300_A0_S_RXFRAGMENTSr_SET(r,d) (r).s_rxfragments[0] = d
#define BCM6300_A0_S_RXFRAGMENTSr_GET(r) (r).s_rxfragments[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_RXFRAGMENTSr_COUNTSf_GET(r) ((r).s_rxfragments[0])
#define BCM6300_A0_S_RXFRAGMENTSr_COUNTSf_SET(r,f) (r).s_rxfragments[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxFragments.
 *
 */
#define BCM6300_A0_READ_S_RXFRAGMENTSr(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_RXFRAGMENTSr,(r._s_rxfragments),4)
#define BCM6300_A0_WRITE_S_RXFRAGMENTSr(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_RXFRAGMENTSr,&(r._s_rxfragments),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXFRAGMENTSr BCM6300_A0_S_RXFRAGMENTSr
#define S_RXFRAGMENTSr_SIZE BCM6300_A0_S_RXFRAGMENTSr_SIZE
typedef BCM6300_A0_S_RXFRAGMENTSr_t S_RXFRAGMENTSr_t;
#define S_RXFRAGMENTSr_CLR BCM6300_A0_S_RXFRAGMENTSr_CLR
#define S_RXFRAGMENTSr_SET BCM6300_A0_S_RXFRAGMENTSr_SET
#define S_RXFRAGMENTSr_GET BCM6300_A0_S_RXFRAGMENTSr_GET
#define S_RXFRAGMENTSr_COUNTSf_GET BCM6300_A0_S_RXFRAGMENTSr_COUNTSf_GET
#define S_RXFRAGMENTSr_COUNTSf_SET BCM6300_A0_S_RXFRAGMENTSr_COUNTSf_SET
#define READ_S_RXFRAGMENTSr BCM6300_A0_READ_S_RXFRAGMENTSr
#define WRITE_S_RXFRAGMENTSr BCM6300_A0_WRITE_S_RXFRAGMENTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_RXFRAGMENTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_RxGoodOctets
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Rx Good Packet Octet Counter
 * SIZE:     64
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_RXGOODOCTETSr 0x0000717c

#define BCM6300_A0_S_RXGOODOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program S_RxGoodOctets.
 *
 */
typedef union BCM6300_A0_S_RXGOODOCTETSr_s {
	uint32_t v[2];
	uint32_t s_rxgoodoctets[2];
	uint32_t _s_rxgoodoctets;
} BCM6300_A0_S_RXGOODOCTETSr_t;

#define BCM6300_A0_S_RXGOODOCTETSr_CLR(r) CDK_MEMSET(&((r)._s_rxgoodoctets), 0, sizeof(BCM6300_A0_S_RXGOODOCTETSr_t))
#define BCM6300_A0_S_RXGOODOCTETSr_SET(r,i,d) (r).s_rxgoodoctets[i] = d
#define BCM6300_A0_S_RXGOODOCTETSr_GET(r,i) (r).s_rxgoodoctets[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_RXGOODOCTETSr_COUNTSf_GET(r,a) cdk_field_get((r).s_rxgoodoctets,0,63,a)
#define BCM6300_A0_S_RXGOODOCTETSr_COUNTSf_SET(r,a) cdk_field_set((r).s_rxgoodoctets,0,63,a)

/*
 * These macros can be used to access S_RxGoodOctets.
 *
 */
#define BCM6300_A0_READ_S_RXGOODOCTETSr(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_RXGOODOCTETSr,(r._s_rxgoodoctets),8)
#define BCM6300_A0_WRITE_S_RXGOODOCTETSr(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_RXGOODOCTETSr,&(r._s_rxgoodoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXGOODOCTETSr BCM6300_A0_S_RXGOODOCTETSr
#define S_RXGOODOCTETSr_SIZE BCM6300_A0_S_RXGOODOCTETSr_SIZE
typedef BCM6300_A0_S_RXGOODOCTETSr_t S_RXGOODOCTETSr_t;
#define S_RXGOODOCTETSr_CLR BCM6300_A0_S_RXGOODOCTETSr_CLR
#define S_RXGOODOCTETSr_SET BCM6300_A0_S_RXGOODOCTETSr_SET
#define S_RXGOODOCTETSr_GET BCM6300_A0_S_RXGOODOCTETSr_GET
#define S_RXGOODOCTETSr_COUNTSf_GET BCM6300_A0_S_RXGOODOCTETSr_COUNTSf_GET
#define S_RXGOODOCTETSr_COUNTSf_SET BCM6300_A0_S_RXGOODOCTETSr_COUNTSf_SET
#define READ_S_RXGOODOCTETSr BCM6300_A0_READ_S_RXGOODOCTETSr
#define WRITE_S_RXGOODOCTETSr BCM6300_A0_WRITE_S_RXGOODOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_RXGOODOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_RxJabbers
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Rx Jabber Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_RXJABBERSr 0x00007170

#define BCM6300_A0_S_RXJABBERSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxJabbers.
 *
 */
typedef union BCM6300_A0_S_RXJABBERSr_s {
	uint32_t v[1];
	uint32_t s_rxjabbers[1];
	uint32_t _s_rxjabbers;
} BCM6300_A0_S_RXJABBERSr_t;

#define BCM6300_A0_S_RXJABBERSr_CLR(r) (r).s_rxjabbers[0] = 0
#define BCM6300_A0_S_RXJABBERSr_SET(r,d) (r).s_rxjabbers[0] = d
#define BCM6300_A0_S_RXJABBERSr_GET(r) (r).s_rxjabbers[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_RXJABBERSr_COUNTSf_GET(r) ((r).s_rxjabbers[0])
#define BCM6300_A0_S_RXJABBERSr_COUNTSf_SET(r,f) (r).s_rxjabbers[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxJabbers.
 *
 */
#define BCM6300_A0_READ_S_RXJABBERSr(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_RXJABBERSr,(r._s_rxjabbers),4)
#define BCM6300_A0_WRITE_S_RXJABBERSr(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_RXJABBERSr,&(r._s_rxjabbers),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXJABBERSr BCM6300_A0_S_RXJABBERSr
#define S_RXJABBERSr_SIZE BCM6300_A0_S_RXJABBERSr_SIZE
typedef BCM6300_A0_S_RXJABBERSr_t S_RXJABBERSr_t;
#define S_RXJABBERSr_CLR BCM6300_A0_S_RXJABBERSr_CLR
#define S_RXJABBERSr_SET BCM6300_A0_S_RXJABBERSr_SET
#define S_RXJABBERSr_GET BCM6300_A0_S_RXJABBERSr_GET
#define S_RXJABBERSr_COUNTSf_GET BCM6300_A0_S_RXJABBERSr_COUNTSf_GET
#define S_RXJABBERSr_COUNTSf_SET BCM6300_A0_S_RXJABBERSr_COUNTSf_SET
#define READ_S_RXJABBERSr BCM6300_A0_READ_S_RXJABBERSr
#define WRITE_S_RXJABBERSr BCM6300_A0_WRITE_S_RXJABBERSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_RXJABBERSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_RxMulticastPkts
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Rx Multicast Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_RXMULTICASTPKTSr 0x0000718c

#define BCM6300_A0_S_RXMULTICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxMulticastPkts.
 *
 */
typedef union BCM6300_A0_S_RXMULTICASTPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxmulticastpkts[1];
	uint32_t _s_rxmulticastpkts;
} BCM6300_A0_S_RXMULTICASTPKTSr_t;

#define BCM6300_A0_S_RXMULTICASTPKTSr_CLR(r) (r).s_rxmulticastpkts[0] = 0
#define BCM6300_A0_S_RXMULTICASTPKTSr_SET(r,d) (r).s_rxmulticastpkts[0] = d
#define BCM6300_A0_S_RXMULTICASTPKTSr_GET(r) (r).s_rxmulticastpkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_RXMULTICASTPKTSr_COUNTSf_GET(r) ((r).s_rxmulticastpkts[0])
#define BCM6300_A0_S_RXMULTICASTPKTSr_COUNTSf_SET(r,f) (r).s_rxmulticastpkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxMulticastPkts.
 *
 */
#define BCM6300_A0_READ_S_RXMULTICASTPKTSr(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_RXMULTICASTPKTSr,(r._s_rxmulticastpkts),4)
#define BCM6300_A0_WRITE_S_RXMULTICASTPKTSr(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_RXMULTICASTPKTSr,&(r._s_rxmulticastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXMULTICASTPKTSr BCM6300_A0_S_RXMULTICASTPKTSr
#define S_RXMULTICASTPKTSr_SIZE BCM6300_A0_S_RXMULTICASTPKTSr_SIZE
typedef BCM6300_A0_S_RXMULTICASTPKTSr_t S_RXMULTICASTPKTSr_t;
#define S_RXMULTICASTPKTSr_CLR BCM6300_A0_S_RXMULTICASTPKTSr_CLR
#define S_RXMULTICASTPKTSr_SET BCM6300_A0_S_RXMULTICASTPKTSr_SET
#define S_RXMULTICASTPKTSr_GET BCM6300_A0_S_RXMULTICASTPKTSr_GET
#define S_RXMULTICASTPKTSr_COUNTSf_GET BCM6300_A0_S_RXMULTICASTPKTSr_COUNTSf_GET
#define S_RXMULTICASTPKTSr_COUNTSf_SET BCM6300_A0_S_RXMULTICASTPKTSr_COUNTSf_SET
#define READ_S_RXMULTICASTPKTSr BCM6300_A0_READ_S_RXMULTICASTPKTSr
#define WRITE_S_RXMULTICASTPKTSr BCM6300_A0_WRITE_S_RXMULTICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_RXMULTICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_RxOctets
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Rx Packet Octets Counter
 * SIZE:     64
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_RXOCTETSr 0x00007144

#define BCM6300_A0_S_RXOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program S_RxOctets.
 *
 */
typedef union BCM6300_A0_S_RXOCTETSr_s {
	uint32_t v[2];
	uint32_t s_rxoctets[2];
	uint32_t _s_rxoctets;
} BCM6300_A0_S_RXOCTETSr_t;

#define BCM6300_A0_S_RXOCTETSr_CLR(r) CDK_MEMSET(&((r)._s_rxoctets), 0, sizeof(BCM6300_A0_S_RXOCTETSr_t))
#define BCM6300_A0_S_RXOCTETSr_SET(r,i,d) (r).s_rxoctets[i] = d
#define BCM6300_A0_S_RXOCTETSr_GET(r,i) (r).s_rxoctets[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_RXOCTETSr_COUNTSf_GET(r,a) cdk_field_get((r).s_rxoctets,0,63,a)
#define BCM6300_A0_S_RXOCTETSr_COUNTSf_SET(r,a) cdk_field_set((r).s_rxoctets,0,63,a)

/*
 * These macros can be used to access S_RxOctets.
 *
 */
#define BCM6300_A0_READ_S_RXOCTETSr(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_RXOCTETSr,(r._s_rxoctets),8)
#define BCM6300_A0_WRITE_S_RXOCTETSr(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_RXOCTETSr,&(r._s_rxoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXOCTETSr BCM6300_A0_S_RXOCTETSr
#define S_RXOCTETSr_SIZE BCM6300_A0_S_RXOCTETSr_SIZE
typedef BCM6300_A0_S_RXOCTETSr_t S_RXOCTETSr_t;
#define S_RXOCTETSr_CLR BCM6300_A0_S_RXOCTETSr_CLR
#define S_RXOCTETSr_SET BCM6300_A0_S_RXOCTETSr_SET
#define S_RXOCTETSr_GET BCM6300_A0_S_RXOCTETSr_GET
#define S_RXOCTETSr_COUNTSf_GET BCM6300_A0_S_RXOCTETSr_COUNTSf_GET
#define S_RXOCTETSr_COUNTSf_SET BCM6300_A0_S_RXOCTETSr_COUNTSf_SET
#define READ_S_RXOCTETSr BCM6300_A0_READ_S_RXOCTETSr
#define WRITE_S_RXOCTETSr BCM6300_A0_WRITE_S_RXOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_RXOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_RxOversizePkts
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Rx Over Size Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_RXOVERSIZEPKTSr 0x0000716c

#define BCM6300_A0_S_RXOVERSIZEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxOversizePkts.
 *
 */
typedef union BCM6300_A0_S_RXOVERSIZEPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxoversizepkts[1];
	uint32_t _s_rxoversizepkts;
} BCM6300_A0_S_RXOVERSIZEPKTSr_t;

#define BCM6300_A0_S_RXOVERSIZEPKTSr_CLR(r) (r).s_rxoversizepkts[0] = 0
#define BCM6300_A0_S_RXOVERSIZEPKTSr_SET(r,d) (r).s_rxoversizepkts[0] = d
#define BCM6300_A0_S_RXOVERSIZEPKTSr_GET(r) (r).s_rxoversizepkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_RXOVERSIZEPKTSr_COUNTSf_GET(r) ((r).s_rxoversizepkts[0])
#define BCM6300_A0_S_RXOVERSIZEPKTSr_COUNTSf_SET(r,f) (r).s_rxoversizepkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxOversizePkts.
 *
 */
#define BCM6300_A0_READ_S_RXOVERSIZEPKTSr(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_RXOVERSIZEPKTSr,(r._s_rxoversizepkts),4)
#define BCM6300_A0_WRITE_S_RXOVERSIZEPKTSr(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_RXOVERSIZEPKTSr,&(r._s_rxoversizepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXOVERSIZEPKTSr BCM6300_A0_S_RXOVERSIZEPKTSr
#define S_RXOVERSIZEPKTSr_SIZE BCM6300_A0_S_RXOVERSIZEPKTSr_SIZE
typedef BCM6300_A0_S_RXOVERSIZEPKTSr_t S_RXOVERSIZEPKTSr_t;
#define S_RXOVERSIZEPKTSr_CLR BCM6300_A0_S_RXOVERSIZEPKTSr_CLR
#define S_RXOVERSIZEPKTSr_SET BCM6300_A0_S_RXOVERSIZEPKTSr_SET
#define S_RXOVERSIZEPKTSr_GET BCM6300_A0_S_RXOVERSIZEPKTSr_GET
#define S_RXOVERSIZEPKTSr_COUNTSf_GET BCM6300_A0_S_RXOVERSIZEPKTSr_COUNTSf_GET
#define S_RXOVERSIZEPKTSr_COUNTSf_SET BCM6300_A0_S_RXOVERSIZEPKTSr_COUNTSf_SET
#define READ_S_RXOVERSIZEPKTSr BCM6300_A0_READ_S_RXOVERSIZEPKTSr
#define WRITE_S_RXOVERSIZEPKTSr BCM6300_A0_WRITE_S_RXOVERSIZEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_RXOVERSIZEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_RxPausePkts
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Rx Pause Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_RXPAUSEPKTSr 0x00007150

#define BCM6300_A0_S_RXPAUSEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxPausePkts.
 *
 */
typedef union BCM6300_A0_S_RXPAUSEPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxpausepkts[1];
	uint32_t _s_rxpausepkts;
} BCM6300_A0_S_RXPAUSEPKTSr_t;

#define BCM6300_A0_S_RXPAUSEPKTSr_CLR(r) (r).s_rxpausepkts[0] = 0
#define BCM6300_A0_S_RXPAUSEPKTSr_SET(r,d) (r).s_rxpausepkts[0] = d
#define BCM6300_A0_S_RXPAUSEPKTSr_GET(r) (r).s_rxpausepkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_RXPAUSEPKTSr_COUNTSf_GET(r) ((r).s_rxpausepkts[0])
#define BCM6300_A0_S_RXPAUSEPKTSr_COUNTSf_SET(r,f) (r).s_rxpausepkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxPausePkts.
 *
 */
#define BCM6300_A0_READ_S_RXPAUSEPKTSr(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_RXPAUSEPKTSr,(r._s_rxpausepkts),4)
#define BCM6300_A0_WRITE_S_RXPAUSEPKTSr(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_RXPAUSEPKTSr,&(r._s_rxpausepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXPAUSEPKTSr BCM6300_A0_S_RXPAUSEPKTSr
#define S_RXPAUSEPKTSr_SIZE BCM6300_A0_S_RXPAUSEPKTSr_SIZE
typedef BCM6300_A0_S_RXPAUSEPKTSr_t S_RXPAUSEPKTSr_t;
#define S_RXPAUSEPKTSr_CLR BCM6300_A0_S_RXPAUSEPKTSr_CLR
#define S_RXPAUSEPKTSr_SET BCM6300_A0_S_RXPAUSEPKTSr_SET
#define S_RXPAUSEPKTSr_GET BCM6300_A0_S_RXPAUSEPKTSr_GET
#define S_RXPAUSEPKTSr_COUNTSf_GET BCM6300_A0_S_RXPAUSEPKTSr_COUNTSf_GET
#define S_RXPAUSEPKTSr_COUNTSf_SET BCM6300_A0_S_RXPAUSEPKTSr_COUNTSf_SET
#define READ_S_RXPAUSEPKTSr BCM6300_A0_READ_S_RXPAUSEPKTSr
#define WRITE_S_RXPAUSEPKTSr BCM6300_A0_WRITE_S_RXPAUSEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_RXPAUSEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_RxQoSOctets
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Rx QoS Packet Octet Counter
 * SIZE:     64
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_RXQOSOCTETSr 0x000071a8

#define BCM6300_A0_S_RXQOSOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program S_RxQoSOctets.
 *
 */
typedef union BCM6300_A0_S_RXQOSOCTETSr_s {
	uint32_t v[2];
	uint32_t s_rxqosoctets[2];
	uint32_t _s_rxqosoctets;
} BCM6300_A0_S_RXQOSOCTETSr_t;

#define BCM6300_A0_S_RXQOSOCTETSr_CLR(r) CDK_MEMSET(&((r)._s_rxqosoctets), 0, sizeof(BCM6300_A0_S_RXQOSOCTETSr_t))
#define BCM6300_A0_S_RXQOSOCTETSr_SET(r,i,d) (r).s_rxqosoctets[i] = d
#define BCM6300_A0_S_RXQOSOCTETSr_GET(r,i) (r).s_rxqosoctets[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_RXQOSOCTETSr_COUNTSf_GET(r,a) cdk_field_get((r).s_rxqosoctets,0,63,a)
#define BCM6300_A0_S_RXQOSOCTETSr_COUNTSf_SET(r,a) cdk_field_set((r).s_rxqosoctets,0,63,a)

/*
 * These macros can be used to access S_RxQoSOctets.
 *
 */
#define BCM6300_A0_READ_S_RXQOSOCTETSr(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_RXQOSOCTETSr,(r._s_rxqosoctets),8)
#define BCM6300_A0_WRITE_S_RXQOSOCTETSr(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_RXQOSOCTETSr,&(r._s_rxqosoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXQOSOCTETSr BCM6300_A0_S_RXQOSOCTETSr
#define S_RXQOSOCTETSr_SIZE BCM6300_A0_S_RXQOSOCTETSr_SIZE
typedef BCM6300_A0_S_RXQOSOCTETSr_t S_RXQOSOCTETSr_t;
#define S_RXQOSOCTETSr_CLR BCM6300_A0_S_RXQOSOCTETSr_CLR
#define S_RXQOSOCTETSr_SET BCM6300_A0_S_RXQOSOCTETSr_SET
#define S_RXQOSOCTETSr_GET BCM6300_A0_S_RXQOSOCTETSr_GET
#define S_RXQOSOCTETSr_COUNTSf_GET BCM6300_A0_S_RXQOSOCTETSr_COUNTSf_GET
#define S_RXQOSOCTETSr_COUNTSf_SET BCM6300_A0_S_RXQOSOCTETSr_COUNTSf_SET
#define READ_S_RXQOSOCTETSr BCM6300_A0_READ_S_RXQOSOCTETSr
#define WRITE_S_RXQOSOCTETSr BCM6300_A0_WRITE_S_RXQOSOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_RXQOSOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_RxQoSPkts
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Rx QoS Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_RXQOSPKTSr 0x000071a4

#define BCM6300_A0_S_RXQOSPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxQoSPkts.
 *
 */
typedef union BCM6300_A0_S_RXQOSPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxqospkts[1];
	uint32_t _s_rxqospkts;
} BCM6300_A0_S_RXQOSPKTSr_t;

#define BCM6300_A0_S_RXQOSPKTSr_CLR(r) (r).s_rxqospkts[0] = 0
#define BCM6300_A0_S_RXQOSPKTSr_SET(r,d) (r).s_rxqospkts[0] = d
#define BCM6300_A0_S_RXQOSPKTSr_GET(r) (r).s_rxqospkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_RXQOSPKTSr_COUNTSf_GET(r) ((r).s_rxqospkts[0])
#define BCM6300_A0_S_RXQOSPKTSr_COUNTSf_SET(r,f) (r).s_rxqospkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxQoSPkts.
 *
 */
#define BCM6300_A0_READ_S_RXQOSPKTSr(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_RXQOSPKTSr,(r._s_rxqospkts),4)
#define BCM6300_A0_WRITE_S_RXQOSPKTSr(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_RXQOSPKTSr,&(r._s_rxqospkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXQOSPKTSr BCM6300_A0_S_RXQOSPKTSr
#define S_RXQOSPKTSr_SIZE BCM6300_A0_S_RXQOSPKTSr_SIZE
typedef BCM6300_A0_S_RXQOSPKTSr_t S_RXQOSPKTSr_t;
#define S_RXQOSPKTSr_CLR BCM6300_A0_S_RXQOSPKTSr_CLR
#define S_RXQOSPKTSr_SET BCM6300_A0_S_RXQOSPKTSr_SET
#define S_RXQOSPKTSr_GET BCM6300_A0_S_RXQOSPKTSr_GET
#define S_RXQOSPKTSr_COUNTSf_GET BCM6300_A0_S_RXQOSPKTSr_COUNTSf_GET
#define S_RXQOSPKTSr_COUNTSf_SET BCM6300_A0_S_RXQOSPKTSr_COUNTSf_SET
#define READ_S_RXQOSPKTSr BCM6300_A0_READ_S_RXQOSPKTSr
#define WRITE_S_RXQOSPKTSr BCM6300_A0_WRITE_S_RXQOSPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_RXQOSPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_RxSAChanges
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Rx SA Change Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_RXSACHANGESr 0x00007194

#define BCM6300_A0_S_RXSACHANGESr_SIZE 4

/*
 * This structure should be used to declare and program S_RxSAChanges.
 *
 */
typedef union BCM6300_A0_S_RXSACHANGESr_s {
	uint32_t v[1];
	uint32_t s_rxsachanges[1];
	uint32_t _s_rxsachanges;
} BCM6300_A0_S_RXSACHANGESr_t;

#define BCM6300_A0_S_RXSACHANGESr_CLR(r) (r).s_rxsachanges[0] = 0
#define BCM6300_A0_S_RXSACHANGESr_SET(r,d) (r).s_rxsachanges[0] = d
#define BCM6300_A0_S_RXSACHANGESr_GET(r) (r).s_rxsachanges[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_RXSACHANGESr_COUNTSf_GET(r) ((r).s_rxsachanges[0])
#define BCM6300_A0_S_RXSACHANGESr_COUNTSf_SET(r,f) (r).s_rxsachanges[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxSAChanges.
 *
 */
#define BCM6300_A0_READ_S_RXSACHANGESr(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_RXSACHANGESr,(r._s_rxsachanges),4)
#define BCM6300_A0_WRITE_S_RXSACHANGESr(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_RXSACHANGESr,&(r._s_rxsachanges),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXSACHANGESr BCM6300_A0_S_RXSACHANGESr
#define S_RXSACHANGESr_SIZE BCM6300_A0_S_RXSACHANGESr_SIZE
typedef BCM6300_A0_S_RXSACHANGESr_t S_RXSACHANGESr_t;
#define S_RXSACHANGESr_CLR BCM6300_A0_S_RXSACHANGESr_CLR
#define S_RXSACHANGESr_SET BCM6300_A0_S_RXSACHANGESr_SET
#define S_RXSACHANGESr_GET BCM6300_A0_S_RXSACHANGESr_GET
#define S_RXSACHANGESr_COUNTSf_GET BCM6300_A0_S_RXSACHANGESr_COUNTSf_GET
#define S_RXSACHANGESr_COUNTSf_SET BCM6300_A0_S_RXSACHANGESr_COUNTSf_SET
#define READ_S_RXSACHANGESr BCM6300_A0_READ_S_RXSACHANGESr
#define WRITE_S_RXSACHANGESr BCM6300_A0_WRITE_S_RXSACHANGESr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_RXSACHANGESr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_RxUndersizePkts
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Rx Under Size Packet Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_RXUNDERSIZEPKTSr 0x0000714c

#define BCM6300_A0_S_RXUNDERSIZEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxUndersizePkts.
 *
 */
typedef union BCM6300_A0_S_RXUNDERSIZEPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxundersizepkts[1];
	uint32_t _s_rxundersizepkts;
} BCM6300_A0_S_RXUNDERSIZEPKTSr_t;

#define BCM6300_A0_S_RXUNDERSIZEPKTSr_CLR(r) (r).s_rxundersizepkts[0] = 0
#define BCM6300_A0_S_RXUNDERSIZEPKTSr_SET(r,d) (r).s_rxundersizepkts[0] = d
#define BCM6300_A0_S_RXUNDERSIZEPKTSr_GET(r) (r).s_rxundersizepkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_RXUNDERSIZEPKTSr_COUNTSf_GET(r) ((r).s_rxundersizepkts[0])
#define BCM6300_A0_S_RXUNDERSIZEPKTSr_COUNTSf_SET(r,f) (r).s_rxundersizepkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxUndersizePkts.
 *
 */
#define BCM6300_A0_READ_S_RXUNDERSIZEPKTSr(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_RXUNDERSIZEPKTSr,(r._s_rxundersizepkts),4)
#define BCM6300_A0_WRITE_S_RXUNDERSIZEPKTSr(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_RXUNDERSIZEPKTSr,&(r._s_rxundersizepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXUNDERSIZEPKTSr BCM6300_A0_S_RXUNDERSIZEPKTSr
#define S_RXUNDERSIZEPKTSr_SIZE BCM6300_A0_S_RXUNDERSIZEPKTSr_SIZE
typedef BCM6300_A0_S_RXUNDERSIZEPKTSr_t S_RXUNDERSIZEPKTSr_t;
#define S_RXUNDERSIZEPKTSr_CLR BCM6300_A0_S_RXUNDERSIZEPKTSr_CLR
#define S_RXUNDERSIZEPKTSr_SET BCM6300_A0_S_RXUNDERSIZEPKTSr_SET
#define S_RXUNDERSIZEPKTSr_GET BCM6300_A0_S_RXUNDERSIZEPKTSr_GET
#define S_RXUNDERSIZEPKTSr_COUNTSf_GET BCM6300_A0_S_RXUNDERSIZEPKTSr_COUNTSf_GET
#define S_RXUNDERSIZEPKTSr_COUNTSf_SET BCM6300_A0_S_RXUNDERSIZEPKTSr_COUNTSf_SET
#define READ_S_RXUNDERSIZEPKTSr BCM6300_A0_READ_S_RXUNDERSIZEPKTSr
#define WRITE_S_RXUNDERSIZEPKTSr BCM6300_A0_WRITE_S_RXUNDERSIZEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_RXUNDERSIZEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_RxUnicastPkts
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Rx Unicast Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_RXUNICASTPKTSr 0x00007188

#define BCM6300_A0_S_RXUNICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxUnicastPkts.
 *
 */
typedef union BCM6300_A0_S_RXUNICASTPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxunicastpkts[1];
	uint32_t _s_rxunicastpkts;
} BCM6300_A0_S_RXUNICASTPKTSr_t;

#define BCM6300_A0_S_RXUNICASTPKTSr_CLR(r) (r).s_rxunicastpkts[0] = 0
#define BCM6300_A0_S_RXUNICASTPKTSr_SET(r,d) (r).s_rxunicastpkts[0] = d
#define BCM6300_A0_S_RXUNICASTPKTSr_GET(r) (r).s_rxunicastpkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_RXUNICASTPKTSr_COUNTSf_GET(r) ((r).s_rxunicastpkts[0])
#define BCM6300_A0_S_RXUNICASTPKTSr_COUNTSf_SET(r,f) (r).s_rxunicastpkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxUnicastPkts.
 *
 */
#define BCM6300_A0_READ_S_RXUNICASTPKTSr(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_RXUNICASTPKTSr,(r._s_rxunicastpkts),4)
#define BCM6300_A0_WRITE_S_RXUNICASTPKTSr(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_RXUNICASTPKTSr,&(r._s_rxunicastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXUNICASTPKTSr BCM6300_A0_S_RXUNICASTPKTSr
#define S_RXUNICASTPKTSr_SIZE BCM6300_A0_S_RXUNICASTPKTSr_SIZE
typedef BCM6300_A0_S_RXUNICASTPKTSr_t S_RXUNICASTPKTSr_t;
#define S_RXUNICASTPKTSr_CLR BCM6300_A0_S_RXUNICASTPKTSr_CLR
#define S_RXUNICASTPKTSr_SET BCM6300_A0_S_RXUNICASTPKTSr_SET
#define S_RXUNICASTPKTSr_GET BCM6300_A0_S_RXUNICASTPKTSr_GET
#define S_RXUNICASTPKTSr_COUNTSf_GET BCM6300_A0_S_RXUNICASTPKTSr_COUNTSf_GET
#define S_RXUNICASTPKTSr_COUNTSf_SET BCM6300_A0_S_RXUNICASTPKTSr_COUNTSf_SET
#define READ_S_RXUNICASTPKTSr BCM6300_A0_READ_S_RXUNICASTPKTSr
#define WRITE_S_RXUNICASTPKTSr BCM6300_A0_WRITE_S_RXUNICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_RXUNICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_TxBroadcastPkts
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Tx Broadcast Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_TXBROADCASTPKTSr 0x00007110

#define BCM6300_A0_S_TXBROADCASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxBroadcastPkts.
 *
 */
typedef union BCM6300_A0_S_TXBROADCASTPKTSr_s {
	uint32_t v[1];
	uint32_t s_txbroadcastpkts[1];
	uint32_t _s_txbroadcastpkts;
} BCM6300_A0_S_TXBROADCASTPKTSr_t;

#define BCM6300_A0_S_TXBROADCASTPKTSr_CLR(r) (r).s_txbroadcastpkts[0] = 0
#define BCM6300_A0_S_TXBROADCASTPKTSr_SET(r,d) (r).s_txbroadcastpkts[0] = d
#define BCM6300_A0_S_TXBROADCASTPKTSr_GET(r) (r).s_txbroadcastpkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_TXBROADCASTPKTSr_COUNTSf_GET(r) ((r).s_txbroadcastpkts[0])
#define BCM6300_A0_S_TXBROADCASTPKTSr_COUNTSf_SET(r,f) (r).s_txbroadcastpkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxBroadcastPkts.
 *
 */
#define BCM6300_A0_READ_S_TXBROADCASTPKTSr(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_TXBROADCASTPKTSr,(r._s_txbroadcastpkts),4)
#define BCM6300_A0_WRITE_S_TXBROADCASTPKTSr(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_TXBROADCASTPKTSr,&(r._s_txbroadcastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXBROADCASTPKTSr BCM6300_A0_S_TXBROADCASTPKTSr
#define S_TXBROADCASTPKTSr_SIZE BCM6300_A0_S_TXBROADCASTPKTSr_SIZE
typedef BCM6300_A0_S_TXBROADCASTPKTSr_t S_TXBROADCASTPKTSr_t;
#define S_TXBROADCASTPKTSr_CLR BCM6300_A0_S_TXBROADCASTPKTSr_CLR
#define S_TXBROADCASTPKTSr_SET BCM6300_A0_S_TXBROADCASTPKTSr_SET
#define S_TXBROADCASTPKTSr_GET BCM6300_A0_S_TXBROADCASTPKTSr_GET
#define S_TXBROADCASTPKTSr_COUNTSf_GET BCM6300_A0_S_TXBROADCASTPKTSr_COUNTSf_GET
#define S_TXBROADCASTPKTSr_COUNTSf_SET BCM6300_A0_S_TXBROADCASTPKTSr_COUNTSf_SET
#define READ_S_TXBROADCASTPKTSr BCM6300_A0_READ_S_TXBROADCASTPKTSr
#define WRITE_S_TXBROADCASTPKTSr BCM6300_A0_WRITE_S_TXBROADCASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_TXBROADCASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_TxCollisions
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Tx Collision Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_TXCOLLISIONSr 0x0000711c

#define BCM6300_A0_S_TXCOLLISIONSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxCollisions.
 *
 */
typedef union BCM6300_A0_S_TXCOLLISIONSr_s {
	uint32_t v[1];
	uint32_t s_txcollisions[1];
	uint32_t _s_txcollisions;
} BCM6300_A0_S_TXCOLLISIONSr_t;

#define BCM6300_A0_S_TXCOLLISIONSr_CLR(r) (r).s_txcollisions[0] = 0
#define BCM6300_A0_S_TXCOLLISIONSr_SET(r,d) (r).s_txcollisions[0] = d
#define BCM6300_A0_S_TXCOLLISIONSr_GET(r) (r).s_txcollisions[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_TXCOLLISIONSr_COUNTSf_GET(r) ((r).s_txcollisions[0])
#define BCM6300_A0_S_TXCOLLISIONSr_COUNTSf_SET(r,f) (r).s_txcollisions[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxCollisions.
 *
 */
#define BCM6300_A0_READ_S_TXCOLLISIONSr(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_TXCOLLISIONSr,(r._s_txcollisions),4)
#define BCM6300_A0_WRITE_S_TXCOLLISIONSr(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_TXCOLLISIONSr,&(r._s_txcollisions),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXCOLLISIONSr BCM6300_A0_S_TXCOLLISIONSr
#define S_TXCOLLISIONSr_SIZE BCM6300_A0_S_TXCOLLISIONSr_SIZE
typedef BCM6300_A0_S_TXCOLLISIONSr_t S_TXCOLLISIONSr_t;
#define S_TXCOLLISIONSr_CLR BCM6300_A0_S_TXCOLLISIONSr_CLR
#define S_TXCOLLISIONSr_SET BCM6300_A0_S_TXCOLLISIONSr_SET
#define S_TXCOLLISIONSr_GET BCM6300_A0_S_TXCOLLISIONSr_GET
#define S_TXCOLLISIONSr_COUNTSf_GET BCM6300_A0_S_TXCOLLISIONSr_COUNTSf_GET
#define S_TXCOLLISIONSr_COUNTSf_SET BCM6300_A0_S_TXCOLLISIONSr_COUNTSf_SET
#define READ_S_TXCOLLISIONSr BCM6300_A0_READ_S_TXCOLLISIONSr
#define WRITE_S_TXCOLLISIONSr BCM6300_A0_WRITE_S_TXCOLLISIONSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_TXCOLLISIONSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_TxDeferredTransmit
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Tx Deferred Transmit Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_TXDEFERREDTRANSMITr 0x00007128

#define BCM6300_A0_S_TXDEFERREDTRANSMITr_SIZE 4

/*
 * This structure should be used to declare and program S_TxDeferredTransmit.
 *
 */
typedef union BCM6300_A0_S_TXDEFERREDTRANSMITr_s {
	uint32_t v[1];
	uint32_t s_txdeferredtransmit[1];
	uint32_t _s_txdeferredtransmit;
} BCM6300_A0_S_TXDEFERREDTRANSMITr_t;

#define BCM6300_A0_S_TXDEFERREDTRANSMITr_CLR(r) (r).s_txdeferredtransmit[0] = 0
#define BCM6300_A0_S_TXDEFERREDTRANSMITr_SET(r,d) (r).s_txdeferredtransmit[0] = d
#define BCM6300_A0_S_TXDEFERREDTRANSMITr_GET(r) (r).s_txdeferredtransmit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_TXDEFERREDTRANSMITr_COUNTSf_GET(r) ((r).s_txdeferredtransmit[0])
#define BCM6300_A0_S_TXDEFERREDTRANSMITr_COUNTSf_SET(r,f) (r).s_txdeferredtransmit[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxDeferredTransmit.
 *
 */
#define BCM6300_A0_READ_S_TXDEFERREDTRANSMITr(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_TXDEFERREDTRANSMITr,(r._s_txdeferredtransmit),4)
#define BCM6300_A0_WRITE_S_TXDEFERREDTRANSMITr(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_TXDEFERREDTRANSMITr,&(r._s_txdeferredtransmit),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXDEFERREDTRANSMITr BCM6300_A0_S_TXDEFERREDTRANSMITr
#define S_TXDEFERREDTRANSMITr_SIZE BCM6300_A0_S_TXDEFERREDTRANSMITr_SIZE
typedef BCM6300_A0_S_TXDEFERREDTRANSMITr_t S_TXDEFERREDTRANSMITr_t;
#define S_TXDEFERREDTRANSMITr_CLR BCM6300_A0_S_TXDEFERREDTRANSMITr_CLR
#define S_TXDEFERREDTRANSMITr_SET BCM6300_A0_S_TXDEFERREDTRANSMITr_SET
#define S_TXDEFERREDTRANSMITr_GET BCM6300_A0_S_TXDEFERREDTRANSMITr_GET
#define S_TXDEFERREDTRANSMITr_COUNTSf_GET BCM6300_A0_S_TXDEFERREDTRANSMITr_COUNTSf_GET
#define S_TXDEFERREDTRANSMITr_COUNTSf_SET BCM6300_A0_S_TXDEFERREDTRANSMITr_COUNTSf_SET
#define READ_S_TXDEFERREDTRANSMITr BCM6300_A0_READ_S_TXDEFERREDTRANSMITr
#define WRITE_S_TXDEFERREDTRANSMITr BCM6300_A0_WRITE_S_TXDEFERREDTRANSMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_TXDEFERREDTRANSMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_TxDropPkts
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot TX Drop Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_TXDROPPKTSr 0x00007108

#define BCM6300_A0_S_TXDROPPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxDropPkts.
 *
 */
typedef union BCM6300_A0_S_TXDROPPKTSr_s {
	uint32_t v[1];
	uint32_t s_txdroppkts[1];
	uint32_t _s_txdroppkts;
} BCM6300_A0_S_TXDROPPKTSr_t;

#define BCM6300_A0_S_TXDROPPKTSr_CLR(r) (r).s_txdroppkts[0] = 0
#define BCM6300_A0_S_TXDROPPKTSr_SET(r,d) (r).s_txdroppkts[0] = d
#define BCM6300_A0_S_TXDROPPKTSr_GET(r) (r).s_txdroppkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_TXDROPPKTSr_COUNTSf_GET(r) ((r).s_txdroppkts[0])
#define BCM6300_A0_S_TXDROPPKTSr_COUNTSf_SET(r,f) (r).s_txdroppkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxDropPkts.
 *
 */
#define BCM6300_A0_READ_S_TXDROPPKTSr(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_TXDROPPKTSr,(r._s_txdroppkts),4)
#define BCM6300_A0_WRITE_S_TXDROPPKTSr(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_TXDROPPKTSr,&(r._s_txdroppkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXDROPPKTSr BCM6300_A0_S_TXDROPPKTSr
#define S_TXDROPPKTSr_SIZE BCM6300_A0_S_TXDROPPKTSr_SIZE
typedef BCM6300_A0_S_TXDROPPKTSr_t S_TXDROPPKTSr_t;
#define S_TXDROPPKTSr_CLR BCM6300_A0_S_TXDROPPKTSr_CLR
#define S_TXDROPPKTSr_SET BCM6300_A0_S_TXDROPPKTSr_SET
#define S_TXDROPPKTSr_GET BCM6300_A0_S_TXDROPPKTSr_GET
#define S_TXDROPPKTSr_COUNTSf_GET BCM6300_A0_S_TXDROPPKTSr_COUNTSf_GET
#define S_TXDROPPKTSr_COUNTSf_SET BCM6300_A0_S_TXDROPPKTSr_COUNTSf_SET
#define READ_S_TXDROPPKTSr BCM6300_A0_READ_S_TXDROPPKTSr
#define WRITE_S_TXDROPPKTSr BCM6300_A0_WRITE_S_TXDROPPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_TXDROPPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_TxExcessiveCollision
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Tx Excessive Collision Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_TXEXCESSIVECOLLISIONr 0x00007130

#define BCM6300_A0_S_TXEXCESSIVECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program S_TxExcessiveCollision.
 *
 */
typedef union BCM6300_A0_S_TXEXCESSIVECOLLISIONr_s {
	uint32_t v[1];
	uint32_t s_txexcessivecollision[1];
	uint32_t _s_txexcessivecollision;
} BCM6300_A0_S_TXEXCESSIVECOLLISIONr_t;

#define BCM6300_A0_S_TXEXCESSIVECOLLISIONr_CLR(r) (r).s_txexcessivecollision[0] = 0
#define BCM6300_A0_S_TXEXCESSIVECOLLISIONr_SET(r,d) (r).s_txexcessivecollision[0] = d
#define BCM6300_A0_S_TXEXCESSIVECOLLISIONr_GET(r) (r).s_txexcessivecollision[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_TXEXCESSIVECOLLISIONr_COUNTSf_GET(r) ((r).s_txexcessivecollision[0])
#define BCM6300_A0_S_TXEXCESSIVECOLLISIONr_COUNTSf_SET(r,f) (r).s_txexcessivecollision[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxExcessiveCollision.
 *
 */
#define BCM6300_A0_READ_S_TXEXCESSIVECOLLISIONr(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_TXEXCESSIVECOLLISIONr,(r._s_txexcessivecollision),4)
#define BCM6300_A0_WRITE_S_TXEXCESSIVECOLLISIONr(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_TXEXCESSIVECOLLISIONr,&(r._s_txexcessivecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXEXCESSIVECOLLISIONr BCM6300_A0_S_TXEXCESSIVECOLLISIONr
#define S_TXEXCESSIVECOLLISIONr_SIZE BCM6300_A0_S_TXEXCESSIVECOLLISIONr_SIZE
typedef BCM6300_A0_S_TXEXCESSIVECOLLISIONr_t S_TXEXCESSIVECOLLISIONr_t;
#define S_TXEXCESSIVECOLLISIONr_CLR BCM6300_A0_S_TXEXCESSIVECOLLISIONr_CLR
#define S_TXEXCESSIVECOLLISIONr_SET BCM6300_A0_S_TXEXCESSIVECOLLISIONr_SET
#define S_TXEXCESSIVECOLLISIONr_GET BCM6300_A0_S_TXEXCESSIVECOLLISIONr_GET
#define S_TXEXCESSIVECOLLISIONr_COUNTSf_GET BCM6300_A0_S_TXEXCESSIVECOLLISIONr_COUNTSf_GET
#define S_TXEXCESSIVECOLLISIONr_COUNTSf_SET BCM6300_A0_S_TXEXCESSIVECOLLISIONr_COUNTSf_SET
#define READ_S_TXEXCESSIVECOLLISIONr BCM6300_A0_READ_S_TXEXCESSIVECOLLISIONr
#define WRITE_S_TXEXCESSIVECOLLISIONr BCM6300_A0_WRITE_S_TXEXCESSIVECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_TXEXCESSIVECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_TxFrameInDisc
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Tx Fram IN Disc Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_TXFRAMEINDISCr 0x00007134

#define BCM6300_A0_S_TXFRAMEINDISCr_SIZE 4

/*
 * This structure should be used to declare and program S_TxFrameInDisc.
 *
 */
typedef union BCM6300_A0_S_TXFRAMEINDISCr_s {
	uint32_t v[1];
	uint32_t s_txframeindisc[1];
	uint32_t _s_txframeindisc;
} BCM6300_A0_S_TXFRAMEINDISCr_t;

#define BCM6300_A0_S_TXFRAMEINDISCr_CLR(r) (r).s_txframeindisc[0] = 0
#define BCM6300_A0_S_TXFRAMEINDISCr_SET(r,d) (r).s_txframeindisc[0] = d
#define BCM6300_A0_S_TXFRAMEINDISCr_GET(r) (r).s_txframeindisc[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_TXFRAMEINDISCr_COUNTSf_GET(r) ((r).s_txframeindisc[0])
#define BCM6300_A0_S_TXFRAMEINDISCr_COUNTSf_SET(r,f) (r).s_txframeindisc[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxFrameInDisc.
 *
 */
#define BCM6300_A0_READ_S_TXFRAMEINDISCr(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_TXFRAMEINDISCr,(r._s_txframeindisc),4)
#define BCM6300_A0_WRITE_S_TXFRAMEINDISCr(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_TXFRAMEINDISCr,&(r._s_txframeindisc),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXFRAMEINDISCr BCM6300_A0_S_TXFRAMEINDISCr
#define S_TXFRAMEINDISCr_SIZE BCM6300_A0_S_TXFRAMEINDISCr_SIZE
typedef BCM6300_A0_S_TXFRAMEINDISCr_t S_TXFRAMEINDISCr_t;
#define S_TXFRAMEINDISCr_CLR BCM6300_A0_S_TXFRAMEINDISCr_CLR
#define S_TXFRAMEINDISCr_SET BCM6300_A0_S_TXFRAMEINDISCr_SET
#define S_TXFRAMEINDISCr_GET BCM6300_A0_S_TXFRAMEINDISCr_GET
#define S_TXFRAMEINDISCr_COUNTSf_GET BCM6300_A0_S_TXFRAMEINDISCr_COUNTSf_GET
#define S_TXFRAMEINDISCr_COUNTSf_SET BCM6300_A0_S_TXFRAMEINDISCr_COUNTSf_SET
#define READ_S_TXFRAMEINDISCr BCM6300_A0_READ_S_TXFRAMEINDISCr
#define WRITE_S_TXFRAMEINDISCr BCM6300_A0_WRITE_S_TXFRAMEINDISCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_TXFRAMEINDISCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_TxLateCollision
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Tx Late Collision Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_TXLATECOLLISIONr 0x0000712c

#define BCM6300_A0_S_TXLATECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program S_TxLateCollision.
 *
 */
typedef union BCM6300_A0_S_TXLATECOLLISIONr_s {
	uint32_t v[1];
	uint32_t s_txlatecollision[1];
	uint32_t _s_txlatecollision;
} BCM6300_A0_S_TXLATECOLLISIONr_t;

#define BCM6300_A0_S_TXLATECOLLISIONr_CLR(r) (r).s_txlatecollision[0] = 0
#define BCM6300_A0_S_TXLATECOLLISIONr_SET(r,d) (r).s_txlatecollision[0] = d
#define BCM6300_A0_S_TXLATECOLLISIONr_GET(r) (r).s_txlatecollision[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_TXLATECOLLISIONr_COUNTSf_GET(r) ((r).s_txlatecollision[0])
#define BCM6300_A0_S_TXLATECOLLISIONr_COUNTSf_SET(r,f) (r).s_txlatecollision[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxLateCollision.
 *
 */
#define BCM6300_A0_READ_S_TXLATECOLLISIONr(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_TXLATECOLLISIONr,(r._s_txlatecollision),4)
#define BCM6300_A0_WRITE_S_TXLATECOLLISIONr(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_TXLATECOLLISIONr,&(r._s_txlatecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXLATECOLLISIONr BCM6300_A0_S_TXLATECOLLISIONr
#define S_TXLATECOLLISIONr_SIZE BCM6300_A0_S_TXLATECOLLISIONr_SIZE
typedef BCM6300_A0_S_TXLATECOLLISIONr_t S_TXLATECOLLISIONr_t;
#define S_TXLATECOLLISIONr_CLR BCM6300_A0_S_TXLATECOLLISIONr_CLR
#define S_TXLATECOLLISIONr_SET BCM6300_A0_S_TXLATECOLLISIONr_SET
#define S_TXLATECOLLISIONr_GET BCM6300_A0_S_TXLATECOLLISIONr_GET
#define S_TXLATECOLLISIONr_COUNTSf_GET BCM6300_A0_S_TXLATECOLLISIONr_COUNTSf_GET
#define S_TXLATECOLLISIONr_COUNTSf_SET BCM6300_A0_S_TXLATECOLLISIONr_COUNTSf_SET
#define READ_S_TXLATECOLLISIONr BCM6300_A0_READ_S_TXLATECOLLISIONr
#define WRITE_S_TXLATECOLLISIONr BCM6300_A0_WRITE_S_TXLATECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_TXLATECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_TxMulticastPkts
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Tx Multicast Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_TXMULTICASTPKTSr 0x00007114

#define BCM6300_A0_S_TXMULTICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxMulticastPkts.
 *
 */
typedef union BCM6300_A0_S_TXMULTICASTPKTSr_s {
	uint32_t v[1];
	uint32_t s_txmulticastpkts[1];
	uint32_t _s_txmulticastpkts;
} BCM6300_A0_S_TXMULTICASTPKTSr_t;

#define BCM6300_A0_S_TXMULTICASTPKTSr_CLR(r) (r).s_txmulticastpkts[0] = 0
#define BCM6300_A0_S_TXMULTICASTPKTSr_SET(r,d) (r).s_txmulticastpkts[0] = d
#define BCM6300_A0_S_TXMULTICASTPKTSr_GET(r) (r).s_txmulticastpkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_TXMULTICASTPKTSr_COUNTSf_GET(r) ((r).s_txmulticastpkts[0])
#define BCM6300_A0_S_TXMULTICASTPKTSr_COUNTSf_SET(r,f) (r).s_txmulticastpkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxMulticastPkts.
 *
 */
#define BCM6300_A0_READ_S_TXMULTICASTPKTSr(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_TXMULTICASTPKTSr,(r._s_txmulticastpkts),4)
#define BCM6300_A0_WRITE_S_TXMULTICASTPKTSr(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_TXMULTICASTPKTSr,&(r._s_txmulticastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXMULTICASTPKTSr BCM6300_A0_S_TXMULTICASTPKTSr
#define S_TXMULTICASTPKTSr_SIZE BCM6300_A0_S_TXMULTICASTPKTSr_SIZE
typedef BCM6300_A0_S_TXMULTICASTPKTSr_t S_TXMULTICASTPKTSr_t;
#define S_TXMULTICASTPKTSr_CLR BCM6300_A0_S_TXMULTICASTPKTSr_CLR
#define S_TXMULTICASTPKTSr_SET BCM6300_A0_S_TXMULTICASTPKTSr_SET
#define S_TXMULTICASTPKTSr_GET BCM6300_A0_S_TXMULTICASTPKTSr_GET
#define S_TXMULTICASTPKTSr_COUNTSf_GET BCM6300_A0_S_TXMULTICASTPKTSr_COUNTSf_GET
#define S_TXMULTICASTPKTSr_COUNTSf_SET BCM6300_A0_S_TXMULTICASTPKTSr_COUNTSf_SET
#define READ_S_TXMULTICASTPKTSr BCM6300_A0_READ_S_TXMULTICASTPKTSr
#define WRITE_S_TXMULTICASTPKTSr BCM6300_A0_WRITE_S_TXMULTICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_TXMULTICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_TxMultipleCollision
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Tx Multiple collsion Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_TXMULTIPLECOLLISIONr 0x00007124

#define BCM6300_A0_S_TXMULTIPLECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program S_TxMultipleCollision.
 *
 */
typedef union BCM6300_A0_S_TXMULTIPLECOLLISIONr_s {
	uint32_t v[1];
	uint32_t s_txmultiplecollision[1];
	uint32_t _s_txmultiplecollision;
} BCM6300_A0_S_TXMULTIPLECOLLISIONr_t;

#define BCM6300_A0_S_TXMULTIPLECOLLISIONr_CLR(r) (r).s_txmultiplecollision[0] = 0
#define BCM6300_A0_S_TXMULTIPLECOLLISIONr_SET(r,d) (r).s_txmultiplecollision[0] = d
#define BCM6300_A0_S_TXMULTIPLECOLLISIONr_GET(r) (r).s_txmultiplecollision[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_TXMULTIPLECOLLISIONr_COUNTSf_GET(r) ((r).s_txmultiplecollision[0])
#define BCM6300_A0_S_TXMULTIPLECOLLISIONr_COUNTSf_SET(r,f) (r).s_txmultiplecollision[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxMultipleCollision.
 *
 */
#define BCM6300_A0_READ_S_TXMULTIPLECOLLISIONr(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_TXMULTIPLECOLLISIONr,(r._s_txmultiplecollision),4)
#define BCM6300_A0_WRITE_S_TXMULTIPLECOLLISIONr(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_TXMULTIPLECOLLISIONr,&(r._s_txmultiplecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXMULTIPLECOLLISIONr BCM6300_A0_S_TXMULTIPLECOLLISIONr
#define S_TXMULTIPLECOLLISIONr_SIZE BCM6300_A0_S_TXMULTIPLECOLLISIONr_SIZE
typedef BCM6300_A0_S_TXMULTIPLECOLLISIONr_t S_TXMULTIPLECOLLISIONr_t;
#define S_TXMULTIPLECOLLISIONr_CLR BCM6300_A0_S_TXMULTIPLECOLLISIONr_CLR
#define S_TXMULTIPLECOLLISIONr_SET BCM6300_A0_S_TXMULTIPLECOLLISIONr_SET
#define S_TXMULTIPLECOLLISIONr_GET BCM6300_A0_S_TXMULTIPLECOLLISIONr_GET
#define S_TXMULTIPLECOLLISIONr_COUNTSf_GET BCM6300_A0_S_TXMULTIPLECOLLISIONr_COUNTSf_GET
#define S_TXMULTIPLECOLLISIONr_COUNTSf_SET BCM6300_A0_S_TXMULTIPLECOLLISIONr_COUNTSf_SET
#define READ_S_TXMULTIPLECOLLISIONr BCM6300_A0_READ_S_TXMULTIPLECOLLISIONr
#define WRITE_S_TXMULTIPLECOLLISIONr BCM6300_A0_WRITE_S_TXMULTIPLECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_TXMULTIPLECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_TxOctets
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Tx Octets
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM6300_A0_S_TXOCTETSr 0x00007100

#define BCM6300_A0_S_TXOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program S_TxOctets.
 *
 */
typedef union BCM6300_A0_S_TXOCTETSr_s {
	uint32_t v[2];
	uint32_t s_txoctets[2];
	uint32_t _s_txoctets;
} BCM6300_A0_S_TXOCTETSr_t;

#define BCM6300_A0_S_TXOCTETSr_CLR(r) CDK_MEMSET(&((r)._s_txoctets), 0, sizeof(BCM6300_A0_S_TXOCTETSr_t))
#define BCM6300_A0_S_TXOCTETSr_SET(r,i,d) (r).s_txoctets[i] = d
#define BCM6300_A0_S_TXOCTETSr_GET(r,i) (r).s_txoctets[i]


/*
 * These macros can be used to access S_TxOctets.
 *
 */
#define BCM6300_A0_READ_S_TXOCTETSr(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_TXOCTETSr,(r._s_txoctets),8)
#define BCM6300_A0_WRITE_S_TXOCTETSr(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_TXOCTETSr,&(r._s_txoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXOCTETSr BCM6300_A0_S_TXOCTETSr
#define S_TXOCTETSr_SIZE BCM6300_A0_S_TXOCTETSr_SIZE
typedef BCM6300_A0_S_TXOCTETSr_t S_TXOCTETSr_t;
#define S_TXOCTETSr_CLR BCM6300_A0_S_TXOCTETSr_CLR
#define S_TXOCTETSr_SET BCM6300_A0_S_TXOCTETSr_SET
#define S_TXOCTETSr_GET BCM6300_A0_S_TXOCTETSr_GET
#define READ_S_TXOCTETSr BCM6300_A0_READ_S_TXOCTETSr
#define WRITE_S_TXOCTETSr BCM6300_A0_WRITE_S_TXOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_TXOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_TxPausePkts
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Tx Pause Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_TXPAUSEPKTSr 0x00007138

#define BCM6300_A0_S_TXPAUSEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxPausePkts.
 *
 */
typedef union BCM6300_A0_S_TXPAUSEPKTSr_s {
	uint32_t v[1];
	uint32_t s_txpausepkts[1];
	uint32_t _s_txpausepkts;
} BCM6300_A0_S_TXPAUSEPKTSr_t;

#define BCM6300_A0_S_TXPAUSEPKTSr_CLR(r) (r).s_txpausepkts[0] = 0
#define BCM6300_A0_S_TXPAUSEPKTSr_SET(r,d) (r).s_txpausepkts[0] = d
#define BCM6300_A0_S_TXPAUSEPKTSr_GET(r) (r).s_txpausepkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_TXPAUSEPKTSr_COUNTSf_GET(r) ((r).s_txpausepkts[0])
#define BCM6300_A0_S_TXPAUSEPKTSr_COUNTSf_SET(r,f) (r).s_txpausepkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxPausePkts.
 *
 */
#define BCM6300_A0_READ_S_TXPAUSEPKTSr(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_TXPAUSEPKTSr,(r._s_txpausepkts),4)
#define BCM6300_A0_WRITE_S_TXPAUSEPKTSr(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_TXPAUSEPKTSr,&(r._s_txpausepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXPAUSEPKTSr BCM6300_A0_S_TXPAUSEPKTSr
#define S_TXPAUSEPKTSr_SIZE BCM6300_A0_S_TXPAUSEPKTSr_SIZE
typedef BCM6300_A0_S_TXPAUSEPKTSr_t S_TXPAUSEPKTSr_t;
#define S_TXPAUSEPKTSr_CLR BCM6300_A0_S_TXPAUSEPKTSr_CLR
#define S_TXPAUSEPKTSr_SET BCM6300_A0_S_TXPAUSEPKTSr_SET
#define S_TXPAUSEPKTSr_GET BCM6300_A0_S_TXPAUSEPKTSr_GET
#define S_TXPAUSEPKTSr_COUNTSf_GET BCM6300_A0_S_TXPAUSEPKTSr_COUNTSf_GET
#define S_TXPAUSEPKTSr_COUNTSf_SET BCM6300_A0_S_TXPAUSEPKTSr_COUNTSf_SET
#define READ_S_TXPAUSEPKTSr BCM6300_A0_READ_S_TXPAUSEPKTSr
#define WRITE_S_TXPAUSEPKTSr BCM6300_A0_WRITE_S_TXPAUSEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_TXPAUSEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_TxQoSOctets
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Tx QoS Packet Octets Counter
 * SIZE:     64
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_TXQOSOCTETSr 0x0000713c

#define BCM6300_A0_S_TXQOSOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program S_TxQoSOctets.
 *
 */
typedef union BCM6300_A0_S_TXQOSOCTETSr_s {
	uint32_t v[2];
	uint32_t s_txqosoctets[2];
	uint32_t _s_txqosoctets;
} BCM6300_A0_S_TXQOSOCTETSr_t;

#define BCM6300_A0_S_TXQOSOCTETSr_CLR(r) CDK_MEMSET(&((r)._s_txqosoctets), 0, sizeof(BCM6300_A0_S_TXQOSOCTETSr_t))
#define BCM6300_A0_S_TXQOSOCTETSr_SET(r,i,d) (r).s_txqosoctets[i] = d
#define BCM6300_A0_S_TXQOSOCTETSr_GET(r,i) (r).s_txqosoctets[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_TXQOSOCTETSr_COUNTSf_GET(r,a) cdk_field_get((r).s_txqosoctets,0,63,a)
#define BCM6300_A0_S_TXQOSOCTETSr_COUNTSf_SET(r,a) cdk_field_set((r).s_txqosoctets,0,63,a)

/*
 * These macros can be used to access S_TxQoSOctets.
 *
 */
#define BCM6300_A0_READ_S_TXQOSOCTETSr(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_TXQOSOCTETSr,(r._s_txqosoctets),8)
#define BCM6300_A0_WRITE_S_TXQOSOCTETSr(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_TXQOSOCTETSr,&(r._s_txqosoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQOSOCTETSr BCM6300_A0_S_TXQOSOCTETSr
#define S_TXQOSOCTETSr_SIZE BCM6300_A0_S_TXQOSOCTETSr_SIZE
typedef BCM6300_A0_S_TXQOSOCTETSr_t S_TXQOSOCTETSr_t;
#define S_TXQOSOCTETSr_CLR BCM6300_A0_S_TXQOSOCTETSr_CLR
#define S_TXQOSOCTETSr_SET BCM6300_A0_S_TXQOSOCTETSr_SET
#define S_TXQOSOCTETSr_GET BCM6300_A0_S_TXQOSOCTETSr_GET
#define S_TXQOSOCTETSr_COUNTSf_GET BCM6300_A0_S_TXQOSOCTETSr_COUNTSf_GET
#define S_TXQOSOCTETSr_COUNTSf_SET BCM6300_A0_S_TXQOSOCTETSr_COUNTSf_SET
#define READ_S_TXQOSOCTETSr BCM6300_A0_READ_S_TXQOSOCTETSr
#define WRITE_S_TXQOSOCTETSr BCM6300_A0_WRITE_S_TXQOSOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_TXQOSOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_TxQoSPkts
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Tx QoS Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_TXQOSPKTSr 0x0000710c

#define BCM6300_A0_S_TXQOSPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxQoSPkts.
 *
 */
typedef union BCM6300_A0_S_TXQOSPKTSr_s {
	uint32_t v[1];
	uint32_t s_txqospkts[1];
	uint32_t _s_txqospkts;
} BCM6300_A0_S_TXQOSPKTSr_t;

#define BCM6300_A0_S_TXQOSPKTSr_CLR(r) (r).s_txqospkts[0] = 0
#define BCM6300_A0_S_TXQOSPKTSr_SET(r,d) (r).s_txqospkts[0] = d
#define BCM6300_A0_S_TXQOSPKTSr_GET(r) (r).s_txqospkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_TXQOSPKTSr_COUNTSf_GET(r) ((r).s_txqospkts[0])
#define BCM6300_A0_S_TXQOSPKTSr_COUNTSf_SET(r,f) (r).s_txqospkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxQoSPkts.
 *
 */
#define BCM6300_A0_READ_S_TXQOSPKTSr(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_TXQOSPKTSr,(r._s_txqospkts),4)
#define BCM6300_A0_WRITE_S_TXQOSPKTSr(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_TXQOSPKTSr,&(r._s_txqospkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQOSPKTSr BCM6300_A0_S_TXQOSPKTSr
#define S_TXQOSPKTSr_SIZE BCM6300_A0_S_TXQOSPKTSr_SIZE
typedef BCM6300_A0_S_TXQOSPKTSr_t S_TXQOSPKTSr_t;
#define S_TXQOSPKTSr_CLR BCM6300_A0_S_TXQOSPKTSr_CLR
#define S_TXQOSPKTSr_SET BCM6300_A0_S_TXQOSPKTSr_SET
#define S_TXQOSPKTSr_GET BCM6300_A0_S_TXQOSPKTSr_GET
#define S_TXQOSPKTSr_COUNTSf_GET BCM6300_A0_S_TXQOSPKTSr_COUNTSf_GET
#define S_TXQOSPKTSr_COUNTSf_SET BCM6300_A0_S_TXQOSPKTSr_COUNTSf_SET
#define READ_S_TXQOSPKTSr BCM6300_A0_READ_S_TXQOSPKTSr
#define WRITE_S_TXQOSPKTSr BCM6300_A0_WRITE_S_TXQOSPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_TXQOSPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_TxSingleCollision
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Tx Single Collision Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_TXSINGLECOLLISIONr 0x00007120

#define BCM6300_A0_S_TXSINGLECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program S_TxSingleCollision.
 *
 */
typedef union BCM6300_A0_S_TXSINGLECOLLISIONr_s {
	uint32_t v[1];
	uint32_t s_txsinglecollision[1];
	uint32_t _s_txsinglecollision;
} BCM6300_A0_S_TXSINGLECOLLISIONr_t;

#define BCM6300_A0_S_TXSINGLECOLLISIONr_CLR(r) (r).s_txsinglecollision[0] = 0
#define BCM6300_A0_S_TXSINGLECOLLISIONr_SET(r,d) (r).s_txsinglecollision[0] = d
#define BCM6300_A0_S_TXSINGLECOLLISIONr_GET(r) (r).s_txsinglecollision[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_TXSINGLECOLLISIONr_COUNTSf_GET(r) ((r).s_txsinglecollision[0])
#define BCM6300_A0_S_TXSINGLECOLLISIONr_COUNTSf_SET(r,f) (r).s_txsinglecollision[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxSingleCollision.
 *
 */
#define BCM6300_A0_READ_S_TXSINGLECOLLISIONr(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_TXSINGLECOLLISIONr,(r._s_txsinglecollision),4)
#define BCM6300_A0_WRITE_S_TXSINGLECOLLISIONr(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_TXSINGLECOLLISIONr,&(r._s_txsinglecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXSINGLECOLLISIONr BCM6300_A0_S_TXSINGLECOLLISIONr
#define S_TXSINGLECOLLISIONr_SIZE BCM6300_A0_S_TXSINGLECOLLISIONr_SIZE
typedef BCM6300_A0_S_TXSINGLECOLLISIONr_t S_TXSINGLECOLLISIONr_t;
#define S_TXSINGLECOLLISIONr_CLR BCM6300_A0_S_TXSINGLECOLLISIONr_CLR
#define S_TXSINGLECOLLISIONr_SET BCM6300_A0_S_TXSINGLECOLLISIONr_SET
#define S_TXSINGLECOLLISIONr_GET BCM6300_A0_S_TXSINGLECOLLISIONr_GET
#define S_TXSINGLECOLLISIONr_COUNTSf_GET BCM6300_A0_S_TXSINGLECOLLISIONr_COUNTSf_GET
#define S_TXSINGLECOLLISIONr_COUNTSf_SET BCM6300_A0_S_TXSINGLECOLLISIONr_COUNTSf_SET
#define READ_S_TXSINGLECOLLISIONr BCM6300_A0_READ_S_TXSINGLECOLLISIONr
#define WRITE_S_TXSINGLECOLLISIONr BCM6300_A0_WRITE_S_TXSINGLECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_TXSINGLECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  S_TxUnicastPkts
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Tx Unicast Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNTS           MIB Counter Value
 *
 ******************************************************************************/
#define BCM6300_A0_S_TXUNICASTPKTSr 0x00007118

#define BCM6300_A0_S_TXUNICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxUnicastPkts.
 *
 */
typedef union BCM6300_A0_S_TXUNICASTPKTSr_s {
	uint32_t v[1];
	uint32_t s_txunicastpkts[1];
	uint32_t _s_txunicastpkts;
} BCM6300_A0_S_TXUNICASTPKTSr_t;

#define BCM6300_A0_S_TXUNICASTPKTSr_CLR(r) (r).s_txunicastpkts[0] = 0
#define BCM6300_A0_S_TXUNICASTPKTSr_SET(r,d) (r).s_txunicastpkts[0] = d
#define BCM6300_A0_S_TXUNICASTPKTSr_GET(r) (r).s_txunicastpkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_S_TXUNICASTPKTSr_COUNTSf_GET(r) ((r).s_txunicastpkts[0])
#define BCM6300_A0_S_TXUNICASTPKTSr_COUNTSf_SET(r,f) (r).s_txunicastpkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxUnicastPkts.
 *
 */
#define BCM6300_A0_READ_S_TXUNICASTPKTSr(u,r) cdk_robo_reg_read(u,BCM6300_A0_S_TXUNICASTPKTSr,(r._s_txunicastpkts),4)
#define BCM6300_A0_WRITE_S_TXUNICASTPKTSr(u,r) cdk_robo_reg_write(u,BCM6300_A0_S_TXUNICASTPKTSr,&(r._s_txunicastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXUNICASTPKTSr BCM6300_A0_S_TXUNICASTPKTSr
#define S_TXUNICASTPKTSr_SIZE BCM6300_A0_S_TXUNICASTPKTSr_SIZE
typedef BCM6300_A0_S_TXUNICASTPKTSr_t S_TXUNICASTPKTSr_t;
#define S_TXUNICASTPKTSr_CLR BCM6300_A0_S_TXUNICASTPKTSr_CLR
#define S_TXUNICASTPKTSr_SET BCM6300_A0_S_TXUNICASTPKTSr_SET
#define S_TXUNICASTPKTSr_GET BCM6300_A0_S_TXUNICASTPKTSr_GET
#define S_TXUNICASTPKTSr_COUNTSf_GET BCM6300_A0_S_TXUNICASTPKTSr_COUNTSf_GET
#define S_TXUNICASTPKTSr_COUNTSf_SET BCM6300_A0_S_TXUNICASTPKTSr_COUNTSf_SET
#define READ_S_TXUNICASTPKTSr BCM6300_A0_READ_S_TXUNICASTPKTSr
#define WRITE_S_TXUNICASTPKTSr BCM6300_A0_WRITE_S_TXUNICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_S_TXUNICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  TRUNK_GRP0_CTL
 * BLOCKS:   SYS
 * DESC:     Trunk Group 0 Control Register
 * SIZE:     16
 * FIELDS:
 *     TRUNK_PORT_MAP0  Per bit per Port trunk group vector.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_TRUNK_GRP0_CTLr 0x00003210

#define BCM6300_A0_TRUNK_GRP0_CTLr_SIZE 2

/*
 * This structure should be used to declare and program TRUNK_GRP0_CTL.
 *
 */
typedef union BCM6300_A0_TRUNK_GRP0_CTLr_s {
	uint32_t v[1];
	uint32_t trunk_grp0_ctl[1];
	uint32_t _trunk_grp0_ctl;
} BCM6300_A0_TRUNK_GRP0_CTLr_t;

#define BCM6300_A0_TRUNK_GRP0_CTLr_CLR(r) (r).trunk_grp0_ctl[0] = 0
#define BCM6300_A0_TRUNK_GRP0_CTLr_SET(r,d) (r).trunk_grp0_ctl[0] = d
#define BCM6300_A0_TRUNK_GRP0_CTLr_GET(r) (r).trunk_grp0_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_TRUNK_GRP0_CTLr_TRUNK_PORT_MAP0f_GET(r) (((r).trunk_grp0_ctl[0]) & 0x1ff)
#define BCM6300_A0_TRUNK_GRP0_CTLr_TRUNK_PORT_MAP0f_SET(r,f) (r).trunk_grp0_ctl[0]=(((r).trunk_grp0_ctl[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_TRUNK_GRP0_CTLr_RESERVED_Rf_GET(r) ((((r).trunk_grp0_ctl[0]) >> 9) & 0x7f)
#define BCM6300_A0_TRUNK_GRP0_CTLr_RESERVED_Rf_SET(r,f) (r).trunk_grp0_ctl[0]=(((r).trunk_grp0_ctl[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access TRUNK_GRP0_CTL.
 *
 */
#define BCM6300_A0_READ_TRUNK_GRP0_CTLr(u,r) cdk_robo_reg_read(u,BCM6300_A0_TRUNK_GRP0_CTLr,(r._trunk_grp0_ctl),2)
#define BCM6300_A0_WRITE_TRUNK_GRP0_CTLr(u,r) cdk_robo_reg_write(u,BCM6300_A0_TRUNK_GRP0_CTLr,&(r._trunk_grp0_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRUNK_GRP0_CTLr BCM6300_A0_TRUNK_GRP0_CTLr
#define TRUNK_GRP0_CTLr_SIZE BCM6300_A0_TRUNK_GRP0_CTLr_SIZE
typedef BCM6300_A0_TRUNK_GRP0_CTLr_t TRUNK_GRP0_CTLr_t;
#define TRUNK_GRP0_CTLr_CLR BCM6300_A0_TRUNK_GRP0_CTLr_CLR
#define TRUNK_GRP0_CTLr_SET BCM6300_A0_TRUNK_GRP0_CTLr_SET
#define TRUNK_GRP0_CTLr_GET BCM6300_A0_TRUNK_GRP0_CTLr_GET
#define TRUNK_GRP0_CTLr_TRUNK_PORT_MAP0f_GET BCM6300_A0_TRUNK_GRP0_CTLr_TRUNK_PORT_MAP0f_GET
#define TRUNK_GRP0_CTLr_TRUNK_PORT_MAP0f_SET BCM6300_A0_TRUNK_GRP0_CTLr_TRUNK_PORT_MAP0f_SET
#define TRUNK_GRP0_CTLr_RESERVED_Rf_GET BCM6300_A0_TRUNK_GRP0_CTLr_RESERVED_Rf_GET
#define TRUNK_GRP0_CTLr_RESERVED_Rf_SET BCM6300_A0_TRUNK_GRP0_CTLr_RESERVED_Rf_SET
#define READ_TRUNK_GRP0_CTLr BCM6300_A0_READ_TRUNK_GRP0_CTLr
#define WRITE_TRUNK_GRP0_CTLr BCM6300_A0_WRITE_TRUNK_GRP0_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_TRUNK_GRP0_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  TRUNK_GRP1_CTL
 * BLOCKS:   SYS
 * DESC:     Trunk Group 1 Control Register
 * SIZE:     16
 * FIELDS:
 *     TRUNK_PORT_MAP1  Per bit per Port trunk group vector.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_TRUNK_GRP1_CTLr 0x00003212

#define BCM6300_A0_TRUNK_GRP1_CTLr_SIZE 2

/*
 * This structure should be used to declare and program TRUNK_GRP1_CTL.
 *
 */
typedef union BCM6300_A0_TRUNK_GRP1_CTLr_s {
	uint32_t v[1];
	uint32_t trunk_grp1_ctl[1];
	uint32_t _trunk_grp1_ctl;
} BCM6300_A0_TRUNK_GRP1_CTLr_t;

#define BCM6300_A0_TRUNK_GRP1_CTLr_CLR(r) (r).trunk_grp1_ctl[0] = 0
#define BCM6300_A0_TRUNK_GRP1_CTLr_SET(r,d) (r).trunk_grp1_ctl[0] = d
#define BCM6300_A0_TRUNK_GRP1_CTLr_GET(r) (r).trunk_grp1_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_TRUNK_GRP1_CTLr_TRUNK_PORT_MAP1f_GET(r) (((r).trunk_grp1_ctl[0]) & 0x1ff)
#define BCM6300_A0_TRUNK_GRP1_CTLr_TRUNK_PORT_MAP1f_SET(r,f) (r).trunk_grp1_ctl[0]=(((r).trunk_grp1_ctl[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_TRUNK_GRP1_CTLr_RESERVED_Rf_GET(r) ((((r).trunk_grp1_ctl[0]) >> 9) & 0x7f)
#define BCM6300_A0_TRUNK_GRP1_CTLr_RESERVED_Rf_SET(r,f) (r).trunk_grp1_ctl[0]=(((r).trunk_grp1_ctl[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access TRUNK_GRP1_CTL.
 *
 */
#define BCM6300_A0_READ_TRUNK_GRP1_CTLr(u,r) cdk_robo_reg_read(u,BCM6300_A0_TRUNK_GRP1_CTLr,(r._trunk_grp1_ctl),2)
#define BCM6300_A0_WRITE_TRUNK_GRP1_CTLr(u,r) cdk_robo_reg_write(u,BCM6300_A0_TRUNK_GRP1_CTLr,&(r._trunk_grp1_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRUNK_GRP1_CTLr BCM6300_A0_TRUNK_GRP1_CTLr
#define TRUNK_GRP1_CTLr_SIZE BCM6300_A0_TRUNK_GRP1_CTLr_SIZE
typedef BCM6300_A0_TRUNK_GRP1_CTLr_t TRUNK_GRP1_CTLr_t;
#define TRUNK_GRP1_CTLr_CLR BCM6300_A0_TRUNK_GRP1_CTLr_CLR
#define TRUNK_GRP1_CTLr_SET BCM6300_A0_TRUNK_GRP1_CTLr_SET
#define TRUNK_GRP1_CTLr_GET BCM6300_A0_TRUNK_GRP1_CTLr_GET
#define TRUNK_GRP1_CTLr_TRUNK_PORT_MAP1f_GET BCM6300_A0_TRUNK_GRP1_CTLr_TRUNK_PORT_MAP1f_GET
#define TRUNK_GRP1_CTLr_TRUNK_PORT_MAP1f_SET BCM6300_A0_TRUNK_GRP1_CTLr_TRUNK_PORT_MAP1f_SET
#define TRUNK_GRP1_CTLr_RESERVED_Rf_GET BCM6300_A0_TRUNK_GRP1_CTLr_RESERVED_Rf_GET
#define TRUNK_GRP1_CTLr_RESERVED_Rf_SET BCM6300_A0_TRUNK_GRP1_CTLr_RESERVED_Rf_SET
#define READ_TRUNK_GRP1_CTLr BCM6300_A0_READ_TRUNK_GRP1_CTLr
#define WRITE_TRUNK_GRP1_CTLr BCM6300_A0_WRITE_TRUNK_GRP1_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_TRUNK_GRP1_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  TRUNK_GRP2_CTL
 * BLOCKS:   SYS
 * DESC:     Trunk Group 2 Control Register
 * SIZE:     16
 * FIELDS:
 *     TRUNK_PORT_MAP2  Per bit per Port trunk group vector.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_TRUNK_GRP2_CTLr 0x00003214

#define BCM6300_A0_TRUNK_GRP2_CTLr_SIZE 2

/*
 * This structure should be used to declare and program TRUNK_GRP2_CTL.
 *
 */
typedef union BCM6300_A0_TRUNK_GRP2_CTLr_s {
	uint32_t v[1];
	uint32_t trunk_grp2_ctl[1];
	uint32_t _trunk_grp2_ctl;
} BCM6300_A0_TRUNK_GRP2_CTLr_t;

#define BCM6300_A0_TRUNK_GRP2_CTLr_CLR(r) (r).trunk_grp2_ctl[0] = 0
#define BCM6300_A0_TRUNK_GRP2_CTLr_SET(r,d) (r).trunk_grp2_ctl[0] = d
#define BCM6300_A0_TRUNK_GRP2_CTLr_GET(r) (r).trunk_grp2_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_TRUNK_GRP2_CTLr_TRUNK_PORT_MAP2f_GET(r) (((r).trunk_grp2_ctl[0]) & 0x1ff)
#define BCM6300_A0_TRUNK_GRP2_CTLr_TRUNK_PORT_MAP2f_SET(r,f) (r).trunk_grp2_ctl[0]=(((r).trunk_grp2_ctl[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_TRUNK_GRP2_CTLr_RESERVED_Rf_GET(r) ((((r).trunk_grp2_ctl[0]) >> 9) & 0x7f)
#define BCM6300_A0_TRUNK_GRP2_CTLr_RESERVED_Rf_SET(r,f) (r).trunk_grp2_ctl[0]=(((r).trunk_grp2_ctl[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access TRUNK_GRP2_CTL.
 *
 */
#define BCM6300_A0_READ_TRUNK_GRP2_CTLr(u,r) cdk_robo_reg_read(u,BCM6300_A0_TRUNK_GRP2_CTLr,(r._trunk_grp2_ctl),2)
#define BCM6300_A0_WRITE_TRUNK_GRP2_CTLr(u,r) cdk_robo_reg_write(u,BCM6300_A0_TRUNK_GRP2_CTLr,&(r._trunk_grp2_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRUNK_GRP2_CTLr BCM6300_A0_TRUNK_GRP2_CTLr
#define TRUNK_GRP2_CTLr_SIZE BCM6300_A0_TRUNK_GRP2_CTLr_SIZE
typedef BCM6300_A0_TRUNK_GRP2_CTLr_t TRUNK_GRP2_CTLr_t;
#define TRUNK_GRP2_CTLr_CLR BCM6300_A0_TRUNK_GRP2_CTLr_CLR
#define TRUNK_GRP2_CTLr_SET BCM6300_A0_TRUNK_GRP2_CTLr_SET
#define TRUNK_GRP2_CTLr_GET BCM6300_A0_TRUNK_GRP2_CTLr_GET
#define TRUNK_GRP2_CTLr_TRUNK_PORT_MAP2f_GET BCM6300_A0_TRUNK_GRP2_CTLr_TRUNK_PORT_MAP2f_GET
#define TRUNK_GRP2_CTLr_TRUNK_PORT_MAP2f_SET BCM6300_A0_TRUNK_GRP2_CTLr_TRUNK_PORT_MAP2f_SET
#define TRUNK_GRP2_CTLr_RESERVED_Rf_GET BCM6300_A0_TRUNK_GRP2_CTLr_RESERVED_Rf_GET
#define TRUNK_GRP2_CTLr_RESERVED_Rf_SET BCM6300_A0_TRUNK_GRP2_CTLr_RESERVED_Rf_SET
#define READ_TRUNK_GRP2_CTLr BCM6300_A0_READ_TRUNK_GRP2_CTLr
#define WRITE_TRUNK_GRP2_CTLr BCM6300_A0_WRITE_TRUNK_GRP2_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_TRUNK_GRP2_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  TRUNK_GRP3_CTL
 * BLOCKS:   SYS
 * DESC:     Trunk Group 3 Control Register
 * SIZE:     16
 * FIELDS:
 *     TRUNK_PORT_MAP3  Per bit per Port trunk group vector.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_TRUNK_GRP3_CTLr 0x00003216

#define BCM6300_A0_TRUNK_GRP3_CTLr_SIZE 2

/*
 * This structure should be used to declare and program TRUNK_GRP3_CTL.
 *
 */
typedef union BCM6300_A0_TRUNK_GRP3_CTLr_s {
	uint32_t v[1];
	uint32_t trunk_grp3_ctl[1];
	uint32_t _trunk_grp3_ctl;
} BCM6300_A0_TRUNK_GRP3_CTLr_t;

#define BCM6300_A0_TRUNK_GRP3_CTLr_CLR(r) (r).trunk_grp3_ctl[0] = 0
#define BCM6300_A0_TRUNK_GRP3_CTLr_SET(r,d) (r).trunk_grp3_ctl[0] = d
#define BCM6300_A0_TRUNK_GRP3_CTLr_GET(r) (r).trunk_grp3_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_TRUNK_GRP3_CTLr_TRUNK_PORT_MAP3f_GET(r) (((r).trunk_grp3_ctl[0]) & 0x1ff)
#define BCM6300_A0_TRUNK_GRP3_CTLr_TRUNK_PORT_MAP3f_SET(r,f) (r).trunk_grp3_ctl[0]=(((r).trunk_grp3_ctl[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_TRUNK_GRP3_CTLr_RESERVED_Rf_GET(r) ((((r).trunk_grp3_ctl[0]) >> 9) & 0x7f)
#define BCM6300_A0_TRUNK_GRP3_CTLr_RESERVED_Rf_SET(r,f) (r).trunk_grp3_ctl[0]=(((r).trunk_grp3_ctl[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access TRUNK_GRP3_CTL.
 *
 */
#define BCM6300_A0_READ_TRUNK_GRP3_CTLr(u,r) cdk_robo_reg_read(u,BCM6300_A0_TRUNK_GRP3_CTLr,(r._trunk_grp3_ctl),2)
#define BCM6300_A0_WRITE_TRUNK_GRP3_CTLr(u,r) cdk_robo_reg_write(u,BCM6300_A0_TRUNK_GRP3_CTLr,&(r._trunk_grp3_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRUNK_GRP3_CTLr BCM6300_A0_TRUNK_GRP3_CTLr
#define TRUNK_GRP3_CTLr_SIZE BCM6300_A0_TRUNK_GRP3_CTLr_SIZE
typedef BCM6300_A0_TRUNK_GRP3_CTLr_t TRUNK_GRP3_CTLr_t;
#define TRUNK_GRP3_CTLr_CLR BCM6300_A0_TRUNK_GRP3_CTLr_CLR
#define TRUNK_GRP3_CTLr_SET BCM6300_A0_TRUNK_GRP3_CTLr_SET
#define TRUNK_GRP3_CTLr_GET BCM6300_A0_TRUNK_GRP3_CTLr_GET
#define TRUNK_GRP3_CTLr_TRUNK_PORT_MAP3f_GET BCM6300_A0_TRUNK_GRP3_CTLr_TRUNK_PORT_MAP3f_GET
#define TRUNK_GRP3_CTLr_TRUNK_PORT_MAP3f_SET BCM6300_A0_TRUNK_GRP3_CTLr_TRUNK_PORT_MAP3f_SET
#define TRUNK_GRP3_CTLr_RESERVED_Rf_GET BCM6300_A0_TRUNK_GRP3_CTLr_RESERVED_Rf_GET
#define TRUNK_GRP3_CTLr_RESERVED_Rf_SET BCM6300_A0_TRUNK_GRP3_CTLr_RESERVED_Rf_SET
#define READ_TRUNK_GRP3_CTLr BCM6300_A0_READ_TRUNK_GRP3_CTLr
#define WRITE_TRUNK_GRP3_CTLr BCM6300_A0_WRITE_TRUNK_GRP3_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_TRUNK_GRP3_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  TXQ_FLUSH_MODE
 * BLOCKS:   SYS
 * DESC:     TxQ Flush Mode Control Registrer
 * SIZE:     8
 * FIELDS:
 *     BYPASS_FASTTXDSC_PATH Bypass Fast Txdsc Path.
 *     DIS_NEW_TXDIS    Disable new txdisable.
 *     EN_LCOL_FLUSH    Enable Locl Flush.
 *     EN_RELOAD_ERR_PATH Enable Reload Error Path.
 *     EN_LCOL_TXFM_MASK enable_lcol_txfm_mask (default = 0)Description:- When enabled, 5388 drops the TX frame upon a latecollision.  (collisions detected beyond 64th byte including the preamble)- When disabled, 5388 transmits TX frames regardless of late-collision occurrence.
 *     EN_ECOL_TXFM_MASK enable_ecol_txfm_mask (default = 1)This bit affect the behavior of the register Retry_Lmt_Dis (Switch Mode reg 00:0Bh bit2) as follows:- When Retry_Lmt_Dis = 1 and enable_ecol_txfm_mask = 1, TX frame is persistently retried forever, while the back off counter increments from 0 to 15 and stay at 15 until the next normal frame transmission.- When Retry_Lmt_Dis = 1 and enable_ecol_txfm_mask = 0, TX frame is persistently retried forever, while the back off counter increments from 0 to 15 and loops back to 0and repeats this until the next normal frame transmission.When Retry_Lmt_Dis = 0 and enable_ecol_txfm_mask = 1, TX frame is retried up to 15 times, and the frame gets dropped upon the 16th consecutive early collision.When Retry_Lmt_Dis = 0 and enable_ecol_txfm_mask = 0,This mode is only engineering purpose, and prohibited for customers (ENGINEERING NOTE: This mode sets 5388 to the old mode, where we observed the tx ports hang. Don't show this in the customer datasheet).
 *     EN_LATECOL65_DROP enable_latecol65_drop.Enable old frame drop when a late collision occurs at 65th byte from start of preamble. When enabled, 5388 goes back to old mode by turning off the fix for Cisco TX Hang.Default is 0NOTE: Engineering only. Do not release this reg to customers.
 *     EN_NEW_BOFF_SEED 1b1: backoff seed refer to port number.1b0: backoff seed use default fix number
 *
 ******************************************************************************/
#define BCM6300_A0_TXQ_FLUSH_MODEr 0x00000031

#define BCM6300_A0_TXQ_FLUSH_MODEr_SIZE 1

/*
 * This structure should be used to declare and program TXQ_FLUSH_MODE.
 *
 */
typedef union BCM6300_A0_TXQ_FLUSH_MODEr_s {
	uint32_t v[1];
	uint32_t txq_flush_mode[1];
	uint32_t _txq_flush_mode;
} BCM6300_A0_TXQ_FLUSH_MODEr_t;

#define BCM6300_A0_TXQ_FLUSH_MODEr_CLR(r) (r).txq_flush_mode[0] = 0
#define BCM6300_A0_TXQ_FLUSH_MODEr_SET(r,d) (r).txq_flush_mode[0] = d
#define BCM6300_A0_TXQ_FLUSH_MODEr_GET(r) (r).txq_flush_mode[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_TXQ_FLUSH_MODEr_BYPASS_FASTTXDSC_PATHf_GET(r) (((r).txq_flush_mode[0]) & 0x1)
#define BCM6300_A0_TXQ_FLUSH_MODEr_BYPASS_FASTTXDSC_PATHf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM6300_A0_TXQ_FLUSH_MODEr_DIS_NEW_TXDISf_GET(r) ((((r).txq_flush_mode[0]) >> 1) & 0x1)
#define BCM6300_A0_TXQ_FLUSH_MODEr_DIS_NEW_TXDISf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM6300_A0_TXQ_FLUSH_MODEr_EN_LCOL_FLUSHf_GET(r) ((((r).txq_flush_mode[0]) >> 2) & 0x1)
#define BCM6300_A0_TXQ_FLUSH_MODEr_EN_LCOL_FLUSHf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM6300_A0_TXQ_FLUSH_MODEr_EN_RELOAD_ERR_PATHf_GET(r) ((((r).txq_flush_mode[0]) >> 3) & 0x1)
#define BCM6300_A0_TXQ_FLUSH_MODEr_EN_RELOAD_ERR_PATHf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM6300_A0_TXQ_FLUSH_MODEr_EN_LCOL_TXFM_MASKf_GET(r) ((((r).txq_flush_mode[0]) >> 4) & 0x1)
#define BCM6300_A0_TXQ_FLUSH_MODEr_EN_LCOL_TXFM_MASKf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM6300_A0_TXQ_FLUSH_MODEr_EN_ECOL_TXFM_MASKf_GET(r) ((((r).txq_flush_mode[0]) >> 5) & 0x1)
#define BCM6300_A0_TXQ_FLUSH_MODEr_EN_ECOL_TXFM_MASKf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM6300_A0_TXQ_FLUSH_MODEr_EN_LATECOL65_DROPf_GET(r) ((((r).txq_flush_mode[0]) >> 6) & 0x1)
#define BCM6300_A0_TXQ_FLUSH_MODEr_EN_LATECOL65_DROPf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM6300_A0_TXQ_FLUSH_MODEr_EN_NEW_BOFF_SEEDf_GET(r) ((((r).txq_flush_mode[0]) >> 7) & 0x1)
#define BCM6300_A0_TXQ_FLUSH_MODEr_EN_NEW_BOFF_SEEDf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access TXQ_FLUSH_MODE.
 *
 */
#define BCM6300_A0_READ_TXQ_FLUSH_MODEr(u,r) cdk_robo_reg_read(u,BCM6300_A0_TXQ_FLUSH_MODEr,(r._txq_flush_mode),1)
#define BCM6300_A0_WRITE_TXQ_FLUSH_MODEr(u,r) cdk_robo_reg_write(u,BCM6300_A0_TXQ_FLUSH_MODEr,&(r._txq_flush_mode),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQ_FLUSH_MODEr BCM6300_A0_TXQ_FLUSH_MODEr
#define TXQ_FLUSH_MODEr_SIZE BCM6300_A0_TXQ_FLUSH_MODEr_SIZE
typedef BCM6300_A0_TXQ_FLUSH_MODEr_t TXQ_FLUSH_MODEr_t;
#define TXQ_FLUSH_MODEr_CLR BCM6300_A0_TXQ_FLUSH_MODEr_CLR
#define TXQ_FLUSH_MODEr_SET BCM6300_A0_TXQ_FLUSH_MODEr_SET
#define TXQ_FLUSH_MODEr_GET BCM6300_A0_TXQ_FLUSH_MODEr_GET
#define TXQ_FLUSH_MODEr_BYPASS_FASTTXDSC_PATHf_GET BCM6300_A0_TXQ_FLUSH_MODEr_BYPASS_FASTTXDSC_PATHf_GET
#define TXQ_FLUSH_MODEr_BYPASS_FASTTXDSC_PATHf_SET BCM6300_A0_TXQ_FLUSH_MODEr_BYPASS_FASTTXDSC_PATHf_SET
#define TXQ_FLUSH_MODEr_DIS_NEW_TXDISf_GET BCM6300_A0_TXQ_FLUSH_MODEr_DIS_NEW_TXDISf_GET
#define TXQ_FLUSH_MODEr_DIS_NEW_TXDISf_SET BCM6300_A0_TXQ_FLUSH_MODEr_DIS_NEW_TXDISf_SET
#define TXQ_FLUSH_MODEr_EN_LCOL_FLUSHf_GET BCM6300_A0_TXQ_FLUSH_MODEr_EN_LCOL_FLUSHf_GET
#define TXQ_FLUSH_MODEr_EN_LCOL_FLUSHf_SET BCM6300_A0_TXQ_FLUSH_MODEr_EN_LCOL_FLUSHf_SET
#define TXQ_FLUSH_MODEr_EN_RELOAD_ERR_PATHf_GET BCM6300_A0_TXQ_FLUSH_MODEr_EN_RELOAD_ERR_PATHf_GET
#define TXQ_FLUSH_MODEr_EN_RELOAD_ERR_PATHf_SET BCM6300_A0_TXQ_FLUSH_MODEr_EN_RELOAD_ERR_PATHf_SET
#define TXQ_FLUSH_MODEr_EN_LCOL_TXFM_MASKf_GET BCM6300_A0_TXQ_FLUSH_MODEr_EN_LCOL_TXFM_MASKf_GET
#define TXQ_FLUSH_MODEr_EN_LCOL_TXFM_MASKf_SET BCM6300_A0_TXQ_FLUSH_MODEr_EN_LCOL_TXFM_MASKf_SET
#define TXQ_FLUSH_MODEr_EN_ECOL_TXFM_MASKf_GET BCM6300_A0_TXQ_FLUSH_MODEr_EN_ECOL_TXFM_MASKf_GET
#define TXQ_FLUSH_MODEr_EN_ECOL_TXFM_MASKf_SET BCM6300_A0_TXQ_FLUSH_MODEr_EN_ECOL_TXFM_MASKf_SET
#define TXQ_FLUSH_MODEr_EN_LATECOL65_DROPf_GET BCM6300_A0_TXQ_FLUSH_MODEr_EN_LATECOL65_DROPf_GET
#define TXQ_FLUSH_MODEr_EN_LATECOL65_DROPf_SET BCM6300_A0_TXQ_FLUSH_MODEr_EN_LATECOL65_DROPf_SET
#define TXQ_FLUSH_MODEr_EN_NEW_BOFF_SEEDf_GET BCM6300_A0_TXQ_FLUSH_MODEr_EN_NEW_BOFF_SEEDf_GET
#define TXQ_FLUSH_MODEr_EN_NEW_BOFF_SEEDf_SET BCM6300_A0_TXQ_FLUSH_MODEr_EN_NEW_BOFF_SEEDf_SET
#define READ_TXQ_FLUSH_MODEr BCM6300_A0_READ_TXQ_FLUSH_MODEr
#define WRITE_TXQ_FLUSH_MODEr BCM6300_A0_WRITE_TXQ_FLUSH_MODEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_TXQ_FLUSH_MODEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  TX_PAUSE_PASS
 * BLOCKS:   SYS
 * DESC:     Pause pass Through for TX Registrer
 * SIZE:     16
 * FIELDS:
 *     TX_PAUSE_PASS    TX pause pass through map.1 : ignore 802.3x.0 :comply with 802.3x pause frame receiving.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_TX_PAUSE_PASSr 0x0000003a

#define BCM6300_A0_TX_PAUSE_PASSr_SIZE 2

/*
 * This structure should be used to declare and program TX_PAUSE_PASS.
 *
 */
typedef union BCM6300_A0_TX_PAUSE_PASSr_s {
	uint32_t v[1];
	uint32_t tx_pause_pass[1];
	uint32_t _tx_pause_pass;
} BCM6300_A0_TX_PAUSE_PASSr_t;

#define BCM6300_A0_TX_PAUSE_PASSr_CLR(r) (r).tx_pause_pass[0] = 0
#define BCM6300_A0_TX_PAUSE_PASSr_SET(r,d) (r).tx_pause_pass[0] = d
#define BCM6300_A0_TX_PAUSE_PASSr_GET(r) (r).tx_pause_pass[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_TX_PAUSE_PASSr_TX_PAUSE_PASSf_GET(r) (((r).tx_pause_pass[0]) & 0x1ff)
#define BCM6300_A0_TX_PAUSE_PASSr_TX_PAUSE_PASSf_SET(r,f) (r).tx_pause_pass[0]=(((r).tx_pause_pass[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_TX_PAUSE_PASSr_RESERVED_Rf_GET(r) ((((r).tx_pause_pass[0]) >> 9) & 0x7f)
#define BCM6300_A0_TX_PAUSE_PASSr_RESERVED_Rf_SET(r,f) (r).tx_pause_pass[0]=(((r).tx_pause_pass[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access TX_PAUSE_PASS.
 *
 */
#define BCM6300_A0_READ_TX_PAUSE_PASSr(u,r) cdk_robo_reg_read(u,BCM6300_A0_TX_PAUSE_PASSr,(r._tx_pause_pass),2)
#define BCM6300_A0_WRITE_TX_PAUSE_PASSr(u,r) cdk_robo_reg_write(u,BCM6300_A0_TX_PAUSE_PASSr,&(r._tx_pause_pass),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TX_PAUSE_PASSr BCM6300_A0_TX_PAUSE_PASSr
#define TX_PAUSE_PASSr_SIZE BCM6300_A0_TX_PAUSE_PASSr_SIZE
typedef BCM6300_A0_TX_PAUSE_PASSr_t TX_PAUSE_PASSr_t;
#define TX_PAUSE_PASSr_CLR BCM6300_A0_TX_PAUSE_PASSr_CLR
#define TX_PAUSE_PASSr_SET BCM6300_A0_TX_PAUSE_PASSr_SET
#define TX_PAUSE_PASSr_GET BCM6300_A0_TX_PAUSE_PASSr_GET
#define TX_PAUSE_PASSr_TX_PAUSE_PASSf_GET BCM6300_A0_TX_PAUSE_PASSr_TX_PAUSE_PASSf_GET
#define TX_PAUSE_PASSr_TX_PAUSE_PASSf_SET BCM6300_A0_TX_PAUSE_PASSr_TX_PAUSE_PASSf_SET
#define TX_PAUSE_PASSr_RESERVED_Rf_GET BCM6300_A0_TX_PAUSE_PASSr_RESERVED_Rf_GET
#define TX_PAUSE_PASSr_RESERVED_Rf_SET BCM6300_A0_TX_PAUSE_PASSr_RESERVED_Rf_SET
#define READ_TX_PAUSE_PASSr BCM6300_A0_READ_TX_PAUSE_PASSr
#define WRITE_TX_PAUSE_PASSr BCM6300_A0_WRITE_TX_PAUSE_PASSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_TX_PAUSE_PASSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  TxBroadcastPkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Broadcast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM6300_A0_TXBROADCASTPKTSr 0x00002010

#define BCM6300_A0_TXBROADCASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program TxBroadcastPkts.
 *
 */
typedef union BCM6300_A0_TXBROADCASTPKTSr_s {
	uint32_t v[1];
	uint32_t txbroadcastpkts[1];
	uint32_t _txbroadcastpkts;
} BCM6300_A0_TXBROADCASTPKTSr_t;

#define BCM6300_A0_TXBROADCASTPKTSr_CLR(r) (r).txbroadcastpkts[0] = 0
#define BCM6300_A0_TXBROADCASTPKTSr_SET(r,d) (r).txbroadcastpkts[0] = d
#define BCM6300_A0_TXBROADCASTPKTSr_GET(r) (r).txbroadcastpkts[0]


/*
 * These macros can be used to access TxBroadcastPkts.
 *
 */
#define BCM6300_A0_READ_TXBROADCASTPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_TXBROADCASTPKTSr,(r._txbroadcastpkts),4)
#define BCM6300_A0_WRITE_TXBROADCASTPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_TXBROADCASTPKTSr,&(r._txbroadcastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXBROADCASTPKTSr BCM6300_A0_TXBROADCASTPKTSr
#define TXBROADCASTPKTSr_SIZE BCM6300_A0_TXBROADCASTPKTSr_SIZE
typedef BCM6300_A0_TXBROADCASTPKTSr_t TXBROADCASTPKTSr_t;
#define TXBROADCASTPKTSr_CLR BCM6300_A0_TXBROADCASTPKTSr_CLR
#define TXBROADCASTPKTSr_SET BCM6300_A0_TXBROADCASTPKTSr_SET
#define TXBROADCASTPKTSr_GET BCM6300_A0_TXBROADCASTPKTSr_GET
#define READ_TXBROADCASTPKTSr BCM6300_A0_READ_TXBROADCASTPKTSr
#define WRITE_TXBROADCASTPKTSr BCM6300_A0_WRITE_TXBROADCASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_TXBROADCASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  TxCollisions
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM6300_A0_TXCOLLISIONSr 0x0000201c

#define BCM6300_A0_TXCOLLISIONSr_SIZE 4

/*
 * This structure should be used to declare and program TxCollisions.
 *
 */
typedef union BCM6300_A0_TXCOLLISIONSr_s {
	uint32_t v[1];
	uint32_t txcollisions[1];
	uint32_t _txcollisions;
} BCM6300_A0_TXCOLLISIONSr_t;

#define BCM6300_A0_TXCOLLISIONSr_CLR(r) (r).txcollisions[0] = 0
#define BCM6300_A0_TXCOLLISIONSr_SET(r,d) (r).txcollisions[0] = d
#define BCM6300_A0_TXCOLLISIONSr_GET(r) (r).txcollisions[0]


/*
 * These macros can be used to access TxCollisions.
 *
 */
#define BCM6300_A0_READ_TXCOLLISIONSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_TXCOLLISIONSr,(r._txcollisions),4)
#define BCM6300_A0_WRITE_TXCOLLISIONSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_TXCOLLISIONSr,&(r._txcollisions),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXCOLLISIONSr BCM6300_A0_TXCOLLISIONSr
#define TXCOLLISIONSr_SIZE BCM6300_A0_TXCOLLISIONSr_SIZE
typedef BCM6300_A0_TXCOLLISIONSr_t TXCOLLISIONSr_t;
#define TXCOLLISIONSr_CLR BCM6300_A0_TXCOLLISIONSr_CLR
#define TXCOLLISIONSr_SET BCM6300_A0_TXCOLLISIONSr_SET
#define TXCOLLISIONSr_GET BCM6300_A0_TXCOLLISIONSr_GET
#define READ_TXCOLLISIONSr BCM6300_A0_READ_TXCOLLISIONSr
#define WRITE_TXCOLLISIONSr BCM6300_A0_WRITE_TXCOLLISIONSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_TXCOLLISIONSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  TxDeferredTransmit
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Deferred Transmit Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM6300_A0_TXDEFERREDTRANSMITr 0x00002028

#define BCM6300_A0_TXDEFERREDTRANSMITr_SIZE 4

/*
 * This structure should be used to declare and program TxDeferredTransmit.
 *
 */
typedef union BCM6300_A0_TXDEFERREDTRANSMITr_s {
	uint32_t v[1];
	uint32_t txdeferredtransmit[1];
	uint32_t _txdeferredtransmit;
} BCM6300_A0_TXDEFERREDTRANSMITr_t;

#define BCM6300_A0_TXDEFERREDTRANSMITr_CLR(r) (r).txdeferredtransmit[0] = 0
#define BCM6300_A0_TXDEFERREDTRANSMITr_SET(r,d) (r).txdeferredtransmit[0] = d
#define BCM6300_A0_TXDEFERREDTRANSMITr_GET(r) (r).txdeferredtransmit[0]


/*
 * These macros can be used to access TxDeferredTransmit.
 *
 */
#define BCM6300_A0_READ_TXDEFERREDTRANSMITr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_TXDEFERREDTRANSMITr,(r._txdeferredtransmit),4)
#define BCM6300_A0_WRITE_TXDEFERREDTRANSMITr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_TXDEFERREDTRANSMITr,&(r._txdeferredtransmit),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXDEFERREDTRANSMITr BCM6300_A0_TXDEFERREDTRANSMITr
#define TXDEFERREDTRANSMITr_SIZE BCM6300_A0_TXDEFERREDTRANSMITr_SIZE
typedef BCM6300_A0_TXDEFERREDTRANSMITr_t TXDEFERREDTRANSMITr_t;
#define TXDEFERREDTRANSMITr_CLR BCM6300_A0_TXDEFERREDTRANSMITr_CLR
#define TXDEFERREDTRANSMITr_SET BCM6300_A0_TXDEFERREDTRANSMITr_SET
#define TXDEFERREDTRANSMITr_GET BCM6300_A0_TXDEFERREDTRANSMITr_GET
#define READ_TXDEFERREDTRANSMITr BCM6300_A0_READ_TXDEFERREDTRANSMITr
#define WRITE_TXDEFERREDTRANSMITr BCM6300_A0_WRITE_TXDEFERREDTRANSMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_TXDEFERREDTRANSMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  TxDropPkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     TX Drop Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM6300_A0_TXDROPPKTSr 0x00002008

#define BCM6300_A0_TXDROPPKTSr_SIZE 4

/*
 * This structure should be used to declare and program TxDropPkts.
 *
 */
typedef union BCM6300_A0_TXDROPPKTSr_s {
	uint32_t v[1];
	uint32_t txdroppkts[1];
	uint32_t _txdroppkts;
} BCM6300_A0_TXDROPPKTSr_t;

#define BCM6300_A0_TXDROPPKTSr_CLR(r) (r).txdroppkts[0] = 0
#define BCM6300_A0_TXDROPPKTSr_SET(r,d) (r).txdroppkts[0] = d
#define BCM6300_A0_TXDROPPKTSr_GET(r) (r).txdroppkts[0]


/*
 * These macros can be used to access TxDropPkts.
 *
 */
#define BCM6300_A0_READ_TXDROPPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_TXDROPPKTSr,(r._txdroppkts),4)
#define BCM6300_A0_WRITE_TXDROPPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_TXDROPPKTSr,&(r._txdroppkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXDROPPKTSr BCM6300_A0_TXDROPPKTSr
#define TXDROPPKTSr_SIZE BCM6300_A0_TXDROPPKTSr_SIZE
typedef BCM6300_A0_TXDROPPKTSr_t TXDROPPKTSr_t;
#define TXDROPPKTSr_CLR BCM6300_A0_TXDROPPKTSr_CLR
#define TXDROPPKTSr_SET BCM6300_A0_TXDROPPKTSr_SET
#define TXDROPPKTSr_GET BCM6300_A0_TXDROPPKTSr_GET
#define READ_TXDROPPKTSr BCM6300_A0_READ_TXDROPPKTSr
#define WRITE_TXDROPPKTSr BCM6300_A0_WRITE_TXDROPPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_TXDROPPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  TxExcessiveCollision
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Excessive Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM6300_A0_TXEXCESSIVECOLLISIONr 0x00002030

#define BCM6300_A0_TXEXCESSIVECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program TxExcessiveCollision.
 *
 */
typedef union BCM6300_A0_TXEXCESSIVECOLLISIONr_s {
	uint32_t v[1];
	uint32_t txexcessivecollision[1];
	uint32_t _txexcessivecollision;
} BCM6300_A0_TXEXCESSIVECOLLISIONr_t;

#define BCM6300_A0_TXEXCESSIVECOLLISIONr_CLR(r) (r).txexcessivecollision[0] = 0
#define BCM6300_A0_TXEXCESSIVECOLLISIONr_SET(r,d) (r).txexcessivecollision[0] = d
#define BCM6300_A0_TXEXCESSIVECOLLISIONr_GET(r) (r).txexcessivecollision[0]


/*
 * These macros can be used to access TxExcessiveCollision.
 *
 */
#define BCM6300_A0_READ_TXEXCESSIVECOLLISIONr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_TXEXCESSIVECOLLISIONr,(r._txexcessivecollision),4)
#define BCM6300_A0_WRITE_TXEXCESSIVECOLLISIONr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_TXEXCESSIVECOLLISIONr,&(r._txexcessivecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXEXCESSIVECOLLISIONr BCM6300_A0_TXEXCESSIVECOLLISIONr
#define TXEXCESSIVECOLLISIONr_SIZE BCM6300_A0_TXEXCESSIVECOLLISIONr_SIZE
typedef BCM6300_A0_TXEXCESSIVECOLLISIONr_t TXEXCESSIVECOLLISIONr_t;
#define TXEXCESSIVECOLLISIONr_CLR BCM6300_A0_TXEXCESSIVECOLLISIONr_CLR
#define TXEXCESSIVECOLLISIONr_SET BCM6300_A0_TXEXCESSIVECOLLISIONr_SET
#define TXEXCESSIVECOLLISIONr_GET BCM6300_A0_TXEXCESSIVECOLLISIONr_GET
#define READ_TXEXCESSIVECOLLISIONr BCM6300_A0_READ_TXEXCESSIVECOLLISIONr
#define WRITE_TXEXCESSIVECOLLISIONr BCM6300_A0_WRITE_TXEXCESSIVECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_TXEXCESSIVECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  TxFrameInDisc
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Fram IN Disc Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM6300_A0_TXFRAMEINDISCr 0x00002034

#define BCM6300_A0_TXFRAMEINDISCr_SIZE 4

/*
 * This structure should be used to declare and program TxFrameInDisc.
 *
 */
typedef union BCM6300_A0_TXFRAMEINDISCr_s {
	uint32_t v[1];
	uint32_t txframeindisc[1];
	uint32_t _txframeindisc;
} BCM6300_A0_TXFRAMEINDISCr_t;

#define BCM6300_A0_TXFRAMEINDISCr_CLR(r) (r).txframeindisc[0] = 0
#define BCM6300_A0_TXFRAMEINDISCr_SET(r,d) (r).txframeindisc[0] = d
#define BCM6300_A0_TXFRAMEINDISCr_GET(r) (r).txframeindisc[0]


/*
 * These macros can be used to access TxFrameInDisc.
 *
 */
#define BCM6300_A0_READ_TXFRAMEINDISCr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_TXFRAMEINDISCr,(r._txframeindisc),4)
#define BCM6300_A0_WRITE_TXFRAMEINDISCr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_TXFRAMEINDISCr,&(r._txframeindisc),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXFRAMEINDISCr BCM6300_A0_TXFRAMEINDISCr
#define TXFRAMEINDISCr_SIZE BCM6300_A0_TXFRAMEINDISCr_SIZE
typedef BCM6300_A0_TXFRAMEINDISCr_t TXFRAMEINDISCr_t;
#define TXFRAMEINDISCr_CLR BCM6300_A0_TXFRAMEINDISCr_CLR
#define TXFRAMEINDISCr_SET BCM6300_A0_TXFRAMEINDISCr_SET
#define TXFRAMEINDISCr_GET BCM6300_A0_TXFRAMEINDISCr_GET
#define READ_TXFRAMEINDISCr BCM6300_A0_READ_TXFRAMEINDISCr
#define WRITE_TXFRAMEINDISCr BCM6300_A0_WRITE_TXFRAMEINDISCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_TXFRAMEINDISCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  TxLateCollision
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Late Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM6300_A0_TXLATECOLLISIONr 0x0000202c

#define BCM6300_A0_TXLATECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program TxLateCollision.
 *
 */
typedef union BCM6300_A0_TXLATECOLLISIONr_s {
	uint32_t v[1];
	uint32_t txlatecollision[1];
	uint32_t _txlatecollision;
} BCM6300_A0_TXLATECOLLISIONr_t;

#define BCM6300_A0_TXLATECOLLISIONr_CLR(r) (r).txlatecollision[0] = 0
#define BCM6300_A0_TXLATECOLLISIONr_SET(r,d) (r).txlatecollision[0] = d
#define BCM6300_A0_TXLATECOLLISIONr_GET(r) (r).txlatecollision[0]


/*
 * These macros can be used to access TxLateCollision.
 *
 */
#define BCM6300_A0_READ_TXLATECOLLISIONr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_TXLATECOLLISIONr,(r._txlatecollision),4)
#define BCM6300_A0_WRITE_TXLATECOLLISIONr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_TXLATECOLLISIONr,&(r._txlatecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXLATECOLLISIONr BCM6300_A0_TXLATECOLLISIONr
#define TXLATECOLLISIONr_SIZE BCM6300_A0_TXLATECOLLISIONr_SIZE
typedef BCM6300_A0_TXLATECOLLISIONr_t TXLATECOLLISIONr_t;
#define TXLATECOLLISIONr_CLR BCM6300_A0_TXLATECOLLISIONr_CLR
#define TXLATECOLLISIONr_SET BCM6300_A0_TXLATECOLLISIONr_SET
#define TXLATECOLLISIONr_GET BCM6300_A0_TXLATECOLLISIONr_GET
#define READ_TXLATECOLLISIONr BCM6300_A0_READ_TXLATECOLLISIONr
#define WRITE_TXLATECOLLISIONr BCM6300_A0_WRITE_TXLATECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_TXLATECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  TxMulticastPkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Multicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM6300_A0_TXMULTICASTPKTSr 0x00002014

#define BCM6300_A0_TXMULTICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program TxMulticastPkts.
 *
 */
typedef union BCM6300_A0_TXMULTICASTPKTSr_s {
	uint32_t v[1];
	uint32_t txmulticastpkts[1];
	uint32_t _txmulticastpkts;
} BCM6300_A0_TXMULTICASTPKTSr_t;

#define BCM6300_A0_TXMULTICASTPKTSr_CLR(r) (r).txmulticastpkts[0] = 0
#define BCM6300_A0_TXMULTICASTPKTSr_SET(r,d) (r).txmulticastpkts[0] = d
#define BCM6300_A0_TXMULTICASTPKTSr_GET(r) (r).txmulticastpkts[0]


/*
 * These macros can be used to access TxMulticastPkts.
 *
 */
#define BCM6300_A0_READ_TXMULTICASTPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_TXMULTICASTPKTSr,(r._txmulticastpkts),4)
#define BCM6300_A0_WRITE_TXMULTICASTPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_TXMULTICASTPKTSr,&(r._txmulticastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXMULTICASTPKTSr BCM6300_A0_TXMULTICASTPKTSr
#define TXMULTICASTPKTSr_SIZE BCM6300_A0_TXMULTICASTPKTSr_SIZE
typedef BCM6300_A0_TXMULTICASTPKTSr_t TXMULTICASTPKTSr_t;
#define TXMULTICASTPKTSr_CLR BCM6300_A0_TXMULTICASTPKTSr_CLR
#define TXMULTICASTPKTSr_SET BCM6300_A0_TXMULTICASTPKTSr_SET
#define TXMULTICASTPKTSr_GET BCM6300_A0_TXMULTICASTPKTSr_GET
#define READ_TXMULTICASTPKTSr BCM6300_A0_READ_TXMULTICASTPKTSr
#define WRITE_TXMULTICASTPKTSr BCM6300_A0_WRITE_TXMULTICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_TXMULTICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  TxMultipleCollision
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Multiple collsion Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM6300_A0_TXMULTIPLECOLLISIONr 0x00002024

#define BCM6300_A0_TXMULTIPLECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program TxMultipleCollision.
 *
 */
typedef union BCM6300_A0_TXMULTIPLECOLLISIONr_s {
	uint32_t v[1];
	uint32_t txmultiplecollision[1];
	uint32_t _txmultiplecollision;
} BCM6300_A0_TXMULTIPLECOLLISIONr_t;

#define BCM6300_A0_TXMULTIPLECOLLISIONr_CLR(r) (r).txmultiplecollision[0] = 0
#define BCM6300_A0_TXMULTIPLECOLLISIONr_SET(r,d) (r).txmultiplecollision[0] = d
#define BCM6300_A0_TXMULTIPLECOLLISIONr_GET(r) (r).txmultiplecollision[0]


/*
 * These macros can be used to access TxMultipleCollision.
 *
 */
#define BCM6300_A0_READ_TXMULTIPLECOLLISIONr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_TXMULTIPLECOLLISIONr,(r._txmultiplecollision),4)
#define BCM6300_A0_WRITE_TXMULTIPLECOLLISIONr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_TXMULTIPLECOLLISIONr,&(r._txmultiplecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXMULTIPLECOLLISIONr BCM6300_A0_TXMULTIPLECOLLISIONr
#define TXMULTIPLECOLLISIONr_SIZE BCM6300_A0_TXMULTIPLECOLLISIONr_SIZE
typedef BCM6300_A0_TXMULTIPLECOLLISIONr_t TXMULTIPLECOLLISIONr_t;
#define TXMULTIPLECOLLISIONr_CLR BCM6300_A0_TXMULTIPLECOLLISIONr_CLR
#define TXMULTIPLECOLLISIONr_SET BCM6300_A0_TXMULTIPLECOLLISIONr_SET
#define TXMULTIPLECOLLISIONr_GET BCM6300_A0_TXMULTIPLECOLLISIONr_GET
#define READ_TXMULTIPLECOLLISIONr BCM6300_A0_READ_TXMULTIPLECOLLISIONr
#define WRITE_TXMULTIPLECOLLISIONr BCM6300_A0_WRITE_TXMULTIPLECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_TXMULTIPLECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  TxOctets
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Octets
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM6300_A0_TXOCTETSr 0x00002000

#define BCM6300_A0_TXOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program TxOctets.
 *
 */
typedef union BCM6300_A0_TXOCTETSr_s {
	uint32_t v[2];
	uint32_t txoctets[2];
	uint32_t _txoctets;
} BCM6300_A0_TXOCTETSr_t;

#define BCM6300_A0_TXOCTETSr_CLR(r) CDK_MEMSET(&((r)._txoctets), 0, sizeof(BCM6300_A0_TXOCTETSr_t))
#define BCM6300_A0_TXOCTETSr_SET(r,i,d) (r).txoctets[i] = d
#define BCM6300_A0_TXOCTETSr_GET(r,i) (r).txoctets[i]


/*
 * These macros can be used to access TxOctets.
 *
 */
#define BCM6300_A0_READ_TXOCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_TXOCTETSr,(r._txoctets),8)
#define BCM6300_A0_WRITE_TXOCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_TXOCTETSr,&(r._txoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXOCTETSr BCM6300_A0_TXOCTETSr
#define TXOCTETSr_SIZE BCM6300_A0_TXOCTETSr_SIZE
typedef BCM6300_A0_TXOCTETSr_t TXOCTETSr_t;
#define TXOCTETSr_CLR BCM6300_A0_TXOCTETSr_CLR
#define TXOCTETSr_SET BCM6300_A0_TXOCTETSr_SET
#define TXOCTETSr_GET BCM6300_A0_TXOCTETSr_GET
#define READ_TXOCTETSr BCM6300_A0_READ_TXOCTETSr
#define WRITE_TXOCTETSr BCM6300_A0_WRITE_TXOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_TXOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  TxPausePkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Pause Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM6300_A0_TXPAUSEPKTSr 0x00002038

#define BCM6300_A0_TXPAUSEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program TxPausePkts.
 *
 */
typedef union BCM6300_A0_TXPAUSEPKTSr_s {
	uint32_t v[1];
	uint32_t txpausepkts[1];
	uint32_t _txpausepkts;
} BCM6300_A0_TXPAUSEPKTSr_t;

#define BCM6300_A0_TXPAUSEPKTSr_CLR(r) (r).txpausepkts[0] = 0
#define BCM6300_A0_TXPAUSEPKTSr_SET(r,d) (r).txpausepkts[0] = d
#define BCM6300_A0_TXPAUSEPKTSr_GET(r) (r).txpausepkts[0]


/*
 * These macros can be used to access TxPausePkts.
 *
 */
#define BCM6300_A0_READ_TXPAUSEPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_TXPAUSEPKTSr,(r._txpausepkts),4)
#define BCM6300_A0_WRITE_TXPAUSEPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_TXPAUSEPKTSr,&(r._txpausepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXPAUSEPKTSr BCM6300_A0_TXPAUSEPKTSr
#define TXPAUSEPKTSr_SIZE BCM6300_A0_TXPAUSEPKTSr_SIZE
typedef BCM6300_A0_TXPAUSEPKTSr_t TXPAUSEPKTSr_t;
#define TXPAUSEPKTSr_CLR BCM6300_A0_TXPAUSEPKTSr_CLR
#define TXPAUSEPKTSr_SET BCM6300_A0_TXPAUSEPKTSr_SET
#define TXPAUSEPKTSr_GET BCM6300_A0_TXPAUSEPKTSr_GET
#define READ_TXPAUSEPKTSr BCM6300_A0_READ_TXPAUSEPKTSr
#define WRITE_TXPAUSEPKTSr BCM6300_A0_WRITE_TXPAUSEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_TXPAUSEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  TxQoSOctets
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx QoS Packet Octets Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM6300_A0_TXQOSOCTETSr 0x0000203c

#define BCM6300_A0_TXQOSOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program TxQoSOctets.
 *
 */
typedef union BCM6300_A0_TXQOSOCTETSr_s {
	uint32_t v[2];
	uint32_t txqosoctets[2];
	uint32_t _txqosoctets;
} BCM6300_A0_TXQOSOCTETSr_t;

#define BCM6300_A0_TXQOSOCTETSr_CLR(r) CDK_MEMSET(&((r)._txqosoctets), 0, sizeof(BCM6300_A0_TXQOSOCTETSr_t))
#define BCM6300_A0_TXQOSOCTETSr_SET(r,i,d) (r).txqosoctets[i] = d
#define BCM6300_A0_TXQOSOCTETSr_GET(r,i) (r).txqosoctets[i]


/*
 * These macros can be used to access TxQoSOctets.
 *
 */
#define BCM6300_A0_READ_TXQOSOCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_TXQOSOCTETSr,(r._txqosoctets),8)
#define BCM6300_A0_WRITE_TXQOSOCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_TXQOSOCTETSr,&(r._txqosoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQOSOCTETSr BCM6300_A0_TXQOSOCTETSr
#define TXQOSOCTETSr_SIZE BCM6300_A0_TXQOSOCTETSr_SIZE
typedef BCM6300_A0_TXQOSOCTETSr_t TXQOSOCTETSr_t;
#define TXQOSOCTETSr_CLR BCM6300_A0_TXQOSOCTETSr_CLR
#define TXQOSOCTETSr_SET BCM6300_A0_TXQOSOCTETSr_SET
#define TXQOSOCTETSr_GET BCM6300_A0_TXQOSOCTETSr_GET
#define READ_TXQOSOCTETSr BCM6300_A0_READ_TXQOSOCTETSr
#define WRITE_TXQOSOCTETSr BCM6300_A0_WRITE_TXQOSOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_TXQOSOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  TxQoSPkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx QoS Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM6300_A0_TXQOSPKTSr 0x0000200c

#define BCM6300_A0_TXQOSPKTSr_SIZE 4

/*
 * This structure should be used to declare and program TxQoSPkts.
 *
 */
typedef union BCM6300_A0_TXQOSPKTSr_s {
	uint32_t v[1];
	uint32_t txqospkts[1];
	uint32_t _txqospkts;
} BCM6300_A0_TXQOSPKTSr_t;

#define BCM6300_A0_TXQOSPKTSr_CLR(r) (r).txqospkts[0] = 0
#define BCM6300_A0_TXQOSPKTSr_SET(r,d) (r).txqospkts[0] = d
#define BCM6300_A0_TXQOSPKTSr_GET(r) (r).txqospkts[0]


/*
 * These macros can be used to access TxQoSPkts.
 *
 */
#define BCM6300_A0_READ_TXQOSPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_TXQOSPKTSr,(r._txqospkts),4)
#define BCM6300_A0_WRITE_TXQOSPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_TXQOSPKTSr,&(r._txqospkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQOSPKTSr BCM6300_A0_TXQOSPKTSr
#define TXQOSPKTSr_SIZE BCM6300_A0_TXQOSPKTSr_SIZE
typedef BCM6300_A0_TXQOSPKTSr_t TXQOSPKTSr_t;
#define TXQOSPKTSr_CLR BCM6300_A0_TXQOSPKTSr_CLR
#define TXQOSPKTSr_SET BCM6300_A0_TXQOSPKTSr_SET
#define TXQOSPKTSr_GET BCM6300_A0_TXQOSPKTSr_GET
#define READ_TXQOSPKTSr BCM6300_A0_READ_TXQOSPKTSr
#define WRITE_TXQOSPKTSr BCM6300_A0_WRITE_TXQOSPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_TXQOSPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  TxSingleCollision
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Single Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM6300_A0_TXSINGLECOLLISIONr 0x00002020

#define BCM6300_A0_TXSINGLECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program TxSingleCollision.
 *
 */
typedef union BCM6300_A0_TXSINGLECOLLISIONr_s {
	uint32_t v[1];
	uint32_t txsinglecollision[1];
	uint32_t _txsinglecollision;
} BCM6300_A0_TXSINGLECOLLISIONr_t;

#define BCM6300_A0_TXSINGLECOLLISIONr_CLR(r) (r).txsinglecollision[0] = 0
#define BCM6300_A0_TXSINGLECOLLISIONr_SET(r,d) (r).txsinglecollision[0] = d
#define BCM6300_A0_TXSINGLECOLLISIONr_GET(r) (r).txsinglecollision[0]


/*
 * These macros can be used to access TxSingleCollision.
 *
 */
#define BCM6300_A0_READ_TXSINGLECOLLISIONr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_TXSINGLECOLLISIONr,(r._txsinglecollision),4)
#define BCM6300_A0_WRITE_TXSINGLECOLLISIONr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_TXSINGLECOLLISIONr,&(r._txsinglecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXSINGLECOLLISIONr BCM6300_A0_TXSINGLECOLLISIONr
#define TXSINGLECOLLISIONr_SIZE BCM6300_A0_TXSINGLECOLLISIONr_SIZE
typedef BCM6300_A0_TXSINGLECOLLISIONr_t TXSINGLECOLLISIONr_t;
#define TXSINGLECOLLISIONr_CLR BCM6300_A0_TXSINGLECOLLISIONr_CLR
#define TXSINGLECOLLISIONr_SET BCM6300_A0_TXSINGLECOLLISIONr_SET
#define TXSINGLECOLLISIONr_GET BCM6300_A0_TXSINGLECOLLISIONr_GET
#define READ_TXSINGLECOLLISIONr BCM6300_A0_READ_TXSINGLECOLLISIONr
#define WRITE_TXSINGLECOLLISIONr BCM6300_A0_WRITE_TXSINGLECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_TXSINGLECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  TxUnicastPkts
 * BLOCKS:   GPIC0 CPIC
 * DESC:     Tx Unicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM6300_A0_TXUNICASTPKTSr 0x00002018

#define BCM6300_A0_TXUNICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program TxUnicastPkts.
 *
 */
typedef union BCM6300_A0_TXUNICASTPKTSr_s {
	uint32_t v[1];
	uint32_t txunicastpkts[1];
	uint32_t _txunicastpkts;
} BCM6300_A0_TXUNICASTPKTSr_t;

#define BCM6300_A0_TXUNICASTPKTSr_CLR(r) (r).txunicastpkts[0] = 0
#define BCM6300_A0_TXUNICASTPKTSr_SET(r,d) (r).txunicastpkts[0] = d
#define BCM6300_A0_TXUNICASTPKTSr_GET(r) (r).txunicastpkts[0]


/*
 * These macros can be used to access TxUnicastPkts.
 *
 */
#define BCM6300_A0_READ_TXUNICASTPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM6300_A0_TXUNICASTPKTSr,(r._txunicastpkts),4)
#define BCM6300_A0_WRITE_TXUNICASTPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM6300_A0_TXUNICASTPKTSr,&(r._txunicastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXUNICASTPKTSr BCM6300_A0_TXUNICASTPKTSr
#define TXUNICASTPKTSr_SIZE BCM6300_A0_TXUNICASTPKTSr_SIZE
typedef BCM6300_A0_TXUNICASTPKTSr_t TXUNICASTPKTSr_t;
#define TXUNICASTPKTSr_CLR BCM6300_A0_TXUNICASTPKTSr_CLR
#define TXUNICASTPKTSr_SET BCM6300_A0_TXUNICASTPKTSr_SET
#define TXUNICASTPKTSr_GET BCM6300_A0_TXUNICASTPKTSr_GET
#define READ_TXUNICASTPKTSr BCM6300_A0_READ_TXUNICASTPKTSr
#define WRITE_TXUNICASTPKTSr BCM6300_A0_WRITE_TXUNICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_TXUNICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  UDF_OFFSET0
 * BLOCKS:   GPIC0 CPIC
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *
 ******************************************************************************/
#define BCM6300_A0_UDF_OFFSET0r 0x00080000

#define BCM6300_A0_UDF_OFFSET0r_SIZE 4

/*
 * This structure should be used to declare and program UDF_OFFSET0.
 *
 */
typedef union BCM6300_A0_UDF_OFFSET0r_s {
	uint32_t v[1];
	uint32_t udf_offset0[1];
	uint32_t _udf_offset0;
} BCM6300_A0_UDF_OFFSET0r_t;

#define BCM6300_A0_UDF_OFFSET0r_CLR(r) (r).udf_offset0[0] = 0
#define BCM6300_A0_UDF_OFFSET0r_SET(r,d) (r).udf_offset0[0] = d
#define BCM6300_A0_UDF_OFFSET0r_GET(r) (r).udf_offset0[0]

/*
 * These macros can be used to access individual fields.
 *
 */

/*
 * These macros can be used to access UDF_OFFSET0.
 *
 */
#define BCM6300_A0_READ_UDF_OFFSET0r(u,r) cdk_robo_reg_read(u,BCM6300_A0_UDF_OFFSET0r,(r._udf_offset0),4)
#define BCM6300_A0_WRITE_UDF_OFFSET0r(u,r) cdk_robo_reg_write(u,BCM6300_A0_UDF_OFFSET0r,&(r._udf_offset0),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UDF_OFFSET0r BCM6300_A0_UDF_OFFSET0r
#define UDF_OFFSET0r_SIZE BCM6300_A0_UDF_OFFSET0r_SIZE
typedef BCM6300_A0_UDF_OFFSET0r_t UDF_OFFSET0r_t;
#define UDF_OFFSET0r_CLR BCM6300_A0_UDF_OFFSET0r_CLR
#define UDF_OFFSET0r_SET BCM6300_A0_UDF_OFFSET0r_SET
#define UDF_OFFSET0r_GET BCM6300_A0_UDF_OFFSET0r_GET
#define READ_UDF_OFFSET0r BCM6300_A0_READ_UDF_OFFSET0r
#define WRITE_UDF_OFFSET0r BCM6300_A0_WRITE_UDF_OFFSET0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_UDF_OFFSET0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  UDF_OFFSET4
 * BLOCKS:   GPIC0 CPIC
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *
 ******************************************************************************/
#define BCM6300_A0_UDF_OFFSET4r 0x00080000

#define BCM6300_A0_UDF_OFFSET4r_SIZE 4

/*
 * This structure should be used to declare and program UDF_OFFSET4.
 *
 */
typedef union BCM6300_A0_UDF_OFFSET4r_s {
	uint32_t v[1];
	uint32_t udf_offset4[1];
	uint32_t _udf_offset4;
} BCM6300_A0_UDF_OFFSET4r_t;

#define BCM6300_A0_UDF_OFFSET4r_CLR(r) (r).udf_offset4[0] = 0
#define BCM6300_A0_UDF_OFFSET4r_SET(r,d) (r).udf_offset4[0] = d
#define BCM6300_A0_UDF_OFFSET4r_GET(r) (r).udf_offset4[0]

/*
 * These macros can be used to access individual fields.
 *
 */

/*
 * These macros can be used to access UDF_OFFSET4.
 *
 */
#define BCM6300_A0_READ_UDF_OFFSET4r(u,r) cdk_robo_reg_read(u,BCM6300_A0_UDF_OFFSET4r,(r._udf_offset4),4)
#define BCM6300_A0_WRITE_UDF_OFFSET4r(u,r) cdk_robo_reg_write(u,BCM6300_A0_UDF_OFFSET4r,&(r._udf_offset4),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UDF_OFFSET4r BCM6300_A0_UDF_OFFSET4r
#define UDF_OFFSET4r_SIZE BCM6300_A0_UDF_OFFSET4r_SIZE
typedef BCM6300_A0_UDF_OFFSET4r_t UDF_OFFSET4r_t;
#define UDF_OFFSET4r_CLR BCM6300_A0_UDF_OFFSET4r_CLR
#define UDF_OFFSET4r_SET BCM6300_A0_UDF_OFFSET4r_SET
#define UDF_OFFSET4r_GET BCM6300_A0_UDF_OFFSET4r_GET
#define READ_UDF_OFFSET4r BCM6300_A0_READ_UDF_OFFSET4r
#define WRITE_UDF_OFFSET4r BCM6300_A0_WRITE_UDF_OFFSET4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_UDF_OFFSET4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  UDF_OFFSET5
 * BLOCKS:   GPIC0 CPIC
 * DESC:     
 * SIZE:     32
 * FIELDS:
 *
 ******************************************************************************/
#define BCM6300_A0_UDF_OFFSET5r 0x00080000

#define BCM6300_A0_UDF_OFFSET5r_SIZE 4

/*
 * This structure should be used to declare and program UDF_OFFSET5.
 *
 */
typedef union BCM6300_A0_UDF_OFFSET5r_s {
	uint32_t v[1];
	uint32_t udf_offset5[1];
	uint32_t _udf_offset5;
} BCM6300_A0_UDF_OFFSET5r_t;

#define BCM6300_A0_UDF_OFFSET5r_CLR(r) (r).udf_offset5[0] = 0
#define BCM6300_A0_UDF_OFFSET5r_SET(r,d) (r).udf_offset5[0] = d
#define BCM6300_A0_UDF_OFFSET5r_GET(r) (r).udf_offset5[0]

/*
 * These macros can be used to access individual fields.
 *
 */

/*
 * These macros can be used to access UDF_OFFSET5.
 *
 */
#define BCM6300_A0_READ_UDF_OFFSET5r(u,r) cdk_robo_reg_read(u,BCM6300_A0_UDF_OFFSET5r,(r._udf_offset5),4)
#define BCM6300_A0_WRITE_UDF_OFFSET5r(u,r) cdk_robo_reg_write(u,BCM6300_A0_UDF_OFFSET5r,&(r._udf_offset5),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define UDF_OFFSET5r BCM6300_A0_UDF_OFFSET5r
#define UDF_OFFSET5r_SIZE BCM6300_A0_UDF_OFFSET5r_SIZE
typedef BCM6300_A0_UDF_OFFSET5r_t UDF_OFFSET5r_t;
#define UDF_OFFSET5r_CLR BCM6300_A0_UDF_OFFSET5r_CLR
#define UDF_OFFSET5r_SET BCM6300_A0_UDF_OFFSET5r_SET
#define UDF_OFFSET5r_GET BCM6300_A0_UDF_OFFSET5r_GET
#define READ_UDF_OFFSET5r BCM6300_A0_READ_UDF_OFFSET5r
#define WRITE_UDF_OFFSET5r BCM6300_A0_WRITE_UDF_OFFSET5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_UDF_OFFSET5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  ULF_DROP_MAP
 * BLOCKS:   SYS
 * DESC:     Unicast Lookup Failed Forward Map Registrer
 * SIZE:     16
 * FIELDS:
 *     UNI_LOOPUP_FAIL_FWD_MAP Unicast Lookup Failed Forward Map.When unicast lookup failed Drop is enabled (Page 00, Offset 21h) and Lookup failure happen, ARL will forward the frame according to the register.
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_ULF_DROP_MAPr 0x00000032

#define BCM6300_A0_ULF_DROP_MAPr_SIZE 2

/*
 * This structure should be used to declare and program ULF_DROP_MAP.
 *
 */
typedef union BCM6300_A0_ULF_DROP_MAPr_s {
	uint32_t v[1];
	uint32_t ulf_drop_map[1];
	uint32_t _ulf_drop_map;
} BCM6300_A0_ULF_DROP_MAPr_t;

#define BCM6300_A0_ULF_DROP_MAPr_CLR(r) (r).ulf_drop_map[0] = 0
#define BCM6300_A0_ULF_DROP_MAPr_SET(r,d) (r).ulf_drop_map[0] = d
#define BCM6300_A0_ULF_DROP_MAPr_GET(r) (r).ulf_drop_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_ULF_DROP_MAPr_UNI_LOOPUP_FAIL_FWD_MAPf_GET(r) (((r).ulf_drop_map[0]) & 0x1ff)
#define BCM6300_A0_ULF_DROP_MAPr_UNI_LOOPUP_FAIL_FWD_MAPf_SET(r,f) (r).ulf_drop_map[0]=(((r).ulf_drop_map[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_ULF_DROP_MAPr_RESERVED_Rf_GET(r) ((((r).ulf_drop_map[0]) >> 9) & 0x7f)
#define BCM6300_A0_ULF_DROP_MAPr_RESERVED_Rf_SET(r,f) (r).ulf_drop_map[0]=(((r).ulf_drop_map[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access ULF_DROP_MAP.
 *
 */
#define BCM6300_A0_READ_ULF_DROP_MAPr(u,r) cdk_robo_reg_read(u,BCM6300_A0_ULF_DROP_MAPr,(r._ulf_drop_map),2)
#define BCM6300_A0_WRITE_ULF_DROP_MAPr(u,r) cdk_robo_reg_write(u,BCM6300_A0_ULF_DROP_MAPr,&(r._ulf_drop_map),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ULF_DROP_MAPr BCM6300_A0_ULF_DROP_MAPr
#define ULF_DROP_MAPr_SIZE BCM6300_A0_ULF_DROP_MAPr_SIZE
typedef BCM6300_A0_ULF_DROP_MAPr_t ULF_DROP_MAPr_t;
#define ULF_DROP_MAPr_CLR BCM6300_A0_ULF_DROP_MAPr_CLR
#define ULF_DROP_MAPr_SET BCM6300_A0_ULF_DROP_MAPr_SET
#define ULF_DROP_MAPr_GET BCM6300_A0_ULF_DROP_MAPr_GET
#define ULF_DROP_MAPr_UNI_LOOPUP_FAIL_FWD_MAPf_GET BCM6300_A0_ULF_DROP_MAPr_UNI_LOOPUP_FAIL_FWD_MAPf_GET
#define ULF_DROP_MAPr_UNI_LOOPUP_FAIL_FWD_MAPf_SET BCM6300_A0_ULF_DROP_MAPr_UNI_LOOPUP_FAIL_FWD_MAPf_SET
#define ULF_DROP_MAPr_RESERVED_Rf_GET BCM6300_A0_ULF_DROP_MAPr_RESERVED_Rf_GET
#define ULF_DROP_MAPr_RESERVED_Rf_SET BCM6300_A0_ULF_DROP_MAPr_RESERVED_Rf_SET
#define READ_ULF_DROP_MAPr BCM6300_A0_READ_ULF_DROP_MAPr
#define WRITE_ULF_DROP_MAPr BCM6300_A0_WRITE_ULF_DROP_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_ULF_DROP_MAPr'
 ******************************************************************************/

/*******************************************************************************
 * CHIP:  BCM6300_A0
 * MEMORY:  VLAN_1Q
 * BLOCKS:   SYS
 * DESC:     VLAN Table
 * SIZE:     22
 * FIELDS:
 *     FORWARD_MAP      Tag port bitmapbit0-bit7 = Giga ports,bit8 = MII port,
 *     UNTAG_MAP        Untag port bitmapbit0-bit7 = Giga ports,bit8 = MII port,
 *     MSPT_ID          MSTP ID
 *
 ******************************************************************************/
#define BCM6300_A0_VLAN_1Qm 0x20000560

#define BCM6300_A0_VLAN_1Qm_MIN 0
#define BCM6300_A0_VLAN_1Qm_MAX 4095
#define BCM6300_A0_VLAN_1Qm_SIZE 3

/*
 * This structure should be used to declare and program VLAN_1Q.
 *
 */
typedef union BCM6300_A0_VLAN_1Qm_s {
	uint32_t v[1];
	uint32_t vlan_1q[1];
	uint32_t _vlan_1q;
} BCM6300_A0_VLAN_1Qm_t;

#define BCM6300_A0_VLAN_1Qm_CLR(r) (r).vlan_1q[0] = 0
#define BCM6300_A0_VLAN_1Qm_SET(r,d) (r).vlan_1q[0] = d
#define BCM6300_A0_VLAN_1Qm_GET(r) (r).vlan_1q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_VLAN_1Qm_FORWARD_MAPf_GET(r) (((r).vlan_1q[0]) & 0x1ff)
#define BCM6300_A0_VLAN_1Qm_FORWARD_MAPf_SET(r,f) (r).vlan_1q[0]=(((r).vlan_1q[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_VLAN_1Qm_UNTAG_MAPf_GET(r) ((((r).vlan_1q[0]) >> 9) & 0x1ff)
#define BCM6300_A0_VLAN_1Qm_UNTAG_MAPf_SET(r,f) (r).vlan_1q[0]=(((r).vlan_1q[0] & ~((uint32_t)0x1ff << 9)) | ((((uint32_t)f) & 0x1ff) << 9))
#define BCM6300_A0_VLAN_1Qm_MSPT_IDf_GET(r) ((((r).vlan_1q[0]) >> 18) & 0xf)
#define BCM6300_A0_VLAN_1Qm_MSPT_IDf_SET(r,f) (r).vlan_1q[0]=(((r).vlan_1q[0] & ~((uint32_t)0xf << 18)) | ((((uint32_t)f) & 0xf) << 18))

/*
 * These macros can be used to access VLAN_1Q.
 *
 */
#define BCM6300_A0_READ_VLAN_1Qm(u,i,m) cdk_robo_mem_read(u,BCM6300_A0_VLAN_1Qm,i,(m),3)
#define BCM6300_A0_WRITE_VLAN_1Qm(u,i,m) cdk_robo_mem_write(u,BCM6300_A0_VLAN_1Qm,i,&(m),3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_1Qm BCM6300_A0_VLAN_1Qm
#define VLAN_1Qm_MIN BCM6300_A0_VLAN_1Qm_MIN
#define VLAN_1Qm_MAX BCM6300_A0_VLAN_1Qm_MAX
#define VLAN_1Qm_SIZE BCM6300_A0_VLAN_1Qm_SIZE
typedef BCM6300_A0_VLAN_1Qm_t VLAN_1Qm_t;
#define VLAN_1Qm_CLR BCM6300_A0_VLAN_1Qm_CLR
#define VLAN_1Qm_SET BCM6300_A0_VLAN_1Qm_SET
#define VLAN_1Qm_GET BCM6300_A0_VLAN_1Qm_GET
#define VLAN_1Qm_FORWARD_MAPf_GET BCM6300_A0_VLAN_1Qm_FORWARD_MAPf_GET
#define VLAN_1Qm_FORWARD_MAPf_SET BCM6300_A0_VLAN_1Qm_FORWARD_MAPf_SET
#define VLAN_1Qm_UNTAG_MAPf_GET BCM6300_A0_VLAN_1Qm_UNTAG_MAPf_GET
#define VLAN_1Qm_UNTAG_MAPf_SET BCM6300_A0_VLAN_1Qm_UNTAG_MAPf_SET
#define VLAN_1Qm_MSPT_IDf_GET BCM6300_A0_VLAN_1Qm_MSPT_IDf_GET
#define VLAN_1Qm_MSPT_IDf_SET BCM6300_A0_VLAN_1Qm_MSPT_IDf_SET
#define READ_VLAN_1Qm BCM6300_A0_READ_VLAN_1Qm
#define WRITE_VLAN_1Qm BCM6300_A0_WRITE_VLAN_1Qm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_VLAN_1Qm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  VLAN_CTRL0
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 0 Registers
 * SIZE:     8
 * FIELDS:
 *     P8021_FM_CTRL    00 : Reserved.01 : Reserved.10 : Change VID (12 bits)11 : Change priority and VID (16 bits)
 *     Q8021_FM_CTRL    00 : No change01 : Change priority (4 bits)10 : Change VID (12 bits)11 : Change priority and VID (16 bits)
 *     RESERVED_R       Reserved.                
 *     VLAN_LEARN_MODE  00: SVL( Shared VLAN Learning Mode)(MAC used to hash ARL table).11:IVL(Individual VLAN Learning Mode) (MAC and VID used to hash ARL table).10= illegal Setting.01= illegal Setting.
 *     VLAN_EN          When set to 1, the 802.1Q VLAN function will be enabled.                
 *
 ******************************************************************************/
#define BCM6300_A0_VLAN_CTRL0r 0x00003400

#define BCM6300_A0_VLAN_CTRL0r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_CTRL0.
 *
 */
typedef union BCM6300_A0_VLAN_CTRL0r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl0[1];
	uint32_t _vlan_ctrl0;
} BCM6300_A0_VLAN_CTRL0r_t;

#define BCM6300_A0_VLAN_CTRL0r_CLR(r) (r).vlan_ctrl0[0] = 0
#define BCM6300_A0_VLAN_CTRL0r_SET(r,d) (r).vlan_ctrl0[0] = d
#define BCM6300_A0_VLAN_CTRL0r_GET(r) (r).vlan_ctrl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_VLAN_CTRL0r_P8021_FM_CTRLf_GET(r) (((r).vlan_ctrl0[0]) & 0x3)
#define BCM6300_A0_VLAN_CTRL0r_P8021_FM_CTRLf_SET(r,f) (r).vlan_ctrl0[0]=(((r).vlan_ctrl0[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM6300_A0_VLAN_CTRL0r_Q8021_FM_CTRLf_GET(r) ((((r).vlan_ctrl0[0]) >> 2) & 0x3)
#define BCM6300_A0_VLAN_CTRL0r_Q8021_FM_CTRLf_SET(r,f) (r).vlan_ctrl0[0]=(((r).vlan_ctrl0[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM6300_A0_VLAN_CTRL0r_RESERVED_Rf_GET(r) ((((r).vlan_ctrl0[0]) >> 4) & 0x1)
#define BCM6300_A0_VLAN_CTRL0r_RESERVED_Rf_SET(r,f) (r).vlan_ctrl0[0]=(((r).vlan_ctrl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM6300_A0_VLAN_CTRL0r_VLAN_LEARN_MODEf_GET(r) ((((r).vlan_ctrl0[0]) >> 5) & 0x3)
#define BCM6300_A0_VLAN_CTRL0r_VLAN_LEARN_MODEf_SET(r,f) (r).vlan_ctrl0[0]=(((r).vlan_ctrl0[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM6300_A0_VLAN_CTRL0r_VLAN_ENf_GET(r) ((((r).vlan_ctrl0[0]) >> 7) & 0x1)
#define BCM6300_A0_VLAN_CTRL0r_VLAN_ENf_SET(r,f) (r).vlan_ctrl0[0]=(((r).vlan_ctrl0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access VLAN_CTRL0.
 *
 */
#define BCM6300_A0_READ_VLAN_CTRL0r(u,r) cdk_robo_reg_read(u,BCM6300_A0_VLAN_CTRL0r,(r._vlan_ctrl0),1)
#define BCM6300_A0_WRITE_VLAN_CTRL0r(u,r) cdk_robo_reg_write(u,BCM6300_A0_VLAN_CTRL0r,&(r._vlan_ctrl0),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL0r BCM6300_A0_VLAN_CTRL0r
#define VLAN_CTRL0r_SIZE BCM6300_A0_VLAN_CTRL0r_SIZE
typedef BCM6300_A0_VLAN_CTRL0r_t VLAN_CTRL0r_t;
#define VLAN_CTRL0r_CLR BCM6300_A0_VLAN_CTRL0r_CLR
#define VLAN_CTRL0r_SET BCM6300_A0_VLAN_CTRL0r_SET
#define VLAN_CTRL0r_GET BCM6300_A0_VLAN_CTRL0r_GET
#define VLAN_CTRL0r_P8021_FM_CTRLf_GET BCM6300_A0_VLAN_CTRL0r_P8021_FM_CTRLf_GET
#define VLAN_CTRL0r_P8021_FM_CTRLf_SET BCM6300_A0_VLAN_CTRL0r_P8021_FM_CTRLf_SET
#define VLAN_CTRL0r_Q8021_FM_CTRLf_GET BCM6300_A0_VLAN_CTRL0r_Q8021_FM_CTRLf_GET
#define VLAN_CTRL0r_Q8021_FM_CTRLf_SET BCM6300_A0_VLAN_CTRL0r_Q8021_FM_CTRLf_SET
#define VLAN_CTRL0r_RESERVED_Rf_GET BCM6300_A0_VLAN_CTRL0r_RESERVED_Rf_GET
#define VLAN_CTRL0r_RESERVED_Rf_SET BCM6300_A0_VLAN_CTRL0r_RESERVED_Rf_SET
#define VLAN_CTRL0r_VLAN_LEARN_MODEf_GET BCM6300_A0_VLAN_CTRL0r_VLAN_LEARN_MODEf_GET
#define VLAN_CTRL0r_VLAN_LEARN_MODEf_SET BCM6300_A0_VLAN_CTRL0r_VLAN_LEARN_MODEf_SET
#define VLAN_CTRL0r_VLAN_ENf_GET BCM6300_A0_VLAN_CTRL0r_VLAN_ENf_GET
#define VLAN_CTRL0r_VLAN_ENf_SET BCM6300_A0_VLAN_CTRL0r_VLAN_ENf_SET
#define READ_VLAN_CTRL0r BCM6300_A0_READ_VLAN_CTRL0r
#define WRITE_VLAN_CTRL0r BCM6300_A0_WRITE_VLAN_CTRL0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_VLAN_CTRL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  VLAN_CTRL1
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 1 Registers
 * SIZE:     8
 * FIELDS:
 *     EN_SEBTRY_VLAN_CHK When we detect a special entry MAC address, we always bypass ARL checking. The register will provide the forwarding map.1: Our two special entries (group0 and group1) address frame will follow 2 VLAN rules. (tagging, v_untagmap)0 : Bypass all VLAN checking (tagging, v_fwdmap, v_untagmap).                
 *     RESERVED_1R      Reserved.It's illegal to set 0.
 *     EN_RSV_MCAST_FWDMAP When asserted, reserved multicast frames (except GMRP and GVRP) will be checked by v_fwdmap.                
 *     EN_RSV_MCAST_UNTAG RW When asserted, reserved multicast frames (except GMRP andmGVRP) will be checked by v_untagmap                
 *     RESERVED_2R      Reserved.It's illegal to set 1.
 *     EN_IPMC_BYPASS_FWDMAP When asserted will not check IPMC frame with V_fwdmap.                
 *     EN_IPMC_BYPASS_UNTAG When asserted will not check the IPMC frame with V_untagmap.
 *     RESERVED_3R      Reserved.                
 *
 ******************************************************************************/
#define BCM6300_A0_VLAN_CTRL1r 0x00003401

#define BCM6300_A0_VLAN_CTRL1r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_CTRL1.
 *
 */
typedef union BCM6300_A0_VLAN_CTRL1r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl1[1];
	uint32_t _vlan_ctrl1;
} BCM6300_A0_VLAN_CTRL1r_t;

#define BCM6300_A0_VLAN_CTRL1r_CLR(r) (r).vlan_ctrl1[0] = 0
#define BCM6300_A0_VLAN_CTRL1r_SET(r,d) (r).vlan_ctrl1[0] = d
#define BCM6300_A0_VLAN_CTRL1r_GET(r) (r).vlan_ctrl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_VLAN_CTRL1r_EN_SEBTRY_VLAN_CHKf_GET(r) (((r).vlan_ctrl1[0]) & 0x1)
#define BCM6300_A0_VLAN_CTRL1r_EN_SEBTRY_VLAN_CHKf_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM6300_A0_VLAN_CTRL1r_RESERVED_1Rf_GET(r) ((((r).vlan_ctrl1[0]) >> 1) & 0x1)
#define BCM6300_A0_VLAN_CTRL1r_RESERVED_1Rf_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM6300_A0_VLAN_CTRL1r_EN_RSV_MCAST_FWDMAPf_GET(r) ((((r).vlan_ctrl1[0]) >> 2) & 0x1)
#define BCM6300_A0_VLAN_CTRL1r_EN_RSV_MCAST_FWDMAPf_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM6300_A0_VLAN_CTRL1r_EN_RSV_MCAST_UNTAGf_GET(r) ((((r).vlan_ctrl1[0]) >> 3) & 0x1)
#define BCM6300_A0_VLAN_CTRL1r_EN_RSV_MCAST_UNTAGf_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM6300_A0_VLAN_CTRL1r_RESERVED_2Rf_GET(r) ((((r).vlan_ctrl1[0]) >> 4) & 0x1)
#define BCM6300_A0_VLAN_CTRL1r_RESERVED_2Rf_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM6300_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_FWDMAPf_GET(r) ((((r).vlan_ctrl1[0]) >> 5) & 0x1)
#define BCM6300_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_FWDMAPf_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM6300_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_UNTAGf_GET(r) ((((r).vlan_ctrl1[0]) >> 6) & 0x1)
#define BCM6300_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_UNTAGf_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM6300_A0_VLAN_CTRL1r_RESERVED_3Rf_GET(r) ((((r).vlan_ctrl1[0]) >> 7) & 0x1)
#define BCM6300_A0_VLAN_CTRL1r_RESERVED_3Rf_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access VLAN_CTRL1.
 *
 */
#define BCM6300_A0_READ_VLAN_CTRL1r(u,r) cdk_robo_reg_read(u,BCM6300_A0_VLAN_CTRL1r,(r._vlan_ctrl1),1)
#define BCM6300_A0_WRITE_VLAN_CTRL1r(u,r) cdk_robo_reg_write(u,BCM6300_A0_VLAN_CTRL1r,&(r._vlan_ctrl1),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL1r BCM6300_A0_VLAN_CTRL1r
#define VLAN_CTRL1r_SIZE BCM6300_A0_VLAN_CTRL1r_SIZE
typedef BCM6300_A0_VLAN_CTRL1r_t VLAN_CTRL1r_t;
#define VLAN_CTRL1r_CLR BCM6300_A0_VLAN_CTRL1r_CLR
#define VLAN_CTRL1r_SET BCM6300_A0_VLAN_CTRL1r_SET
#define VLAN_CTRL1r_GET BCM6300_A0_VLAN_CTRL1r_GET
#define VLAN_CTRL1r_EN_SEBTRY_VLAN_CHKf_GET BCM6300_A0_VLAN_CTRL1r_EN_SEBTRY_VLAN_CHKf_GET
#define VLAN_CTRL1r_EN_SEBTRY_VLAN_CHKf_SET BCM6300_A0_VLAN_CTRL1r_EN_SEBTRY_VLAN_CHKf_SET
#define VLAN_CTRL1r_RESERVED_1Rf_GET BCM6300_A0_VLAN_CTRL1r_RESERVED_1Rf_GET
#define VLAN_CTRL1r_RESERVED_1Rf_SET BCM6300_A0_VLAN_CTRL1r_RESERVED_1Rf_SET
#define VLAN_CTRL1r_EN_RSV_MCAST_FWDMAPf_GET BCM6300_A0_VLAN_CTRL1r_EN_RSV_MCAST_FWDMAPf_GET
#define VLAN_CTRL1r_EN_RSV_MCAST_FWDMAPf_SET BCM6300_A0_VLAN_CTRL1r_EN_RSV_MCAST_FWDMAPf_SET
#define VLAN_CTRL1r_EN_RSV_MCAST_UNTAGf_GET BCM6300_A0_VLAN_CTRL1r_EN_RSV_MCAST_UNTAGf_GET
#define VLAN_CTRL1r_EN_RSV_MCAST_UNTAGf_SET BCM6300_A0_VLAN_CTRL1r_EN_RSV_MCAST_UNTAGf_SET
#define VLAN_CTRL1r_RESERVED_2Rf_GET BCM6300_A0_VLAN_CTRL1r_RESERVED_2Rf_GET
#define VLAN_CTRL1r_RESERVED_2Rf_SET BCM6300_A0_VLAN_CTRL1r_RESERVED_2Rf_SET
#define VLAN_CTRL1r_EN_IPMC_BYPASS_FWDMAPf_GET BCM6300_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_FWDMAPf_GET
#define VLAN_CTRL1r_EN_IPMC_BYPASS_FWDMAPf_SET BCM6300_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_FWDMAPf_SET
#define VLAN_CTRL1r_EN_IPMC_BYPASS_UNTAGf_GET BCM6300_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_UNTAGf_GET
#define VLAN_CTRL1r_EN_IPMC_BYPASS_UNTAGf_SET BCM6300_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_UNTAGf_SET
#define VLAN_CTRL1r_RESERVED_3Rf_GET BCM6300_A0_VLAN_CTRL1r_RESERVED_3Rf_GET
#define VLAN_CTRL1r_RESERVED_3Rf_SET BCM6300_A0_VLAN_CTRL1r_RESERVED_3Rf_SET
#define READ_VLAN_CTRL1r BCM6300_A0_READ_VLAN_CTRL1r
#define WRITE_VLAN_CTRL1r BCM6300_A0_WRITE_VLAN_CTRL1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_VLAN_CTRL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  VLAN_CTRL2
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 2 Registers
 * SIZE:     8
 * FIELDS:
 *     RESERVED_0R      Reserved.                
 *     EN_MIIM_BYPASS_V_FWDMAP When set to 1, frames reveived by MII_manage port will bypass V_fwdmap checking.** Untagged frame received by MII_manage port will never be tagged.                
 *     EN_MIIM_BYPASS_V_UNTAG When set to 1, frames reveived by MII_manage port will by pass V_untagmap.                
 *     RESERVED_2R      Reserved.It's illegal to set 0.
 *     EN_GMRP_GVRP_V_FWDMAP When set to 1, GMRP,GVRP will be checked by v_fwdmap.** this rule do not apply to MII_manage EXP and SPI ports.                
 *     EN_GMRP_GVRP_UNTAG_MAP When set to 1, r GMRP,GVRP will be checked by v_untagmap** this rule do not apply to MII_manage exp and SPI ports.                
 *     EN_REMAP_PRI     When asserted, the pri_field (3bits) in ingress frame (802.1Q frame or priority tagged frame) will be remapped to a new value based on re_map_reg[23:0]. The CFI bit will be preserved as original frame.** When enable this feature, control0[1:0] has to be either 01, or 11.and control0[3:2] has to be either 01, or 11.
 *
 ******************************************************************************/
#define BCM6300_A0_VLAN_CTRL2r 0x00003402

#define BCM6300_A0_VLAN_CTRL2r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_CTRL2.
 *
 */
typedef union BCM6300_A0_VLAN_CTRL2r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl2[1];
	uint32_t _vlan_ctrl2;
} BCM6300_A0_VLAN_CTRL2r_t;

#define BCM6300_A0_VLAN_CTRL2r_CLR(r) (r).vlan_ctrl2[0] = 0
#define BCM6300_A0_VLAN_CTRL2r_SET(r,d) (r).vlan_ctrl2[0] = d
#define BCM6300_A0_VLAN_CTRL2r_GET(r) (r).vlan_ctrl2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_VLAN_CTRL2r_RESERVED_0Rf_GET(r) (((r).vlan_ctrl2[0]) & 0x3)
#define BCM6300_A0_VLAN_CTRL2r_RESERVED_0Rf_SET(r,f) (r).vlan_ctrl2[0]=(((r).vlan_ctrl2[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM6300_A0_VLAN_CTRL2r_EN_MIIM_BYPASS_V_FWDMAPf_GET(r) ((((r).vlan_ctrl2[0]) >> 2) & 0x1)
#define BCM6300_A0_VLAN_CTRL2r_EN_MIIM_BYPASS_V_FWDMAPf_SET(r,f) (r).vlan_ctrl2[0]=(((r).vlan_ctrl2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM6300_A0_VLAN_CTRL2r_EN_MIIM_BYPASS_V_UNTAGf_GET(r) ((((r).vlan_ctrl2[0]) >> 3) & 0x1)
#define BCM6300_A0_VLAN_CTRL2r_EN_MIIM_BYPASS_V_UNTAGf_SET(r,f) (r).vlan_ctrl2[0]=(((r).vlan_ctrl2[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM6300_A0_VLAN_CTRL2r_RESERVED_2Rf_GET(r) ((((r).vlan_ctrl2[0]) >> 4) & 0x1)
#define BCM6300_A0_VLAN_CTRL2r_RESERVED_2Rf_SET(r,f) (r).vlan_ctrl2[0]=(((r).vlan_ctrl2[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM6300_A0_VLAN_CTRL2r_EN_GMRP_GVRP_V_FWDMAPf_GET(r) ((((r).vlan_ctrl2[0]) >> 5) & 0x1)
#define BCM6300_A0_VLAN_CTRL2r_EN_GMRP_GVRP_V_FWDMAPf_SET(r,f) (r).vlan_ctrl2[0]=(((r).vlan_ctrl2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM6300_A0_VLAN_CTRL2r_EN_GMRP_GVRP_UNTAG_MAPf_GET(r) ((((r).vlan_ctrl2[0]) >> 6) & 0x1)
#define BCM6300_A0_VLAN_CTRL2r_EN_GMRP_GVRP_UNTAG_MAPf_SET(r,f) (r).vlan_ctrl2[0]=(((r).vlan_ctrl2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM6300_A0_VLAN_CTRL2r_EN_REMAP_PRIf_GET(r) ((((r).vlan_ctrl2[0]) >> 7) & 0x1)
#define BCM6300_A0_VLAN_CTRL2r_EN_REMAP_PRIf_SET(r,f) (r).vlan_ctrl2[0]=(((r).vlan_ctrl2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access VLAN_CTRL2.
 *
 */
#define BCM6300_A0_READ_VLAN_CTRL2r(u,r) cdk_robo_reg_read(u,BCM6300_A0_VLAN_CTRL2r,(r._vlan_ctrl2),1)
#define BCM6300_A0_WRITE_VLAN_CTRL2r(u,r) cdk_robo_reg_write(u,BCM6300_A0_VLAN_CTRL2r,&(r._vlan_ctrl2),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL2r BCM6300_A0_VLAN_CTRL2r
#define VLAN_CTRL2r_SIZE BCM6300_A0_VLAN_CTRL2r_SIZE
typedef BCM6300_A0_VLAN_CTRL2r_t VLAN_CTRL2r_t;
#define VLAN_CTRL2r_CLR BCM6300_A0_VLAN_CTRL2r_CLR
#define VLAN_CTRL2r_SET BCM6300_A0_VLAN_CTRL2r_SET
#define VLAN_CTRL2r_GET BCM6300_A0_VLAN_CTRL2r_GET
#define VLAN_CTRL2r_RESERVED_0Rf_GET BCM6300_A0_VLAN_CTRL2r_RESERVED_0Rf_GET
#define VLAN_CTRL2r_RESERVED_0Rf_SET BCM6300_A0_VLAN_CTRL2r_RESERVED_0Rf_SET
#define VLAN_CTRL2r_EN_MIIM_BYPASS_V_FWDMAPf_GET BCM6300_A0_VLAN_CTRL2r_EN_MIIM_BYPASS_V_FWDMAPf_GET
#define VLAN_CTRL2r_EN_MIIM_BYPASS_V_FWDMAPf_SET BCM6300_A0_VLAN_CTRL2r_EN_MIIM_BYPASS_V_FWDMAPf_SET
#define VLAN_CTRL2r_EN_MIIM_BYPASS_V_UNTAGf_GET BCM6300_A0_VLAN_CTRL2r_EN_MIIM_BYPASS_V_UNTAGf_GET
#define VLAN_CTRL2r_EN_MIIM_BYPASS_V_UNTAGf_SET BCM6300_A0_VLAN_CTRL2r_EN_MIIM_BYPASS_V_UNTAGf_SET
#define VLAN_CTRL2r_RESERVED_2Rf_GET BCM6300_A0_VLAN_CTRL2r_RESERVED_2Rf_GET
#define VLAN_CTRL2r_RESERVED_2Rf_SET BCM6300_A0_VLAN_CTRL2r_RESERVED_2Rf_SET
#define VLAN_CTRL2r_EN_GMRP_GVRP_V_FWDMAPf_GET BCM6300_A0_VLAN_CTRL2r_EN_GMRP_GVRP_V_FWDMAPf_GET
#define VLAN_CTRL2r_EN_GMRP_GVRP_V_FWDMAPf_SET BCM6300_A0_VLAN_CTRL2r_EN_GMRP_GVRP_V_FWDMAPf_SET
#define VLAN_CTRL2r_EN_GMRP_GVRP_UNTAG_MAPf_GET BCM6300_A0_VLAN_CTRL2r_EN_GMRP_GVRP_UNTAG_MAPf_GET
#define VLAN_CTRL2r_EN_GMRP_GVRP_UNTAG_MAPf_SET BCM6300_A0_VLAN_CTRL2r_EN_GMRP_GVRP_UNTAG_MAPf_SET
#define VLAN_CTRL2r_EN_REMAP_PRIf_GET BCM6300_A0_VLAN_CTRL2r_EN_REMAP_PRIf_GET
#define VLAN_CTRL2r_EN_REMAP_PRIf_SET BCM6300_A0_VLAN_CTRL2r_EN_REMAP_PRIf_SET
#define READ_VLAN_CTRL2r BCM6300_A0_READ_VLAN_CTRL2r
#define WRITE_VLAN_CTRL2r BCM6300_A0_WRITE_VLAN_CTRL2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_VLAN_CTRL2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  VLAN_CTRL3
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 3 Registers
 * SIZE:     16
 * FIELDS:
 *     EN_DROP_NON1Q    When enabled , any non_1Q frame will be dropped by this port. Ports 8-0 respectively.
 *     RESERVED_R       Reserved.                
 *
 ******************************************************************************/
#define BCM6300_A0_VLAN_CTRL3r 0x00003404

#define BCM6300_A0_VLAN_CTRL3r_SIZE 2

/*
 * This structure should be used to declare and program VLAN_CTRL3.
 *
 */
typedef union BCM6300_A0_VLAN_CTRL3r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl3[1];
	uint32_t _vlan_ctrl3;
} BCM6300_A0_VLAN_CTRL3r_t;

#define BCM6300_A0_VLAN_CTRL3r_CLR(r) (r).vlan_ctrl3[0] = 0
#define BCM6300_A0_VLAN_CTRL3r_SET(r,d) (r).vlan_ctrl3[0] = d
#define BCM6300_A0_VLAN_CTRL3r_GET(r) (r).vlan_ctrl3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_VLAN_CTRL3r_EN_DROP_NON1Qf_GET(r) (((r).vlan_ctrl3[0]) & 0x1ff)
#define BCM6300_A0_VLAN_CTRL3r_EN_DROP_NON1Qf_SET(r,f) (r).vlan_ctrl3[0]=(((r).vlan_ctrl3[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_VLAN_CTRL3r_RESERVED_Rf_GET(r) ((((r).vlan_ctrl3[0]) >> 9) & 0x7f)
#define BCM6300_A0_VLAN_CTRL3r_RESERVED_Rf_SET(r,f) (r).vlan_ctrl3[0]=(((r).vlan_ctrl3[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access VLAN_CTRL3.
 *
 */
#define BCM6300_A0_READ_VLAN_CTRL3r(u,r) cdk_robo_reg_read(u,BCM6300_A0_VLAN_CTRL3r,(r._vlan_ctrl3),2)
#define BCM6300_A0_WRITE_VLAN_CTRL3r(u,r) cdk_robo_reg_write(u,BCM6300_A0_VLAN_CTRL3r,&(r._vlan_ctrl3),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL3r BCM6300_A0_VLAN_CTRL3r
#define VLAN_CTRL3r_SIZE BCM6300_A0_VLAN_CTRL3r_SIZE
typedef BCM6300_A0_VLAN_CTRL3r_t VLAN_CTRL3r_t;
#define VLAN_CTRL3r_CLR BCM6300_A0_VLAN_CTRL3r_CLR
#define VLAN_CTRL3r_SET BCM6300_A0_VLAN_CTRL3r_SET
#define VLAN_CTRL3r_GET BCM6300_A0_VLAN_CTRL3r_GET
#define VLAN_CTRL3r_EN_DROP_NON1Qf_GET BCM6300_A0_VLAN_CTRL3r_EN_DROP_NON1Qf_GET
#define VLAN_CTRL3r_EN_DROP_NON1Qf_SET BCM6300_A0_VLAN_CTRL3r_EN_DROP_NON1Qf_SET
#define VLAN_CTRL3r_RESERVED_Rf_GET BCM6300_A0_VLAN_CTRL3r_RESERVED_Rf_GET
#define VLAN_CTRL3r_RESERVED_Rf_SET BCM6300_A0_VLAN_CTRL3r_RESERVED_Rf_SET
#define READ_VLAN_CTRL3r BCM6300_A0_READ_VLAN_CTRL3r
#define WRITE_VLAN_CTRL3r BCM6300_A0_WRITE_VLAN_CTRL3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_VLAN_CTRL3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  VLAN_CTRL4
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 4 Registers
 * SIZE:     8
 * FIELDS:
 *     RESERVED_1R      Reserved.
 *     RESV_MCAST_FLOOD 1: flood reserved mcast based on the VLAN rule.0: trap reserved mcast to CPU(01-80-c2-00-00-02~2F).
 *     EN_DOU_TAG       1: enable double tag mode.0: disable double tag mode.
 *     RESERVED_2R      Reserved.It's illegal to set 1.
 *     EN_MGE_REV_GMRP  When set to 1, management port ( the port with CPU) will be the destination port of GMRP frame. In multiple chip system, a GMRP frmae received by a chip without CPU will pass it to expansion port, and eventually it will be forward to CPU.                
 *     EN_MGE_REV_GVRP  When set to 1. management port ( the port with CPU) will be the destination port of GVRP frame.                
 *     INGR_VID_CHK     00: forward ingress VID violation frame( VID is not in v_fwdmap). But do not learn in ARL table.01: Drop frame if frame has VID violation, not Learned.10: Do not check ingress VID violation.(Forward and Learn as no violation case)11:Forward ingress VIO violation frame to IMP, but not learn(default)** This rule do not apply IMP
 *
 ******************************************************************************/
#define BCM6300_A0_VLAN_CTRL4r 0x00003406

#define BCM6300_A0_VLAN_CTRL4r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_CTRL4.
 *
 */
typedef union BCM6300_A0_VLAN_CTRL4r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl4[1];
	uint32_t _vlan_ctrl4;
} BCM6300_A0_VLAN_CTRL4r_t;

#define BCM6300_A0_VLAN_CTRL4r_CLR(r) (r).vlan_ctrl4[0] = 0
#define BCM6300_A0_VLAN_CTRL4r_SET(r,d) (r).vlan_ctrl4[0] = d
#define BCM6300_A0_VLAN_CTRL4r_GET(r) (r).vlan_ctrl4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_VLAN_CTRL4r_RESERVED_1Rf_GET(r) (((r).vlan_ctrl4[0]) & 0x1)
#define BCM6300_A0_VLAN_CTRL4r_RESERVED_1Rf_SET(r,f) (r).vlan_ctrl4[0]=(((r).vlan_ctrl4[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM6300_A0_VLAN_CTRL4r_RESV_MCAST_FLOODf_GET(r) ((((r).vlan_ctrl4[0]) >> 1) & 0x1)
#define BCM6300_A0_VLAN_CTRL4r_RESV_MCAST_FLOODf_SET(r,f) (r).vlan_ctrl4[0]=(((r).vlan_ctrl4[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM6300_A0_VLAN_CTRL4r_EN_DOU_TAGf_GET(r) ((((r).vlan_ctrl4[0]) >> 2) & 0x1)
#define BCM6300_A0_VLAN_CTRL4r_EN_DOU_TAGf_SET(r,f) (r).vlan_ctrl4[0]=(((r).vlan_ctrl4[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM6300_A0_VLAN_CTRL4r_RESERVED_2Rf_GET(r) ((((r).vlan_ctrl4[0]) >> 3) & 0x1)
#define BCM6300_A0_VLAN_CTRL4r_RESERVED_2Rf_SET(r,f) (r).vlan_ctrl4[0]=(((r).vlan_ctrl4[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM6300_A0_VLAN_CTRL4r_EN_MGE_REV_GMRPf_GET(r) ((((r).vlan_ctrl4[0]) >> 4) & 0x1)
#define BCM6300_A0_VLAN_CTRL4r_EN_MGE_REV_GMRPf_SET(r,f) (r).vlan_ctrl4[0]=(((r).vlan_ctrl4[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM6300_A0_VLAN_CTRL4r_EN_MGE_REV_GVRPf_GET(r) ((((r).vlan_ctrl4[0]) >> 5) & 0x1)
#define BCM6300_A0_VLAN_CTRL4r_EN_MGE_REV_GVRPf_SET(r,f) (r).vlan_ctrl4[0]=(((r).vlan_ctrl4[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM6300_A0_VLAN_CTRL4r_INGR_VID_CHKf_GET(r) ((((r).vlan_ctrl4[0]) >> 6) & 0x3)
#define BCM6300_A0_VLAN_CTRL4r_INGR_VID_CHKf_SET(r,f) (r).vlan_ctrl4[0]=(((r).vlan_ctrl4[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access VLAN_CTRL4.
 *
 */
#define BCM6300_A0_READ_VLAN_CTRL4r(u,r) cdk_robo_reg_read(u,BCM6300_A0_VLAN_CTRL4r,(r._vlan_ctrl4),1)
#define BCM6300_A0_WRITE_VLAN_CTRL4r(u,r) cdk_robo_reg_write(u,BCM6300_A0_VLAN_CTRL4r,&(r._vlan_ctrl4),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL4r BCM6300_A0_VLAN_CTRL4r
#define VLAN_CTRL4r_SIZE BCM6300_A0_VLAN_CTRL4r_SIZE
typedef BCM6300_A0_VLAN_CTRL4r_t VLAN_CTRL4r_t;
#define VLAN_CTRL4r_CLR BCM6300_A0_VLAN_CTRL4r_CLR
#define VLAN_CTRL4r_SET BCM6300_A0_VLAN_CTRL4r_SET
#define VLAN_CTRL4r_GET BCM6300_A0_VLAN_CTRL4r_GET
#define VLAN_CTRL4r_RESERVED_1Rf_GET BCM6300_A0_VLAN_CTRL4r_RESERVED_1Rf_GET
#define VLAN_CTRL4r_RESERVED_1Rf_SET BCM6300_A0_VLAN_CTRL4r_RESERVED_1Rf_SET
#define VLAN_CTRL4r_RESV_MCAST_FLOODf_GET BCM6300_A0_VLAN_CTRL4r_RESV_MCAST_FLOODf_GET
#define VLAN_CTRL4r_RESV_MCAST_FLOODf_SET BCM6300_A0_VLAN_CTRL4r_RESV_MCAST_FLOODf_SET
#define VLAN_CTRL4r_EN_DOU_TAGf_GET BCM6300_A0_VLAN_CTRL4r_EN_DOU_TAGf_GET
#define VLAN_CTRL4r_EN_DOU_TAGf_SET BCM6300_A0_VLAN_CTRL4r_EN_DOU_TAGf_SET
#define VLAN_CTRL4r_RESERVED_2Rf_GET BCM6300_A0_VLAN_CTRL4r_RESERVED_2Rf_GET
#define VLAN_CTRL4r_RESERVED_2Rf_SET BCM6300_A0_VLAN_CTRL4r_RESERVED_2Rf_SET
#define VLAN_CTRL4r_EN_MGE_REV_GMRPf_GET BCM6300_A0_VLAN_CTRL4r_EN_MGE_REV_GMRPf_GET
#define VLAN_CTRL4r_EN_MGE_REV_GMRPf_SET BCM6300_A0_VLAN_CTRL4r_EN_MGE_REV_GMRPf_SET
#define VLAN_CTRL4r_EN_MGE_REV_GVRPf_GET BCM6300_A0_VLAN_CTRL4r_EN_MGE_REV_GVRPf_GET
#define VLAN_CTRL4r_EN_MGE_REV_GVRPf_SET BCM6300_A0_VLAN_CTRL4r_EN_MGE_REV_GVRPf_SET
#define VLAN_CTRL4r_INGR_VID_CHKf_GET BCM6300_A0_VLAN_CTRL4r_INGR_VID_CHKf_GET
#define VLAN_CTRL4r_INGR_VID_CHKf_SET BCM6300_A0_VLAN_CTRL4r_INGR_VID_CHKf_SET
#define READ_VLAN_CTRL4r BCM6300_A0_READ_VLAN_CTRL4r
#define WRITE_VLAN_CTRL4r BCM6300_A0_WRITE_VLAN_CTRL4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_VLAN_CTRL4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  VLAN_CTRL5
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 5 Registers
 * SIZE:     8
 * FIELDS:
 *     EN_TX_CRC_GENA_RATION when en_1QVLAN =0 ( default=0)1 : Txport will re-generate CRC even when en_1QVLAN = 00 : TXport will not re_generate CRC when en_1QVALN =0                
 *     EN_CPU_RX_BYPASS_CRCCHK rcchkWhen set to 1, The management port (MII ) with CPU on it will ignore any CRC ( BRCM tag frame, or Ethernet frame).When set to 0: The management port will check both CRC.Work as old 5318/5328.** In old 5325/28 design, management port need to calculate CRC for Ethernet frame and BRCM tagged frame. Those two CRC calculations take a lot of CPU power and are not needed.With this option, CPU do not need to calculate CRC for BRCM frame.                
 *     EN_VID_FFF_FWD   0 : comply with standard, drop frame.1: forwaed frame.
 *     DROP_VTABLE_MISS When set to 1, a frame with V_table miss will be dropped.When set to 0, a frame with V_table miss will be fowarded to IMP.                             
 *     EGRESS_DIR_FRM_BYPASS_TRUNK_EN Egress Directed Frame Bypass Trunking Re-direction EnableSet to1 : Egress Directed Frame From Management Port will bypass Re-Trunking Re-directed RuleSet to 0: Egress Directed Frame will From Management Port will follow Trunking Re-directed Rule.                   
 *     EN_PRESV_1P_TAG  To enable this, en_preserv_non_1q_frame must be also enabled.When enabled, it preserves priority (802.1p) tagged frames as priority tagged frames at TX even if untag map in VLAN table is 1.                
 *     PRESV_NON1Q      - en_preserv_non_1q_frame: (default 0)When enabled, it preserves untagged frame as untagged frame at TX regardless of untag map in VLAN table, and preserves priority (802.1p) tagged frames as priority tagged frames at TX if untag map in VLAN Table is 0, but otherwise ntag priority tag.                
 *     RESERVED_R       Reserved.#Enable Reserved Multicast Address Learn#1: The frame with reserved multicast DA will be learned. #   Either {SA+Default PVID} or {SA + Frame VID}#0: It will not be learned.                
 *
 ******************************************************************************/
#define BCM6300_A0_VLAN_CTRL5r 0x00003407

#define BCM6300_A0_VLAN_CTRL5r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_CTRL5.
 *
 */
typedef union BCM6300_A0_VLAN_CTRL5r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl5[1];
	uint32_t _vlan_ctrl5;
} BCM6300_A0_VLAN_CTRL5r_t;

#define BCM6300_A0_VLAN_CTRL5r_CLR(r) (r).vlan_ctrl5[0] = 0
#define BCM6300_A0_VLAN_CTRL5r_SET(r,d) (r).vlan_ctrl5[0] = d
#define BCM6300_A0_VLAN_CTRL5r_GET(r) (r).vlan_ctrl5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_VLAN_CTRL5r_EN_TX_CRC_GENA_RATIONf_GET(r) (((r).vlan_ctrl5[0]) & 0x1)
#define BCM6300_A0_VLAN_CTRL5r_EN_TX_CRC_GENA_RATIONf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM6300_A0_VLAN_CTRL5r_EN_CPU_RX_BYPASS_CRCCHKf_GET(r) ((((r).vlan_ctrl5[0]) >> 1) & 0x1)
#define BCM6300_A0_VLAN_CTRL5r_EN_CPU_RX_BYPASS_CRCCHKf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM6300_A0_VLAN_CTRL5r_EN_VID_FFF_FWDf_GET(r) ((((r).vlan_ctrl5[0]) >> 2) & 0x1)
#define BCM6300_A0_VLAN_CTRL5r_EN_VID_FFF_FWDf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM6300_A0_VLAN_CTRL5r_DROP_VTABLE_MISSf_GET(r) ((((r).vlan_ctrl5[0]) >> 3) & 0x1)
#define BCM6300_A0_VLAN_CTRL5r_DROP_VTABLE_MISSf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM6300_A0_VLAN_CTRL5r_EGRESS_DIR_FRM_BYPASS_TRUNK_ENf_GET(r) ((((r).vlan_ctrl5[0]) >> 4) & 0x1)
#define BCM6300_A0_VLAN_CTRL5r_EGRESS_DIR_FRM_BYPASS_TRUNK_ENf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM6300_A0_VLAN_CTRL5r_EN_PRESV_1P_TAGf_GET(r) ((((r).vlan_ctrl5[0]) >> 5) & 0x1)
#define BCM6300_A0_VLAN_CTRL5r_EN_PRESV_1P_TAGf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM6300_A0_VLAN_CTRL5r_PRESV_NON1Qf_GET(r) ((((r).vlan_ctrl5[0]) >> 6) & 0x1)
#define BCM6300_A0_VLAN_CTRL5r_PRESV_NON1Qf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM6300_A0_VLAN_CTRL5r_RESERVED_Rf_GET(r) ((((r).vlan_ctrl5[0]) >> 7) & 0x1)
#define BCM6300_A0_VLAN_CTRL5r_RESERVED_Rf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access VLAN_CTRL5.
 *
 */
#define BCM6300_A0_READ_VLAN_CTRL5r(u,r) cdk_robo_reg_read(u,BCM6300_A0_VLAN_CTRL5r,(r._vlan_ctrl5),1)
#define BCM6300_A0_WRITE_VLAN_CTRL5r(u,r) cdk_robo_reg_write(u,BCM6300_A0_VLAN_CTRL5r,&(r._vlan_ctrl5),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL5r BCM6300_A0_VLAN_CTRL5r
#define VLAN_CTRL5r_SIZE BCM6300_A0_VLAN_CTRL5r_SIZE
typedef BCM6300_A0_VLAN_CTRL5r_t VLAN_CTRL5r_t;
#define VLAN_CTRL5r_CLR BCM6300_A0_VLAN_CTRL5r_CLR
#define VLAN_CTRL5r_SET BCM6300_A0_VLAN_CTRL5r_SET
#define VLAN_CTRL5r_GET BCM6300_A0_VLAN_CTRL5r_GET
#define VLAN_CTRL5r_EN_TX_CRC_GENA_RATIONf_GET BCM6300_A0_VLAN_CTRL5r_EN_TX_CRC_GENA_RATIONf_GET
#define VLAN_CTRL5r_EN_TX_CRC_GENA_RATIONf_SET BCM6300_A0_VLAN_CTRL5r_EN_TX_CRC_GENA_RATIONf_SET
#define VLAN_CTRL5r_EN_CPU_RX_BYPASS_CRCCHKf_GET BCM6300_A0_VLAN_CTRL5r_EN_CPU_RX_BYPASS_CRCCHKf_GET
#define VLAN_CTRL5r_EN_CPU_RX_BYPASS_CRCCHKf_SET BCM6300_A0_VLAN_CTRL5r_EN_CPU_RX_BYPASS_CRCCHKf_SET
#define VLAN_CTRL5r_EN_VID_FFF_FWDf_GET BCM6300_A0_VLAN_CTRL5r_EN_VID_FFF_FWDf_GET
#define VLAN_CTRL5r_EN_VID_FFF_FWDf_SET BCM6300_A0_VLAN_CTRL5r_EN_VID_FFF_FWDf_SET
#define VLAN_CTRL5r_DROP_VTABLE_MISSf_GET BCM6300_A0_VLAN_CTRL5r_DROP_VTABLE_MISSf_GET
#define VLAN_CTRL5r_DROP_VTABLE_MISSf_SET BCM6300_A0_VLAN_CTRL5r_DROP_VTABLE_MISSf_SET
#define VLAN_CTRL5r_EGRESS_DIR_FRM_BYPASS_TRUNK_ENf_GET BCM6300_A0_VLAN_CTRL5r_EGRESS_DIR_FRM_BYPASS_TRUNK_ENf_GET
#define VLAN_CTRL5r_EGRESS_DIR_FRM_BYPASS_TRUNK_ENf_SET BCM6300_A0_VLAN_CTRL5r_EGRESS_DIR_FRM_BYPASS_TRUNK_ENf_SET
#define VLAN_CTRL5r_EN_PRESV_1P_TAGf_GET BCM6300_A0_VLAN_CTRL5r_EN_PRESV_1P_TAGf_GET
#define VLAN_CTRL5r_EN_PRESV_1P_TAGf_SET BCM6300_A0_VLAN_CTRL5r_EN_PRESV_1P_TAGf_SET
#define VLAN_CTRL5r_PRESV_NON1Qf_GET BCM6300_A0_VLAN_CTRL5r_PRESV_NON1Qf_GET
#define VLAN_CTRL5r_PRESV_NON1Qf_SET BCM6300_A0_VLAN_CTRL5r_PRESV_NON1Qf_SET
#define VLAN_CTRL5r_RESERVED_Rf_GET BCM6300_A0_VLAN_CTRL5r_RESERVED_Rf_GET
#define VLAN_CTRL5r_RESERVED_Rf_SET BCM6300_A0_VLAN_CTRL5r_RESERVED_Rf_SET
#define READ_VLAN_CTRL5r BCM6300_A0_READ_VLAN_CTRL5r
#define WRITE_VLAN_CTRL5r BCM6300_A0_WRITE_VLAN_CTRL5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_VLAN_CTRL5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  VLAN_CTRL6
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 6 Registers
 * SIZE:     8
 * FIELDS:
 *     STRICT_SFD_DETECT When enabled, 5388 drops frames with no preamble and start with SFD regardless of the phase rx clk at which nibble data of SFD is received.When disabled (dfault), 5388 drops such frames only at certain phase of the nibble data of SFD.NOTE: This register turns on a bug fix, so should be hidden in the customer datasheet. We decided to turn it off by default for safety purpose.0                
 *     LENG_BY_TAGGED_FM 1 : 5388 uses the old way of dropping oversize frames. If an untagged ingress frame is internally tagged (1Q enabled), the frame length + 4B is compared with the undersize (64B) and ovesize limit which is determined based on std_ovsz_drop.0 : (default) 5388 uses the new way of dropping oversize frames. Whether an ingress frame had tag or not, the original frame length is compared with the undersize (64B) and oversize limit which is determined based on std_ovsz_drop.** NOTE: this bit is added per YiHsien's request, just in case we need to set it back to old mode when any thing goes wrong, which shouldn't happen.                
 *     RESERVED_R       Reserved.                
 *     STD_OVSZ_DROP    If std_ovsz_drop is 1,5388 drops untagged ingress frames greater than 1518B and tagged ingress frames greater than 1522B at the ports where jumbo is disabled. Whereas at the ports where jumbo is enabled,5388 drops untagged ingress frames greater than 9724B and tagged ingress frames greater than 9728B.If std_ovsz_drop is 0, (default) 5388 drops (tagged or untagged) ingress frames greater than 1536B and at the portswhere jumbo is disabled. Whereas at the ports where jumbo is enabled, 5388 drops tagged or untagged) ingress frames greater than 9728B.** NOTE: At a non-jumbo port, untagged 1536B frames may be internally tagged and become 1540B, and such frames are still accepted. Whereas at a jumbo port, untagged 9728B frames may be internally tagged and become 9732B, then such frames, however, get dropped, in order to keep the max buffer allocation for each frame at most 38 buffer units.                                
 *     DIS_ARL_BUST_LMT Disable ARL arbiter burst limit of 2 cycles.When set to 1, it disables the fix for ARL arbiter problem of not granting the high-priority request immediately. Default is 0.NOTE: Engineering only. Do not release this reg to customers                
 *     ARL_LATE_SEL     Num of extra states to accommodate ARL latency.When 3'b000, lengthen rxfsm by 2 cycles (Default).When 3'b001, lengthen rxfsm by 3 cycles.When 3'b010, lengthen rxfsm by 4 cycles.When 3'b111, lengthen rxfsm by 1 cycles.When 3'b110, lengthen rxfsm by 0 cycles.When 3'b100, lengthen rxfsm by 2 cycles and turn off pulling in fmstopped effectively by 1 cycle.When other values, behaves the same as the 3'b000 case Default is 3'b000.NOTE: Engineering only. Do not release this reg to customers.                
 *
 ******************************************************************************/
#define BCM6300_A0_VLAN_CTRL6r 0x00003408

#define BCM6300_A0_VLAN_CTRL6r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_CTRL6.
 *
 */
typedef union BCM6300_A0_VLAN_CTRL6r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl6[1];
	uint32_t _vlan_ctrl6;
} BCM6300_A0_VLAN_CTRL6r_t;

#define BCM6300_A0_VLAN_CTRL6r_CLR(r) (r).vlan_ctrl6[0] = 0
#define BCM6300_A0_VLAN_CTRL6r_SET(r,d) (r).vlan_ctrl6[0] = d
#define BCM6300_A0_VLAN_CTRL6r_GET(r) (r).vlan_ctrl6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_VLAN_CTRL6r_STRICT_SFD_DETECTf_GET(r) (((r).vlan_ctrl6[0]) & 0x1)
#define BCM6300_A0_VLAN_CTRL6r_STRICT_SFD_DETECTf_SET(r,f) (r).vlan_ctrl6[0]=(((r).vlan_ctrl6[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM6300_A0_VLAN_CTRL6r_LENG_BY_TAGGED_FMf_GET(r) ((((r).vlan_ctrl6[0]) >> 1) & 0x1)
#define BCM6300_A0_VLAN_CTRL6r_LENG_BY_TAGGED_FMf_SET(r,f) (r).vlan_ctrl6[0]=(((r).vlan_ctrl6[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM6300_A0_VLAN_CTRL6r_RESERVED_Rf_GET(r) ((((r).vlan_ctrl6[0]) >> 2) & 0x1)
#define BCM6300_A0_VLAN_CTRL6r_RESERVED_Rf_SET(r,f) (r).vlan_ctrl6[0]=(((r).vlan_ctrl6[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM6300_A0_VLAN_CTRL6r_STD_OVSZ_DROPf_GET(r) ((((r).vlan_ctrl6[0]) >> 3) & 0x1)
#define BCM6300_A0_VLAN_CTRL6r_STD_OVSZ_DROPf_SET(r,f) (r).vlan_ctrl6[0]=(((r).vlan_ctrl6[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM6300_A0_VLAN_CTRL6r_DIS_ARL_BUST_LMTf_GET(r) ((((r).vlan_ctrl6[0]) >> 4) & 0x1)
#define BCM6300_A0_VLAN_CTRL6r_DIS_ARL_BUST_LMTf_SET(r,f) (r).vlan_ctrl6[0]=(((r).vlan_ctrl6[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM6300_A0_VLAN_CTRL6r_ARL_LATE_SELf_GET(r) ((((r).vlan_ctrl6[0]) >> 5) & 0x7)
#define BCM6300_A0_VLAN_CTRL6r_ARL_LATE_SELf_SET(r,f) (r).vlan_ctrl6[0]=(((r).vlan_ctrl6[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access VLAN_CTRL6.
 *
 */
#define BCM6300_A0_READ_VLAN_CTRL6r(u,r) cdk_robo_reg_read(u,BCM6300_A0_VLAN_CTRL6r,(r._vlan_ctrl6),1)
#define BCM6300_A0_WRITE_VLAN_CTRL6r(u,r) cdk_robo_reg_write(u,BCM6300_A0_VLAN_CTRL6r,&(r._vlan_ctrl6),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL6r BCM6300_A0_VLAN_CTRL6r
#define VLAN_CTRL6r_SIZE BCM6300_A0_VLAN_CTRL6r_SIZE
typedef BCM6300_A0_VLAN_CTRL6r_t VLAN_CTRL6r_t;
#define VLAN_CTRL6r_CLR BCM6300_A0_VLAN_CTRL6r_CLR
#define VLAN_CTRL6r_SET BCM6300_A0_VLAN_CTRL6r_SET
#define VLAN_CTRL6r_GET BCM6300_A0_VLAN_CTRL6r_GET
#define VLAN_CTRL6r_STRICT_SFD_DETECTf_GET BCM6300_A0_VLAN_CTRL6r_STRICT_SFD_DETECTf_GET
#define VLAN_CTRL6r_STRICT_SFD_DETECTf_SET BCM6300_A0_VLAN_CTRL6r_STRICT_SFD_DETECTf_SET
#define VLAN_CTRL6r_LENG_BY_TAGGED_FMf_GET BCM6300_A0_VLAN_CTRL6r_LENG_BY_TAGGED_FMf_GET
#define VLAN_CTRL6r_LENG_BY_TAGGED_FMf_SET BCM6300_A0_VLAN_CTRL6r_LENG_BY_TAGGED_FMf_SET
#define VLAN_CTRL6r_RESERVED_Rf_GET BCM6300_A0_VLAN_CTRL6r_RESERVED_Rf_GET
#define VLAN_CTRL6r_RESERVED_Rf_SET BCM6300_A0_VLAN_CTRL6r_RESERVED_Rf_SET
#define VLAN_CTRL6r_STD_OVSZ_DROPf_GET BCM6300_A0_VLAN_CTRL6r_STD_OVSZ_DROPf_GET
#define VLAN_CTRL6r_STD_OVSZ_DROPf_SET BCM6300_A0_VLAN_CTRL6r_STD_OVSZ_DROPf_SET
#define VLAN_CTRL6r_DIS_ARL_BUST_LMTf_GET BCM6300_A0_VLAN_CTRL6r_DIS_ARL_BUST_LMTf_GET
#define VLAN_CTRL6r_DIS_ARL_BUST_LMTf_SET BCM6300_A0_VLAN_CTRL6r_DIS_ARL_BUST_LMTf_SET
#define VLAN_CTRL6r_ARL_LATE_SELf_GET BCM6300_A0_VLAN_CTRL6r_ARL_LATE_SELf_GET
#define VLAN_CTRL6r_ARL_LATE_SELf_SET BCM6300_A0_VLAN_CTRL6r_ARL_LATE_SELf_SET
#define READ_VLAN_CTRL6r BCM6300_A0_READ_VLAN_CTRL6r
#define WRITE_VLAN_CTRL6r BCM6300_A0_WRITE_VLAN_CTRL6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_VLAN_CTRL6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  WAN_PORT_SEL
 * BLOCKS:   SYS
 * DESC:     WAN Port select Register
 * SIZE:     16
 * FIELDS:
 *     WAN_SELECT       
 *     EN_MAN2WAN       
 *     WAN_PORT_RESERVED Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_WAN_PORT_SELr 0x00000026

#define BCM6300_A0_WAN_PORT_SELr_SIZE 2

/*
 * This structure should be used to declare and program WAN_PORT_SEL.
 *
 */
typedef union BCM6300_A0_WAN_PORT_SELr_s {
	uint32_t v[1];
	uint32_t wan_port_sel[1];
	uint32_t _wan_port_sel;
} BCM6300_A0_WAN_PORT_SELr_t;

#define BCM6300_A0_WAN_PORT_SELr_CLR(r) (r).wan_port_sel[0] = 0
#define BCM6300_A0_WAN_PORT_SELr_SET(r,d) (r).wan_port_sel[0] = d
#define BCM6300_A0_WAN_PORT_SELr_GET(r) (r).wan_port_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_WAN_PORT_SELr_WAN_SELECTf_GET(r) (((r).wan_port_sel[0]) & 0x1ff)
#define BCM6300_A0_WAN_PORT_SELr_WAN_SELECTf_SET(r,f) (r).wan_port_sel[0]=(((r).wan_port_sel[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_WAN_PORT_SELr_EN_MAN2WANf_GET(r) ((((r).wan_port_sel[0]) >> 9) & 0x1)
#define BCM6300_A0_WAN_PORT_SELr_EN_MAN2WANf_SET(r,f) (r).wan_port_sel[0]=(((r).wan_port_sel[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM6300_A0_WAN_PORT_SELr_WAN_PORT_RESERVEDf_GET(r) ((((r).wan_port_sel[0]) >> 10) & 0x3f)
#define BCM6300_A0_WAN_PORT_SELr_WAN_PORT_RESERVEDf_SET(r,f) (r).wan_port_sel[0]=(((r).wan_port_sel[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access WAN_PORT_SEL.
 *
 */
#define BCM6300_A0_READ_WAN_PORT_SELr(u,r) cdk_robo_reg_read(u,BCM6300_A0_WAN_PORT_SELr,(r._wan_port_sel),2)
#define BCM6300_A0_WRITE_WAN_PORT_SELr(u,r) cdk_robo_reg_write(u,BCM6300_A0_WAN_PORT_SELr,&(r._wan_port_sel),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define WAN_PORT_SELr BCM6300_A0_WAN_PORT_SELr
#define WAN_PORT_SELr_SIZE BCM6300_A0_WAN_PORT_SELr_SIZE
typedef BCM6300_A0_WAN_PORT_SELr_t WAN_PORT_SELr_t;
#define WAN_PORT_SELr_CLR BCM6300_A0_WAN_PORT_SELr_CLR
#define WAN_PORT_SELr_SET BCM6300_A0_WAN_PORT_SELr_SET
#define WAN_PORT_SELr_GET BCM6300_A0_WAN_PORT_SELr_GET
#define WAN_PORT_SELr_WAN_SELECTf_GET BCM6300_A0_WAN_PORT_SELr_WAN_SELECTf_GET
#define WAN_PORT_SELr_WAN_SELECTf_SET BCM6300_A0_WAN_PORT_SELr_WAN_SELECTf_SET
#define WAN_PORT_SELr_EN_MAN2WANf_GET BCM6300_A0_WAN_PORT_SELr_EN_MAN2WANf_GET
#define WAN_PORT_SELr_EN_MAN2WANf_SET BCM6300_A0_WAN_PORT_SELr_EN_MAN2WANf_SET
#define WAN_PORT_SELr_WAN_PORT_RESERVEDf_GET BCM6300_A0_WAN_PORT_SELr_WAN_PORT_RESERVEDf_GET
#define WAN_PORT_SELr_WAN_PORT_RESERVEDf_SET BCM6300_A0_WAN_PORT_SELr_WAN_PORT_RESERVEDf_SET
#define READ_WAN_PORT_SELr BCM6300_A0_READ_WAN_PORT_SELr
#define WRITE_WAN_PORT_SELr BCM6300_A0_WRITE_WAN_PORT_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_WAN_PORT_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  WATCH_DOG_CTRL
 * BLOCKS:   SYS
 * DESC:     SWatch Dog Control Registrer
 * SIZE:     8
 * FIELDS:
 *     EN_RST_SWCODE    Enable Reset Switch Code.Default value by strap pin auto_reset_en.
 *     EN_RST_REGFILE   Enable Reset Register.Default value by strap pin auto_reset_en.
 *     EN_RELOAD_EEPROM Enable Reload EEPROM after software Reset.Default value by strap pin auto_reset_en.
 *     EN_AUTO_RESET    Enable watch dog Auto-Reset (in dumb system).Default value by strap pin auto_reset_en.
 *     EN_HW_RESET      Enable Hardware Reset.
 *     RESERVED_R       Reserved
 *     SOFTWARE_RESET   Enable Software Reset.1: Reset activeShoudl write software_reset bit 1, then write 0 to clear the reset state.
 *
 ******************************************************************************/
#define BCM6300_A0_WATCH_DOG_CTRLr 0x00000079

#define BCM6300_A0_WATCH_DOG_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program WATCH_DOG_CTRL.
 *
 */
typedef union BCM6300_A0_WATCH_DOG_CTRLr_s {
	uint32_t v[1];
	uint32_t watch_dog_ctrl[1];
	uint32_t _watch_dog_ctrl;
} BCM6300_A0_WATCH_DOG_CTRLr_t;

#define BCM6300_A0_WATCH_DOG_CTRLr_CLR(r) (r).watch_dog_ctrl[0] = 0
#define BCM6300_A0_WATCH_DOG_CTRLr_SET(r,d) (r).watch_dog_ctrl[0] = d
#define BCM6300_A0_WATCH_DOG_CTRLr_GET(r) (r).watch_dog_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_WATCH_DOG_CTRLr_EN_RST_SWCODEf_GET(r) (((r).watch_dog_ctrl[0]) & 0x1)
#define BCM6300_A0_WATCH_DOG_CTRLr_EN_RST_SWCODEf_SET(r,f) (r).watch_dog_ctrl[0]=(((r).watch_dog_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM6300_A0_WATCH_DOG_CTRLr_EN_RST_REGFILEf_GET(r) ((((r).watch_dog_ctrl[0]) >> 1) & 0x1)
#define BCM6300_A0_WATCH_DOG_CTRLr_EN_RST_REGFILEf_SET(r,f) (r).watch_dog_ctrl[0]=(((r).watch_dog_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM6300_A0_WATCH_DOG_CTRLr_EN_RELOAD_EEPROMf_GET(r) ((((r).watch_dog_ctrl[0]) >> 2) & 0x1)
#define BCM6300_A0_WATCH_DOG_CTRLr_EN_RELOAD_EEPROMf_SET(r,f) (r).watch_dog_ctrl[0]=(((r).watch_dog_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM6300_A0_WATCH_DOG_CTRLr_EN_AUTO_RESETf_GET(r) ((((r).watch_dog_ctrl[0]) >> 3) & 0x1)
#define BCM6300_A0_WATCH_DOG_CTRLr_EN_AUTO_RESETf_SET(r,f) (r).watch_dog_ctrl[0]=(((r).watch_dog_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM6300_A0_WATCH_DOG_CTRLr_EN_HW_RESETf_GET(r) ((((r).watch_dog_ctrl[0]) >> 4) & 0x1)
#define BCM6300_A0_WATCH_DOG_CTRLr_EN_HW_RESETf_SET(r,f) (r).watch_dog_ctrl[0]=(((r).watch_dog_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM6300_A0_WATCH_DOG_CTRLr_RESERVED_Rf_GET(r) ((((r).watch_dog_ctrl[0]) >> 5) & 0x3)
#define BCM6300_A0_WATCH_DOG_CTRLr_RESERVED_Rf_SET(r,f) (r).watch_dog_ctrl[0]=(((r).watch_dog_ctrl[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM6300_A0_WATCH_DOG_CTRLr_SOFTWARE_RESETf_GET(r) ((((r).watch_dog_ctrl[0]) >> 7) & 0x1)
#define BCM6300_A0_WATCH_DOG_CTRLr_SOFTWARE_RESETf_SET(r,f) (r).watch_dog_ctrl[0]=(((r).watch_dog_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access WATCH_DOG_CTRL.
 *
 */
#define BCM6300_A0_READ_WATCH_DOG_CTRLr(u,r) cdk_robo_reg_read(u,BCM6300_A0_WATCH_DOG_CTRLr,(r._watch_dog_ctrl),1)
#define BCM6300_A0_WRITE_WATCH_DOG_CTRLr(u,r) cdk_robo_reg_write(u,BCM6300_A0_WATCH_DOG_CTRLr,&(r._watch_dog_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define WATCH_DOG_CTRLr BCM6300_A0_WATCH_DOG_CTRLr
#define WATCH_DOG_CTRLr_SIZE BCM6300_A0_WATCH_DOG_CTRLr_SIZE
typedef BCM6300_A0_WATCH_DOG_CTRLr_t WATCH_DOG_CTRLr_t;
#define WATCH_DOG_CTRLr_CLR BCM6300_A0_WATCH_DOG_CTRLr_CLR
#define WATCH_DOG_CTRLr_SET BCM6300_A0_WATCH_DOG_CTRLr_SET
#define WATCH_DOG_CTRLr_GET BCM6300_A0_WATCH_DOG_CTRLr_GET
#define WATCH_DOG_CTRLr_EN_RST_SWCODEf_GET BCM6300_A0_WATCH_DOG_CTRLr_EN_RST_SWCODEf_GET
#define WATCH_DOG_CTRLr_EN_RST_SWCODEf_SET BCM6300_A0_WATCH_DOG_CTRLr_EN_RST_SWCODEf_SET
#define WATCH_DOG_CTRLr_EN_RST_REGFILEf_GET BCM6300_A0_WATCH_DOG_CTRLr_EN_RST_REGFILEf_GET
#define WATCH_DOG_CTRLr_EN_RST_REGFILEf_SET BCM6300_A0_WATCH_DOG_CTRLr_EN_RST_REGFILEf_SET
#define WATCH_DOG_CTRLr_EN_RELOAD_EEPROMf_GET BCM6300_A0_WATCH_DOG_CTRLr_EN_RELOAD_EEPROMf_GET
#define WATCH_DOG_CTRLr_EN_RELOAD_EEPROMf_SET BCM6300_A0_WATCH_DOG_CTRLr_EN_RELOAD_EEPROMf_SET
#define WATCH_DOG_CTRLr_EN_AUTO_RESETf_GET BCM6300_A0_WATCH_DOG_CTRLr_EN_AUTO_RESETf_GET
#define WATCH_DOG_CTRLr_EN_AUTO_RESETf_SET BCM6300_A0_WATCH_DOG_CTRLr_EN_AUTO_RESETf_SET
#define WATCH_DOG_CTRLr_EN_HW_RESETf_GET BCM6300_A0_WATCH_DOG_CTRLr_EN_HW_RESETf_GET
#define WATCH_DOG_CTRLr_EN_HW_RESETf_SET BCM6300_A0_WATCH_DOG_CTRLr_EN_HW_RESETf_SET
#define WATCH_DOG_CTRLr_RESERVED_Rf_GET BCM6300_A0_WATCH_DOG_CTRLr_RESERVED_Rf_GET
#define WATCH_DOG_CTRLr_RESERVED_Rf_SET BCM6300_A0_WATCH_DOG_CTRLr_RESERVED_Rf_SET
#define WATCH_DOG_CTRLr_SOFTWARE_RESETf_GET BCM6300_A0_WATCH_DOG_CTRLr_SOFTWARE_RESETf_GET
#define WATCH_DOG_CTRLr_SOFTWARE_RESETf_SET BCM6300_A0_WATCH_DOG_CTRLr_SOFTWARE_RESETf_SET
#define READ_WATCH_DOG_CTRLr BCM6300_A0_READ_WATCH_DOG_CTRLr
#define WRITE_WATCH_DOG_CTRLr BCM6300_A0_WRITE_WATCH_DOG_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_WATCH_DOG_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  WATCH_DOG_RPT1
 * BLOCKS:   SYS
 * DESC:     Watch Dog Report 1 Registrer
 * SIZE:     16
 * FIELDS:
 *     TX_PORT_HUNG_INDICATOR Tx Hung IndicatorBit 8:0 = Port 8:01: Means hung case happen0: Means Ok
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_WATCH_DOG_RPT1r 0x0000007a

#define BCM6300_A0_WATCH_DOG_RPT1r_SIZE 2

/*
 * This structure should be used to declare and program WATCH_DOG_RPT1.
 *
 */
typedef union BCM6300_A0_WATCH_DOG_RPT1r_s {
	uint32_t v[1];
	uint32_t watch_dog_rpt1[1];
	uint32_t _watch_dog_rpt1;
} BCM6300_A0_WATCH_DOG_RPT1r_t;

#define BCM6300_A0_WATCH_DOG_RPT1r_CLR(r) (r).watch_dog_rpt1[0] = 0
#define BCM6300_A0_WATCH_DOG_RPT1r_SET(r,d) (r).watch_dog_rpt1[0] = d
#define BCM6300_A0_WATCH_DOG_RPT1r_GET(r) (r).watch_dog_rpt1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_WATCH_DOG_RPT1r_TX_PORT_HUNG_INDICATORf_GET(r) (((r).watch_dog_rpt1[0]) & 0x1ff)
#define BCM6300_A0_WATCH_DOG_RPT1r_TX_PORT_HUNG_INDICATORf_SET(r,f) (r).watch_dog_rpt1[0]=(((r).watch_dog_rpt1[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_WATCH_DOG_RPT1r_RESERVED_Rf_GET(r) ((((r).watch_dog_rpt1[0]) >> 9) & 0x7f)
#define BCM6300_A0_WATCH_DOG_RPT1r_RESERVED_Rf_SET(r,f) (r).watch_dog_rpt1[0]=(((r).watch_dog_rpt1[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access WATCH_DOG_RPT1.
 *
 */
#define BCM6300_A0_READ_WATCH_DOG_RPT1r(u,r) cdk_robo_reg_read(u,BCM6300_A0_WATCH_DOG_RPT1r,(r._watch_dog_rpt1),2)
#define BCM6300_A0_WRITE_WATCH_DOG_RPT1r(u,r) cdk_robo_reg_write(u,BCM6300_A0_WATCH_DOG_RPT1r,&(r._watch_dog_rpt1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define WATCH_DOG_RPT1r BCM6300_A0_WATCH_DOG_RPT1r
#define WATCH_DOG_RPT1r_SIZE BCM6300_A0_WATCH_DOG_RPT1r_SIZE
typedef BCM6300_A0_WATCH_DOG_RPT1r_t WATCH_DOG_RPT1r_t;
#define WATCH_DOG_RPT1r_CLR BCM6300_A0_WATCH_DOG_RPT1r_CLR
#define WATCH_DOG_RPT1r_SET BCM6300_A0_WATCH_DOG_RPT1r_SET
#define WATCH_DOG_RPT1r_GET BCM6300_A0_WATCH_DOG_RPT1r_GET
#define WATCH_DOG_RPT1r_TX_PORT_HUNG_INDICATORf_GET BCM6300_A0_WATCH_DOG_RPT1r_TX_PORT_HUNG_INDICATORf_GET
#define WATCH_DOG_RPT1r_TX_PORT_HUNG_INDICATORf_SET BCM6300_A0_WATCH_DOG_RPT1r_TX_PORT_HUNG_INDICATORf_SET
#define WATCH_DOG_RPT1r_RESERVED_Rf_GET BCM6300_A0_WATCH_DOG_RPT1r_RESERVED_Rf_GET
#define WATCH_DOG_RPT1r_RESERVED_Rf_SET BCM6300_A0_WATCH_DOG_RPT1r_RESERVED_Rf_SET
#define READ_WATCH_DOG_RPT1r BCM6300_A0_READ_WATCH_DOG_RPT1r
#define WRITE_WATCH_DOG_RPT1r BCM6300_A0_WRITE_WATCH_DOG_RPT1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_WATCH_DOG_RPT1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  WATCH_DOG_RPT2
 * BLOCKS:   SYS
 * DESC:     Watch Dog Report 2 Registrer
 * SIZE:     16
 * FIELDS:
 *     RX_PORT_HUNG_INDICATOR Rx Hung IndicatorBit 8:0 = Port 8:01: Means hung case happen0: Means Ok
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_WATCH_DOG_RPT2r 0x0000007c

#define BCM6300_A0_WATCH_DOG_RPT2r_SIZE 2

/*
 * This structure should be used to declare and program WATCH_DOG_RPT2.
 *
 */
typedef union BCM6300_A0_WATCH_DOG_RPT2r_s {
	uint32_t v[1];
	uint32_t watch_dog_rpt2[1];
	uint32_t _watch_dog_rpt2;
} BCM6300_A0_WATCH_DOG_RPT2r_t;

#define BCM6300_A0_WATCH_DOG_RPT2r_CLR(r) (r).watch_dog_rpt2[0] = 0
#define BCM6300_A0_WATCH_DOG_RPT2r_SET(r,d) (r).watch_dog_rpt2[0] = d
#define BCM6300_A0_WATCH_DOG_RPT2r_GET(r) (r).watch_dog_rpt2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_WATCH_DOG_RPT2r_RX_PORT_HUNG_INDICATORf_GET(r) (((r).watch_dog_rpt2[0]) & 0x1ff)
#define BCM6300_A0_WATCH_DOG_RPT2r_RX_PORT_HUNG_INDICATORf_SET(r,f) (r).watch_dog_rpt2[0]=(((r).watch_dog_rpt2[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_WATCH_DOG_RPT2r_RESERVED_Rf_GET(r) ((((r).watch_dog_rpt2[0]) >> 9) & 0x7f)
#define BCM6300_A0_WATCH_DOG_RPT2r_RESERVED_Rf_SET(r,f) (r).watch_dog_rpt2[0]=(((r).watch_dog_rpt2[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access WATCH_DOG_RPT2.
 *
 */
#define BCM6300_A0_READ_WATCH_DOG_RPT2r(u,r) cdk_robo_reg_read(u,BCM6300_A0_WATCH_DOG_RPT2r,(r._watch_dog_rpt2),2)
#define BCM6300_A0_WRITE_WATCH_DOG_RPT2r(u,r) cdk_robo_reg_write(u,BCM6300_A0_WATCH_DOG_RPT2r,&(r._watch_dog_rpt2),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define WATCH_DOG_RPT2r BCM6300_A0_WATCH_DOG_RPT2r
#define WATCH_DOG_RPT2r_SIZE BCM6300_A0_WATCH_DOG_RPT2r_SIZE
typedef BCM6300_A0_WATCH_DOG_RPT2r_t WATCH_DOG_RPT2r_t;
#define WATCH_DOG_RPT2r_CLR BCM6300_A0_WATCH_DOG_RPT2r_CLR
#define WATCH_DOG_RPT2r_SET BCM6300_A0_WATCH_DOG_RPT2r_SET
#define WATCH_DOG_RPT2r_GET BCM6300_A0_WATCH_DOG_RPT2r_GET
#define WATCH_DOG_RPT2r_RX_PORT_HUNG_INDICATORf_GET BCM6300_A0_WATCH_DOG_RPT2r_RX_PORT_HUNG_INDICATORf_GET
#define WATCH_DOG_RPT2r_RX_PORT_HUNG_INDICATORf_SET BCM6300_A0_WATCH_DOG_RPT2r_RX_PORT_HUNG_INDICATORf_SET
#define WATCH_DOG_RPT2r_RESERVED_Rf_GET BCM6300_A0_WATCH_DOG_RPT2r_RESERVED_Rf_GET
#define WATCH_DOG_RPT2r_RESERVED_Rf_SET BCM6300_A0_WATCH_DOG_RPT2r_RESERVED_Rf_SET
#define READ_WATCH_DOG_RPT2r BCM6300_A0_READ_WATCH_DOG_RPT2r
#define WRITE_WATCH_DOG_RPT2r BCM6300_A0_WRITE_WATCH_DOG_RPT2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_WATCH_DOG_RPT2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  WATCH_DOG_RPT3
 * BLOCKS:   SYS
 * DESC:     Watch Dog Report 3 Registrer
 * SIZE:     16
 * FIELDS:
 *     ARL_HUNG_INDICATOR ARL Indicator.Bit 8:0 = Port 8:01: Means hung case happen0: Means Ok
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_WATCH_DOG_RPT3r 0x0000007e

#define BCM6300_A0_WATCH_DOG_RPT3r_SIZE 2

/*
 * This structure should be used to declare and program WATCH_DOG_RPT3.
 *
 */
typedef union BCM6300_A0_WATCH_DOG_RPT3r_s {
	uint32_t v[1];
	uint32_t watch_dog_rpt3[1];
	uint32_t _watch_dog_rpt3;
} BCM6300_A0_WATCH_DOG_RPT3r_t;

#define BCM6300_A0_WATCH_DOG_RPT3r_CLR(r) (r).watch_dog_rpt3[0] = 0
#define BCM6300_A0_WATCH_DOG_RPT3r_SET(r,d) (r).watch_dog_rpt3[0] = d
#define BCM6300_A0_WATCH_DOG_RPT3r_GET(r) (r).watch_dog_rpt3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_WATCH_DOG_RPT3r_ARL_HUNG_INDICATORf_GET(r) (((r).watch_dog_rpt3[0]) & 0x1ff)
#define BCM6300_A0_WATCH_DOG_RPT3r_ARL_HUNG_INDICATORf_SET(r,f) (r).watch_dog_rpt3[0]=(((r).watch_dog_rpt3[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM6300_A0_WATCH_DOG_RPT3r_RESERVED_Rf_GET(r) ((((r).watch_dog_rpt3[0]) >> 9) & 0x7f)
#define BCM6300_A0_WATCH_DOG_RPT3r_RESERVED_Rf_SET(r,f) (r).watch_dog_rpt3[0]=(((r).watch_dog_rpt3[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access WATCH_DOG_RPT3.
 *
 */
#define BCM6300_A0_READ_WATCH_DOG_RPT3r(u,r) cdk_robo_reg_read(u,BCM6300_A0_WATCH_DOG_RPT3r,(r._watch_dog_rpt3),2)
#define BCM6300_A0_WRITE_WATCH_DOG_RPT3r(u,r) cdk_robo_reg_write(u,BCM6300_A0_WATCH_DOG_RPT3r,&(r._watch_dog_rpt3),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define WATCH_DOG_RPT3r BCM6300_A0_WATCH_DOG_RPT3r
#define WATCH_DOG_RPT3r_SIZE BCM6300_A0_WATCH_DOG_RPT3r_SIZE
typedef BCM6300_A0_WATCH_DOG_RPT3r_t WATCH_DOG_RPT3r_t;
#define WATCH_DOG_RPT3r_CLR BCM6300_A0_WATCH_DOG_RPT3r_CLR
#define WATCH_DOG_RPT3r_SET BCM6300_A0_WATCH_DOG_RPT3r_SET
#define WATCH_DOG_RPT3r_GET BCM6300_A0_WATCH_DOG_RPT3r_GET
#define WATCH_DOG_RPT3r_ARL_HUNG_INDICATORf_GET BCM6300_A0_WATCH_DOG_RPT3r_ARL_HUNG_INDICATORf_GET
#define WATCH_DOG_RPT3r_ARL_HUNG_INDICATORf_SET BCM6300_A0_WATCH_DOG_RPT3r_ARL_HUNG_INDICATORf_SET
#define WATCH_DOG_RPT3r_RESERVED_Rf_GET BCM6300_A0_WATCH_DOG_RPT3r_RESERVED_Rf_GET
#define WATCH_DOG_RPT3r_RESERVED_Rf_SET BCM6300_A0_WATCH_DOG_RPT3r_RESERVED_Rf_SET
#define READ_WATCH_DOG_RPT3r BCM6300_A0_READ_WATCH_DOG_RPT3r
#define WRITE_WATCH_DOG_RPT3r BCM6300_A0_WRITE_WATCH_DOG_RPT3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_WATCH_DOG_RPT3r'
 ******************************************************************************/

/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  IUDMA Control
 * BLOCKS:   SYS
 * DESC:     iuDMA Control Registrer
 * SIZE:     32
 * FIELDS:
 *     RESERVED1_R     Reserved
 *     RXQ_PRIO           Priority From iuDMA Queue
 *     RXBD_PRIO         Priority From BD
 *     TXDMA_EN          Enable Tx DMA
 *     RXDMA_EN          Enable Rx DMA
 *     PRIO_SEL            RX Priority Selection (from switch or classifier)
 *     RESERVED_R       Reserved
 *
 ******************************************************************************/
#define BCM6300_A0_IUDMA_CTRLr 0x000000a8

#define BCM6300_A0_IUDMA_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program IUDMA_CTRL.
 *
 */
typedef union BCM6300_A0_IUDMA_CTRLr_s {
	uint32_t v[1];
	uint32_t iudma_ctrl[1];
	uint32_t _iudma_ctrl;
} BCM6300_A0_IUDMA_CTRLr_t;

#define BCM6300_A0_IUDMA_CTRLr_CLR(r) (r).IUDMA_CTRL[0] = 0
#define BCM6300_A0_IUDMA_CTRLr_SET(r,d) (r).IUDMA_CTRL[0] = d
#define BCM6300_A0_IUDMA_CTRLr_GET(r) (r).IUDMA_CTRL[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_IUDMA_CTRLr_RESERVED_Rf_GET(r) (((r).iudma_ctrl[0]) & 0x3f)
#define BCM6300_A0_IUDMA_CTRLr_RESERVED_Rf_SET(r,f) (r).iudma_ctrl[0]=(((r).iudma_ctrl[0] & ~(uint32_t)0x3f) | (((uint32_t)f) & 0x3f))
#define BCM6300_A0_IUDMA_CTRLr_PRIO_SELf_GET(r) ((((r).iudma_ctrl[0]) >> 6) & 0x1)
#define BCM6300_A0_IUDMA_CTRLr_PRIO_SELf_SET(r,f) (r).iudma_ctrl[0]=(((r).iudma_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM6300_A0_IUDMA_CTRLr_RXDMA_ENf_GET(r) ((((r).iudma_ctrl[0]) >> 7) & 0x1)
#define BCM6300_A0_IUDMA_CTRLr_RXDMA_ENf_SET(r,f) (r).iudma_ctrl[0]=(((r).iudma_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM6300_A0_IUDMA_CTRLr_TXDMA_ENf_GET(r) ((((r).iudma_ctrl[0]) >> 8) & 0x1)
#define BCM6300_A0_IUDMA_CTRLr_TXDMA_ENf_SET(r,f) (r).iudma_ctrl[0]=(((r).iudma_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM6300_A0_IUDMA_CTRLr_RXBD_PRIOf_GET(r) ((((r).iudma_ctrl[0]) >> 9) & 0x1)
#define BCM6300_A0_IUDMA_CTRLr_RXBD_PRIOf_SET(r,f) (r).iudma_ctrl[0]=(((r).iudma_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM6300_A0_IUDMA_CTRLr_RXQ_PRIOf_GET(r) ((((r).iudma_ctrl[0]) >> 10) & 0x1)
#define BCM6300_A0_IUDMA_CTRLr_RXQ_PRIOf_SET(r,f) (r).iudma_ctrl[0]=(((r).iudma_ctrl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM6300_A0_IUDMA_CTRLr_RESERVED1_Rf_GET(r) ((((r).iudma_ctrl[0]) >> 11) & 0x1FFFFF)
#define BCM6300_A0_IUDMA_CTRLr_RESERVED1_Rf_SET(r,f) (r).iudma_ctrl[0]=(((r).iudma_ctrl[0] & ~((uint32_t)0x1FFFFF << 11)) | ((((uint32_t)f) & 0x1FFFFF) << 11))

/*
 * These macros can be used to access IUDMA_CTRL.
 *
 */
#define BCM6300_A0_READ_IUDMA_CTRLr(u,r) cdk_robo_reg_read(u,BCM6300_A0_IUDMA_CTRLr,(r._iudma_ctrl),4)
#define BCM6300_A0_WRITE_IUDMA_CTRLr(u,r) cdk_robo_reg_write(u,BCM6300_A0_IUDMA_CTRLr,&(r._iudma_ctrl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IUDMA_CTRLr BCM6300_A0_IUDMA_CTRLr
#define IUDMA_CTRLr_SIZE BCM6300_A0_IUDMA_CTRLr_SIZE
typedef BCM6300_A0_IUDMA_CTRLr_t IUDMA_CTRLr_t;
#define IUDMA_CTRLr_CLR BCM6300_A0_IUDMA_CTRLr_CLR
#define IUDMA_CTRLr_SET BCM6300_A0_IUDMA_CTRLr_SET
#define IUDMA_CTRLr_GET BCM6300_A0_IUDMA_CTRLr_GET
#define IUDMA_CTRLr_RXQ_PRIOf_GET BCM6300_A0_IUDMA_CTRLr_RXQ_PRIOf_GET
#define IUDMA_CTRLr_RXQ_PRIOf_SET BCM6300_A0_IUDMA_CTRLr_RXQ_PRIOf_SET
#define IUDMA_CTRLr_RXBD_PRIOf_GET BCM6300_A0_IUDMA_CTRLr_RXBD_PRIOf_GET
#define IUDMA_CTRLr_RXBD_PRIOf_SET BCM6300_A0_IUDMA_CTRLr_RXBD_PRIOf_SET
#define IUDMA_CTRLr_TXDMA_ENf_GET BCM6300_A0_IUDMA_CTRLr_TXDMA_ENf_GET
#define IUDMA_CTRLr_TXDMA_ENf_SET BCM6300_A0_IUDMA_CTRLr_TXDMA_ENf_SET
#define IUDMA_CTRLr_RXDMA_ENf_GET BCM6300_A0_IUDMA_CTRLr_RXDMA_ENf_GET
#define IUDMA_CTRLr_RXDMA_ENf_SET BCM6300_A0_IUDMA_CTRLr_RXDMA_ENf_SET
#define IUDMA_CTRLr_RESERVED_Rf_GET BCM6300_A0_IUDMA_CTRLr_RESERVED_Rf_GET
#define IUDMA_CTRLr_RESERVED_Rf_SET BCM6300_A0_IUDMA_CTRLr_RESERVED_Rf_SET
#define READ_IUDMA_CTRLr BCM6300_A0_READ_IUDMA_CTRLr
#define WRITE_IUDMA_CTRLr BCM6300_A0_WRITE_IUDMA_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_IUDMA_CTRLr'
 ******************************************************************************/

/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  IUDMA Queue Control
 * BLOCKS:   SYS
 * DESC:     iuDMA Queue Control Registrer
 * SIZE:     32
 * FIELDS:
 *     RXQ_SEL             Rx Queue Selection (from switch or classifier)
 *     RESERVED_R       Reserved
 *     TXQ_SEL             Tx Queue Selection
 *
 ******************************************************************************/
#define BCM6300_A0_IUDMA_QUEUE_CTRLr 0x000000ac

#define BCM6300_A0_IUDMA_QUEUE_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program IUDMA_QUEUE_CTRL.
 *
 */
typedef union BCM6300_A0_IUDMA_QUEUE_CTRLr_s {
	uint32_t v[1];
	uint32_t iudma_queue_ctrl[1];
	uint32_t _iudma_queue_ctrl;
} BCM6300_A0_IUDMA_QUEUE_CTRLr_t;

#define BCM6300_A0_IUDMA_QUEUE_CTRLr_CLR(r) (r).IUDMA_QUEUE_CTRL[0] = 0
#define BCM6300_A0_IUDMA_QUEUE_CTRLr_SET(r,d) (r).IUDMA_QUEUE_CTRL[0] = d
#define BCM6300_A0_IUDMA_QUEUE_CTRLr_GET(r) (r).IUDMA_QUEUE_CTRL[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_IUDMA_QUEUE_CTRLr_TXQ_SELf_GET(r) (((r).iudma_queue_ctrl[0]) & 0xfff)
#define BCM6300_A0_IUDMA_QUEUE_CTRLr_TXQ_SELf_SET(r,f) (r).iudma_queue_ctrl[0]=(((r).iudma_queue_ctrl[0] & ~(uint32_t)0xfff) | (((uint32_t)f) & 0xfff))
#define BCM6300_A0_IUDMA_QUEUE_CTRLr_RESERVED_Rf_GET(r) ((((r).iudma_queue_ctrl[0]) >> 12) & 0xf)
#define BCM6300_A0_IUDMA_QUEUE_CTRLr_RESERVED_Rf_SET(r,f) (r).iudma_queue_ctrl[0]=(((r).iudma_queue_ctrl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM6300_A0_IUDMA_QUEUE_CTRLr_RXQ_SELf_GET(r) ((((r).iudma_queue_ctrl[0]) >> 16) & 0xffff)
#define BCM6300_A0_IUDMA_QUEUE_CTRLr_RXQ_SELf_SET(r,f) (r).iudma_queue_ctrl[0]=(((r).iudma_queue_ctrl[0] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access IUDMA_QUEUE_CTRL.
 *
 */
#define BCM6300_A0_READ_IUDMA_QUEUE_CTRLr(u,r) cdk_robo_reg_read(u,BCM6300_A0_IUDMA_QUEUE_CTRLr,(r._iudma_queue_ctrl),4)
#define BCM6300_A0_WRITE_IUDMA_QUEUE_CTRLr(u,r) cdk_robo_reg_write(u,BCM6300_A0_IUDMA_QUEUE_CTRLr,&(r._iudma_queue_ctrl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IUDMA_QUEUE_CTRLr BCM6300_A0_IUDMA_QUEUE_CTRLr
#define IUDMA_QUEUE_CTRLr_SIZE BCM6300_A0_IUDMA_QUEUE_CTRLr_SIZE
typedef BCM6300_A0_IUDMA_QUEUE_CTRLr_t IUDMA_QUEUE_CTRLr_t;
#define IUDMA_QUEUE_CTRLr_CLR BCM6300_A0_IUDMA_QUEUE_CTRLr_CLR
#define IUDMA_QUEUE_CTRLr_SET BCM6300_A0_IUDMA_QUEUE_CTRLr_SET
#define IUDMA_QUEUE_CTRLr_GET BCM6300_A0_IUDMA_QUEUE_CTRLr_GET
#define IUDMA_QUEUE_CTRLr_RXQ_SELf_GET BCM6300_A0_IUDMA_QUEUE_CTRLr_RXQ_SELf_GET
#define IUDMA_QUEUE_CTRLr_RXQ_SELf_SET BCM6300_A0_IUDMA_QUEUE_CTRLr_RXQ_SELf_SET
#define IUDMA_QUEUE_CTRLr_RESERVED_Rf_GET BCM6300_A0_IUDMA_QUEUE_CTRLr_RESERVED_Rf_GET
#define IUDMA_QUEUE_CTRLr_RESERVED_Rf_SET BCM6300_A0_IUDMA_QUEUE_CTRLr_RESERVED_Rf_SET
#define IUDMA_QUEUE_CTRLr_TXQ_SELf_GET BCM6300_A0_IUDMA_QUEUE_CTRLr_TXQ_SELf_GET
#define IUDMA_QUEUE_CTRLr_TXQ_SELf_SET BCM6300_A0_IUDMA_QUEUE_CTRLr_TXQ_SELf_SET
#define READ_IUDMA_QUEUE_CTRLr BCM6300_A0_READ_IUDMA_QUEUE_CTRLr
#define WRITE_IUDMA_QUEUE_CTRLr BCM6300_A0_WRITE_IUDMA_QUEUE_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_IUDMA_QUEUE_CTRLr'
 ******************************************************************************/

/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  MARLA_MACVID_ENTRY0
 * BLOCKS:   SYS
 * DESC:     Multicast ARL Table entry
 * SIZE:     64
 * FIELDS:
 *     MAC_ADDR     
 *     VLAN_ID 
 *
 ******************************************************************************/
#define BCM6300_A0_MARLA_MACVID_ENTRY0r 0x00005000

#define BCM6300_A0_MARLA_MACVID_ENTRY0r_SIZE 8

/*
 * This structure should be used to declare and program MARLA_MACVID_ENTRY0.
 *
 */
typedef union BCM6300_A0_MARLA_MACVID_ENTRY0r_s {
	uint32_t v[2];
	uint32_t marla_macvid_entry0[2];
	uint32_t _marla_macvid_entry0;
} BCM6300_A0_MARLA_MACVID_ENTRY0r_t;

#define BCM6300_A0_MARLA_MACVID_ENTRY0r_CLR(r) CDK_MEMSET(&((r)._marla_macvid_entry0), 0, sizeof(BCM6300_A0_MARLA_MACVID_ENTRY0r_t))
#define BCM6300_A0_MARLA_MACVID_ENTRY0r_SET(r,i,d) (r).marla_macvid_entry0[i] = d
#define BCM6300_A0_MARLA_MACVID_ENTRY0r_GET(r,i) (r).marla_macvid_entry0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_MARLA_MACVID_ENTRY0r_ARL_MACADDRf_GET(r,a) cdk_field_get((r).marla_macvid_entry0,0,47,a)
#define BCM6300_A0_MARLA_MACVID_ENTRY0r_ARL_MACADDRf_SET(r,a) cdk_field_set((r).marla_macvid_entry0,0,47,a)
#define BCM6300_A0_MARLA_MACVID_ENTRY0r_VID_Rf_GET(r) ((((r).marla_macvid_entry0[1]) >> 16) & 0xfff)
#define BCM6300_A0_MARLA_MACVID_ENTRY0r_VID_Rf_SET(r,f) (r).marla_macvid_entry0[1]=(((r).marla_macvid_entry0[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM6300_A0_MARLA_MACVID_ENTRY0r_RESERVED_Rf_GET(r) ((((r).marla_macvid_entry0[1]) >> 28) & 0xf)
#define BCM6300_A0_MARLA_MACVID_ENTRY0r_RESERVED_Rf_SET(r,f) (r).marla_macvid_entry0[1]=(((r).marla_macvid_entry0[1] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access MARLA_MACVID_ENTRY0.
 *
 */
#define BCM6300_A0_READ_MARLA_MACVID_ENTRY0r(u,i,r) cdk_robo_reg_read(u,BCM6300_A0_MARLA_MACVID_ENTRY0r+(16*(i)),(r._marla_macvid_entry0),8)
#define BCM6300_A0_WRITE_MARLA_MACVID_ENTRY0r(u,i,r) cdk_robo_reg_write(u,BCM6300_A0_MARLA_MACVID_ENTRY0r+(16*(i)),&(r._marla_macvid_entry0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MARLA_MACVID_ENTRY0r BCM6300_A0_MARLA_MACVID_ENTRY0r
#define MARLA_MACVID_ENTRY0r_SIZE BCM6300_A0_MARLA_MACVID_ENTRY0r_SIZE
typedef BCM6300_A0_MARLA_MACVID_ENTRY0r_t MARLA_MACVID_ENTRY0r_t;
#define MARLA_MACVID_ENTRY0r_CLR BCM6300_A0_MARLA_MACVID_ENTRY0r_CLR
#define MARLA_MACVID_ENTRY0r_SET BCM6300_A0_MARLA_MACVID_ENTRY0r_SET
#define MARLA_MACVID_ENTRY0r_GET BCM6300_A0_MARLA_MACVID_ENTRY0r_GET
#define MARLA_MACVID_ENTRY0r_ARL_MACADDRf_GET BCM6300_A0_MARLA_MACVID_ENTRY0r_ARL_MACADDRf_GET
#define MARLA_MACVID_ENTRY0r_ARL_MACADDRf_SET BCM6300_A0_MARLA_MACVID_ENTRY0r_ARL_MACADDRf_SET
#define MARLA_MACVID_ENTRY0r_VID_Rf_GET BCM6300_A0_MARLA_MACVID_ENTRY0r_VID_Rf_GET
#define MARLA_MACVID_ENTRY0r_VID_Rf_SET BCM6300_A0_MARLA_MACVID_ENTRY0r_VID_Rf_SET
#define MARLA_MACVID_ENTRY0r_RESERVED_Rf_GET BCM6300_A0_MARLA_MACVID_ENTRY0r_RESERVED_Rf_GET
#define MARLA_MACVID_ENTRY0r_RESERVED_Rf_SET BCM6300_A0_MARLA_MACVID_ENTRY0r_RESERVED_Rf_SET
#define READ_MARLA_MACVID_ENTRY0r BCM6300_A0_READ_MARLA_MACVID_ENTRY0r
#define WRITE_MARLA_MACVID_ENTRY0r BCM6300_A0_WRITE_MARLA_MACVID_ENTRY0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_MARLA_MACVID_ENTRY0r'
 ******************************************************************************/

/*******************************************************************************
 * CHIP:  BCM6300_A0
 * REGISTER:  MARLA_DATA_ENTRY0
 * BLOCKS:   SYS
 * DESC:     MARL FWD Entry 0 Register
 * SIZE:     32
 * FIELDS:
 *     FWD_PRT_MAP     Forward Port Map
 *     DA_CTRL             Forwarding Ctrl to also send to IMP
 *     PRIORITY            Priority for MAC based QoS          
 *     FWD_PRT_MAP8   Forward portmap bit for port-8 (IMP port)          
 *     STATIC               Static. MARLA entries shall always be static as no ageing is performed.
 *     VALID                 Valid. Indicates a valid entry
 *     USED                  Used. Indicates a successful lookup from previous read
 *
 ******************************************************************************/
#define BCM6300_A0_MARLA_DATA_ENTRY0r 0x00005008

#define BCM6300_A0_MARLA_DATA_ENTRY0r_SIZE 4

/*
 * This structure should be used to declare and program MARLA_DATA_ENTRY0.
 *
 */
typedef union BCM6300_A0_MARLA_DATA_ENTRY0r_s {
	uint32_t v[1];
	uint32_t marla_data_entry0[1];
	uint32_t _marla_data_entry0;
} BCM6300_A0_MARLA_DATA_ENTRY0r_t;

#define BCM6300_A0_MARLA_DATA_ENTRY0r_CLR(r) (r).marla_data_entry0[0] = 0
#define BCM6300_A0_MARLA_DATA_ENTRY0r_SET(r,d) (r).marla_data_entry0[0] = d
#define BCM6300_A0_MARLA_DATA_ENTRY0r_GET(r) (r).marla_data_entry0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM6300_A0_MARLA_DATA_ENTRY0r_FWD_PRT_MAPf_GET(r) (((r).marla_data_entry0[0]) & 0xff)
#define BCM6300_A0_MARLA_DATA_ENTRY0r_FWD_PRT_MAPf_SET(r,f) (r).marla_data_entry0[0]=(((r).marla_data_entry0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM6300_A0_MARLA_DATA_ENTRY0r_DA_CTRLf_GET(r) ((((r).marla_data_entry0[0]) >> 8) & 0x3)
#define BCM6300_A0_MARLA_DATA_ENTRY0r_DA_CTRLf_SET(r,f) (r).marla_data_entry0[0]=(((r).marla_data_entry0[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM6300_A0_MARLA_DATA_ENTRY0r_PRIORITYf_GET(r) ((((r).marla_data_entry0[0]) >> 10) & 0x7)
#define BCM6300_A0_MARLA_DATA_ENTRY0r_PRIORITYf_SET(r,f) (r).marla_data_entry0[0]=(((r).marla_data_entry0[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM6300_A0_MARLA_DATA_ENTRY0r_FWD_PRT_MAP8f_GET(r) ((((r).marla_data_entry0[0]) >> 13) & 0x1)
#define BCM6300_A0_MARLA_DATA_ENTRY0r_FWD_PRT_MAP8f_SET(r,f) (r).marla_data_entry0[0]=(((r).marla_data_entry0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM6300_A0_MARLA_DATA_ENTRY0r_STATICf_GET(r) ((((r).marla_data_entry0[0]) >> 14) & 0x1)
#define BCM6300_A0_MARLA_DATA_ENTRY0r_STATICf_SET(r,f) (r).marla_data_entry0[0]=(((r).marla_data_entry0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM6300_A0_MARLA_DATA_ENTRY0r_VALIDf_GET(r) ((((r).marla_data_entry0[0]) >> 15) & 0x1)
#define BCM6300_A0_MARLA_DATA_ENTRY0r_VALIDf_SET(r,f) (r).marla_data_entry0[0]=(((r).marla_data_entry0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM6300_A0_MARLA_DATA_ENTRY0r_USEDf_GET(r) ((((r).marla_data_entry0[0]) >> 16) & 0x1)
#define BCM6300_A0_MARLA_DATA_ENTRY0r_USEDf_SET(r,f) (r).marla_data_entry0[0]=(((r).marla_data_entry0[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))

/*
 * These macros can be used to access MARLA_DATA_ENTRY0.
 *
 */
#define BCM6300_A0_READ_MARLA_DATA_ENTRY0r(u,i,r) cdk_robo_reg_read(u,BCM6300_A0_MARLA_DATA_ENTRY0r+(16*(i)),(r._marla_data_entry0),4)
#define BCM6300_A0_WRITE_MARLA_DATA_ENTRY0r(u,i,r) cdk_robo_reg_write(u,BCM6300_A0_MARLA_DATA_ENTRY0r+(16*(i)),&(r._marla_data_entry0),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MARLA_DATA_ENTRY0r BCM6300_A0_MARLA_DATA_ENTRY0r
#define MARLA_DATA_ENTRY0r_SIZE BCM6300_A0_MARLA_DATA_ENTRY0r_SIZE
typedef BCM6300_A0_MARLA_DATA_ENTRY0r_t MARLA_DATA_ENTRY0r_t;
#define MARLA_DATA_ENTRY0r_CLR BCM6300_A0_MARLA_DATA_ENTRY0r_CLR
#define MARLA_DATA_ENTRY0r_SET BCM6300_A0_MARLA_DATA_ENTRY0r_SET
#define MARLA_DATA_ENTRY0r_GET BCM6300_A0_MARLA_DATA_ENTRY0r_GET
#define MARLA_DATA_ENTRY0r_FWD_PRT_MAPf_GET BCM6300_A0_MARLA_DATA_ENTRY0r_FWD_PRT_MAPf_GET
#define MARLA_DATA_ENTRY0r_FWD_PRT_MAPf_SET BCM6300_A0_MARLA_DATA_ENTRY0r_FWD_PRT_MAPf_SET
#define MARLA_DATA_ENTRY0r_DA_CTRLf_GET BCM6300_A0_MARLA_DATA_ENTRY0r_DA_CTRLf_GET
#define MARLA_DATA_ENTRY0r_DA_CTRLf_SET BCM6300_A0_MARLA_DATA_ENTRY0r_DA_CTRLf_SET
#define MARLA_DATA_ENTRY0r_PRIORITYf_GET BCM6300_A0_MARLA_DATA_ENTRY0r_PRIORITYf_GET
#define MARLA_DATA_ENTRY0r_PRIORITYf_SET BCM6300_A0_MARLA_DATA_ENTRY0r_PRIORITYf_SET
#define MARLA_DATA_ENTRY0r_FWD_PRT_MAP8f_GET BCM6300_A0_MARLA_DATA_ENTRY0r_FWD_PRT_MAP8f_GET
#define MARLA_DATA_ENTRY0r_FWD_PRT_MAP8f_SET BCM6300_A0_MARLA_DATA_ENTRY0r_FWD_PRT_MAP8f_SET
#define MARLA_DATA_ENTRY0r_STATICf_GET BCM6300_A0_MARLA_DATA_ENTRY0r_STATICf_GET
#define MARLA_DATA_ENTRY0r_STATICf_SET BCM6300_A0_MARLA_DATA_ENTRY0r_STATICf_SET
#define MARLA_DATA_ENTRY0r_VALIDf_GET BCM6300_A0_MARLA_DATA_ENTRY0r_VALIDf_GET
#define MARLA_DATA_ENTRY0r_VALIDf_SET BCM6300_A0_MARLA_DATA_ENTRY0r_VALIDf_SET
#define MARLA_DATA_ENTRY0r_USEDf_GET BCM6300_A0_MARLA_DATA_ENTRY0r_USEDf_GET
#define MARLA_DATA_ENTRY0r_USEDf_SET BCM6300_A0_MARLA_DATA_ENTRY0r_USEDf_SET
#define READ_MARLA_DATA_ENTRY0r BCM6300_A0_READ_MARLA_DATA_ENTRY0r
#define WRITE_MARLA_DATA_ENTRY0r BCM6300_A0_WRITE_MARLA_DATA_ENTRY0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM6300_A0_MARLA_DATA_ENTRY0r'
 ******************************************************************************/



#define NUM_EGRESS_QUEUES       4


#endif /* CDK_CONFIG_CHIP_DEFS_USE_DSYMS */
#endif /* __BCM6300_A0_DEFS_H__ */
