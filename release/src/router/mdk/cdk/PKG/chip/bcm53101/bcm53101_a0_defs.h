#ifndef __BCM53101_A0_DEFS_H__
#define __BCM53101_A0_DEFS_H__
/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from the registers file.
 * Edits to this file will be lost when it is regenerated.
 *
 * $Copyright: Copyright 2013 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 *
 * Definition file for the BCM53101_A0.
 * This file provides all basic definitions required to program the BCM53101_A0.
 *
 ******************************************************************************/

#include <cdk/cdk_string.h>
#include <cdk/cdk_field.h>
#include <cdk/arch/robo_reg.h>
#include <cdk/arch/robo_mem.h>

/*******************************************************************************
 *
 *                    CHIP DEFINITIONS BEGIN HERE
 *
 ******************************************************************************/



/* CPIC/IMP port */
#define BCM53101_A0_CPIC_PORT           8

/* Additional block types */
#define BCM53101_A0_BLKTYPE_CPIC        0
#define BCM53101_A0_BLKTYPE_EPIC        1
#define BCM53101_A0_BLKTYPE_EXP         2
#define BCM53101_A0_BLKTYPE_SPI         3
#define BCM53101_A0_BLKTYPE_SYS         4


#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPIC_PORT                       BCM53101_A0_CPIC_PORT

#define BLKTYPE_CPIC                    BCM53101_A0_BLKTYPE_CPIC
#define BLKTYPE_EPIC                    BCM53101_A0_BLKTYPE_EPIC
#define BLKTYPE_EXP                     BCM53101_A0_BLKTYPE_EXP
#define BLKTYPE_SPI                     BCM53101_A0_BLKTYPE_SPI
#define BLKTYPE_SYS                     BCM53101_A0_BLKTYPE_SYS


#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */



#if CDK_CONFIG_CHIP_DEFS_USE_DSYMS == 1
/* Use DSYM all_defs.h instead of static chip definitions */
#include "all_defs.h"
#else

/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  ANADV
 * BLOCKS:   EPIC0
 * DESC:     Auto-Negotiation Advertisement Register
 * SIZE:     16
 * FIELDS:
 *     ADV_SEL_FIELD    Indicates 802.3
 *     ADV_B10T_FDX     1 = Advertise 10BASE-T full-duplex full-duplex.0 = Do not advertise 10BASE-T full-duplex.EOT             },            ADV_B10T => {                MAXBIT      => 5,   MINBIT => 5,    RESETVAL => 0x1,                DESC        => <<'EOT'1 = Advertise 10BASE-T.
 *     ADV_B100X        1 = Advertise 100BASE-X.
 *     ADV_B100X_FDX    1 = Advertise 100BASE-X full-duplex full-duplex.0 = Do not advertise 100BASE-X full-duplex.
 *     ADV_B100T4       1 = Advertise T4 capability.0 = Do not advertise T4 capability.
 *     ADV_PAUSE_CAP    1 = pause operation for full-duplex.
 *     RESV_TECH        
 *     REMOTE_FAULT     1 = Transmit remote fault.
 *     RESERVED         Reserved
 *     NEXT_PAGE        1 = next page ability is enable.0 = next page ability is disable.
 *
 ******************************************************************************/
#define BCM53101_A0_ANADVr 0x00001008

#define BCM53101_A0_ANADVr_SIZE 2

/*
 * This structure should be used to declare and program ANADV.
 *
 */
typedef union BCM53101_A0_ANADVr_s {
	uint32_t v[1];
	uint32_t anadv[1];
	uint32_t _anadv;
} BCM53101_A0_ANADVr_t;

#define BCM53101_A0_ANADVr_CLR(r) (r).anadv[0] = 0
#define BCM53101_A0_ANADVr_SET(r,d) (r).anadv[0] = d
#define BCM53101_A0_ANADVr_GET(r) (r).anadv[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_ANADVr_ADV_SEL_FIELDf_GET(r) (((r).anadv[0]) & 0x1f)
#define BCM53101_A0_ANADVr_ADV_SEL_FIELDf_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53101_A0_ANADVr_ADV_B10T_FDXf_GET(r) ((((r).anadv[0]) >> 6) & 0x1)
#define BCM53101_A0_ANADVr_ADV_B10T_FDXf_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_ANADVr_ADV_B100Xf_GET(r) ((((r).anadv[0]) >> 7) & 0x1)
#define BCM53101_A0_ANADVr_ADV_B100Xf_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53101_A0_ANADVr_ADV_B100X_FDXf_GET(r) ((((r).anadv[0]) >> 8) & 0x1)
#define BCM53101_A0_ANADVr_ADV_B100X_FDXf_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53101_A0_ANADVr_ADV_B100T4f_GET(r) ((((r).anadv[0]) >> 9) & 0x1)
#define BCM53101_A0_ANADVr_ADV_B100T4f_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53101_A0_ANADVr_ADV_PAUSE_CAPf_GET(r) ((((r).anadv[0]) >> 10) & 0x1)
#define BCM53101_A0_ANADVr_ADV_PAUSE_CAPf_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53101_A0_ANADVr_RESV_TECHf_GET(r) ((((r).anadv[0]) >> 11) & 0x3)
#define BCM53101_A0_ANADVr_RESV_TECHf_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11))
#define BCM53101_A0_ANADVr_REMOTE_FAULTf_GET(r) ((((r).anadv[0]) >> 13) & 0x1)
#define BCM53101_A0_ANADVr_REMOTE_FAULTf_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53101_A0_ANADVr_RESERVEDf_GET(r) ((((r).anadv[0]) >> 14) & 0x1)
#define BCM53101_A0_ANADVr_RESERVEDf_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_ANADVr_NEXT_PAGEf_GET(r) ((((r).anadv[0]) >> 15) & 0x1)
#define BCM53101_A0_ANADVr_NEXT_PAGEf_SET(r,f) (r).anadv[0]=(((r).anadv[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access ANADV.
 *
 */
#define BCM53101_A0_READ_ANADVr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_ANADVr,(r._anadv),2)
#define BCM53101_A0_WRITE_ANADVr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_ANADVr,&(r._anadv),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ANADVr BCM53101_A0_ANADVr
#define ANADVr_SIZE BCM53101_A0_ANADVr_SIZE
typedef BCM53101_A0_ANADVr_t ANADVr_t;
#define ANADVr_CLR BCM53101_A0_ANADVr_CLR
#define ANADVr_SET BCM53101_A0_ANADVr_SET
#define ANADVr_GET BCM53101_A0_ANADVr_GET
#define ANADVr_ADV_SEL_FIELDf_GET BCM53101_A0_ANADVr_ADV_SEL_FIELDf_GET
#define ANADVr_ADV_SEL_FIELDf_SET BCM53101_A0_ANADVr_ADV_SEL_FIELDf_SET
#define ANADVr_ADV_B10T_FDXf_GET BCM53101_A0_ANADVr_ADV_B10T_FDXf_GET
#define ANADVr_ADV_B10T_FDXf_SET BCM53101_A0_ANADVr_ADV_B10T_FDXf_SET
#define ANADVr_ADV_B100Xf_GET BCM53101_A0_ANADVr_ADV_B100Xf_GET
#define ANADVr_ADV_B100Xf_SET BCM53101_A0_ANADVr_ADV_B100Xf_SET
#define ANADVr_ADV_B100X_FDXf_GET BCM53101_A0_ANADVr_ADV_B100X_FDXf_GET
#define ANADVr_ADV_B100X_FDXf_SET BCM53101_A0_ANADVr_ADV_B100X_FDXf_SET
#define ANADVr_ADV_B100T4f_GET BCM53101_A0_ANADVr_ADV_B100T4f_GET
#define ANADVr_ADV_B100T4f_SET BCM53101_A0_ANADVr_ADV_B100T4f_SET
#define ANADVr_ADV_PAUSE_CAPf_GET BCM53101_A0_ANADVr_ADV_PAUSE_CAPf_GET
#define ANADVr_ADV_PAUSE_CAPf_SET BCM53101_A0_ANADVr_ADV_PAUSE_CAPf_SET
#define ANADVr_RESV_TECHf_GET BCM53101_A0_ANADVr_RESV_TECHf_GET
#define ANADVr_RESV_TECHf_SET BCM53101_A0_ANADVr_RESV_TECHf_SET
#define ANADVr_REMOTE_FAULTf_GET BCM53101_A0_ANADVr_REMOTE_FAULTf_GET
#define ANADVr_REMOTE_FAULTf_SET BCM53101_A0_ANADVr_REMOTE_FAULTf_SET
#define ANADVr_RESERVEDf_GET BCM53101_A0_ANADVr_RESERVEDf_GET
#define ANADVr_RESERVEDf_SET BCM53101_A0_ANADVr_RESERVEDf_SET
#define ANADVr_NEXT_PAGEf_GET BCM53101_A0_ANADVr_NEXT_PAGEf_GET
#define ANADVr_NEXT_PAGEf_SET BCM53101_A0_ANADVr_NEXT_PAGEf_SET
#define READ_ANADVr BCM53101_A0_READ_ANADVr
#define WRITE_ANADVr BCM53101_A0_WRITE_ANADVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_ANADVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  ANADV_EXT_P5
 * BLOCKS:   SYS
 * DESC:     Auto-Negotiation Advertisement Register
 * SIZE:     16
 * FIELDS:
 *     ADV_SEL_FIELD    Indicates 802.3
 *     ADV_B10T         1 = Advertise 10BASE-T.
 *     ADV_B10T_FDX     1 = Advertise 10BASE-T full-duplex full-duplex.0 = Do not advertise 10BASE-T full-duplex.
 *     ADV_B100X        1 = Advertise 100BASE-X. 
 *     ADV_B100X_FDX    1 = Advertise 100BASE-X full-duplex full-duplex.0 = Do not advertise 100BASE-X full-duplex.
 *     ADV_B100T4       1 = Advertise T4 capability.0 = Do not advertise T4 capability.
 *     ADV_PAUSE_CAP    1 = pause operation for full-duplex.
 *     RESV_TECH        
 *     REMOTE_FAULT     1 = Transmit remote fault.
 *     RESERVED         Reserved
 *     NEXT_PAGE        1 = next page ability is enable.0 = next page ability is disable.
 *
 ******************************************************************************/
#define BCM53101_A0_ANADV_EXT_P5r 0x00008508

#define BCM53101_A0_ANADV_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program ANADV_EXT_P5.
 *
 */
typedef union BCM53101_A0_ANADV_EXT_P5r_s {
	uint32_t v[1];
	uint32_t anadv_ext_p5[1];
	uint32_t _anadv_ext_p5;
} BCM53101_A0_ANADV_EXT_P5r_t;

#define BCM53101_A0_ANADV_EXT_P5r_CLR(r) (r).anadv_ext_p5[0] = 0
#define BCM53101_A0_ANADV_EXT_P5r_SET(r,d) (r).anadv_ext_p5[0] = d
#define BCM53101_A0_ANADV_EXT_P5r_GET(r) (r).anadv_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_ANADV_EXT_P5r_ADV_SEL_FIELDf_GET(r) (((r).anadv_ext_p5[0]) & 0x1f)
#define BCM53101_A0_ANADV_EXT_P5r_ADV_SEL_FIELDf_SET(r,f) (r).anadv_ext_p5[0]=(((r).anadv_ext_p5[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53101_A0_ANADV_EXT_P5r_ADV_B10Tf_GET(r) ((((r).anadv_ext_p5[0]) >> 5) & 0x1)
#define BCM53101_A0_ANADV_EXT_P5r_ADV_B10Tf_SET(r,f) (r).anadv_ext_p5[0]=(((r).anadv_ext_p5[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_ANADV_EXT_P5r_ADV_B10T_FDXf_GET(r) ((((r).anadv_ext_p5[0]) >> 6) & 0x1)
#define BCM53101_A0_ANADV_EXT_P5r_ADV_B10T_FDXf_SET(r,f) (r).anadv_ext_p5[0]=(((r).anadv_ext_p5[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_ANADV_EXT_P5r_ADV_B100Xf_GET(r) ((((r).anadv_ext_p5[0]) >> 7) & 0x1)
#define BCM53101_A0_ANADV_EXT_P5r_ADV_B100Xf_SET(r,f) (r).anadv_ext_p5[0]=(((r).anadv_ext_p5[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53101_A0_ANADV_EXT_P5r_ADV_B100X_FDXf_GET(r) ((((r).anadv_ext_p5[0]) >> 8) & 0x1)
#define BCM53101_A0_ANADV_EXT_P5r_ADV_B100X_FDXf_SET(r,f) (r).anadv_ext_p5[0]=(((r).anadv_ext_p5[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53101_A0_ANADV_EXT_P5r_ADV_B100T4f_GET(r) ((((r).anadv_ext_p5[0]) >> 9) & 0x1)
#define BCM53101_A0_ANADV_EXT_P5r_ADV_B100T4f_SET(r,f) (r).anadv_ext_p5[0]=(((r).anadv_ext_p5[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53101_A0_ANADV_EXT_P5r_ADV_PAUSE_CAPf_GET(r) ((((r).anadv_ext_p5[0]) >> 10) & 0x1)
#define BCM53101_A0_ANADV_EXT_P5r_ADV_PAUSE_CAPf_SET(r,f) (r).anadv_ext_p5[0]=(((r).anadv_ext_p5[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53101_A0_ANADV_EXT_P5r_RESV_TECHf_GET(r) ((((r).anadv_ext_p5[0]) >> 11) & 0x3)
#define BCM53101_A0_ANADV_EXT_P5r_RESV_TECHf_SET(r,f) (r).anadv_ext_p5[0]=(((r).anadv_ext_p5[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11))
#define BCM53101_A0_ANADV_EXT_P5r_REMOTE_FAULTf_GET(r) ((((r).anadv_ext_p5[0]) >> 13) & 0x1)
#define BCM53101_A0_ANADV_EXT_P5r_REMOTE_FAULTf_SET(r,f) (r).anadv_ext_p5[0]=(((r).anadv_ext_p5[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53101_A0_ANADV_EXT_P5r_RESERVEDf_GET(r) ((((r).anadv_ext_p5[0]) >> 14) & 0x1)
#define BCM53101_A0_ANADV_EXT_P5r_RESERVEDf_SET(r,f) (r).anadv_ext_p5[0]=(((r).anadv_ext_p5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_ANADV_EXT_P5r_NEXT_PAGEf_GET(r) ((((r).anadv_ext_p5[0]) >> 15) & 0x1)
#define BCM53101_A0_ANADV_EXT_P5r_NEXT_PAGEf_SET(r,f) (r).anadv_ext_p5[0]=(((r).anadv_ext_p5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access ANADV_EXT_P5.
 *
 */
#define BCM53101_A0_READ_ANADV_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53101_A0_ANADV_EXT_P5r,(r._anadv_ext_p5),2)
#define BCM53101_A0_WRITE_ANADV_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53101_A0_ANADV_EXT_P5r,&(r._anadv_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ANADV_EXT_P5r BCM53101_A0_ANADV_EXT_P5r
#define ANADV_EXT_P5r_SIZE BCM53101_A0_ANADV_EXT_P5r_SIZE
typedef BCM53101_A0_ANADV_EXT_P5r_t ANADV_EXT_P5r_t;
#define ANADV_EXT_P5r_CLR BCM53101_A0_ANADV_EXT_P5r_CLR
#define ANADV_EXT_P5r_SET BCM53101_A0_ANADV_EXT_P5r_SET
#define ANADV_EXT_P5r_GET BCM53101_A0_ANADV_EXT_P5r_GET
#define ANADV_EXT_P5r_ADV_SEL_FIELDf_GET BCM53101_A0_ANADV_EXT_P5r_ADV_SEL_FIELDf_GET
#define ANADV_EXT_P5r_ADV_SEL_FIELDf_SET BCM53101_A0_ANADV_EXT_P5r_ADV_SEL_FIELDf_SET
#define ANADV_EXT_P5r_ADV_B10Tf_GET BCM53101_A0_ANADV_EXT_P5r_ADV_B10Tf_GET
#define ANADV_EXT_P5r_ADV_B10Tf_SET BCM53101_A0_ANADV_EXT_P5r_ADV_B10Tf_SET
#define ANADV_EXT_P5r_ADV_B10T_FDXf_GET BCM53101_A0_ANADV_EXT_P5r_ADV_B10T_FDXf_GET
#define ANADV_EXT_P5r_ADV_B10T_FDXf_SET BCM53101_A0_ANADV_EXT_P5r_ADV_B10T_FDXf_SET
#define ANADV_EXT_P5r_ADV_B100Xf_GET BCM53101_A0_ANADV_EXT_P5r_ADV_B100Xf_GET
#define ANADV_EXT_P5r_ADV_B100Xf_SET BCM53101_A0_ANADV_EXT_P5r_ADV_B100Xf_SET
#define ANADV_EXT_P5r_ADV_B100X_FDXf_GET BCM53101_A0_ANADV_EXT_P5r_ADV_B100X_FDXf_GET
#define ANADV_EXT_P5r_ADV_B100X_FDXf_SET BCM53101_A0_ANADV_EXT_P5r_ADV_B100X_FDXf_SET
#define ANADV_EXT_P5r_ADV_B100T4f_GET BCM53101_A0_ANADV_EXT_P5r_ADV_B100T4f_GET
#define ANADV_EXT_P5r_ADV_B100T4f_SET BCM53101_A0_ANADV_EXT_P5r_ADV_B100T4f_SET
#define ANADV_EXT_P5r_ADV_PAUSE_CAPf_GET BCM53101_A0_ANADV_EXT_P5r_ADV_PAUSE_CAPf_GET
#define ANADV_EXT_P5r_ADV_PAUSE_CAPf_SET BCM53101_A0_ANADV_EXT_P5r_ADV_PAUSE_CAPf_SET
#define ANADV_EXT_P5r_RESV_TECHf_GET BCM53101_A0_ANADV_EXT_P5r_RESV_TECHf_GET
#define ANADV_EXT_P5r_RESV_TECHf_SET BCM53101_A0_ANADV_EXT_P5r_RESV_TECHf_SET
#define ANADV_EXT_P5r_REMOTE_FAULTf_GET BCM53101_A0_ANADV_EXT_P5r_REMOTE_FAULTf_GET
#define ANADV_EXT_P5r_REMOTE_FAULTf_SET BCM53101_A0_ANADV_EXT_P5r_REMOTE_FAULTf_SET
#define ANADV_EXT_P5r_RESERVEDf_GET BCM53101_A0_ANADV_EXT_P5r_RESERVEDf_GET
#define ANADV_EXT_P5r_RESERVEDf_SET BCM53101_A0_ANADV_EXT_P5r_RESERVEDf_SET
#define ANADV_EXT_P5r_NEXT_PAGEf_GET BCM53101_A0_ANADV_EXT_P5r_NEXT_PAGEf_GET
#define ANADV_EXT_P5r_NEXT_PAGEf_SET BCM53101_A0_ANADV_EXT_P5r_NEXT_PAGEf_SET
#define READ_ANADV_EXT_P5r BCM53101_A0_READ_ANADV_EXT_P5r
#define WRITE_ANADV_EXT_P5r BCM53101_A0_WRITE_ANADV_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_ANADV_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  ANEXP
 * BLOCKS:   EPIC0
 * DESC:     Auto-Negotiation Expansion Register
 * SIZE:     16
 * FIELDS:
 *     LP_AN_ABLE       1 = Link partner has auto-negotiation capability.0 = Link partner does not have auto-negotiation capability.
 *     PAGE_RECEIVED    1 = New page has been received.0 = New page has not been received.
 *     NEXT_PAGE_ABLE   1 = Next Page able.
 *     LP_NEXT_PAGE_ABLE 1 = Link partner has Next Page capability.0 = Link partner does not have Next Page capability.
 *     PD_FAULT         1 = Parallel detection fault.0 = No parallel detection fault.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_ANEXPr 0x0000100c

#define BCM53101_A0_ANEXPr_SIZE 2

/*
 * This structure should be used to declare and program ANEXP.
 *
 */
typedef union BCM53101_A0_ANEXPr_s {
	uint32_t v[1];
	uint32_t anexp[1];
	uint32_t _anexp;
} BCM53101_A0_ANEXPr_t;

#define BCM53101_A0_ANEXPr_CLR(r) (r).anexp[0] = 0
#define BCM53101_A0_ANEXPr_SET(r,d) (r).anexp[0] = d
#define BCM53101_A0_ANEXPr_GET(r) (r).anexp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_ANEXPr_LP_AN_ABLEf_GET(r) (((r).anexp[0]) & 0x1)
#define BCM53101_A0_ANEXPr_LP_AN_ABLEf_SET(r,f) (r).anexp[0]=(((r).anexp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_ANEXPr_PAGE_RECEIVEDf_GET(r) ((((r).anexp[0]) >> 1) & 0x1)
#define BCM53101_A0_ANEXPr_PAGE_RECEIVEDf_SET(r,f) (r).anexp[0]=(((r).anexp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_ANEXPr_NEXT_PAGE_ABLEf_GET(r) ((((r).anexp[0]) >> 2) & 0x1)
#define BCM53101_A0_ANEXPr_NEXT_PAGE_ABLEf_SET(r,f) (r).anexp[0]=(((r).anexp[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_ANEXPr_LP_NEXT_PAGE_ABLEf_GET(r) ((((r).anexp[0]) >> 3) & 0x1)
#define BCM53101_A0_ANEXPr_LP_NEXT_PAGE_ABLEf_SET(r,f) (r).anexp[0]=(((r).anexp[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_ANEXPr_PD_FAULTf_GET(r) ((((r).anexp[0]) >> 4) & 0x1)
#define BCM53101_A0_ANEXPr_PD_FAULTf_SET(r,f) (r).anexp[0]=(((r).anexp[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_ANEXPr_RESERVEDf_GET(r) ((((r).anexp[0]) >> 5) & 0x7ff)
#define BCM53101_A0_ANEXPr_RESERVEDf_SET(r,f) (r).anexp[0]=(((r).anexp[0] & ~((uint32_t)0x7ff << 5)) | ((((uint32_t)f) & 0x7ff) << 5))

/*
 * These macros can be used to access ANEXP.
 *
 */
#define BCM53101_A0_READ_ANEXPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_ANEXPr,(r._anexp),2)
#define BCM53101_A0_WRITE_ANEXPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_ANEXPr,&(r._anexp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ANEXPr BCM53101_A0_ANEXPr
#define ANEXPr_SIZE BCM53101_A0_ANEXPr_SIZE
typedef BCM53101_A0_ANEXPr_t ANEXPr_t;
#define ANEXPr_CLR BCM53101_A0_ANEXPr_CLR
#define ANEXPr_SET BCM53101_A0_ANEXPr_SET
#define ANEXPr_GET BCM53101_A0_ANEXPr_GET
#define ANEXPr_LP_AN_ABLEf_GET BCM53101_A0_ANEXPr_LP_AN_ABLEf_GET
#define ANEXPr_LP_AN_ABLEf_SET BCM53101_A0_ANEXPr_LP_AN_ABLEf_SET
#define ANEXPr_PAGE_RECEIVEDf_GET BCM53101_A0_ANEXPr_PAGE_RECEIVEDf_GET
#define ANEXPr_PAGE_RECEIVEDf_SET BCM53101_A0_ANEXPr_PAGE_RECEIVEDf_SET
#define ANEXPr_NEXT_PAGE_ABLEf_GET BCM53101_A0_ANEXPr_NEXT_PAGE_ABLEf_GET
#define ANEXPr_NEXT_PAGE_ABLEf_SET BCM53101_A0_ANEXPr_NEXT_PAGE_ABLEf_SET
#define ANEXPr_LP_NEXT_PAGE_ABLEf_GET BCM53101_A0_ANEXPr_LP_NEXT_PAGE_ABLEf_GET
#define ANEXPr_LP_NEXT_PAGE_ABLEf_SET BCM53101_A0_ANEXPr_LP_NEXT_PAGE_ABLEf_SET
#define ANEXPr_PD_FAULTf_GET BCM53101_A0_ANEXPr_PD_FAULTf_GET
#define ANEXPr_PD_FAULTf_SET BCM53101_A0_ANEXPr_PD_FAULTf_SET
#define ANEXPr_RESERVEDf_GET BCM53101_A0_ANEXPr_RESERVEDf_GET
#define ANEXPr_RESERVEDf_SET BCM53101_A0_ANEXPr_RESERVEDf_SET
#define READ_ANEXPr BCM53101_A0_READ_ANEXPr
#define WRITE_ANEXPr BCM53101_A0_WRITE_ANEXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_ANEXPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  ANEXP_EXT_P5
 * BLOCKS:   SYS
 * DESC:     Auto-Negotiation Expansion Register
 * SIZE:     16
 * FIELDS:
 *     LP_AN_ABLE       1 = Link partner has auto-negotiation capability.0 = Link partner does not have auto-negotiation capability.
 *     PAGE_RECEIVED    1 = New page has been received.0 = New page has not been received.
 *     NEXT_PAGE_ABLE   1 = Next Page able.
 *     LP_NEXT_PAGE_ABLE 1 = Link partner has Next Page capability.0 = Link partner does not have Next Page capability.
 *     PD_FAULT         1 = Parallel detection fault. 0 = No parallel detection fault.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_ANEXP_EXT_P5r 0x0000850c

#define BCM53101_A0_ANEXP_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program ANEXP_EXT_P5.
 *
 */
typedef union BCM53101_A0_ANEXP_EXT_P5r_s {
	uint32_t v[1];
	uint32_t anexp_ext_p5[1];
	uint32_t _anexp_ext_p5;
} BCM53101_A0_ANEXP_EXT_P5r_t;

#define BCM53101_A0_ANEXP_EXT_P5r_CLR(r) (r).anexp_ext_p5[0] = 0
#define BCM53101_A0_ANEXP_EXT_P5r_SET(r,d) (r).anexp_ext_p5[0] = d
#define BCM53101_A0_ANEXP_EXT_P5r_GET(r) (r).anexp_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_ANEXP_EXT_P5r_LP_AN_ABLEf_GET(r) (((r).anexp_ext_p5[0]) & 0x1)
#define BCM53101_A0_ANEXP_EXT_P5r_LP_AN_ABLEf_SET(r,f) (r).anexp_ext_p5[0]=(((r).anexp_ext_p5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_ANEXP_EXT_P5r_PAGE_RECEIVEDf_GET(r) ((((r).anexp_ext_p5[0]) >> 1) & 0x1)
#define BCM53101_A0_ANEXP_EXT_P5r_PAGE_RECEIVEDf_SET(r,f) (r).anexp_ext_p5[0]=(((r).anexp_ext_p5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_ANEXP_EXT_P5r_NEXT_PAGE_ABLEf_GET(r) ((((r).anexp_ext_p5[0]) >> 2) & 0x1)
#define BCM53101_A0_ANEXP_EXT_P5r_NEXT_PAGE_ABLEf_SET(r,f) (r).anexp_ext_p5[0]=(((r).anexp_ext_p5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_ANEXP_EXT_P5r_LP_NEXT_PAGE_ABLEf_GET(r) ((((r).anexp_ext_p5[0]) >> 3) & 0x1)
#define BCM53101_A0_ANEXP_EXT_P5r_LP_NEXT_PAGE_ABLEf_SET(r,f) (r).anexp_ext_p5[0]=(((r).anexp_ext_p5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_ANEXP_EXT_P5r_PD_FAULTf_GET(r) ((((r).anexp_ext_p5[0]) >> 4) & 0x1)
#define BCM53101_A0_ANEXP_EXT_P5r_PD_FAULTf_SET(r,f) (r).anexp_ext_p5[0]=(((r).anexp_ext_p5[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_ANEXP_EXT_P5r_RESERVEDf_GET(r) ((((r).anexp_ext_p5[0]) >> 5) & 0x7ff)
#define BCM53101_A0_ANEXP_EXT_P5r_RESERVEDf_SET(r,f) (r).anexp_ext_p5[0]=(((r).anexp_ext_p5[0] & ~((uint32_t)0x7ff << 5)) | ((((uint32_t)f) & 0x7ff) << 5))

/*
 * These macros can be used to access ANEXP_EXT_P5.
 *
 */
#define BCM53101_A0_READ_ANEXP_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53101_A0_ANEXP_EXT_P5r,(r._anexp_ext_p5),2)
#define BCM53101_A0_WRITE_ANEXP_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53101_A0_ANEXP_EXT_P5r,&(r._anexp_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ANEXP_EXT_P5r BCM53101_A0_ANEXP_EXT_P5r
#define ANEXP_EXT_P5r_SIZE BCM53101_A0_ANEXP_EXT_P5r_SIZE
typedef BCM53101_A0_ANEXP_EXT_P5r_t ANEXP_EXT_P5r_t;
#define ANEXP_EXT_P5r_CLR BCM53101_A0_ANEXP_EXT_P5r_CLR
#define ANEXP_EXT_P5r_SET BCM53101_A0_ANEXP_EXT_P5r_SET
#define ANEXP_EXT_P5r_GET BCM53101_A0_ANEXP_EXT_P5r_GET
#define ANEXP_EXT_P5r_LP_AN_ABLEf_GET BCM53101_A0_ANEXP_EXT_P5r_LP_AN_ABLEf_GET
#define ANEXP_EXT_P5r_LP_AN_ABLEf_SET BCM53101_A0_ANEXP_EXT_P5r_LP_AN_ABLEf_SET
#define ANEXP_EXT_P5r_PAGE_RECEIVEDf_GET BCM53101_A0_ANEXP_EXT_P5r_PAGE_RECEIVEDf_GET
#define ANEXP_EXT_P5r_PAGE_RECEIVEDf_SET BCM53101_A0_ANEXP_EXT_P5r_PAGE_RECEIVEDf_SET
#define ANEXP_EXT_P5r_NEXT_PAGE_ABLEf_GET BCM53101_A0_ANEXP_EXT_P5r_NEXT_PAGE_ABLEf_GET
#define ANEXP_EXT_P5r_NEXT_PAGE_ABLEf_SET BCM53101_A0_ANEXP_EXT_P5r_NEXT_PAGE_ABLEf_SET
#define ANEXP_EXT_P5r_LP_NEXT_PAGE_ABLEf_GET BCM53101_A0_ANEXP_EXT_P5r_LP_NEXT_PAGE_ABLEf_GET
#define ANEXP_EXT_P5r_LP_NEXT_PAGE_ABLEf_SET BCM53101_A0_ANEXP_EXT_P5r_LP_NEXT_PAGE_ABLEf_SET
#define ANEXP_EXT_P5r_PD_FAULTf_GET BCM53101_A0_ANEXP_EXT_P5r_PD_FAULTf_GET
#define ANEXP_EXT_P5r_PD_FAULTf_SET BCM53101_A0_ANEXP_EXT_P5r_PD_FAULTf_SET
#define ANEXP_EXT_P5r_RESERVEDf_GET BCM53101_A0_ANEXP_EXT_P5r_RESERVEDf_GET
#define ANEXP_EXT_P5r_RESERVEDf_SET BCM53101_A0_ANEXP_EXT_P5r_RESERVEDf_SET
#define READ_ANEXP_EXT_P5r BCM53101_A0_READ_ANEXP_EXT_P5r
#define WRITE_ANEXP_EXT_P5r BCM53101_A0_WRITE_ANEXP_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_ANEXP_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  ANLPA
 * BLOCKS:   EPIC0
 * DESC:     Auto-Negotiation Link Partner (LP) Ability Register
 * SIZE:     16
 * FIELDS:
 *     LP_ADV_SEL_FIELD Link partner selector field.
 *     LP_ADV_B10T      Link partner has 10BASE-T capability.
 *     LP_ADV_B10T_FDX  Link partner has 10BASE-T FDX capability.
 *     LP_ADV_B100X     Link partner has 100BASE-X capability.
 *     LP_ADV_B100X_FDX Link partner has 100BASE-X FDX capability.
 *     LP_ADV_B100T4    Link partner has 100BASE-T4 capability.
 *     LP_ADV_PAUSE     Link partner has pause capability.
 *     RESV_TECH        
 *     LP_REMOTE_FAULT  Link partner remote fault indicator.
 *     LP_ACK           Link partner acknowledge bit.
 *     LP_NEXT_PAGE     Link partner Next Page bit.
 *
 ******************************************************************************/
#define BCM53101_A0_ANLPAr 0x0000100a

#define BCM53101_A0_ANLPAr_SIZE 2

/*
 * This structure should be used to declare and program ANLPA.
 *
 */
typedef union BCM53101_A0_ANLPAr_s {
	uint32_t v[1];
	uint32_t anlpa[1];
	uint32_t _anlpa;
} BCM53101_A0_ANLPAr_t;

#define BCM53101_A0_ANLPAr_CLR(r) (r).anlpa[0] = 0
#define BCM53101_A0_ANLPAr_SET(r,d) (r).anlpa[0] = d
#define BCM53101_A0_ANLPAr_GET(r) (r).anlpa[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_ANLPAr_LP_ADV_SEL_FIELDf_GET(r) (((r).anlpa[0]) & 0x1f)
#define BCM53101_A0_ANLPAr_LP_ADV_SEL_FIELDf_SET(r,f) (r).anlpa[0]=(((r).anlpa[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53101_A0_ANLPAr_LP_ADV_B10Tf_GET(r) ((((r).anlpa[0]) >> 5) & 0x1)
#define BCM53101_A0_ANLPAr_LP_ADV_B10Tf_SET(r,f) (r).anlpa[0]=(((r).anlpa[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_ANLPAr_LP_ADV_B10T_FDXf_GET(r) ((((r).anlpa[0]) >> 6) & 0x1)
#define BCM53101_A0_ANLPAr_LP_ADV_B10T_FDXf_SET(r,f) (r).anlpa[0]=(((r).anlpa[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_ANLPAr_LP_ADV_B100Xf_GET(r) ((((r).anlpa[0]) >> 7) & 0x1)
#define BCM53101_A0_ANLPAr_LP_ADV_B100Xf_SET(r,f) (r).anlpa[0]=(((r).anlpa[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53101_A0_ANLPAr_LP_ADV_B100X_FDXf_GET(r) ((((r).anlpa[0]) >> 8) & 0x1)
#define BCM53101_A0_ANLPAr_LP_ADV_B100X_FDXf_SET(r,f) (r).anlpa[0]=(((r).anlpa[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53101_A0_ANLPAr_LP_ADV_B100T4f_GET(r) ((((r).anlpa[0]) >> 9) & 0x1)
#define BCM53101_A0_ANLPAr_LP_ADV_B100T4f_SET(r,f) (r).anlpa[0]=(((r).anlpa[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53101_A0_ANLPAr_LP_ADV_PAUSEf_GET(r) ((((r).anlpa[0]) >> 10) & 0x1)
#define BCM53101_A0_ANLPAr_LP_ADV_PAUSEf_SET(r,f) (r).anlpa[0]=(((r).anlpa[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53101_A0_ANLPAr_RESV_TECHf_GET(r) ((((r).anlpa[0]) >> 11) & 0x3)
#define BCM53101_A0_ANLPAr_RESV_TECHf_SET(r,f) (r).anlpa[0]=(((r).anlpa[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11))
#define BCM53101_A0_ANLPAr_LP_REMOTE_FAULTf_GET(r) ((((r).anlpa[0]) >> 13) & 0x1)
#define BCM53101_A0_ANLPAr_LP_REMOTE_FAULTf_SET(r,f) (r).anlpa[0]=(((r).anlpa[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53101_A0_ANLPAr_LP_ACKf_GET(r) ((((r).anlpa[0]) >> 14) & 0x1)
#define BCM53101_A0_ANLPAr_LP_ACKf_SET(r,f) (r).anlpa[0]=(((r).anlpa[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_ANLPAr_LP_NEXT_PAGEf_GET(r) ((((r).anlpa[0]) >> 15) & 0x1)
#define BCM53101_A0_ANLPAr_LP_NEXT_PAGEf_SET(r,f) (r).anlpa[0]=(((r).anlpa[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access ANLPA.
 *
 */
#define BCM53101_A0_READ_ANLPAr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_ANLPAr,(r._anlpa),2)
#define BCM53101_A0_WRITE_ANLPAr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_ANLPAr,&(r._anlpa),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ANLPAr BCM53101_A0_ANLPAr
#define ANLPAr_SIZE BCM53101_A0_ANLPAr_SIZE
typedef BCM53101_A0_ANLPAr_t ANLPAr_t;
#define ANLPAr_CLR BCM53101_A0_ANLPAr_CLR
#define ANLPAr_SET BCM53101_A0_ANLPAr_SET
#define ANLPAr_GET BCM53101_A0_ANLPAr_GET
#define ANLPAr_LP_ADV_SEL_FIELDf_GET BCM53101_A0_ANLPAr_LP_ADV_SEL_FIELDf_GET
#define ANLPAr_LP_ADV_SEL_FIELDf_SET BCM53101_A0_ANLPAr_LP_ADV_SEL_FIELDf_SET
#define ANLPAr_LP_ADV_B10Tf_GET BCM53101_A0_ANLPAr_LP_ADV_B10Tf_GET
#define ANLPAr_LP_ADV_B10Tf_SET BCM53101_A0_ANLPAr_LP_ADV_B10Tf_SET
#define ANLPAr_LP_ADV_B10T_FDXf_GET BCM53101_A0_ANLPAr_LP_ADV_B10T_FDXf_GET
#define ANLPAr_LP_ADV_B10T_FDXf_SET BCM53101_A0_ANLPAr_LP_ADV_B10T_FDXf_SET
#define ANLPAr_LP_ADV_B100Xf_GET BCM53101_A0_ANLPAr_LP_ADV_B100Xf_GET
#define ANLPAr_LP_ADV_B100Xf_SET BCM53101_A0_ANLPAr_LP_ADV_B100Xf_SET
#define ANLPAr_LP_ADV_B100X_FDXf_GET BCM53101_A0_ANLPAr_LP_ADV_B100X_FDXf_GET
#define ANLPAr_LP_ADV_B100X_FDXf_SET BCM53101_A0_ANLPAr_LP_ADV_B100X_FDXf_SET
#define ANLPAr_LP_ADV_B100T4f_GET BCM53101_A0_ANLPAr_LP_ADV_B100T4f_GET
#define ANLPAr_LP_ADV_B100T4f_SET BCM53101_A0_ANLPAr_LP_ADV_B100T4f_SET
#define ANLPAr_LP_ADV_PAUSEf_GET BCM53101_A0_ANLPAr_LP_ADV_PAUSEf_GET
#define ANLPAr_LP_ADV_PAUSEf_SET BCM53101_A0_ANLPAr_LP_ADV_PAUSEf_SET
#define ANLPAr_RESV_TECHf_GET BCM53101_A0_ANLPAr_RESV_TECHf_GET
#define ANLPAr_RESV_TECHf_SET BCM53101_A0_ANLPAr_RESV_TECHf_SET
#define ANLPAr_LP_REMOTE_FAULTf_GET BCM53101_A0_ANLPAr_LP_REMOTE_FAULTf_GET
#define ANLPAr_LP_REMOTE_FAULTf_SET BCM53101_A0_ANLPAr_LP_REMOTE_FAULTf_SET
#define ANLPAr_LP_ACKf_GET BCM53101_A0_ANLPAr_LP_ACKf_GET
#define ANLPAr_LP_ACKf_SET BCM53101_A0_ANLPAr_LP_ACKf_SET
#define ANLPAr_LP_NEXT_PAGEf_GET BCM53101_A0_ANLPAr_LP_NEXT_PAGEf_GET
#define ANLPAr_LP_NEXT_PAGEf_SET BCM53101_A0_ANLPAr_LP_NEXT_PAGEf_SET
#define READ_ANLPAr BCM53101_A0_READ_ANLPAr
#define WRITE_ANLPAr BCM53101_A0_WRITE_ANLPAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_ANLPAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  ANLPA_EXT_P5
 * BLOCKS:   SYS
 * DESC:     Auto-Negotiation Link Partner (LP) Ability Register
 * SIZE:     16
 * FIELDS:
 *     LP_ADV_SEL_FIELD Link partner selector field.
 *     LP_ADV_B10T      Link partner has 10BASE-T capability.
 *     LP_ADV_B10T_FDX  Link partner has 10BASE-T FDX capability.
 *     LP_ADV_B100X     Link partner has 100BASE-X capability.
 *     LP_ADV_B100X_FDX Link partner has 100BASE-X FDX capability.
 *     LP_ADV_B100T4    Link partner has 100BASE-T4 capability.
 *     LP_ADV_PAUSE     Link partner has pause capability.
 *     RESV_TECH        
 *     LP_REMOTE_FAULT  Link partner remote fault indicator.
 *     LP_ACK           Link partner acknowledge bit.
 *     LP_NEXT_PAGE     Link partner Next Page bit.
 *
 ******************************************************************************/
#define BCM53101_A0_ANLPA_EXT_P5r 0x0000850a

#define BCM53101_A0_ANLPA_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program ANLPA_EXT_P5.
 *
 */
typedef union BCM53101_A0_ANLPA_EXT_P5r_s {
	uint32_t v[1];
	uint32_t anlpa_ext_p5[1];
	uint32_t _anlpa_ext_p5;
} BCM53101_A0_ANLPA_EXT_P5r_t;

#define BCM53101_A0_ANLPA_EXT_P5r_CLR(r) (r).anlpa_ext_p5[0] = 0
#define BCM53101_A0_ANLPA_EXT_P5r_SET(r,d) (r).anlpa_ext_p5[0] = d
#define BCM53101_A0_ANLPA_EXT_P5r_GET(r) (r).anlpa_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_ANLPA_EXT_P5r_LP_ADV_SEL_FIELDf_GET(r) (((r).anlpa_ext_p5[0]) & 0x1f)
#define BCM53101_A0_ANLPA_EXT_P5r_LP_ADV_SEL_FIELDf_SET(r,f) (r).anlpa_ext_p5[0]=(((r).anlpa_ext_p5[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53101_A0_ANLPA_EXT_P5r_LP_ADV_B10Tf_GET(r) ((((r).anlpa_ext_p5[0]) >> 5) & 0x1)
#define BCM53101_A0_ANLPA_EXT_P5r_LP_ADV_B10Tf_SET(r,f) (r).anlpa_ext_p5[0]=(((r).anlpa_ext_p5[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_ANLPA_EXT_P5r_LP_ADV_B10T_FDXf_GET(r) ((((r).anlpa_ext_p5[0]) >> 6) & 0x1)
#define BCM53101_A0_ANLPA_EXT_P5r_LP_ADV_B10T_FDXf_SET(r,f) (r).anlpa_ext_p5[0]=(((r).anlpa_ext_p5[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_ANLPA_EXT_P5r_LP_ADV_B100Xf_GET(r) ((((r).anlpa_ext_p5[0]) >> 7) & 0x1)
#define BCM53101_A0_ANLPA_EXT_P5r_LP_ADV_B100Xf_SET(r,f) (r).anlpa_ext_p5[0]=(((r).anlpa_ext_p5[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53101_A0_ANLPA_EXT_P5r_LP_ADV_B100X_FDXf_GET(r) ((((r).anlpa_ext_p5[0]) >> 8) & 0x1)
#define BCM53101_A0_ANLPA_EXT_P5r_LP_ADV_B100X_FDXf_SET(r,f) (r).anlpa_ext_p5[0]=(((r).anlpa_ext_p5[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53101_A0_ANLPA_EXT_P5r_LP_ADV_B100T4f_GET(r) ((((r).anlpa_ext_p5[0]) >> 9) & 0x1)
#define BCM53101_A0_ANLPA_EXT_P5r_LP_ADV_B100T4f_SET(r,f) (r).anlpa_ext_p5[0]=(((r).anlpa_ext_p5[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53101_A0_ANLPA_EXT_P5r_LP_ADV_PAUSEf_GET(r) ((((r).anlpa_ext_p5[0]) >> 10) & 0x1)
#define BCM53101_A0_ANLPA_EXT_P5r_LP_ADV_PAUSEf_SET(r,f) (r).anlpa_ext_p5[0]=(((r).anlpa_ext_p5[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53101_A0_ANLPA_EXT_P5r_RESV_TECHf_GET(r) ((((r).anlpa_ext_p5[0]) >> 11) & 0x3)
#define BCM53101_A0_ANLPA_EXT_P5r_RESV_TECHf_SET(r,f) (r).anlpa_ext_p5[0]=(((r).anlpa_ext_p5[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11))
#define BCM53101_A0_ANLPA_EXT_P5r_LP_REMOTE_FAULTf_GET(r) ((((r).anlpa_ext_p5[0]) >> 13) & 0x1)
#define BCM53101_A0_ANLPA_EXT_P5r_LP_REMOTE_FAULTf_SET(r,f) (r).anlpa_ext_p5[0]=(((r).anlpa_ext_p5[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53101_A0_ANLPA_EXT_P5r_LP_ACKf_GET(r) ((((r).anlpa_ext_p5[0]) >> 14) & 0x1)
#define BCM53101_A0_ANLPA_EXT_P5r_LP_ACKf_SET(r,f) (r).anlpa_ext_p5[0]=(((r).anlpa_ext_p5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_ANLPA_EXT_P5r_LP_NEXT_PAGEf_GET(r) ((((r).anlpa_ext_p5[0]) >> 15) & 0x1)
#define BCM53101_A0_ANLPA_EXT_P5r_LP_NEXT_PAGEf_SET(r,f) (r).anlpa_ext_p5[0]=(((r).anlpa_ext_p5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access ANLPA_EXT_P5.
 *
 */
#define BCM53101_A0_READ_ANLPA_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53101_A0_ANLPA_EXT_P5r,(r._anlpa_ext_p5),2)
#define BCM53101_A0_WRITE_ANLPA_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53101_A0_ANLPA_EXT_P5r,&(r._anlpa_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ANLPA_EXT_P5r BCM53101_A0_ANLPA_EXT_P5r
#define ANLPA_EXT_P5r_SIZE BCM53101_A0_ANLPA_EXT_P5r_SIZE
typedef BCM53101_A0_ANLPA_EXT_P5r_t ANLPA_EXT_P5r_t;
#define ANLPA_EXT_P5r_CLR BCM53101_A0_ANLPA_EXT_P5r_CLR
#define ANLPA_EXT_P5r_SET BCM53101_A0_ANLPA_EXT_P5r_SET
#define ANLPA_EXT_P5r_GET BCM53101_A0_ANLPA_EXT_P5r_GET
#define ANLPA_EXT_P5r_LP_ADV_SEL_FIELDf_GET BCM53101_A0_ANLPA_EXT_P5r_LP_ADV_SEL_FIELDf_GET
#define ANLPA_EXT_P5r_LP_ADV_SEL_FIELDf_SET BCM53101_A0_ANLPA_EXT_P5r_LP_ADV_SEL_FIELDf_SET
#define ANLPA_EXT_P5r_LP_ADV_B10Tf_GET BCM53101_A0_ANLPA_EXT_P5r_LP_ADV_B10Tf_GET
#define ANLPA_EXT_P5r_LP_ADV_B10Tf_SET BCM53101_A0_ANLPA_EXT_P5r_LP_ADV_B10Tf_SET
#define ANLPA_EXT_P5r_LP_ADV_B10T_FDXf_GET BCM53101_A0_ANLPA_EXT_P5r_LP_ADV_B10T_FDXf_GET
#define ANLPA_EXT_P5r_LP_ADV_B10T_FDXf_SET BCM53101_A0_ANLPA_EXT_P5r_LP_ADV_B10T_FDXf_SET
#define ANLPA_EXT_P5r_LP_ADV_B100Xf_GET BCM53101_A0_ANLPA_EXT_P5r_LP_ADV_B100Xf_GET
#define ANLPA_EXT_P5r_LP_ADV_B100Xf_SET BCM53101_A0_ANLPA_EXT_P5r_LP_ADV_B100Xf_SET
#define ANLPA_EXT_P5r_LP_ADV_B100X_FDXf_GET BCM53101_A0_ANLPA_EXT_P5r_LP_ADV_B100X_FDXf_GET
#define ANLPA_EXT_P5r_LP_ADV_B100X_FDXf_SET BCM53101_A0_ANLPA_EXT_P5r_LP_ADV_B100X_FDXf_SET
#define ANLPA_EXT_P5r_LP_ADV_B100T4f_GET BCM53101_A0_ANLPA_EXT_P5r_LP_ADV_B100T4f_GET
#define ANLPA_EXT_P5r_LP_ADV_B100T4f_SET BCM53101_A0_ANLPA_EXT_P5r_LP_ADV_B100T4f_SET
#define ANLPA_EXT_P5r_LP_ADV_PAUSEf_GET BCM53101_A0_ANLPA_EXT_P5r_LP_ADV_PAUSEf_GET
#define ANLPA_EXT_P5r_LP_ADV_PAUSEf_SET BCM53101_A0_ANLPA_EXT_P5r_LP_ADV_PAUSEf_SET
#define ANLPA_EXT_P5r_RESV_TECHf_GET BCM53101_A0_ANLPA_EXT_P5r_RESV_TECHf_GET
#define ANLPA_EXT_P5r_RESV_TECHf_SET BCM53101_A0_ANLPA_EXT_P5r_RESV_TECHf_SET
#define ANLPA_EXT_P5r_LP_REMOTE_FAULTf_GET BCM53101_A0_ANLPA_EXT_P5r_LP_REMOTE_FAULTf_GET
#define ANLPA_EXT_P5r_LP_REMOTE_FAULTf_SET BCM53101_A0_ANLPA_EXT_P5r_LP_REMOTE_FAULTf_SET
#define ANLPA_EXT_P5r_LP_ACKf_GET BCM53101_A0_ANLPA_EXT_P5r_LP_ACKf_GET
#define ANLPA_EXT_P5r_LP_ACKf_SET BCM53101_A0_ANLPA_EXT_P5r_LP_ACKf_SET
#define ANLPA_EXT_P5r_LP_NEXT_PAGEf_GET BCM53101_A0_ANLPA_EXT_P5r_LP_NEXT_PAGEf_GET
#define ANLPA_EXT_P5r_LP_NEXT_PAGEf_SET BCM53101_A0_ANLPA_EXT_P5r_LP_NEXT_PAGEf_SET
#define READ_ANLPA_EXT_P5r BCM53101_A0_READ_ANLPA_EXT_P5r
#define WRITE_ANLPA_EXT_P5r BCM53101_A0_WRITE_ANLPA_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_ANLPA_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  ANNXP
 * BLOCKS:   EPIC0
 * DESC:     Auto-Negotiation Next Page Register
 * SIZE:     16
 * FIELDS:
 *     CODE_FIELD       Message/Unformatted Code Field.
 *     TOGGLE           1 = Previous value of the transmitted link code word equaled logic 0.0 = Previous value of the transmitted link code word equaled logic 1.
 *     ACK_2            1 = Will comply with message.0 = Can not comply with message.
 *     MESSAGE_PAGE     1 = Message page.0 = Unformatted page.
 *     RESERVED         Reserved
 *     NEXT_PAGE        1 = Addition next page(s) follows.0 = Last page.
 *
 ******************************************************************************/
#define BCM53101_A0_ANNXPr 0x0000100e

#define BCM53101_A0_ANNXPr_SIZE 2

/*
 * This structure should be used to declare and program ANNXP.
 *
 */
typedef union BCM53101_A0_ANNXPr_s {
	uint32_t v[1];
	uint32_t annxp[1];
	uint32_t _annxp;
} BCM53101_A0_ANNXPr_t;

#define BCM53101_A0_ANNXPr_CLR(r) (r).annxp[0] = 0
#define BCM53101_A0_ANNXPr_SET(r,d) (r).annxp[0] = d
#define BCM53101_A0_ANNXPr_GET(r) (r).annxp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_ANNXPr_CODE_FIELDf_GET(r) (((r).annxp[0]) & 0x7ff)
#define BCM53101_A0_ANNXPr_CODE_FIELDf_SET(r,f) (r).annxp[0]=(((r).annxp[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53101_A0_ANNXPr_TOGGLEf_GET(r) ((((r).annxp[0]) >> 11) & 0x1)
#define BCM53101_A0_ANNXPr_TOGGLEf_SET(r,f) (r).annxp[0]=(((r).annxp[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53101_A0_ANNXPr_ACK_2f_GET(r) ((((r).annxp[0]) >> 12) & 0x1)
#define BCM53101_A0_ANNXPr_ACK_2f_SET(r,f) (r).annxp[0]=(((r).annxp[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53101_A0_ANNXPr_MESSAGE_PAGEf_GET(r) ((((r).annxp[0]) >> 13) & 0x1)
#define BCM53101_A0_ANNXPr_MESSAGE_PAGEf_SET(r,f) (r).annxp[0]=(((r).annxp[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53101_A0_ANNXPr_RESERVEDf_GET(r) ((((r).annxp[0]) >> 14) & 0x1)
#define BCM53101_A0_ANNXPr_RESERVEDf_SET(r,f) (r).annxp[0]=(((r).annxp[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_ANNXPr_NEXT_PAGEf_GET(r) ((((r).annxp[0]) >> 15) & 0x1)
#define BCM53101_A0_ANNXPr_NEXT_PAGEf_SET(r,f) (r).annxp[0]=(((r).annxp[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access ANNXP.
 *
 */
#define BCM53101_A0_READ_ANNXPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_ANNXPr,(r._annxp),2)
#define BCM53101_A0_WRITE_ANNXPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_ANNXPr,&(r._annxp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ANNXPr BCM53101_A0_ANNXPr
#define ANNXPr_SIZE BCM53101_A0_ANNXPr_SIZE
typedef BCM53101_A0_ANNXPr_t ANNXPr_t;
#define ANNXPr_CLR BCM53101_A0_ANNXPr_CLR
#define ANNXPr_SET BCM53101_A0_ANNXPr_SET
#define ANNXPr_GET BCM53101_A0_ANNXPr_GET
#define ANNXPr_CODE_FIELDf_GET BCM53101_A0_ANNXPr_CODE_FIELDf_GET
#define ANNXPr_CODE_FIELDf_SET BCM53101_A0_ANNXPr_CODE_FIELDf_SET
#define ANNXPr_TOGGLEf_GET BCM53101_A0_ANNXPr_TOGGLEf_GET
#define ANNXPr_TOGGLEf_SET BCM53101_A0_ANNXPr_TOGGLEf_SET
#define ANNXPr_ACK_2f_GET BCM53101_A0_ANNXPr_ACK_2f_GET
#define ANNXPr_ACK_2f_SET BCM53101_A0_ANNXPr_ACK_2f_SET
#define ANNXPr_MESSAGE_PAGEf_GET BCM53101_A0_ANNXPr_MESSAGE_PAGEf_GET
#define ANNXPr_MESSAGE_PAGEf_SET BCM53101_A0_ANNXPr_MESSAGE_PAGEf_SET
#define ANNXPr_RESERVEDf_GET BCM53101_A0_ANNXPr_RESERVEDf_GET
#define ANNXPr_RESERVEDf_SET BCM53101_A0_ANNXPr_RESERVEDf_SET
#define ANNXPr_NEXT_PAGEf_GET BCM53101_A0_ANNXPr_NEXT_PAGEf_GET
#define ANNXPr_NEXT_PAGEf_SET BCM53101_A0_ANNXPr_NEXT_PAGEf_SET
#define READ_ANNXPr BCM53101_A0_READ_ANNXPr
#define WRITE_ANNXPr BCM53101_A0_WRITE_ANNXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_ANNXPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  ANNXP_EXT_P5
 * BLOCKS:   SYS
 * DESC:     Auto-Negotiation Next Page Register
 * SIZE:     16
 * FIELDS:
 *     CODE_FIELD       Message/Unformatted Code Field.
 *     TOGGLE           1 = Previous value of the transmitted link code word equaled logic 0.0 = Previous value of the transmitted link code word equaled logic 1.
 *     ACK_2            1 = Will comply with message.0 = Can not comply with message.
 *     MESSAGE_PAGE     1 = Message page.0 = Unformatted page.
 *     RESERVED         Reserved
 *     NEXT_PAGE        1 = Addition next page(s) follows.0 = Last page.
 *
 ******************************************************************************/
#define BCM53101_A0_ANNXP_EXT_P5r 0x0000850e

#define BCM53101_A0_ANNXP_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program ANNXP_EXT_P5.
 *
 */
typedef union BCM53101_A0_ANNXP_EXT_P5r_s {
	uint32_t v[1];
	uint32_t annxp_ext_p5[1];
	uint32_t _annxp_ext_p5;
} BCM53101_A0_ANNXP_EXT_P5r_t;

#define BCM53101_A0_ANNXP_EXT_P5r_CLR(r) (r).annxp_ext_p5[0] = 0
#define BCM53101_A0_ANNXP_EXT_P5r_SET(r,d) (r).annxp_ext_p5[0] = d
#define BCM53101_A0_ANNXP_EXT_P5r_GET(r) (r).annxp_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_ANNXP_EXT_P5r_CODE_FIELDf_GET(r) (((r).annxp_ext_p5[0]) & 0x7ff)
#define BCM53101_A0_ANNXP_EXT_P5r_CODE_FIELDf_SET(r,f) (r).annxp_ext_p5[0]=(((r).annxp_ext_p5[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53101_A0_ANNXP_EXT_P5r_TOGGLEf_GET(r) ((((r).annxp_ext_p5[0]) >> 11) & 0x1)
#define BCM53101_A0_ANNXP_EXT_P5r_TOGGLEf_SET(r,f) (r).annxp_ext_p5[0]=(((r).annxp_ext_p5[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53101_A0_ANNXP_EXT_P5r_ACK_2f_GET(r) ((((r).annxp_ext_p5[0]) >> 12) & 0x1)
#define BCM53101_A0_ANNXP_EXT_P5r_ACK_2f_SET(r,f) (r).annxp_ext_p5[0]=(((r).annxp_ext_p5[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53101_A0_ANNXP_EXT_P5r_MESSAGE_PAGEf_GET(r) ((((r).annxp_ext_p5[0]) >> 13) & 0x1)
#define BCM53101_A0_ANNXP_EXT_P5r_MESSAGE_PAGEf_SET(r,f) (r).annxp_ext_p5[0]=(((r).annxp_ext_p5[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53101_A0_ANNXP_EXT_P5r_RESERVEDf_GET(r) ((((r).annxp_ext_p5[0]) >> 14) & 0x1)
#define BCM53101_A0_ANNXP_EXT_P5r_RESERVEDf_SET(r,f) (r).annxp_ext_p5[0]=(((r).annxp_ext_p5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_ANNXP_EXT_P5r_NEXT_PAGEf_GET(r) ((((r).annxp_ext_p5[0]) >> 15) & 0x1)
#define BCM53101_A0_ANNXP_EXT_P5r_NEXT_PAGEf_SET(r,f) (r).annxp_ext_p5[0]=(((r).annxp_ext_p5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access ANNXP_EXT_P5.
 *
 */
#define BCM53101_A0_READ_ANNXP_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53101_A0_ANNXP_EXT_P5r,(r._annxp_ext_p5),2)
#define BCM53101_A0_WRITE_ANNXP_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53101_A0_ANNXP_EXT_P5r,&(r._annxp_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ANNXP_EXT_P5r BCM53101_A0_ANNXP_EXT_P5r
#define ANNXP_EXT_P5r_SIZE BCM53101_A0_ANNXP_EXT_P5r_SIZE
typedef BCM53101_A0_ANNXP_EXT_P5r_t ANNXP_EXT_P5r_t;
#define ANNXP_EXT_P5r_CLR BCM53101_A0_ANNXP_EXT_P5r_CLR
#define ANNXP_EXT_P5r_SET BCM53101_A0_ANNXP_EXT_P5r_SET
#define ANNXP_EXT_P5r_GET BCM53101_A0_ANNXP_EXT_P5r_GET
#define ANNXP_EXT_P5r_CODE_FIELDf_GET BCM53101_A0_ANNXP_EXT_P5r_CODE_FIELDf_GET
#define ANNXP_EXT_P5r_CODE_FIELDf_SET BCM53101_A0_ANNXP_EXT_P5r_CODE_FIELDf_SET
#define ANNXP_EXT_P5r_TOGGLEf_GET BCM53101_A0_ANNXP_EXT_P5r_TOGGLEf_GET
#define ANNXP_EXT_P5r_TOGGLEf_SET BCM53101_A0_ANNXP_EXT_P5r_TOGGLEf_SET
#define ANNXP_EXT_P5r_ACK_2f_GET BCM53101_A0_ANNXP_EXT_P5r_ACK_2f_GET
#define ANNXP_EXT_P5r_ACK_2f_SET BCM53101_A0_ANNXP_EXT_P5r_ACK_2f_SET
#define ANNXP_EXT_P5r_MESSAGE_PAGEf_GET BCM53101_A0_ANNXP_EXT_P5r_MESSAGE_PAGEf_GET
#define ANNXP_EXT_P5r_MESSAGE_PAGEf_SET BCM53101_A0_ANNXP_EXT_P5r_MESSAGE_PAGEf_SET
#define ANNXP_EXT_P5r_RESERVEDf_GET BCM53101_A0_ANNXP_EXT_P5r_RESERVEDf_GET
#define ANNXP_EXT_P5r_RESERVEDf_SET BCM53101_A0_ANNXP_EXT_P5r_RESERVEDf_SET
#define ANNXP_EXT_P5r_NEXT_PAGEf_GET BCM53101_A0_ANNXP_EXT_P5r_NEXT_PAGEf_GET
#define ANNXP_EXT_P5r_NEXT_PAGEf_SET BCM53101_A0_ANNXP_EXT_P5r_NEXT_PAGEf_SET
#define READ_ANNXP_EXT_P5r BCM53101_A0_READ_ANNXP_EXT_P5r
#define WRITE_ANNXP_EXT_P5r BCM53101_A0_WRITE_ANNXP_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_ANNXP_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  ARLA_FWD_ENTRY0
 * BLOCKS:   SYS
 * DESC:     ARL FWD Entry 0 Register
 * SIZE:     32
 * FIELDS:
 *     PORTID           Port IdentificationIf system turn on multicast address scheme and MAC address is multicast type and, the bit[8:0] stands for Multicast Group Forward Portmap.Bit[8] : CPU Port/MII PortBit[7:0] : Port 7~0If system turn off multicast address scheme and MAC address is unicast type and, the bit[8:0] stands for Unicast Forward PortID.Bit[8:4] : ReservedBit[3:0] : Port ID/Port Number which identifies where the station with unique MACADDR_N is connected.
 *     ARL_CON          ARL MODE00: Forward according to FWD_MAP only.01: Drop if the entry is matched as a destination.10: Drop if the entry is matched as a source.11: Copy to CPU, in addition to forwarding according to FWD_MAP.01,10 and 11 can only be used when the entry is Static.
 *     ARL_PRI          Priority Bit for DA MAC based QOS
 *     ARL_AGE          AgingSet to indicate that an address entry has been learned or accessed. Reset by the internal aging algorithm. If the internal aging process detects a Valid entry has remained unused for period set by the AGE_TIME, and the entry has not been marked as Static, the entry will have the Valid bit cleared. The Age bit is ignored if the entry has been marked as Static.
 *     ARL_STATIC       Static.Set to indicate that the entry is controlled by the external management processor, and automatic learning and aging of the entry will not take place.When cleared, the internal learning and aging process will control the validity of the entry.
 *     ARL_VALID        Valid.Set to indicate that a valid MAC address is stored in the MACADDR0 field, and that the entry has not aged out or been freed by the management processor.Reset when an entry is empty, the address has been aged out by the internal aging process, or the external management processor has invalidated the entry. Automatic learning will take place if an address location is not valid and has not been marked as static.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_ARLA_FWD_ENTRY0r 0x00000518

#define BCM53101_A0_ARLA_FWD_ENTRY0r_SIZE 4

/*
 * This structure should be used to declare and program ARLA_FWD_ENTRY0.
 *
 */
typedef union BCM53101_A0_ARLA_FWD_ENTRY0r_s {
	uint32_t v[1];
	uint32_t arla_fwd_entry0[1];
	uint32_t _arla_fwd_entry0;
} BCM53101_A0_ARLA_FWD_ENTRY0r_t;

#define BCM53101_A0_ARLA_FWD_ENTRY0r_CLR(r) (r).arla_fwd_entry0[0] = 0
#define BCM53101_A0_ARLA_FWD_ENTRY0r_SET(r,d) (r).arla_fwd_entry0[0] = d
#define BCM53101_A0_ARLA_FWD_ENTRY0r_GET(r) (r).arla_fwd_entry0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_ARLA_FWD_ENTRY0r_PORTIDf_GET(r) (((r).arla_fwd_entry0[0]) & 0x1ff)
#define BCM53101_A0_ARLA_FWD_ENTRY0r_PORTIDf_SET(r,f) (r).arla_fwd_entry0[0]=(((r).arla_fwd_entry0[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_ARLA_FWD_ENTRY0r_ARL_CONf_GET(r) ((((r).arla_fwd_entry0[0]) >> 9) & 0x3)
#define BCM53101_A0_ARLA_FWD_ENTRY0r_ARL_CONf_SET(r,f) (r).arla_fwd_entry0[0]=(((r).arla_fwd_entry0[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM53101_A0_ARLA_FWD_ENTRY0r_ARL_PRIf_GET(r) ((((r).arla_fwd_entry0[0]) >> 11) & 0x7)
#define BCM53101_A0_ARLA_FWD_ENTRY0r_ARL_PRIf_SET(r,f) (r).arla_fwd_entry0[0]=(((r).arla_fwd_entry0[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))
#define BCM53101_A0_ARLA_FWD_ENTRY0r_ARL_AGEf_GET(r) ((((r).arla_fwd_entry0[0]) >> 14) & 0x1)
#define BCM53101_A0_ARLA_FWD_ENTRY0r_ARL_AGEf_SET(r,f) (r).arla_fwd_entry0[0]=(((r).arla_fwd_entry0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_ARLA_FWD_ENTRY0r_ARL_STATICf_GET(r) ((((r).arla_fwd_entry0[0]) >> 15) & 0x1)
#define BCM53101_A0_ARLA_FWD_ENTRY0r_ARL_STATICf_SET(r,f) (r).arla_fwd_entry0[0]=(((r).arla_fwd_entry0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53101_A0_ARLA_FWD_ENTRY0r_ARL_VALIDf_GET(r) ((((r).arla_fwd_entry0[0]) >> 16) & 0x1)
#define BCM53101_A0_ARLA_FWD_ENTRY0r_ARL_VALIDf_SET(r,f) (r).arla_fwd_entry0[0]=(((r).arla_fwd_entry0[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53101_A0_ARLA_FWD_ENTRY0r_RESERVEDf_GET(r) ((((r).arla_fwd_entry0[0]) >> 17) & 0x7fff)
#define BCM53101_A0_ARLA_FWD_ENTRY0r_RESERVEDf_SET(r,f) (r).arla_fwd_entry0[0]=(((r).arla_fwd_entry0[0] & ~((uint32_t)0x7fff << 17)) | ((((uint32_t)f) & 0x7fff) << 17))

/*
 * These macros can be used to access ARLA_FWD_ENTRY0.
 *
 */
#define BCM53101_A0_READ_ARLA_FWD_ENTRY0r(u,r) cdk_robo_reg_read(u,BCM53101_A0_ARLA_FWD_ENTRY0r,(r._arla_fwd_entry0),4)
#define BCM53101_A0_WRITE_ARLA_FWD_ENTRY0r(u,r) cdk_robo_reg_write(u,BCM53101_A0_ARLA_FWD_ENTRY0r,&(r._arla_fwd_entry0),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_FWD_ENTRY0r BCM53101_A0_ARLA_FWD_ENTRY0r
#define ARLA_FWD_ENTRY0r_SIZE BCM53101_A0_ARLA_FWD_ENTRY0r_SIZE
typedef BCM53101_A0_ARLA_FWD_ENTRY0r_t ARLA_FWD_ENTRY0r_t;
#define ARLA_FWD_ENTRY0r_CLR BCM53101_A0_ARLA_FWD_ENTRY0r_CLR
#define ARLA_FWD_ENTRY0r_SET BCM53101_A0_ARLA_FWD_ENTRY0r_SET
#define ARLA_FWD_ENTRY0r_GET BCM53101_A0_ARLA_FWD_ENTRY0r_GET
#define ARLA_FWD_ENTRY0r_PORTIDf_GET BCM53101_A0_ARLA_FWD_ENTRY0r_PORTIDf_GET
#define ARLA_FWD_ENTRY0r_PORTIDf_SET BCM53101_A0_ARLA_FWD_ENTRY0r_PORTIDf_SET
#define ARLA_FWD_ENTRY0r_ARL_CONf_GET BCM53101_A0_ARLA_FWD_ENTRY0r_ARL_CONf_GET
#define ARLA_FWD_ENTRY0r_ARL_CONf_SET BCM53101_A0_ARLA_FWD_ENTRY0r_ARL_CONf_SET
#define ARLA_FWD_ENTRY0r_ARL_PRIf_GET BCM53101_A0_ARLA_FWD_ENTRY0r_ARL_PRIf_GET
#define ARLA_FWD_ENTRY0r_ARL_PRIf_SET BCM53101_A0_ARLA_FWD_ENTRY0r_ARL_PRIf_SET
#define ARLA_FWD_ENTRY0r_ARL_AGEf_GET BCM53101_A0_ARLA_FWD_ENTRY0r_ARL_AGEf_GET
#define ARLA_FWD_ENTRY0r_ARL_AGEf_SET BCM53101_A0_ARLA_FWD_ENTRY0r_ARL_AGEf_SET
#define ARLA_FWD_ENTRY0r_ARL_STATICf_GET BCM53101_A0_ARLA_FWD_ENTRY0r_ARL_STATICf_GET
#define ARLA_FWD_ENTRY0r_ARL_STATICf_SET BCM53101_A0_ARLA_FWD_ENTRY0r_ARL_STATICf_SET
#define ARLA_FWD_ENTRY0r_ARL_VALIDf_GET BCM53101_A0_ARLA_FWD_ENTRY0r_ARL_VALIDf_GET
#define ARLA_FWD_ENTRY0r_ARL_VALIDf_SET BCM53101_A0_ARLA_FWD_ENTRY0r_ARL_VALIDf_SET
#define ARLA_FWD_ENTRY0r_RESERVEDf_GET BCM53101_A0_ARLA_FWD_ENTRY0r_RESERVEDf_GET
#define ARLA_FWD_ENTRY0r_RESERVEDf_SET BCM53101_A0_ARLA_FWD_ENTRY0r_RESERVEDf_SET
#define READ_ARLA_FWD_ENTRY0r BCM53101_A0_READ_ARLA_FWD_ENTRY0r
#define WRITE_ARLA_FWD_ENTRY0r BCM53101_A0_WRITE_ARLA_FWD_ENTRY0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_ARLA_FWD_ENTRY0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  ARLA_FWD_ENTRY1
 * BLOCKS:   SYS
 * DESC:     ARL FWD Entry 1 Register
 * SIZE:     32
 * FIELDS:
 *     PORTID           Port IdentificationIf system turn on multicast address scheme and MAC address is multicast type and, the bit[8:0] stands for Multicast Group Forward Portmap.Bit[8] : CPU Port/MII PortBit[7:0] : Port 7~0If system turn off multicast address scheme and MAC address is unicast type and, the bit[8:0] stands for Unicast Forward PortID.Bit[8:4] : ReservedBit[3:0] : Port ID/Port Number which identifies where the station with unique MACADDR_N is connected.
 *     ARL_CON          ARL MODE00: Forward according to FWD_MAP only.01: Drop if the entry is matched as a destination.10: Drop if the entry is matched as a source.11: Copy to CPU, in addition to forwarding according to FWD_MAP.01,10 and 11 can only be used when the entry is Static.
 *     ARL_PRI          Priority Bit for DA MAC based QOS
 *     ARL_AGE          AgingSet to indicate that an address entry has been learned or accessed. Reset by the internal aging algorithm. If the internal aging process detects a Valid entry has remained unused for period set by the AGE_TIME, and the entry has not been marked as Static, the entry will have the Valid bit cleared. The Age bit is ignored if the entry has been marked as Static.
 *     ARL_STATIC       Static.Set to indicate that the entry is controlled by the external management processor, and automatic learning and aging of the entry will not take place.When cleared, the internal learning and aging process will control the validity of the entry.
 *     ARL_VALID        Valid.Set to indicate that a valid MAC address is stored in the MACADDR1 field, and that the entry has not aged out or been freed by the management processor.Reset when an entry is empty, the address has been aged out by the internal aging process, or the external management processor has invalidated the entry. Automatic learning will take place if an address location is not valid and has not been marked as static.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_ARLA_FWD_ENTRY1r 0x00000528

#define BCM53101_A0_ARLA_FWD_ENTRY1r_SIZE 4

/*
 * This structure should be used to declare and program ARLA_FWD_ENTRY1.
 *
 */
typedef union BCM53101_A0_ARLA_FWD_ENTRY1r_s {
	uint32_t v[1];
	uint32_t arla_fwd_entry1[1];
	uint32_t _arla_fwd_entry1;
} BCM53101_A0_ARLA_FWD_ENTRY1r_t;

#define BCM53101_A0_ARLA_FWD_ENTRY1r_CLR(r) (r).arla_fwd_entry1[0] = 0
#define BCM53101_A0_ARLA_FWD_ENTRY1r_SET(r,d) (r).arla_fwd_entry1[0] = d
#define BCM53101_A0_ARLA_FWD_ENTRY1r_GET(r) (r).arla_fwd_entry1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_ARLA_FWD_ENTRY1r_PORTIDf_GET(r) (((r).arla_fwd_entry1[0]) & 0x1ff)
#define BCM53101_A0_ARLA_FWD_ENTRY1r_PORTIDf_SET(r,f) (r).arla_fwd_entry1[0]=(((r).arla_fwd_entry1[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_ARLA_FWD_ENTRY1r_ARL_CONf_GET(r) ((((r).arla_fwd_entry1[0]) >> 9) & 0x3)
#define BCM53101_A0_ARLA_FWD_ENTRY1r_ARL_CONf_SET(r,f) (r).arla_fwd_entry1[0]=(((r).arla_fwd_entry1[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM53101_A0_ARLA_FWD_ENTRY1r_ARL_PRIf_GET(r) ((((r).arla_fwd_entry1[0]) >> 11) & 0x7)
#define BCM53101_A0_ARLA_FWD_ENTRY1r_ARL_PRIf_SET(r,f) (r).arla_fwd_entry1[0]=(((r).arla_fwd_entry1[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))
#define BCM53101_A0_ARLA_FWD_ENTRY1r_ARL_AGEf_GET(r) ((((r).arla_fwd_entry1[0]) >> 14) & 0x1)
#define BCM53101_A0_ARLA_FWD_ENTRY1r_ARL_AGEf_SET(r,f) (r).arla_fwd_entry1[0]=(((r).arla_fwd_entry1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_ARLA_FWD_ENTRY1r_ARL_STATICf_GET(r) ((((r).arla_fwd_entry1[0]) >> 15) & 0x1)
#define BCM53101_A0_ARLA_FWD_ENTRY1r_ARL_STATICf_SET(r,f) (r).arla_fwd_entry1[0]=(((r).arla_fwd_entry1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53101_A0_ARLA_FWD_ENTRY1r_ARL_VALIDf_GET(r) ((((r).arla_fwd_entry1[0]) >> 16) & 0x1)
#define BCM53101_A0_ARLA_FWD_ENTRY1r_ARL_VALIDf_SET(r,f) (r).arla_fwd_entry1[0]=(((r).arla_fwd_entry1[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53101_A0_ARLA_FWD_ENTRY1r_RESERVEDf_GET(r) ((((r).arla_fwd_entry1[0]) >> 17) & 0x7fff)
#define BCM53101_A0_ARLA_FWD_ENTRY1r_RESERVEDf_SET(r,f) (r).arla_fwd_entry1[0]=(((r).arla_fwd_entry1[0] & ~((uint32_t)0x7fff << 17)) | ((((uint32_t)f) & 0x7fff) << 17))

/*
 * These macros can be used to access ARLA_FWD_ENTRY1.
 *
 */
#define BCM53101_A0_READ_ARLA_FWD_ENTRY1r(u,r) cdk_robo_reg_read(u,BCM53101_A0_ARLA_FWD_ENTRY1r,(r._arla_fwd_entry1),4)
#define BCM53101_A0_WRITE_ARLA_FWD_ENTRY1r(u,r) cdk_robo_reg_write(u,BCM53101_A0_ARLA_FWD_ENTRY1r,&(r._arla_fwd_entry1),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_FWD_ENTRY1r BCM53101_A0_ARLA_FWD_ENTRY1r
#define ARLA_FWD_ENTRY1r_SIZE BCM53101_A0_ARLA_FWD_ENTRY1r_SIZE
typedef BCM53101_A0_ARLA_FWD_ENTRY1r_t ARLA_FWD_ENTRY1r_t;
#define ARLA_FWD_ENTRY1r_CLR BCM53101_A0_ARLA_FWD_ENTRY1r_CLR
#define ARLA_FWD_ENTRY1r_SET BCM53101_A0_ARLA_FWD_ENTRY1r_SET
#define ARLA_FWD_ENTRY1r_GET BCM53101_A0_ARLA_FWD_ENTRY1r_GET
#define ARLA_FWD_ENTRY1r_PORTIDf_GET BCM53101_A0_ARLA_FWD_ENTRY1r_PORTIDf_GET
#define ARLA_FWD_ENTRY1r_PORTIDf_SET BCM53101_A0_ARLA_FWD_ENTRY1r_PORTIDf_SET
#define ARLA_FWD_ENTRY1r_ARL_CONf_GET BCM53101_A0_ARLA_FWD_ENTRY1r_ARL_CONf_GET
#define ARLA_FWD_ENTRY1r_ARL_CONf_SET BCM53101_A0_ARLA_FWD_ENTRY1r_ARL_CONf_SET
#define ARLA_FWD_ENTRY1r_ARL_PRIf_GET BCM53101_A0_ARLA_FWD_ENTRY1r_ARL_PRIf_GET
#define ARLA_FWD_ENTRY1r_ARL_PRIf_SET BCM53101_A0_ARLA_FWD_ENTRY1r_ARL_PRIf_SET
#define ARLA_FWD_ENTRY1r_ARL_AGEf_GET BCM53101_A0_ARLA_FWD_ENTRY1r_ARL_AGEf_GET
#define ARLA_FWD_ENTRY1r_ARL_AGEf_SET BCM53101_A0_ARLA_FWD_ENTRY1r_ARL_AGEf_SET
#define ARLA_FWD_ENTRY1r_ARL_STATICf_GET BCM53101_A0_ARLA_FWD_ENTRY1r_ARL_STATICf_GET
#define ARLA_FWD_ENTRY1r_ARL_STATICf_SET BCM53101_A0_ARLA_FWD_ENTRY1r_ARL_STATICf_SET
#define ARLA_FWD_ENTRY1r_ARL_VALIDf_GET BCM53101_A0_ARLA_FWD_ENTRY1r_ARL_VALIDf_GET
#define ARLA_FWD_ENTRY1r_ARL_VALIDf_SET BCM53101_A0_ARLA_FWD_ENTRY1r_ARL_VALIDf_SET
#define ARLA_FWD_ENTRY1r_RESERVEDf_GET BCM53101_A0_ARLA_FWD_ENTRY1r_RESERVEDf_GET
#define ARLA_FWD_ENTRY1r_RESERVEDf_SET BCM53101_A0_ARLA_FWD_ENTRY1r_RESERVEDf_SET
#define READ_ARLA_FWD_ENTRY1r BCM53101_A0_READ_ARLA_FWD_ENTRY1r
#define WRITE_ARLA_FWD_ENTRY1r BCM53101_A0_WRITE_ARLA_FWD_ENTRY1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_ARLA_FWD_ENTRY1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  ARLA_FWD_ENTRY2
 * BLOCKS:   SYS
 * DESC:     ARL FWD Entry 2 Register
 * SIZE:     32
 * FIELDS:
 *     PORTID           Port IdentificationIf system turn on multicast address scheme and MAC address is multicast type and, the bit[8:0] stands for Multicast Group Forward Portmap.Bit[8] : CPU Port/MII PortBit[7:0] : Port 7~0If system turn off multicast address scheme and MAC address is unicast type and, the bit[8:0] stands for Unicast Forward PortID.Bit[8:4] : ReservedBit[3:0] : Port ID/Port Number which identifies where the station with unique MACADDR_N is connected.
 *     ARL_CON          ARL MODE00: Forward according to FWD_MAP only.01: Drop if the entry is matched as a destination.10: Drop if the entry is matched as a source.11: Copy to CPU, in addition to forwarding according to FWD_MAP.01,10 and 11 can only be used when the entry is Static.
 *     ARL_PRI          Priority Bit for DA MAC based QOS
 *     ARL_AGE          AgingSet to indicate that an address entry has been learned or accessed. Reset by the internal aging algorithm. If the internal aging process detects a Valid entry has remained unused for period set by the AGE_TIME, and the entry has not been marked as Static, the entry will have the Valid bit cleared. The Age bit is ignored if the entry has been marked as Static.
 *     ARL_STATIC       Static.Set to indicate that the entry is controlled by the external management processor, and automatic learning and aging of the entry will not take place.When cleared, the internal learning and aging process will control the validity of the entry.
 *     ARL_VALID        Valid.Set to indicate that a valid MAC address is stored in the MACADDR2 field, and that the entry has not aged out or been freed by the management processor.Reset when an entry is empty, the address has been aged out by the internal aging process, or the external management processor has invalidated the entry. Automatic learning will take place if an address location is not valid and has not been marked as static.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_ARLA_FWD_ENTRY2r 0x00000538

#define BCM53101_A0_ARLA_FWD_ENTRY2r_SIZE 4

/*
 * This structure should be used to declare and program ARLA_FWD_ENTRY2.
 *
 */
typedef union BCM53101_A0_ARLA_FWD_ENTRY2r_s {
	uint32_t v[1];
	uint32_t arla_fwd_entry2[1];
	uint32_t _arla_fwd_entry2;
} BCM53101_A0_ARLA_FWD_ENTRY2r_t;

#define BCM53101_A0_ARLA_FWD_ENTRY2r_CLR(r) (r).arla_fwd_entry2[0] = 0
#define BCM53101_A0_ARLA_FWD_ENTRY2r_SET(r,d) (r).arla_fwd_entry2[0] = d
#define BCM53101_A0_ARLA_FWD_ENTRY2r_GET(r) (r).arla_fwd_entry2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_ARLA_FWD_ENTRY2r_PORTIDf_GET(r) (((r).arla_fwd_entry2[0]) & 0x1ff)
#define BCM53101_A0_ARLA_FWD_ENTRY2r_PORTIDf_SET(r,f) (r).arla_fwd_entry2[0]=(((r).arla_fwd_entry2[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_ARLA_FWD_ENTRY2r_ARL_CONf_GET(r) ((((r).arla_fwd_entry2[0]) >> 9) & 0x3)
#define BCM53101_A0_ARLA_FWD_ENTRY2r_ARL_CONf_SET(r,f) (r).arla_fwd_entry2[0]=(((r).arla_fwd_entry2[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM53101_A0_ARLA_FWD_ENTRY2r_ARL_PRIf_GET(r) ((((r).arla_fwd_entry2[0]) >> 11) & 0x7)
#define BCM53101_A0_ARLA_FWD_ENTRY2r_ARL_PRIf_SET(r,f) (r).arla_fwd_entry2[0]=(((r).arla_fwd_entry2[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))
#define BCM53101_A0_ARLA_FWD_ENTRY2r_ARL_AGEf_GET(r) ((((r).arla_fwd_entry2[0]) >> 14) & 0x1)
#define BCM53101_A0_ARLA_FWD_ENTRY2r_ARL_AGEf_SET(r,f) (r).arla_fwd_entry2[0]=(((r).arla_fwd_entry2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_ARLA_FWD_ENTRY2r_ARL_STATICf_GET(r) ((((r).arla_fwd_entry2[0]) >> 15) & 0x1)
#define BCM53101_A0_ARLA_FWD_ENTRY2r_ARL_STATICf_SET(r,f) (r).arla_fwd_entry2[0]=(((r).arla_fwd_entry2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53101_A0_ARLA_FWD_ENTRY2r_ARL_VALIDf_GET(r) ((((r).arla_fwd_entry2[0]) >> 16) & 0x1)
#define BCM53101_A0_ARLA_FWD_ENTRY2r_ARL_VALIDf_SET(r,f) (r).arla_fwd_entry2[0]=(((r).arla_fwd_entry2[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53101_A0_ARLA_FWD_ENTRY2r_RESERVEDf_GET(r) ((((r).arla_fwd_entry2[0]) >> 17) & 0x7fff)
#define BCM53101_A0_ARLA_FWD_ENTRY2r_RESERVEDf_SET(r,f) (r).arla_fwd_entry2[0]=(((r).arla_fwd_entry2[0] & ~((uint32_t)0x7fff << 17)) | ((((uint32_t)f) & 0x7fff) << 17))

/*
 * These macros can be used to access ARLA_FWD_ENTRY2.
 *
 */
#define BCM53101_A0_READ_ARLA_FWD_ENTRY2r(u,r) cdk_robo_reg_read(u,BCM53101_A0_ARLA_FWD_ENTRY2r,(r._arla_fwd_entry2),4)
#define BCM53101_A0_WRITE_ARLA_FWD_ENTRY2r(u,r) cdk_robo_reg_write(u,BCM53101_A0_ARLA_FWD_ENTRY2r,&(r._arla_fwd_entry2),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_FWD_ENTRY2r BCM53101_A0_ARLA_FWD_ENTRY2r
#define ARLA_FWD_ENTRY2r_SIZE BCM53101_A0_ARLA_FWD_ENTRY2r_SIZE
typedef BCM53101_A0_ARLA_FWD_ENTRY2r_t ARLA_FWD_ENTRY2r_t;
#define ARLA_FWD_ENTRY2r_CLR BCM53101_A0_ARLA_FWD_ENTRY2r_CLR
#define ARLA_FWD_ENTRY2r_SET BCM53101_A0_ARLA_FWD_ENTRY2r_SET
#define ARLA_FWD_ENTRY2r_GET BCM53101_A0_ARLA_FWD_ENTRY2r_GET
#define ARLA_FWD_ENTRY2r_PORTIDf_GET BCM53101_A0_ARLA_FWD_ENTRY2r_PORTIDf_GET
#define ARLA_FWD_ENTRY2r_PORTIDf_SET BCM53101_A0_ARLA_FWD_ENTRY2r_PORTIDf_SET
#define ARLA_FWD_ENTRY2r_ARL_CONf_GET BCM53101_A0_ARLA_FWD_ENTRY2r_ARL_CONf_GET
#define ARLA_FWD_ENTRY2r_ARL_CONf_SET BCM53101_A0_ARLA_FWD_ENTRY2r_ARL_CONf_SET
#define ARLA_FWD_ENTRY2r_ARL_PRIf_GET BCM53101_A0_ARLA_FWD_ENTRY2r_ARL_PRIf_GET
#define ARLA_FWD_ENTRY2r_ARL_PRIf_SET BCM53101_A0_ARLA_FWD_ENTRY2r_ARL_PRIf_SET
#define ARLA_FWD_ENTRY2r_ARL_AGEf_GET BCM53101_A0_ARLA_FWD_ENTRY2r_ARL_AGEf_GET
#define ARLA_FWD_ENTRY2r_ARL_AGEf_SET BCM53101_A0_ARLA_FWD_ENTRY2r_ARL_AGEf_SET
#define ARLA_FWD_ENTRY2r_ARL_STATICf_GET BCM53101_A0_ARLA_FWD_ENTRY2r_ARL_STATICf_GET
#define ARLA_FWD_ENTRY2r_ARL_STATICf_SET BCM53101_A0_ARLA_FWD_ENTRY2r_ARL_STATICf_SET
#define ARLA_FWD_ENTRY2r_ARL_VALIDf_GET BCM53101_A0_ARLA_FWD_ENTRY2r_ARL_VALIDf_GET
#define ARLA_FWD_ENTRY2r_ARL_VALIDf_SET BCM53101_A0_ARLA_FWD_ENTRY2r_ARL_VALIDf_SET
#define ARLA_FWD_ENTRY2r_RESERVEDf_GET BCM53101_A0_ARLA_FWD_ENTRY2r_RESERVEDf_GET
#define ARLA_FWD_ENTRY2r_RESERVEDf_SET BCM53101_A0_ARLA_FWD_ENTRY2r_RESERVEDf_SET
#define READ_ARLA_FWD_ENTRY2r BCM53101_A0_READ_ARLA_FWD_ENTRY2r
#define WRITE_ARLA_FWD_ENTRY2r BCM53101_A0_WRITE_ARLA_FWD_ENTRY2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_ARLA_FWD_ENTRY2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  ARLA_FWD_ENTRY3
 * BLOCKS:   SYS
 * DESC:     ARL FWD Entry 3 Register
 * SIZE:     32
 * FIELDS:
 *     PORTID           Port IdentificationIf system turn on multicast address scheme and MAC address is multicast type and, the bit[8:0] stands for Multicast Group Forward Portmap.Bit[8] : CPU Port/MII PortBit[7:0] : Port 7~0If system turn off multicast address scheme and MAC address is unicast type and, the bit[8:0] stands for Unicast Forward PortID.Bit[8:4] : ReservedBit[3:0] : Port ID/Port Number which identifies where the station with unique MACADDR_N is connected.
 *     ARL_CON          ARL MODE00: Forward according to FWD_MAP only.01: Drop if the entry is matched as a destination.10: Drop if the entry is matched as a source.11: Copy to CPU, in addition to forwarding according to FWD_MAP.01,10 and 11 can only be used when the entry is Static.
 *     ARL_PRI          Priority Bit for DA MAC based QOS
 *     ARL_AGE          AgingSet to indicate that an address entry has been learned or accessed. Reset by the internal aging algorithm. If the internal aging process detects a Valid entry has remained unused for period set by the AGE_TIME, and the entry has not been marked as Static, the entry will have the Valid bit cleared. The Age bit is ignored if the entry has been marked as Static.
 *     ARL_STATIC       Static.Set to indicate that the entry is controlled by the external management processor, and automatic learning and aging of the entry will not take place.When cleared, the internal learning and aging process will control the validity of the entry.
 *     ARL_VALID        Valid.Set to indicate that a valid MAC address is stored in the MACADDR3 field, and that the entry has not aged out or been freed by the management processor.Reset when an entry is empty, the address has been aged out by the internal aging process, or the external management processor has invalidated the entry. Automatic learning will take place if an address location is not valid and has not been marked as static.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_ARLA_FWD_ENTRY3r 0x00000548

#define BCM53101_A0_ARLA_FWD_ENTRY3r_SIZE 4

/*
 * This structure should be used to declare and program ARLA_FWD_ENTRY3.
 *
 */
typedef union BCM53101_A0_ARLA_FWD_ENTRY3r_s {
	uint32_t v[1];
	uint32_t arla_fwd_entry3[1];
	uint32_t _arla_fwd_entry3;
} BCM53101_A0_ARLA_FWD_ENTRY3r_t;

#define BCM53101_A0_ARLA_FWD_ENTRY3r_CLR(r) (r).arla_fwd_entry3[0] = 0
#define BCM53101_A0_ARLA_FWD_ENTRY3r_SET(r,d) (r).arla_fwd_entry3[0] = d
#define BCM53101_A0_ARLA_FWD_ENTRY3r_GET(r) (r).arla_fwd_entry3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_ARLA_FWD_ENTRY3r_PORTIDf_GET(r) (((r).arla_fwd_entry3[0]) & 0x1ff)
#define BCM53101_A0_ARLA_FWD_ENTRY3r_PORTIDf_SET(r,f) (r).arla_fwd_entry3[0]=(((r).arla_fwd_entry3[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_ARLA_FWD_ENTRY3r_ARL_CONf_GET(r) ((((r).arla_fwd_entry3[0]) >> 9) & 0x3)
#define BCM53101_A0_ARLA_FWD_ENTRY3r_ARL_CONf_SET(r,f) (r).arla_fwd_entry3[0]=(((r).arla_fwd_entry3[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM53101_A0_ARLA_FWD_ENTRY3r_ARL_PRIf_GET(r) ((((r).arla_fwd_entry3[0]) >> 11) & 0x7)
#define BCM53101_A0_ARLA_FWD_ENTRY3r_ARL_PRIf_SET(r,f) (r).arla_fwd_entry3[0]=(((r).arla_fwd_entry3[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))
#define BCM53101_A0_ARLA_FWD_ENTRY3r_ARL_AGEf_GET(r) ((((r).arla_fwd_entry3[0]) >> 14) & 0x1)
#define BCM53101_A0_ARLA_FWD_ENTRY3r_ARL_AGEf_SET(r,f) (r).arla_fwd_entry3[0]=(((r).arla_fwd_entry3[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_ARLA_FWD_ENTRY3r_ARL_STATICf_GET(r) ((((r).arla_fwd_entry3[0]) >> 15) & 0x1)
#define BCM53101_A0_ARLA_FWD_ENTRY3r_ARL_STATICf_SET(r,f) (r).arla_fwd_entry3[0]=(((r).arla_fwd_entry3[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53101_A0_ARLA_FWD_ENTRY3r_ARL_VALIDf_GET(r) ((((r).arla_fwd_entry3[0]) >> 16) & 0x1)
#define BCM53101_A0_ARLA_FWD_ENTRY3r_ARL_VALIDf_SET(r,f) (r).arla_fwd_entry3[0]=(((r).arla_fwd_entry3[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53101_A0_ARLA_FWD_ENTRY3r_RESERVEDf_GET(r) ((((r).arla_fwd_entry3[0]) >> 17) & 0x7fff)
#define BCM53101_A0_ARLA_FWD_ENTRY3r_RESERVEDf_SET(r,f) (r).arla_fwd_entry3[0]=(((r).arla_fwd_entry3[0] & ~((uint32_t)0x7fff << 17)) | ((((uint32_t)f) & 0x7fff) << 17))

/*
 * These macros can be used to access ARLA_FWD_ENTRY3.
 *
 */
#define BCM53101_A0_READ_ARLA_FWD_ENTRY3r(u,r) cdk_robo_reg_read(u,BCM53101_A0_ARLA_FWD_ENTRY3r,(r._arla_fwd_entry3),4)
#define BCM53101_A0_WRITE_ARLA_FWD_ENTRY3r(u,r) cdk_robo_reg_write(u,BCM53101_A0_ARLA_FWD_ENTRY3r,&(r._arla_fwd_entry3),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_FWD_ENTRY3r BCM53101_A0_ARLA_FWD_ENTRY3r
#define ARLA_FWD_ENTRY3r_SIZE BCM53101_A0_ARLA_FWD_ENTRY3r_SIZE
typedef BCM53101_A0_ARLA_FWD_ENTRY3r_t ARLA_FWD_ENTRY3r_t;
#define ARLA_FWD_ENTRY3r_CLR BCM53101_A0_ARLA_FWD_ENTRY3r_CLR
#define ARLA_FWD_ENTRY3r_SET BCM53101_A0_ARLA_FWD_ENTRY3r_SET
#define ARLA_FWD_ENTRY3r_GET BCM53101_A0_ARLA_FWD_ENTRY3r_GET
#define ARLA_FWD_ENTRY3r_PORTIDf_GET BCM53101_A0_ARLA_FWD_ENTRY3r_PORTIDf_GET
#define ARLA_FWD_ENTRY3r_PORTIDf_SET BCM53101_A0_ARLA_FWD_ENTRY3r_PORTIDf_SET
#define ARLA_FWD_ENTRY3r_ARL_CONf_GET BCM53101_A0_ARLA_FWD_ENTRY3r_ARL_CONf_GET
#define ARLA_FWD_ENTRY3r_ARL_CONf_SET BCM53101_A0_ARLA_FWD_ENTRY3r_ARL_CONf_SET
#define ARLA_FWD_ENTRY3r_ARL_PRIf_GET BCM53101_A0_ARLA_FWD_ENTRY3r_ARL_PRIf_GET
#define ARLA_FWD_ENTRY3r_ARL_PRIf_SET BCM53101_A0_ARLA_FWD_ENTRY3r_ARL_PRIf_SET
#define ARLA_FWD_ENTRY3r_ARL_AGEf_GET BCM53101_A0_ARLA_FWD_ENTRY3r_ARL_AGEf_GET
#define ARLA_FWD_ENTRY3r_ARL_AGEf_SET BCM53101_A0_ARLA_FWD_ENTRY3r_ARL_AGEf_SET
#define ARLA_FWD_ENTRY3r_ARL_STATICf_GET BCM53101_A0_ARLA_FWD_ENTRY3r_ARL_STATICf_GET
#define ARLA_FWD_ENTRY3r_ARL_STATICf_SET BCM53101_A0_ARLA_FWD_ENTRY3r_ARL_STATICf_SET
#define ARLA_FWD_ENTRY3r_ARL_VALIDf_GET BCM53101_A0_ARLA_FWD_ENTRY3r_ARL_VALIDf_GET
#define ARLA_FWD_ENTRY3r_ARL_VALIDf_SET BCM53101_A0_ARLA_FWD_ENTRY3r_ARL_VALIDf_SET
#define ARLA_FWD_ENTRY3r_RESERVEDf_GET BCM53101_A0_ARLA_FWD_ENTRY3r_RESERVEDf_GET
#define ARLA_FWD_ENTRY3r_RESERVEDf_SET BCM53101_A0_ARLA_FWD_ENTRY3r_RESERVEDf_SET
#define READ_ARLA_FWD_ENTRY3r BCM53101_A0_READ_ARLA_FWD_ENTRY3r
#define WRITE_ARLA_FWD_ENTRY3r BCM53101_A0_WRITE_ARLA_FWD_ENTRY3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_ARLA_FWD_ENTRY3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  ARLA_MAC
 * BLOCKS:   SYS
 * DESC:     MAC Address Index Register
 * SIZE:     48
 * FIELDS:
 *     MAC_ADDR_INDX    MAC Address Index.The MAC address for which status is to be read or written.By writing the 48 bit SA or DA address, and initiating a read command, the complete ARL bin location is returned in the ARL Entry 0/1/2/3 locations. These entries are 64 bits wide. Initiating a write command will write the contents of ARL Entry 0/1/2/3 to the specified bin location (4 entries deep) and will overwrite the current contents of the bin, regardless of the status of the Valid bit(s) in each entry.
 *
 ******************************************************************************/
#define BCM53101_A0_ARLA_MACr 0x00000502

#define BCM53101_A0_ARLA_MACr_SIZE 6

/*
 * This structure should be used to declare and program ARLA_MAC.
 *
 */
typedef union BCM53101_A0_ARLA_MACr_s {
	uint32_t v[2];
	uint32_t arla_mac[2];
	uint32_t _arla_mac;
} BCM53101_A0_ARLA_MACr_t;

#define BCM53101_A0_ARLA_MACr_CLR(r) CDK_MEMSET(&((r)._arla_mac), 0, sizeof(BCM53101_A0_ARLA_MACr_t))
#define BCM53101_A0_ARLA_MACr_SET(r,i,d) (r).arla_mac[i] = d
#define BCM53101_A0_ARLA_MACr_GET(r,i) (r).arla_mac[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_ARLA_MACr_MAC_ADDR_INDXf_GET(r,a) cdk_field_get((r).arla_mac,0,47,a)
#define BCM53101_A0_ARLA_MACr_MAC_ADDR_INDXf_SET(r,a) cdk_field_set((r).arla_mac,0,47,a)

/*
 * These macros can be used to access ARLA_MAC.
 *
 */
#define BCM53101_A0_READ_ARLA_MACr(u,r) cdk_robo_reg_read(u,BCM53101_A0_ARLA_MACr,(r._arla_mac),6)
#define BCM53101_A0_WRITE_ARLA_MACr(u,r) cdk_robo_reg_write(u,BCM53101_A0_ARLA_MACr,&(r._arla_mac),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_MACr BCM53101_A0_ARLA_MACr
#define ARLA_MACr_SIZE BCM53101_A0_ARLA_MACr_SIZE
typedef BCM53101_A0_ARLA_MACr_t ARLA_MACr_t;
#define ARLA_MACr_CLR BCM53101_A0_ARLA_MACr_CLR
#define ARLA_MACr_SET BCM53101_A0_ARLA_MACr_SET
#define ARLA_MACr_GET BCM53101_A0_ARLA_MACr_GET
#define ARLA_MACr_MAC_ADDR_INDXf_GET BCM53101_A0_ARLA_MACr_MAC_ADDR_INDXf_GET
#define ARLA_MACr_MAC_ADDR_INDXf_SET BCM53101_A0_ARLA_MACr_MAC_ADDR_INDXf_SET
#define READ_ARLA_MACr BCM53101_A0_READ_ARLA_MACr
#define WRITE_ARLA_MACr BCM53101_A0_WRITE_ARLA_MACr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_ARLA_MACr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  ARLA_MACVID_ENTRY0
 * BLOCKS:   SYS
 * DESC:     ARL MAC/VID Entry 0 Register
 * SIZE:     64
 * FIELDS:
 *     ARL_MACADDR      MAC Address 0.
 *     VID              VID0.The VID0 register is used to write VID field of ARL table, or to read VID field of ARL table entry ARL FWD Entry 0 Register and MAC/VID Entry 0 Register compose a complete Entry in ARL Table while 802.1Q enabled
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_ARLA_MACVID_ENTRY0r 0x00000510

#define BCM53101_A0_ARLA_MACVID_ENTRY0r_SIZE 8

/*
 * This structure should be used to declare and program ARLA_MACVID_ENTRY0.
 *
 */
typedef union BCM53101_A0_ARLA_MACVID_ENTRY0r_s {
	uint32_t v[2];
	uint32_t arla_macvid_entry0[2];
	uint32_t _arla_macvid_entry0;
} BCM53101_A0_ARLA_MACVID_ENTRY0r_t;

#define BCM53101_A0_ARLA_MACVID_ENTRY0r_CLR(r) CDK_MEMSET(&((r)._arla_macvid_entry0), 0, sizeof(BCM53101_A0_ARLA_MACVID_ENTRY0r_t))
#define BCM53101_A0_ARLA_MACVID_ENTRY0r_SET(r,i,d) (r).arla_macvid_entry0[i] = d
#define BCM53101_A0_ARLA_MACVID_ENTRY0r_GET(r,i) (r).arla_macvid_entry0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_ARLA_MACVID_ENTRY0r_ARL_MACADDRf_GET(r,a) cdk_field_get((r).arla_macvid_entry0,0,47,a)
#define BCM53101_A0_ARLA_MACVID_ENTRY0r_ARL_MACADDRf_SET(r,a) cdk_field_set((r).arla_macvid_entry0,0,47,a)
#define BCM53101_A0_ARLA_MACVID_ENTRY0r_VIDf_GET(r) ((((r).arla_macvid_entry0[1]) >> 16) & 0xfff)
#define BCM53101_A0_ARLA_MACVID_ENTRY0r_VIDf_SET(r,f) (r).arla_macvid_entry0[1]=(((r).arla_macvid_entry0[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53101_A0_ARLA_MACVID_ENTRY0r_RESERVEDf_GET(r) ((((r).arla_macvid_entry0[1]) >> 28) & 0xf)
#define BCM53101_A0_ARLA_MACVID_ENTRY0r_RESERVEDf_SET(r,f) (r).arla_macvid_entry0[1]=(((r).arla_macvid_entry0[1] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access ARLA_MACVID_ENTRY0.
 *
 */
#define BCM53101_A0_READ_ARLA_MACVID_ENTRY0r(u,r) cdk_robo_reg_read(u,BCM53101_A0_ARLA_MACVID_ENTRY0r,(r._arla_macvid_entry0),8)
#define BCM53101_A0_WRITE_ARLA_MACVID_ENTRY0r(u,r) cdk_robo_reg_write(u,BCM53101_A0_ARLA_MACVID_ENTRY0r,&(r._arla_macvid_entry0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_MACVID_ENTRY0r BCM53101_A0_ARLA_MACVID_ENTRY0r
#define ARLA_MACVID_ENTRY0r_SIZE BCM53101_A0_ARLA_MACVID_ENTRY0r_SIZE
typedef BCM53101_A0_ARLA_MACVID_ENTRY0r_t ARLA_MACVID_ENTRY0r_t;
#define ARLA_MACVID_ENTRY0r_CLR BCM53101_A0_ARLA_MACVID_ENTRY0r_CLR
#define ARLA_MACVID_ENTRY0r_SET BCM53101_A0_ARLA_MACVID_ENTRY0r_SET
#define ARLA_MACVID_ENTRY0r_GET BCM53101_A0_ARLA_MACVID_ENTRY0r_GET
#define ARLA_MACVID_ENTRY0r_ARL_MACADDRf_GET BCM53101_A0_ARLA_MACVID_ENTRY0r_ARL_MACADDRf_GET
#define ARLA_MACVID_ENTRY0r_ARL_MACADDRf_SET BCM53101_A0_ARLA_MACVID_ENTRY0r_ARL_MACADDRf_SET
#define ARLA_MACVID_ENTRY0r_VIDf_GET BCM53101_A0_ARLA_MACVID_ENTRY0r_VIDf_GET
#define ARLA_MACVID_ENTRY0r_VIDf_SET BCM53101_A0_ARLA_MACVID_ENTRY0r_VIDf_SET
#define ARLA_MACVID_ENTRY0r_RESERVEDf_GET BCM53101_A0_ARLA_MACVID_ENTRY0r_RESERVEDf_GET
#define ARLA_MACVID_ENTRY0r_RESERVEDf_SET BCM53101_A0_ARLA_MACVID_ENTRY0r_RESERVEDf_SET
#define READ_ARLA_MACVID_ENTRY0r BCM53101_A0_READ_ARLA_MACVID_ENTRY0r
#define WRITE_ARLA_MACVID_ENTRY0r BCM53101_A0_WRITE_ARLA_MACVID_ENTRY0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_ARLA_MACVID_ENTRY0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  ARLA_MACVID_ENTRY1
 * BLOCKS:   SYS
 * DESC:     ARL MAC/VID Entry 1 Register
 * SIZE:     64
 * FIELDS:
 *     ARL_MACADDR      MAC Address 1.
 *     VID              VID1.The VID1 register is used to write VID field of ARL table, or to read VID field of ARL table entry ARL FWD Entry 1 Register and MAC/VID Entry 1 Register compose a complete Entry in ARL Table while 802.1Q enabled
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_ARLA_MACVID_ENTRY1r 0x00000520

#define BCM53101_A0_ARLA_MACVID_ENTRY1r_SIZE 8

/*
 * This structure should be used to declare and program ARLA_MACVID_ENTRY1.
 *
 */
typedef union BCM53101_A0_ARLA_MACVID_ENTRY1r_s {
	uint32_t v[2];
	uint32_t arla_macvid_entry1[2];
	uint32_t _arla_macvid_entry1;
} BCM53101_A0_ARLA_MACVID_ENTRY1r_t;

#define BCM53101_A0_ARLA_MACVID_ENTRY1r_CLR(r) CDK_MEMSET(&((r)._arla_macvid_entry1), 0, sizeof(BCM53101_A0_ARLA_MACVID_ENTRY1r_t))
#define BCM53101_A0_ARLA_MACVID_ENTRY1r_SET(r,i,d) (r).arla_macvid_entry1[i] = d
#define BCM53101_A0_ARLA_MACVID_ENTRY1r_GET(r,i) (r).arla_macvid_entry1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_ARLA_MACVID_ENTRY1r_ARL_MACADDRf_GET(r,a) cdk_field_get((r).arla_macvid_entry1,0,47,a)
#define BCM53101_A0_ARLA_MACVID_ENTRY1r_ARL_MACADDRf_SET(r,a) cdk_field_set((r).arla_macvid_entry1,0,47,a)
#define BCM53101_A0_ARLA_MACVID_ENTRY1r_VIDf_GET(r) ((((r).arla_macvid_entry1[1]) >> 16) & 0xfff)
#define BCM53101_A0_ARLA_MACVID_ENTRY1r_VIDf_SET(r,f) (r).arla_macvid_entry1[1]=(((r).arla_macvid_entry1[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53101_A0_ARLA_MACVID_ENTRY1r_RESERVEDf_GET(r) ((((r).arla_macvid_entry1[1]) >> 28) & 0xf)
#define BCM53101_A0_ARLA_MACVID_ENTRY1r_RESERVEDf_SET(r,f) (r).arla_macvid_entry1[1]=(((r).arla_macvid_entry1[1] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access ARLA_MACVID_ENTRY1.
 *
 */
#define BCM53101_A0_READ_ARLA_MACVID_ENTRY1r(u,r) cdk_robo_reg_read(u,BCM53101_A0_ARLA_MACVID_ENTRY1r,(r._arla_macvid_entry1),8)
#define BCM53101_A0_WRITE_ARLA_MACVID_ENTRY1r(u,r) cdk_robo_reg_write(u,BCM53101_A0_ARLA_MACVID_ENTRY1r,&(r._arla_macvid_entry1),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_MACVID_ENTRY1r BCM53101_A0_ARLA_MACVID_ENTRY1r
#define ARLA_MACVID_ENTRY1r_SIZE BCM53101_A0_ARLA_MACVID_ENTRY1r_SIZE
typedef BCM53101_A0_ARLA_MACVID_ENTRY1r_t ARLA_MACVID_ENTRY1r_t;
#define ARLA_MACVID_ENTRY1r_CLR BCM53101_A0_ARLA_MACVID_ENTRY1r_CLR
#define ARLA_MACVID_ENTRY1r_SET BCM53101_A0_ARLA_MACVID_ENTRY1r_SET
#define ARLA_MACVID_ENTRY1r_GET BCM53101_A0_ARLA_MACVID_ENTRY1r_GET
#define ARLA_MACVID_ENTRY1r_ARL_MACADDRf_GET BCM53101_A0_ARLA_MACVID_ENTRY1r_ARL_MACADDRf_GET
#define ARLA_MACVID_ENTRY1r_ARL_MACADDRf_SET BCM53101_A0_ARLA_MACVID_ENTRY1r_ARL_MACADDRf_SET
#define ARLA_MACVID_ENTRY1r_VIDf_GET BCM53101_A0_ARLA_MACVID_ENTRY1r_VIDf_GET
#define ARLA_MACVID_ENTRY1r_VIDf_SET BCM53101_A0_ARLA_MACVID_ENTRY1r_VIDf_SET
#define ARLA_MACVID_ENTRY1r_RESERVEDf_GET BCM53101_A0_ARLA_MACVID_ENTRY1r_RESERVEDf_GET
#define ARLA_MACVID_ENTRY1r_RESERVEDf_SET BCM53101_A0_ARLA_MACVID_ENTRY1r_RESERVEDf_SET
#define READ_ARLA_MACVID_ENTRY1r BCM53101_A0_READ_ARLA_MACVID_ENTRY1r
#define WRITE_ARLA_MACVID_ENTRY1r BCM53101_A0_WRITE_ARLA_MACVID_ENTRY1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_ARLA_MACVID_ENTRY1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  ARLA_MACVID_ENTRY2
 * BLOCKS:   SYS
 * DESC:     ARL MAC/VID Entry 2 Register
 * SIZE:     64
 * FIELDS:
 *     ARL_MACADDR      MAC Address 2.
 *     VID              VID2.The VID2 register is used to write VID field of ARL table, or to read VID field of ARL table entry ARL FWD Entry 2 Register and MAC/VID Entry 2 Register compose a complete Entry in ARL Table while 802.1Q enabled
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_ARLA_MACVID_ENTRY2r 0x00000530

#define BCM53101_A0_ARLA_MACVID_ENTRY2r_SIZE 8

/*
 * This structure should be used to declare and program ARLA_MACVID_ENTRY2.
 *
 */
typedef union BCM53101_A0_ARLA_MACVID_ENTRY2r_s {
	uint32_t v[2];
	uint32_t arla_macvid_entry2[2];
	uint32_t _arla_macvid_entry2;
} BCM53101_A0_ARLA_MACVID_ENTRY2r_t;

#define BCM53101_A0_ARLA_MACVID_ENTRY2r_CLR(r) CDK_MEMSET(&((r)._arla_macvid_entry2), 0, sizeof(BCM53101_A0_ARLA_MACVID_ENTRY2r_t))
#define BCM53101_A0_ARLA_MACVID_ENTRY2r_SET(r,i,d) (r).arla_macvid_entry2[i] = d
#define BCM53101_A0_ARLA_MACVID_ENTRY2r_GET(r,i) (r).arla_macvid_entry2[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_ARLA_MACVID_ENTRY2r_ARL_MACADDRf_GET(r,a) cdk_field_get((r).arla_macvid_entry2,0,47,a)
#define BCM53101_A0_ARLA_MACVID_ENTRY2r_ARL_MACADDRf_SET(r,a) cdk_field_set((r).arla_macvid_entry2,0,47,a)
#define BCM53101_A0_ARLA_MACVID_ENTRY2r_VIDf_GET(r) ((((r).arla_macvid_entry2[1]) >> 16) & 0xfff)
#define BCM53101_A0_ARLA_MACVID_ENTRY2r_VIDf_SET(r,f) (r).arla_macvid_entry2[1]=(((r).arla_macvid_entry2[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53101_A0_ARLA_MACVID_ENTRY2r_RESERVEDf_GET(r) ((((r).arla_macvid_entry2[1]) >> 28) & 0xf)
#define BCM53101_A0_ARLA_MACVID_ENTRY2r_RESERVEDf_SET(r,f) (r).arla_macvid_entry2[1]=(((r).arla_macvid_entry2[1] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access ARLA_MACVID_ENTRY2.
 *
 */
#define BCM53101_A0_READ_ARLA_MACVID_ENTRY2r(u,r) cdk_robo_reg_read(u,BCM53101_A0_ARLA_MACVID_ENTRY2r,(r._arla_macvid_entry2),8)
#define BCM53101_A0_WRITE_ARLA_MACVID_ENTRY2r(u,r) cdk_robo_reg_write(u,BCM53101_A0_ARLA_MACVID_ENTRY2r,&(r._arla_macvid_entry2),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_MACVID_ENTRY2r BCM53101_A0_ARLA_MACVID_ENTRY2r
#define ARLA_MACVID_ENTRY2r_SIZE BCM53101_A0_ARLA_MACVID_ENTRY2r_SIZE
typedef BCM53101_A0_ARLA_MACVID_ENTRY2r_t ARLA_MACVID_ENTRY2r_t;
#define ARLA_MACVID_ENTRY2r_CLR BCM53101_A0_ARLA_MACVID_ENTRY2r_CLR
#define ARLA_MACVID_ENTRY2r_SET BCM53101_A0_ARLA_MACVID_ENTRY2r_SET
#define ARLA_MACVID_ENTRY2r_GET BCM53101_A0_ARLA_MACVID_ENTRY2r_GET
#define ARLA_MACVID_ENTRY2r_ARL_MACADDRf_GET BCM53101_A0_ARLA_MACVID_ENTRY2r_ARL_MACADDRf_GET
#define ARLA_MACVID_ENTRY2r_ARL_MACADDRf_SET BCM53101_A0_ARLA_MACVID_ENTRY2r_ARL_MACADDRf_SET
#define ARLA_MACVID_ENTRY2r_VIDf_GET BCM53101_A0_ARLA_MACVID_ENTRY2r_VIDf_GET
#define ARLA_MACVID_ENTRY2r_VIDf_SET BCM53101_A0_ARLA_MACVID_ENTRY2r_VIDf_SET
#define ARLA_MACVID_ENTRY2r_RESERVEDf_GET BCM53101_A0_ARLA_MACVID_ENTRY2r_RESERVEDf_GET
#define ARLA_MACVID_ENTRY2r_RESERVEDf_SET BCM53101_A0_ARLA_MACVID_ENTRY2r_RESERVEDf_SET
#define READ_ARLA_MACVID_ENTRY2r BCM53101_A0_READ_ARLA_MACVID_ENTRY2r
#define WRITE_ARLA_MACVID_ENTRY2r BCM53101_A0_WRITE_ARLA_MACVID_ENTRY2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_ARLA_MACVID_ENTRY2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  ARLA_MACVID_ENTRY3
 * BLOCKS:   SYS
 * DESC:     ARL MAC/VID Entry 3 Register
 * SIZE:     64
 * FIELDS:
 *     ARL_MACADDR      MAC Address 3.
 *     VID              VID3.The VID3 register is used to write VID field of ARL table, or to read VID field of ARL table entry ARL FWD Entry 3 Register and MAC/VID Entry 3 Register compose a complete Entry in ARL Table while 802.1Q enabled
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_ARLA_MACVID_ENTRY3r 0x00000540

#define BCM53101_A0_ARLA_MACVID_ENTRY3r_SIZE 8

/*
 * This structure should be used to declare and program ARLA_MACVID_ENTRY3.
 *
 */
typedef union BCM53101_A0_ARLA_MACVID_ENTRY3r_s {
	uint32_t v[2];
	uint32_t arla_macvid_entry3[2];
	uint32_t _arla_macvid_entry3;
} BCM53101_A0_ARLA_MACVID_ENTRY3r_t;

#define BCM53101_A0_ARLA_MACVID_ENTRY3r_CLR(r) CDK_MEMSET(&((r)._arla_macvid_entry3), 0, sizeof(BCM53101_A0_ARLA_MACVID_ENTRY3r_t))
#define BCM53101_A0_ARLA_MACVID_ENTRY3r_SET(r,i,d) (r).arla_macvid_entry3[i] = d
#define BCM53101_A0_ARLA_MACVID_ENTRY3r_GET(r,i) (r).arla_macvid_entry3[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_ARLA_MACVID_ENTRY3r_ARL_MACADDRf_GET(r,a) cdk_field_get((r).arla_macvid_entry3,0,47,a)
#define BCM53101_A0_ARLA_MACVID_ENTRY3r_ARL_MACADDRf_SET(r,a) cdk_field_set((r).arla_macvid_entry3,0,47,a)
#define BCM53101_A0_ARLA_MACVID_ENTRY3r_VIDf_GET(r) ((((r).arla_macvid_entry3[1]) >> 16) & 0xfff)
#define BCM53101_A0_ARLA_MACVID_ENTRY3r_VIDf_SET(r,f) (r).arla_macvid_entry3[1]=(((r).arla_macvid_entry3[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53101_A0_ARLA_MACVID_ENTRY3r_RESERVEDf_GET(r) ((((r).arla_macvid_entry3[1]) >> 28) & 0xf)
#define BCM53101_A0_ARLA_MACVID_ENTRY3r_RESERVEDf_SET(r,f) (r).arla_macvid_entry3[1]=(((r).arla_macvid_entry3[1] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access ARLA_MACVID_ENTRY3.
 *
 */
#define BCM53101_A0_READ_ARLA_MACVID_ENTRY3r(u,r) cdk_robo_reg_read(u,BCM53101_A0_ARLA_MACVID_ENTRY3r,(r._arla_macvid_entry3),8)
#define BCM53101_A0_WRITE_ARLA_MACVID_ENTRY3r(u,r) cdk_robo_reg_write(u,BCM53101_A0_ARLA_MACVID_ENTRY3r,&(r._arla_macvid_entry3),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_MACVID_ENTRY3r BCM53101_A0_ARLA_MACVID_ENTRY3r
#define ARLA_MACVID_ENTRY3r_SIZE BCM53101_A0_ARLA_MACVID_ENTRY3r_SIZE
typedef BCM53101_A0_ARLA_MACVID_ENTRY3r_t ARLA_MACVID_ENTRY3r_t;
#define ARLA_MACVID_ENTRY3r_CLR BCM53101_A0_ARLA_MACVID_ENTRY3r_CLR
#define ARLA_MACVID_ENTRY3r_SET BCM53101_A0_ARLA_MACVID_ENTRY3r_SET
#define ARLA_MACVID_ENTRY3r_GET BCM53101_A0_ARLA_MACVID_ENTRY3r_GET
#define ARLA_MACVID_ENTRY3r_ARL_MACADDRf_GET BCM53101_A0_ARLA_MACVID_ENTRY3r_ARL_MACADDRf_GET
#define ARLA_MACVID_ENTRY3r_ARL_MACADDRf_SET BCM53101_A0_ARLA_MACVID_ENTRY3r_ARL_MACADDRf_SET
#define ARLA_MACVID_ENTRY3r_VIDf_GET BCM53101_A0_ARLA_MACVID_ENTRY3r_VIDf_GET
#define ARLA_MACVID_ENTRY3r_VIDf_SET BCM53101_A0_ARLA_MACVID_ENTRY3r_VIDf_SET
#define ARLA_MACVID_ENTRY3r_RESERVEDf_GET BCM53101_A0_ARLA_MACVID_ENTRY3r_RESERVEDf_GET
#define ARLA_MACVID_ENTRY3r_RESERVEDf_SET BCM53101_A0_ARLA_MACVID_ENTRY3r_RESERVEDf_SET
#define READ_ARLA_MACVID_ENTRY3r BCM53101_A0_READ_ARLA_MACVID_ENTRY3r
#define WRITE_ARLA_MACVID_ENTRY3r BCM53101_A0_WRITE_ARLA_MACVID_ENTRY3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_ARLA_MACVID_ENTRY3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  ARLA_RWCTL
 * BLOCKS:   SYS
 * DESC:     ARL Read/Write Control Register
 * SIZE:     8
 * FIELDS:
 *     ARL_RW           ARL Read/Write.1 = Read,0 = Write.
 *     RESERVED         Reserved
 *     ARL_STRTDN       Start/Done Command.Write as 1 to initiate a read or write command, after first loading the MAC_ADDR_INDX register with the MAC address for which the ARL entry is to be read or written.The Lotus will reset the bit to indicate a write operation completed, or a read operation has completed and data from the bin entry is available in ARL Entry 0/1 Note that both ARL Entry 0 and 1 are both always read/written by the Lotus when accessing the address table locations in memory.
 *
 ******************************************************************************/
#define BCM53101_A0_ARLA_RWCTLr 0x00000500

#define BCM53101_A0_ARLA_RWCTLr_SIZE 1

/*
 * This structure should be used to declare and program ARLA_RWCTL.
 *
 */
typedef union BCM53101_A0_ARLA_RWCTLr_s {
	uint32_t v[1];
	uint32_t arla_rwctl[1];
	uint32_t _arla_rwctl;
} BCM53101_A0_ARLA_RWCTLr_t;

#define BCM53101_A0_ARLA_RWCTLr_CLR(r) (r).arla_rwctl[0] = 0
#define BCM53101_A0_ARLA_RWCTLr_SET(r,d) (r).arla_rwctl[0] = d
#define BCM53101_A0_ARLA_RWCTLr_GET(r) (r).arla_rwctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_ARLA_RWCTLr_ARL_RWf_GET(r) (((r).arla_rwctl[0]) & 0x1)
#define BCM53101_A0_ARLA_RWCTLr_ARL_RWf_SET(r,f) (r).arla_rwctl[0]=(((r).arla_rwctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_ARLA_RWCTLr_RESERVEDf_GET(r) ((((r).arla_rwctl[0]) >> 1) & 0x3f)
#define BCM53101_A0_ARLA_RWCTLr_RESERVEDf_SET(r,f) (r).arla_rwctl[0]=(((r).arla_rwctl[0] & ~((uint32_t)0x3f << 1)) | ((((uint32_t)f) & 0x3f) << 1))
#define BCM53101_A0_ARLA_RWCTLr_ARL_STRTDNf_GET(r) ((((r).arla_rwctl[0]) >> 7) & 0x1)
#define BCM53101_A0_ARLA_RWCTLr_ARL_STRTDNf_SET(r,f) (r).arla_rwctl[0]=(((r).arla_rwctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access ARLA_RWCTL.
 *
 */
#define BCM53101_A0_READ_ARLA_RWCTLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_ARLA_RWCTLr,(r._arla_rwctl),1)
#define BCM53101_A0_WRITE_ARLA_RWCTLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_ARLA_RWCTLr,&(r._arla_rwctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_RWCTLr BCM53101_A0_ARLA_RWCTLr
#define ARLA_RWCTLr_SIZE BCM53101_A0_ARLA_RWCTLr_SIZE
typedef BCM53101_A0_ARLA_RWCTLr_t ARLA_RWCTLr_t;
#define ARLA_RWCTLr_CLR BCM53101_A0_ARLA_RWCTLr_CLR
#define ARLA_RWCTLr_SET BCM53101_A0_ARLA_RWCTLr_SET
#define ARLA_RWCTLr_GET BCM53101_A0_ARLA_RWCTLr_GET
#define ARLA_RWCTLr_ARL_RWf_GET BCM53101_A0_ARLA_RWCTLr_ARL_RWf_GET
#define ARLA_RWCTLr_ARL_RWf_SET BCM53101_A0_ARLA_RWCTLr_ARL_RWf_SET
#define ARLA_RWCTLr_RESERVEDf_GET BCM53101_A0_ARLA_RWCTLr_RESERVEDf_GET
#define ARLA_RWCTLr_RESERVEDf_SET BCM53101_A0_ARLA_RWCTLr_RESERVEDf_SET
#define ARLA_RWCTLr_ARL_STRTDNf_GET BCM53101_A0_ARLA_RWCTLr_ARL_STRTDNf_GET
#define ARLA_RWCTLr_ARL_STRTDNf_SET BCM53101_A0_ARLA_RWCTLr_ARL_STRTDNf_SET
#define READ_ARLA_RWCTLr BCM53101_A0_READ_ARLA_RWCTLr
#define WRITE_ARLA_RWCTLr BCM53101_A0_WRITE_ARLA_RWCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_ARLA_RWCTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  ARLA_SRCH_ADR
 * BLOCKS:   SYS
 * DESC:     ARL Search Address Register
 * SIZE:     16
 * FIELDS:
 *     ARLA_SRCH_ADR    ARL Address.15 bit internal representation of the address of the ARL entry currently being accessed by the ARL search routine.This is not a direct address of the ARL location, and is intended for factory test/diagnostic use only.
 *     ARLA_SRCH_ADR_VALID ARL Address Valid.Indicates the lower 15 bits of this register contain a valid internal representation of the ARL entry currently being accessed. Intended for factory test/diagnostic use only.
 *
 ******************************************************************************/
#define BCM53101_A0_ARLA_SRCH_ADRr 0x00000551

#define BCM53101_A0_ARLA_SRCH_ADRr_SIZE 2

/*
 * This structure should be used to declare and program ARLA_SRCH_ADR.
 *
 */
typedef union BCM53101_A0_ARLA_SRCH_ADRr_s {
	uint32_t v[1];
	uint32_t arla_srch_adr[1];
	uint32_t _arla_srch_adr;
} BCM53101_A0_ARLA_SRCH_ADRr_t;

#define BCM53101_A0_ARLA_SRCH_ADRr_CLR(r) (r).arla_srch_adr[0] = 0
#define BCM53101_A0_ARLA_SRCH_ADRr_SET(r,d) (r).arla_srch_adr[0] = d
#define BCM53101_A0_ARLA_SRCH_ADRr_GET(r) (r).arla_srch_adr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADRf_GET(r) (((r).arla_srch_adr[0]) & 0x7fff)
#define BCM53101_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADRf_SET(r,f) (r).arla_srch_adr[0]=(((r).arla_srch_adr[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff))
#define BCM53101_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADR_VALIDf_GET(r) ((((r).arla_srch_adr[0]) >> 15) & 0x1)
#define BCM53101_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADR_VALIDf_SET(r,f) (r).arla_srch_adr[0]=(((r).arla_srch_adr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access ARLA_SRCH_ADR.
 *
 */
#define BCM53101_A0_READ_ARLA_SRCH_ADRr(u,r) cdk_robo_reg_read(u,BCM53101_A0_ARLA_SRCH_ADRr,(r._arla_srch_adr),2)
#define BCM53101_A0_WRITE_ARLA_SRCH_ADRr(u,r) cdk_robo_reg_write(u,BCM53101_A0_ARLA_SRCH_ADRr,&(r._arla_srch_adr),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_SRCH_ADRr BCM53101_A0_ARLA_SRCH_ADRr
#define ARLA_SRCH_ADRr_SIZE BCM53101_A0_ARLA_SRCH_ADRr_SIZE
typedef BCM53101_A0_ARLA_SRCH_ADRr_t ARLA_SRCH_ADRr_t;
#define ARLA_SRCH_ADRr_CLR BCM53101_A0_ARLA_SRCH_ADRr_CLR
#define ARLA_SRCH_ADRr_SET BCM53101_A0_ARLA_SRCH_ADRr_SET
#define ARLA_SRCH_ADRr_GET BCM53101_A0_ARLA_SRCH_ADRr_GET
#define ARLA_SRCH_ADRr_ARLA_SRCH_ADRf_GET BCM53101_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADRf_GET
#define ARLA_SRCH_ADRr_ARLA_SRCH_ADRf_SET BCM53101_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADRf_SET
#define ARLA_SRCH_ADRr_ARLA_SRCH_ADR_VALIDf_GET BCM53101_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADR_VALIDf_GET
#define ARLA_SRCH_ADRr_ARLA_SRCH_ADR_VALIDf_SET BCM53101_A0_ARLA_SRCH_ADRr_ARLA_SRCH_ADR_VALIDf_SET
#define READ_ARLA_SRCH_ADRr BCM53101_A0_READ_ARLA_SRCH_ADRr
#define WRITE_ARLA_SRCH_ADRr BCM53101_A0_WRITE_ARLA_SRCH_ADRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_ARLA_SRCH_ADRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  ARLA_SRCH_CTL
 * BLOCKS:   SYS
 * DESC:     ARL Search Control Register
 * SIZE:     8
 * FIELDS:
 *     ARLA_SRCH_VLID   ARL Search Result ValidAvailable in the ARL Search Result register.Reset by a host read to the ARL Search Result register 1 , which will cause the ARL search process to continue through the ARL entries until the next entry is found with a Valid bit is set.(Note: should not reset by a host read to ARL Search VID Result Register. The correct process of reading a ARL Entry after having searched a valid one: Read ARL Search VID Result Register => Read ARL Search Result Register 1)
 *     RESERVED         Reserved
 *     ARLA_SRCH_STDN   Start/Done.Write as 1 to initiate a sequential search of the ARL entries, returning each entry that is currently occupied (Valid = 1 and AGE = 0) in the ARL Search Result register. Reading the ARL Search Result Register causes the ARL search to continue.The Lotus will clear this bit to indicate the entire ARL entry database has been searched.)
 *
 ******************************************************************************/
#define BCM53101_A0_ARLA_SRCH_CTLr 0x00000550

#define BCM53101_A0_ARLA_SRCH_CTLr_SIZE 1

/*
 * This structure should be used to declare and program ARLA_SRCH_CTL.
 *
 */
typedef union BCM53101_A0_ARLA_SRCH_CTLr_s {
	uint32_t v[1];
	uint32_t arla_srch_ctl[1];
	uint32_t _arla_srch_ctl;
} BCM53101_A0_ARLA_SRCH_CTLr_t;

#define BCM53101_A0_ARLA_SRCH_CTLr_CLR(r) (r).arla_srch_ctl[0] = 0
#define BCM53101_A0_ARLA_SRCH_CTLr_SET(r,d) (r).arla_srch_ctl[0] = d
#define BCM53101_A0_ARLA_SRCH_CTLr_GET(r) (r).arla_srch_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_ARLA_SRCH_CTLr_ARLA_SRCH_VLIDf_GET(r) (((r).arla_srch_ctl[0]) & 0x1)
#define BCM53101_A0_ARLA_SRCH_CTLr_ARLA_SRCH_VLIDf_SET(r,f) (r).arla_srch_ctl[0]=(((r).arla_srch_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_ARLA_SRCH_CTLr_RESERVEDf_GET(r) ((((r).arla_srch_ctl[0]) >> 1) & 0x3f)
#define BCM53101_A0_ARLA_SRCH_CTLr_RESERVEDf_SET(r,f) (r).arla_srch_ctl[0]=(((r).arla_srch_ctl[0] & ~((uint32_t)0x3f << 1)) | ((((uint32_t)f) & 0x3f) << 1))
#define BCM53101_A0_ARLA_SRCH_CTLr_ARLA_SRCH_STDNf_GET(r) ((((r).arla_srch_ctl[0]) >> 7) & 0x1)
#define BCM53101_A0_ARLA_SRCH_CTLr_ARLA_SRCH_STDNf_SET(r,f) (r).arla_srch_ctl[0]=(((r).arla_srch_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access ARLA_SRCH_CTL.
 *
 */
#define BCM53101_A0_READ_ARLA_SRCH_CTLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_ARLA_SRCH_CTLr,(r._arla_srch_ctl),1)
#define BCM53101_A0_WRITE_ARLA_SRCH_CTLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_ARLA_SRCH_CTLr,&(r._arla_srch_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_SRCH_CTLr BCM53101_A0_ARLA_SRCH_CTLr
#define ARLA_SRCH_CTLr_SIZE BCM53101_A0_ARLA_SRCH_CTLr_SIZE
typedef BCM53101_A0_ARLA_SRCH_CTLr_t ARLA_SRCH_CTLr_t;
#define ARLA_SRCH_CTLr_CLR BCM53101_A0_ARLA_SRCH_CTLr_CLR
#define ARLA_SRCH_CTLr_SET BCM53101_A0_ARLA_SRCH_CTLr_SET
#define ARLA_SRCH_CTLr_GET BCM53101_A0_ARLA_SRCH_CTLr_GET
#define ARLA_SRCH_CTLr_ARLA_SRCH_VLIDf_GET BCM53101_A0_ARLA_SRCH_CTLr_ARLA_SRCH_VLIDf_GET
#define ARLA_SRCH_CTLr_ARLA_SRCH_VLIDf_SET BCM53101_A0_ARLA_SRCH_CTLr_ARLA_SRCH_VLIDf_SET
#define ARLA_SRCH_CTLr_RESERVEDf_GET BCM53101_A0_ARLA_SRCH_CTLr_RESERVEDf_GET
#define ARLA_SRCH_CTLr_RESERVEDf_SET BCM53101_A0_ARLA_SRCH_CTLr_RESERVEDf_SET
#define ARLA_SRCH_CTLr_ARLA_SRCH_STDNf_GET BCM53101_A0_ARLA_SRCH_CTLr_ARLA_SRCH_STDNf_GET
#define ARLA_SRCH_CTLr_ARLA_SRCH_STDNf_SET BCM53101_A0_ARLA_SRCH_CTLr_ARLA_SRCH_STDNf_SET
#define READ_ARLA_SRCH_CTLr BCM53101_A0_READ_ARLA_SRCH_CTLr
#define WRITE_ARLA_SRCH_CTLr BCM53101_A0_WRITE_ARLA_SRCH_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_ARLA_SRCH_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  ARLA_SRCH_RSLT
 * BLOCKS:   SYS
 * DESC:     ARL Search Result 0 Register
 * SIZE:     32
 * FIELDS:
 *     PORTID           Port IdentificationIf system turn on multicast address scheme and MAC address is multicast type and, the bit[8:0] stands for Multicast Group Forward Portmap.Bit[8] : CPU Port/MII PortBit[7:0] : Port 7~0If system turn off multicast address scheme and MAC address is unicast type and, the bit[8:0] stands for Unicast Forward PortID.Bit[8:4] : ReservedBit[3:0] : Port ID/Port Number which identifies where the station with unique MACADDR_N is connected.
 *     ARL_CON          ARL control bit for ARL control mode enhancement
 *     ARLA_SRCH_RSLT_PRI Priority Bit For MAC based QOS.
 *     ARLA_SRCH_RSLT_AGE Age.Set to indicate that an address entry has been learned or accessed.Reset by the internal aging algorithm. If the internal aging process detects a Valid entry has remained unused for the period set by the AGE_TIME, and the entry has not been marked as Static, the entry will have the Valid bit cleared. The Age bit is ignored if the entry has been marked as Static.Multicast group Forward Portmap bit8 for CPU.
 *     ARLA_SRCH_RSLT_STATIC Static.Set to indicate that the entry is controlled by the external management processor, and automatic learning and aging of the entry will not take place.When cleared, the internal learning and aging process will control the validity of the entry.
 *     ARLA_SRCH_RSLT_VLID Valid.Set to indicate that a valid MAC address is stored in the MACADDR field, and that the entry has not aged out or been freed by the management processor.Reset when an entry is empty, the address has been aged out by the internal aging process, or the external management processor has invalidated the entry.Automatic learning will take place if an address location is not valid and has not been marked as static.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_ARLA_SRCH_RSLTr 0x00000568

#define BCM53101_A0_ARLA_SRCH_RSLTr_SIZE 4

/*
 * This structure should be used to declare and program ARLA_SRCH_RSLT.
 *
 */
typedef union BCM53101_A0_ARLA_SRCH_RSLTr_s {
	uint32_t v[1];
	uint32_t arla_srch_rslt[1];
	uint32_t _arla_srch_rslt;
} BCM53101_A0_ARLA_SRCH_RSLTr_t;

#define BCM53101_A0_ARLA_SRCH_RSLTr_CLR(r) (r).arla_srch_rslt[0] = 0
#define BCM53101_A0_ARLA_SRCH_RSLTr_SET(r,d) (r).arla_srch_rslt[0] = d
#define BCM53101_A0_ARLA_SRCH_RSLTr_GET(r) (r).arla_srch_rslt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_ARLA_SRCH_RSLTr_PORTIDf_GET(r) (((r).arla_srch_rslt[0]) & 0x1ff)
#define BCM53101_A0_ARLA_SRCH_RSLTr_PORTIDf_SET(r,f) (r).arla_srch_rslt[0]=(((r).arla_srch_rslt[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_ARLA_SRCH_RSLTr_ARL_CONf_GET(r) ((((r).arla_srch_rslt[0]) >> 9) & 0x3)
#define BCM53101_A0_ARLA_SRCH_RSLTr_ARL_CONf_SET(r,f) (r).arla_srch_rslt[0]=(((r).arla_srch_rslt[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM53101_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIf_GET(r) ((((r).arla_srch_rslt[0]) >> 11) & 0x7)
#define BCM53101_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIf_SET(r,f) (r).arla_srch_rslt[0]=(((r).arla_srch_rslt[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))
#define BCM53101_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_AGEf_GET(r) ((((r).arla_srch_rslt[0]) >> 14) & 0x1)
#define BCM53101_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_AGEf_SET(r,f) (r).arla_srch_rslt[0]=(((r).arla_srch_rslt[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_GET(r) ((((r).arla_srch_rslt[0]) >> 15) & 0x1)
#define BCM53101_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_SET(r,f) (r).arla_srch_rslt[0]=(((r).arla_srch_rslt[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53101_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_GET(r) ((((r).arla_srch_rslt[0]) >> 16) & 0x1)
#define BCM53101_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_SET(r,f) (r).arla_srch_rslt[0]=(((r).arla_srch_rslt[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53101_A0_ARLA_SRCH_RSLTr_RESERVEDf_GET(r) ((((r).arla_srch_rslt[0]) >> 17) & 0x7fff)
#define BCM53101_A0_ARLA_SRCH_RSLTr_RESERVEDf_SET(r,f) (r).arla_srch_rslt[0]=(((r).arla_srch_rslt[0] & ~((uint32_t)0x7fff << 17)) | ((((uint32_t)f) & 0x7fff) << 17))

/*
 * These macros can be used to access ARLA_SRCH_RSLT.
 *
 */
#define BCM53101_A0_READ_ARLA_SRCH_RSLTr(u,r) cdk_robo_reg_read(u,BCM53101_A0_ARLA_SRCH_RSLTr,(r._arla_srch_rslt),4)
#define BCM53101_A0_WRITE_ARLA_SRCH_RSLTr(u,r) cdk_robo_reg_write(u,BCM53101_A0_ARLA_SRCH_RSLTr,&(r._arla_srch_rslt),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_SRCH_RSLTr BCM53101_A0_ARLA_SRCH_RSLTr
#define ARLA_SRCH_RSLTr_SIZE BCM53101_A0_ARLA_SRCH_RSLTr_SIZE
typedef BCM53101_A0_ARLA_SRCH_RSLTr_t ARLA_SRCH_RSLTr_t;
#define ARLA_SRCH_RSLTr_CLR BCM53101_A0_ARLA_SRCH_RSLTr_CLR
#define ARLA_SRCH_RSLTr_SET BCM53101_A0_ARLA_SRCH_RSLTr_SET
#define ARLA_SRCH_RSLTr_GET BCM53101_A0_ARLA_SRCH_RSLTr_GET
#define ARLA_SRCH_RSLTr_PORTIDf_GET BCM53101_A0_ARLA_SRCH_RSLTr_PORTIDf_GET
#define ARLA_SRCH_RSLTr_PORTIDf_SET BCM53101_A0_ARLA_SRCH_RSLTr_PORTIDf_SET
#define ARLA_SRCH_RSLTr_ARL_CONf_GET BCM53101_A0_ARLA_SRCH_RSLTr_ARL_CONf_GET
#define ARLA_SRCH_RSLTr_ARL_CONf_SET BCM53101_A0_ARLA_SRCH_RSLTr_ARL_CONf_SET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIf_GET BCM53101_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIf_GET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIf_SET BCM53101_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_PRIf_SET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_AGEf_GET BCM53101_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_AGEf_GET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_AGEf_SET BCM53101_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_AGEf_SET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_GET BCM53101_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_GET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_SET BCM53101_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_STATICf_SET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_GET BCM53101_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_GET
#define ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_SET BCM53101_A0_ARLA_SRCH_RSLTr_ARLA_SRCH_RSLT_VLIDf_SET
#define ARLA_SRCH_RSLTr_RESERVEDf_GET BCM53101_A0_ARLA_SRCH_RSLTr_RESERVEDf_GET
#define ARLA_SRCH_RSLTr_RESERVEDf_SET BCM53101_A0_ARLA_SRCH_RSLTr_RESERVEDf_SET
#define READ_ARLA_SRCH_RSLTr BCM53101_A0_READ_ARLA_SRCH_RSLTr
#define WRITE_ARLA_SRCH_RSLTr BCM53101_A0_WRITE_ARLA_SRCH_RSLTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_ARLA_SRCH_RSLTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  ARLA_SRCH_RSLT_0_MACVID
 * BLOCKS:   SYS
 * DESC:     ARL Search MAC/VID Result 0 Register
 * SIZE:     64
 * FIELDS:
 *     ARLA_SRCH_MACADDR MAC Address.
 *     ARLA_SRCH_RSLT_VID ARL SEARCH VID RESULT.The ARL Search VID Result Registers Keep the VID field in Valid ARL Entry indicated by ARL Search Function.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_ARLA_SRCH_RSLT_0_MACVIDr 0x00000560

#define BCM53101_A0_ARLA_SRCH_RSLT_0_MACVIDr_SIZE 8

/*
 * This structure should be used to declare and program ARLA_SRCH_RSLT_0_MACVID.
 *
 */
typedef union BCM53101_A0_ARLA_SRCH_RSLT_0_MACVIDr_s {
	uint32_t v[2];
	uint32_t arla_srch_rslt_0_macvid[2];
	uint32_t _arla_srch_rslt_0_macvid;
} BCM53101_A0_ARLA_SRCH_RSLT_0_MACVIDr_t;

#define BCM53101_A0_ARLA_SRCH_RSLT_0_MACVIDr_CLR(r) CDK_MEMSET(&((r)._arla_srch_rslt_0_macvid), 0, sizeof(BCM53101_A0_ARLA_SRCH_RSLT_0_MACVIDr_t))
#define BCM53101_A0_ARLA_SRCH_RSLT_0_MACVIDr_SET(r,i,d) (r).arla_srch_rslt_0_macvid[i] = d
#define BCM53101_A0_ARLA_SRCH_RSLT_0_MACVIDr_GET(r,i) (r).arla_srch_rslt_0_macvid[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_MACADDRf_GET(r,a) cdk_field_get((r).arla_srch_rslt_0_macvid,0,47,a)
#define BCM53101_A0_ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_MACADDRf_SET(r,a) cdk_field_set((r).arla_srch_rslt_0_macvid,0,47,a)
#define BCM53101_A0_ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_RSLT_VIDf_GET(r) ((((r).arla_srch_rslt_0_macvid[1]) >> 16) & 0xfff)
#define BCM53101_A0_ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_RSLT_VIDf_SET(r,f) (r).arla_srch_rslt_0_macvid[1]=(((r).arla_srch_rslt_0_macvid[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53101_A0_ARLA_SRCH_RSLT_0_MACVIDr_RESERVEDf_GET(r) ((((r).arla_srch_rslt_0_macvid[1]) >> 28) & 0xf)
#define BCM53101_A0_ARLA_SRCH_RSLT_0_MACVIDr_RESERVEDf_SET(r,f) (r).arla_srch_rslt_0_macvid[1]=(((r).arla_srch_rslt_0_macvid[1] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access ARLA_SRCH_RSLT_0_MACVID.
 *
 */
#define BCM53101_A0_READ_ARLA_SRCH_RSLT_0_MACVIDr(u,r) cdk_robo_reg_read(u,BCM53101_A0_ARLA_SRCH_RSLT_0_MACVIDr,(r._arla_srch_rslt_0_macvid),8)
#define BCM53101_A0_WRITE_ARLA_SRCH_RSLT_0_MACVIDr(u,r) cdk_robo_reg_write(u,BCM53101_A0_ARLA_SRCH_RSLT_0_MACVIDr,&(r._arla_srch_rslt_0_macvid),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_SRCH_RSLT_0_MACVIDr BCM53101_A0_ARLA_SRCH_RSLT_0_MACVIDr
#define ARLA_SRCH_RSLT_0_MACVIDr_SIZE BCM53101_A0_ARLA_SRCH_RSLT_0_MACVIDr_SIZE
typedef BCM53101_A0_ARLA_SRCH_RSLT_0_MACVIDr_t ARLA_SRCH_RSLT_0_MACVIDr_t;
#define ARLA_SRCH_RSLT_0_MACVIDr_CLR BCM53101_A0_ARLA_SRCH_RSLT_0_MACVIDr_CLR
#define ARLA_SRCH_RSLT_0_MACVIDr_SET BCM53101_A0_ARLA_SRCH_RSLT_0_MACVIDr_SET
#define ARLA_SRCH_RSLT_0_MACVIDr_GET BCM53101_A0_ARLA_SRCH_RSLT_0_MACVIDr_GET
#define ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_MACADDRf_GET BCM53101_A0_ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_MACADDRf_GET
#define ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_MACADDRf_SET BCM53101_A0_ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_MACADDRf_SET
#define ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_RSLT_VIDf_GET BCM53101_A0_ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_RSLT_VIDf_GET
#define ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_RSLT_VIDf_SET BCM53101_A0_ARLA_SRCH_RSLT_0_MACVIDr_ARLA_SRCH_RSLT_VIDf_SET
#define ARLA_SRCH_RSLT_0_MACVIDr_RESERVEDf_GET BCM53101_A0_ARLA_SRCH_RSLT_0_MACVIDr_RESERVEDf_GET
#define ARLA_SRCH_RSLT_0_MACVIDr_RESERVEDf_SET BCM53101_A0_ARLA_SRCH_RSLT_0_MACVIDr_RESERVEDf_SET
#define READ_ARLA_SRCH_RSLT_0_MACVIDr BCM53101_A0_READ_ARLA_SRCH_RSLT_0_MACVIDr
#define WRITE_ARLA_SRCH_RSLT_0_MACVIDr BCM53101_A0_WRITE_ARLA_SRCH_RSLT_0_MACVIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_ARLA_SRCH_RSLT_0_MACVIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  ARLA_SRCH_RSLT_1
 * BLOCKS:   SYS
 * DESC:     ARL Search Result 1 Register
 * SIZE:     32
 * FIELDS:
 *     PORTID           Port IdentificationIf system turn on multicast address scheme and MAC address is multicast type and, the bit[8:0] stands for Multicast Group Forward Portmap.Bit[8] : CPU Port/MII PortBit[7:0] : Port 7~0If system turn off multicast address scheme and MAC address is unicast type and, the bit[8:0] stands for Unicast Forward PortID.Bit[8:4] : ReservedBit[3:0] : Port ID/Port Number which identifies where the station with unique MACADDR_N is connected.
 *     ARL_CON          ARL control bit for ARL control mode enhancement
 *     ARLA_SRCH_RSLT_PRI Priority Bit For MAC based QOS.
 *     ARLA_SRCH_RSLT_AGE Age.Set to indicate that an address entry has been learned or accessed.Reset by the internal aging algorithm. If the internal aging process detects a Valid entry has remained unused for the period set by the AGE_TIME, and the entry has not been marked as Static, the entry will have the Valid bit cleared. The Age bit is ignored if the entry has been marked as Static.Multicast group Forward Portmap bit8 for CPU.
 *     ARLA_SRCH_RSLT_STATIC Static.Set to indicate that the entry is controlled by the external management processor, and automatic learning and aging of the entry will not take place.When cleared, the internal learning and aging process will control the validity of the entry.
 *     ARLA_SRCH_RSLT_VLID Valid.Set to indicate that a valid MAC address is stored in the MACADDR field, and that the entry has not aged out or been freed by the management processor.Reset when an entry is empty, the address has been aged out by the internal aging process, or the external management processor has invalidated the entry. Automatic learning will take place if an address location is not valid and has not been marked as static.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_ARLA_SRCH_RSLT_1r 0x00000578

#define BCM53101_A0_ARLA_SRCH_RSLT_1r_SIZE 4

/*
 * This structure should be used to declare and program ARLA_SRCH_RSLT_1.
 *
 */
typedef union BCM53101_A0_ARLA_SRCH_RSLT_1r_s {
	uint32_t v[1];
	uint32_t arla_srch_rslt_1[1];
	uint32_t _arla_srch_rslt_1;
} BCM53101_A0_ARLA_SRCH_RSLT_1r_t;

#define BCM53101_A0_ARLA_SRCH_RSLT_1r_CLR(r) (r).arla_srch_rslt_1[0] = 0
#define BCM53101_A0_ARLA_SRCH_RSLT_1r_SET(r,d) (r).arla_srch_rslt_1[0] = d
#define BCM53101_A0_ARLA_SRCH_RSLT_1r_GET(r) (r).arla_srch_rslt_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_ARLA_SRCH_RSLT_1r_PORTIDf_GET(r) (((r).arla_srch_rslt_1[0]) & 0x1ff)
#define BCM53101_A0_ARLA_SRCH_RSLT_1r_PORTIDf_SET(r,f) (r).arla_srch_rslt_1[0]=(((r).arla_srch_rslt_1[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_ARLA_SRCH_RSLT_1r_ARL_CONf_GET(r) ((((r).arla_srch_rslt_1[0]) >> 9) & 0x3)
#define BCM53101_A0_ARLA_SRCH_RSLT_1r_ARL_CONf_SET(r,f) (r).arla_srch_rslt_1[0]=(((r).arla_srch_rslt_1[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9))
#define BCM53101_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_PRIf_GET(r) ((((r).arla_srch_rslt_1[0]) >> 11) & 0x7)
#define BCM53101_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_PRIf_SET(r,f) (r).arla_srch_rslt_1[0]=(((r).arla_srch_rslt_1[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11))
#define BCM53101_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_AGEf_GET(r) ((((r).arla_srch_rslt_1[0]) >> 14) & 0x1)
#define BCM53101_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_AGEf_SET(r,f) (r).arla_srch_rslt_1[0]=(((r).arla_srch_rslt_1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_STATICf_GET(r) ((((r).arla_srch_rslt_1[0]) >> 15) & 0x1)
#define BCM53101_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_STATICf_SET(r,f) (r).arla_srch_rslt_1[0]=(((r).arla_srch_rslt_1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53101_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_VLIDf_GET(r) ((((r).arla_srch_rslt_1[0]) >> 16) & 0x1)
#define BCM53101_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_VLIDf_SET(r,f) (r).arla_srch_rslt_1[0]=(((r).arla_srch_rslt_1[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53101_A0_ARLA_SRCH_RSLT_1r_RESERVEDf_GET(r) ((((r).arla_srch_rslt_1[0]) >> 17) & 0x7fff)
#define BCM53101_A0_ARLA_SRCH_RSLT_1r_RESERVEDf_SET(r,f) (r).arla_srch_rslt_1[0]=(((r).arla_srch_rslt_1[0] & ~((uint32_t)0x7fff << 17)) | ((((uint32_t)f) & 0x7fff) << 17))

/*
 * These macros can be used to access ARLA_SRCH_RSLT_1.
 *
 */
#define BCM53101_A0_READ_ARLA_SRCH_RSLT_1r(u,r) cdk_robo_reg_read(u,BCM53101_A0_ARLA_SRCH_RSLT_1r,(r._arla_srch_rslt_1),4)
#define BCM53101_A0_WRITE_ARLA_SRCH_RSLT_1r(u,r) cdk_robo_reg_write(u,BCM53101_A0_ARLA_SRCH_RSLT_1r,&(r._arla_srch_rslt_1),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_SRCH_RSLT_1r BCM53101_A0_ARLA_SRCH_RSLT_1r
#define ARLA_SRCH_RSLT_1r_SIZE BCM53101_A0_ARLA_SRCH_RSLT_1r_SIZE
typedef BCM53101_A0_ARLA_SRCH_RSLT_1r_t ARLA_SRCH_RSLT_1r_t;
#define ARLA_SRCH_RSLT_1r_CLR BCM53101_A0_ARLA_SRCH_RSLT_1r_CLR
#define ARLA_SRCH_RSLT_1r_SET BCM53101_A0_ARLA_SRCH_RSLT_1r_SET
#define ARLA_SRCH_RSLT_1r_GET BCM53101_A0_ARLA_SRCH_RSLT_1r_GET
#define ARLA_SRCH_RSLT_1r_PORTIDf_GET BCM53101_A0_ARLA_SRCH_RSLT_1r_PORTIDf_GET
#define ARLA_SRCH_RSLT_1r_PORTIDf_SET BCM53101_A0_ARLA_SRCH_RSLT_1r_PORTIDf_SET
#define ARLA_SRCH_RSLT_1r_ARL_CONf_GET BCM53101_A0_ARLA_SRCH_RSLT_1r_ARL_CONf_GET
#define ARLA_SRCH_RSLT_1r_ARL_CONf_SET BCM53101_A0_ARLA_SRCH_RSLT_1r_ARL_CONf_SET
#define ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_PRIf_GET BCM53101_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_PRIf_GET
#define ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_PRIf_SET BCM53101_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_PRIf_SET
#define ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_AGEf_GET BCM53101_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_AGEf_GET
#define ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_AGEf_SET BCM53101_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_AGEf_SET
#define ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_STATICf_GET BCM53101_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_STATICf_GET
#define ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_STATICf_SET BCM53101_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_STATICf_SET
#define ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_VLIDf_GET BCM53101_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_VLIDf_GET
#define ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_VLIDf_SET BCM53101_A0_ARLA_SRCH_RSLT_1r_ARLA_SRCH_RSLT_VLIDf_SET
#define ARLA_SRCH_RSLT_1r_RESERVEDf_GET BCM53101_A0_ARLA_SRCH_RSLT_1r_RESERVEDf_GET
#define ARLA_SRCH_RSLT_1r_RESERVEDf_SET BCM53101_A0_ARLA_SRCH_RSLT_1r_RESERVEDf_SET
#define READ_ARLA_SRCH_RSLT_1r BCM53101_A0_READ_ARLA_SRCH_RSLT_1r
#define WRITE_ARLA_SRCH_RSLT_1r BCM53101_A0_WRITE_ARLA_SRCH_RSLT_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_ARLA_SRCH_RSLT_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  ARLA_SRCH_RSLT_1_MACVID
 * BLOCKS:   SYS
 * DESC:     ARL Search MAC/VID Result 1 Register
 * SIZE:     64
 * FIELDS:
 *     ARLA_SRCH_MACADDR MAC Address.
 *     ARLA_SRCH_RSLT_VID ARL SEARCH VID RESULT.The ARL Search VID Result Registers Keep the VID field in Valid ARL Entry indicated by ARL Search Function.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_ARLA_SRCH_RSLT_1_MACVIDr 0x00000570

#define BCM53101_A0_ARLA_SRCH_RSLT_1_MACVIDr_SIZE 8

/*
 * This structure should be used to declare and program ARLA_SRCH_RSLT_1_MACVID.
 *
 */
typedef union BCM53101_A0_ARLA_SRCH_RSLT_1_MACVIDr_s {
	uint32_t v[2];
	uint32_t arla_srch_rslt_1_macvid[2];
	uint32_t _arla_srch_rslt_1_macvid;
} BCM53101_A0_ARLA_SRCH_RSLT_1_MACVIDr_t;

#define BCM53101_A0_ARLA_SRCH_RSLT_1_MACVIDr_CLR(r) CDK_MEMSET(&((r)._arla_srch_rslt_1_macvid), 0, sizeof(BCM53101_A0_ARLA_SRCH_RSLT_1_MACVIDr_t))
#define BCM53101_A0_ARLA_SRCH_RSLT_1_MACVIDr_SET(r,i,d) (r).arla_srch_rslt_1_macvid[i] = d
#define BCM53101_A0_ARLA_SRCH_RSLT_1_MACVIDr_GET(r,i) (r).arla_srch_rslt_1_macvid[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_MACADDRf_GET(r,a) cdk_field_get((r).arla_srch_rslt_1_macvid,0,47,a)
#define BCM53101_A0_ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_MACADDRf_SET(r,a) cdk_field_set((r).arla_srch_rslt_1_macvid,0,47,a)
#define BCM53101_A0_ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_RSLT_VIDf_GET(r) ((((r).arla_srch_rslt_1_macvid[1]) >> 16) & 0xfff)
#define BCM53101_A0_ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_RSLT_VIDf_SET(r,f) (r).arla_srch_rslt_1_macvid[1]=(((r).arla_srch_rslt_1_macvid[1] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53101_A0_ARLA_SRCH_RSLT_1_MACVIDr_RESERVEDf_GET(r) ((((r).arla_srch_rslt_1_macvid[1]) >> 28) & 0xf)
#define BCM53101_A0_ARLA_SRCH_RSLT_1_MACVIDr_RESERVEDf_SET(r,f) (r).arla_srch_rslt_1_macvid[1]=(((r).arla_srch_rslt_1_macvid[1] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access ARLA_SRCH_RSLT_1_MACVID.
 *
 */
#define BCM53101_A0_READ_ARLA_SRCH_RSLT_1_MACVIDr(u,r) cdk_robo_reg_read(u,BCM53101_A0_ARLA_SRCH_RSLT_1_MACVIDr,(r._arla_srch_rslt_1_macvid),8)
#define BCM53101_A0_WRITE_ARLA_SRCH_RSLT_1_MACVIDr(u,r) cdk_robo_reg_write(u,BCM53101_A0_ARLA_SRCH_RSLT_1_MACVIDr,&(r._arla_srch_rslt_1_macvid),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_SRCH_RSLT_1_MACVIDr BCM53101_A0_ARLA_SRCH_RSLT_1_MACVIDr
#define ARLA_SRCH_RSLT_1_MACVIDr_SIZE BCM53101_A0_ARLA_SRCH_RSLT_1_MACVIDr_SIZE
typedef BCM53101_A0_ARLA_SRCH_RSLT_1_MACVIDr_t ARLA_SRCH_RSLT_1_MACVIDr_t;
#define ARLA_SRCH_RSLT_1_MACVIDr_CLR BCM53101_A0_ARLA_SRCH_RSLT_1_MACVIDr_CLR
#define ARLA_SRCH_RSLT_1_MACVIDr_SET BCM53101_A0_ARLA_SRCH_RSLT_1_MACVIDr_SET
#define ARLA_SRCH_RSLT_1_MACVIDr_GET BCM53101_A0_ARLA_SRCH_RSLT_1_MACVIDr_GET
#define ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_MACADDRf_GET BCM53101_A0_ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_MACADDRf_GET
#define ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_MACADDRf_SET BCM53101_A0_ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_MACADDRf_SET
#define ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_RSLT_VIDf_GET BCM53101_A0_ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_RSLT_VIDf_GET
#define ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_RSLT_VIDf_SET BCM53101_A0_ARLA_SRCH_RSLT_1_MACVIDr_ARLA_SRCH_RSLT_VIDf_SET
#define ARLA_SRCH_RSLT_1_MACVIDr_RESERVEDf_GET BCM53101_A0_ARLA_SRCH_RSLT_1_MACVIDr_RESERVEDf_GET
#define ARLA_SRCH_RSLT_1_MACVIDr_RESERVEDf_SET BCM53101_A0_ARLA_SRCH_RSLT_1_MACVIDr_RESERVEDf_SET
#define READ_ARLA_SRCH_RSLT_1_MACVIDr BCM53101_A0_READ_ARLA_SRCH_RSLT_1_MACVIDr
#define WRITE_ARLA_SRCH_RSLT_1_MACVIDr BCM53101_A0_WRITE_ARLA_SRCH_RSLT_1_MACVIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_ARLA_SRCH_RSLT_1_MACVIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  ARLA_VID
 * BLOCKS:   SYS
 * DESC:     VID Index Register
 * SIZE:     16
 * FIELDS:
 *     ARLA_VIDTAB_INDX VID Index.The MAC address for which status is to be read or written.By writing the 48 bit SA or DA address upon MAC Address Index, upon 12 bit VID Index Register if 802.1Q is enabled, and initiating a read command, the complete ARL bin location is returned in the ARL Entry 0 locations and VID Entry0. Both ARL entries are 64 bits wide. Both VID entries are 12 bits wide.Initiating a write command will write the contents of ARL Entry 0/1 and VID Entry 0/1 to the specified bin location and will overwrite the current contents of the bin, regardless of the status of the Valid bit(s) in each entry.
 *     ARLA_VIDTAB_RSRV0 Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_ARLA_VIDr 0x00000508

#define BCM53101_A0_ARLA_VIDr_SIZE 2

/*
 * This structure should be used to declare and program ARLA_VID.
 *
 */
typedef union BCM53101_A0_ARLA_VIDr_s {
	uint32_t v[1];
	uint32_t arla_vid[1];
	uint32_t _arla_vid;
} BCM53101_A0_ARLA_VIDr_t;

#define BCM53101_A0_ARLA_VIDr_CLR(r) (r).arla_vid[0] = 0
#define BCM53101_A0_ARLA_VIDr_SET(r,d) (r).arla_vid[0] = d
#define BCM53101_A0_ARLA_VIDr_GET(r) (r).arla_vid[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_ARLA_VIDr_ARLA_VIDTAB_INDXf_GET(r) (((r).arla_vid[0]) & 0xfff)
#define BCM53101_A0_ARLA_VIDr_ARLA_VIDTAB_INDXf_SET(r,f) (r).arla_vid[0]=(((r).arla_vid[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53101_A0_ARLA_VIDr_ARLA_VIDTAB_RSRV0f_GET(r) ((((r).arla_vid[0]) >> 12) & 0xf)
#define BCM53101_A0_ARLA_VIDr_ARLA_VIDTAB_RSRV0f_SET(r,f) (r).arla_vid[0]=(((r).arla_vid[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access ARLA_VID.
 *
 */
#define BCM53101_A0_READ_ARLA_VIDr(u,r) cdk_robo_reg_read(u,BCM53101_A0_ARLA_VIDr,(r._arla_vid),2)
#define BCM53101_A0_WRITE_ARLA_VIDr(u,r) cdk_robo_reg_write(u,BCM53101_A0_ARLA_VIDr,&(r._arla_vid),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_VIDr BCM53101_A0_ARLA_VIDr
#define ARLA_VIDr_SIZE BCM53101_A0_ARLA_VIDr_SIZE
typedef BCM53101_A0_ARLA_VIDr_t ARLA_VIDr_t;
#define ARLA_VIDr_CLR BCM53101_A0_ARLA_VIDr_CLR
#define ARLA_VIDr_SET BCM53101_A0_ARLA_VIDr_SET
#define ARLA_VIDr_GET BCM53101_A0_ARLA_VIDr_GET
#define ARLA_VIDr_ARLA_VIDTAB_INDXf_GET BCM53101_A0_ARLA_VIDr_ARLA_VIDTAB_INDXf_GET
#define ARLA_VIDr_ARLA_VIDTAB_INDXf_SET BCM53101_A0_ARLA_VIDr_ARLA_VIDTAB_INDXf_SET
#define ARLA_VIDr_ARLA_VIDTAB_RSRV0f_GET BCM53101_A0_ARLA_VIDr_ARLA_VIDTAB_RSRV0f_GET
#define ARLA_VIDr_ARLA_VIDTAB_RSRV0f_SET BCM53101_A0_ARLA_VIDr_ARLA_VIDTAB_RSRV0f_SET
#define READ_ARLA_VIDr BCM53101_A0_READ_ARLA_VIDr
#define WRITE_ARLA_VIDr BCM53101_A0_WRITE_ARLA_VIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_ARLA_VIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  ARLA_VTBL_ADDR
 * BLOCKS:   SYS
 * DESC:     VTBL Address Index Register
 * SIZE:     16
 * FIELDS:
 *     VTBL_ADDR_INDEX  VLAN Table Address Index.The VLAN Table Address Index Register is used to access VLAN Table Entry.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_ARLA_VTBL_ADDRr 0x00000581

#define BCM53101_A0_ARLA_VTBL_ADDRr_SIZE 2

/*
 * This structure should be used to declare and program ARLA_VTBL_ADDR.
 *
 */
typedef union BCM53101_A0_ARLA_VTBL_ADDRr_s {
	uint32_t v[1];
	uint32_t arla_vtbl_addr[1];
	uint32_t _arla_vtbl_addr;
} BCM53101_A0_ARLA_VTBL_ADDRr_t;

#define BCM53101_A0_ARLA_VTBL_ADDRr_CLR(r) (r).arla_vtbl_addr[0] = 0
#define BCM53101_A0_ARLA_VTBL_ADDRr_SET(r,d) (r).arla_vtbl_addr[0] = d
#define BCM53101_A0_ARLA_VTBL_ADDRr_GET(r) (r).arla_vtbl_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_ARLA_VTBL_ADDRr_VTBL_ADDR_INDEXf_GET(r) (((r).arla_vtbl_addr[0]) & 0xfff)
#define BCM53101_A0_ARLA_VTBL_ADDRr_VTBL_ADDR_INDEXf_SET(r,f) (r).arla_vtbl_addr[0]=(((r).arla_vtbl_addr[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53101_A0_ARLA_VTBL_ADDRr_RESERVEDf_GET(r) ((((r).arla_vtbl_addr[0]) >> 12) & 0xf)
#define BCM53101_A0_ARLA_VTBL_ADDRr_RESERVEDf_SET(r,f) (r).arla_vtbl_addr[0]=(((r).arla_vtbl_addr[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access ARLA_VTBL_ADDR.
 *
 */
#define BCM53101_A0_READ_ARLA_VTBL_ADDRr(u,r) cdk_robo_reg_read(u,BCM53101_A0_ARLA_VTBL_ADDRr,(r._arla_vtbl_addr),2)
#define BCM53101_A0_WRITE_ARLA_VTBL_ADDRr(u,r) cdk_robo_reg_write(u,BCM53101_A0_ARLA_VTBL_ADDRr,&(r._arla_vtbl_addr),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_VTBL_ADDRr BCM53101_A0_ARLA_VTBL_ADDRr
#define ARLA_VTBL_ADDRr_SIZE BCM53101_A0_ARLA_VTBL_ADDRr_SIZE
typedef BCM53101_A0_ARLA_VTBL_ADDRr_t ARLA_VTBL_ADDRr_t;
#define ARLA_VTBL_ADDRr_CLR BCM53101_A0_ARLA_VTBL_ADDRr_CLR
#define ARLA_VTBL_ADDRr_SET BCM53101_A0_ARLA_VTBL_ADDRr_SET
#define ARLA_VTBL_ADDRr_GET BCM53101_A0_ARLA_VTBL_ADDRr_GET
#define ARLA_VTBL_ADDRr_VTBL_ADDR_INDEXf_GET BCM53101_A0_ARLA_VTBL_ADDRr_VTBL_ADDR_INDEXf_GET
#define ARLA_VTBL_ADDRr_VTBL_ADDR_INDEXf_SET BCM53101_A0_ARLA_VTBL_ADDRr_VTBL_ADDR_INDEXf_SET
#define ARLA_VTBL_ADDRr_RESERVEDf_GET BCM53101_A0_ARLA_VTBL_ADDRr_RESERVEDf_GET
#define ARLA_VTBL_ADDRr_RESERVEDf_SET BCM53101_A0_ARLA_VTBL_ADDRr_RESERVEDf_SET
#define READ_ARLA_VTBL_ADDRr BCM53101_A0_READ_ARLA_VTBL_ADDRr
#define WRITE_ARLA_VTBL_ADDRr BCM53101_A0_WRITE_ARLA_VTBL_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_ARLA_VTBL_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  ARLA_VTBL_ENTRY
 * BLOCKS:   SYS
 * DESC:     VTBL Entry Register
 * SIZE:     32
 * FIELDS:
 *     FWD_MAP          Forward PORT MAP.The VLAN-tagged Frame is allowed to be forwarded to the destination ports corresponding bits set in the Map.Bits5-0: Port 5-0.Bits7-6: Reserved.Bit8: Management Port.
 *     UNTAG_MAP        Untag Port Map.The VLAN-tagged Frame forward to the destination ports corresponding bits set in the Map will be untagged.Bits5-0: Port 5-0.Bits7-6: Reserved.Bit8: Management Port.
 *     MSPT_INDEX       Index for 8 spanning tree.
 *     FWD_MODE         It indicate wheter the packet forwarding should be based on VLANmembership of based on ARL flow.1: Based on VLAN membership(excluding ingress port)0: Based on ARL flow.Note that the VLAN membership based forwarding mode is only used forcertain ISP tagged packets received from ISP port when Falcon isoperating in Double Tag mode.
 *     POLICER_EN       VLAN policer EnableThis bit specify this VLAN entry is target for ingress policing.1 : enable0 : disable
 *     POLICER_ID       VLAN policer IDThis bit specify the the policer ID (bucket0 or bucket1) when police_en = 10: bucket01: bucket1
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_ARLA_VTBL_ENTRYr 0x00000583

#define BCM53101_A0_ARLA_VTBL_ENTRYr_SIZE 4

/*
 * This structure should be used to declare and program ARLA_VTBL_ENTRY.
 *
 */
typedef union BCM53101_A0_ARLA_VTBL_ENTRYr_s {
	uint32_t v[1];
	uint32_t arla_vtbl_entry[1];
	uint32_t _arla_vtbl_entry;
} BCM53101_A0_ARLA_VTBL_ENTRYr_t;

#define BCM53101_A0_ARLA_VTBL_ENTRYr_CLR(r) (r).arla_vtbl_entry[0] = 0
#define BCM53101_A0_ARLA_VTBL_ENTRYr_SET(r,d) (r).arla_vtbl_entry[0] = d
#define BCM53101_A0_ARLA_VTBL_ENTRYr_GET(r) (r).arla_vtbl_entry[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_ARLA_VTBL_ENTRYr_FWD_MAPf_GET(r) (((r).arla_vtbl_entry[0]) & 0x1ff)
#define BCM53101_A0_ARLA_VTBL_ENTRYr_FWD_MAPf_SET(r,f) (r).arla_vtbl_entry[0]=(((r).arla_vtbl_entry[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_ARLA_VTBL_ENTRYr_UNTAG_MAPf_GET(r) ((((r).arla_vtbl_entry[0]) >> 9) & 0x1ff)
#define BCM53101_A0_ARLA_VTBL_ENTRYr_UNTAG_MAPf_SET(r,f) (r).arla_vtbl_entry[0]=(((r).arla_vtbl_entry[0] & ~((uint32_t)0x1ff << 9)) | ((((uint32_t)f) & 0x1ff) << 9))
#define BCM53101_A0_ARLA_VTBL_ENTRYr_MSPT_INDEXf_GET(r) ((((r).arla_vtbl_entry[0]) >> 18) & 0x7)
#define BCM53101_A0_ARLA_VTBL_ENTRYr_MSPT_INDEXf_SET(r,f) (r).arla_vtbl_entry[0]=(((r).arla_vtbl_entry[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM53101_A0_ARLA_VTBL_ENTRYr_FWD_MODEf_GET(r) ((((r).arla_vtbl_entry[0]) >> 21) & 0x1)
#define BCM53101_A0_ARLA_VTBL_ENTRYr_FWD_MODEf_SET(r,f) (r).arla_vtbl_entry[0]=(((r).arla_vtbl_entry[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM53101_A0_ARLA_VTBL_ENTRYr_POLICER_ENf_GET(r) ((((r).arla_vtbl_entry[0]) >> 22) & 0x1)
#define BCM53101_A0_ARLA_VTBL_ENTRYr_POLICER_ENf_SET(r,f) (r).arla_vtbl_entry[0]=(((r).arla_vtbl_entry[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM53101_A0_ARLA_VTBL_ENTRYr_POLICER_IDf_GET(r) ((((r).arla_vtbl_entry[0]) >> 23) & 0x1)
#define BCM53101_A0_ARLA_VTBL_ENTRYr_POLICER_IDf_SET(r,f) (r).arla_vtbl_entry[0]=(((r).arla_vtbl_entry[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM53101_A0_ARLA_VTBL_ENTRYr_RESERVEDf_GET(r) ((((r).arla_vtbl_entry[0]) >> 24) & 0xff)
#define BCM53101_A0_ARLA_VTBL_ENTRYr_RESERVEDf_SET(r,f) (r).arla_vtbl_entry[0]=(((r).arla_vtbl_entry[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access ARLA_VTBL_ENTRY.
 *
 */
#define BCM53101_A0_READ_ARLA_VTBL_ENTRYr(u,r) cdk_robo_reg_read(u,BCM53101_A0_ARLA_VTBL_ENTRYr,(r._arla_vtbl_entry),4)
#define BCM53101_A0_WRITE_ARLA_VTBL_ENTRYr(u,r) cdk_robo_reg_write(u,BCM53101_A0_ARLA_VTBL_ENTRYr,&(r._arla_vtbl_entry),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_VTBL_ENTRYr BCM53101_A0_ARLA_VTBL_ENTRYr
#define ARLA_VTBL_ENTRYr_SIZE BCM53101_A0_ARLA_VTBL_ENTRYr_SIZE
typedef BCM53101_A0_ARLA_VTBL_ENTRYr_t ARLA_VTBL_ENTRYr_t;
#define ARLA_VTBL_ENTRYr_CLR BCM53101_A0_ARLA_VTBL_ENTRYr_CLR
#define ARLA_VTBL_ENTRYr_SET BCM53101_A0_ARLA_VTBL_ENTRYr_SET
#define ARLA_VTBL_ENTRYr_GET BCM53101_A0_ARLA_VTBL_ENTRYr_GET
#define ARLA_VTBL_ENTRYr_FWD_MAPf_GET BCM53101_A0_ARLA_VTBL_ENTRYr_FWD_MAPf_GET
#define ARLA_VTBL_ENTRYr_FWD_MAPf_SET BCM53101_A0_ARLA_VTBL_ENTRYr_FWD_MAPf_SET
#define ARLA_VTBL_ENTRYr_UNTAG_MAPf_GET BCM53101_A0_ARLA_VTBL_ENTRYr_UNTAG_MAPf_GET
#define ARLA_VTBL_ENTRYr_UNTAG_MAPf_SET BCM53101_A0_ARLA_VTBL_ENTRYr_UNTAG_MAPf_SET
#define ARLA_VTBL_ENTRYr_MSPT_INDEXf_GET BCM53101_A0_ARLA_VTBL_ENTRYr_MSPT_INDEXf_GET
#define ARLA_VTBL_ENTRYr_MSPT_INDEXf_SET BCM53101_A0_ARLA_VTBL_ENTRYr_MSPT_INDEXf_SET
#define ARLA_VTBL_ENTRYr_FWD_MODEf_GET BCM53101_A0_ARLA_VTBL_ENTRYr_FWD_MODEf_GET
#define ARLA_VTBL_ENTRYr_FWD_MODEf_SET BCM53101_A0_ARLA_VTBL_ENTRYr_FWD_MODEf_SET
#define ARLA_VTBL_ENTRYr_POLICER_ENf_GET BCM53101_A0_ARLA_VTBL_ENTRYr_POLICER_ENf_GET
#define ARLA_VTBL_ENTRYr_POLICER_ENf_SET BCM53101_A0_ARLA_VTBL_ENTRYr_POLICER_ENf_SET
#define ARLA_VTBL_ENTRYr_POLICER_IDf_GET BCM53101_A0_ARLA_VTBL_ENTRYr_POLICER_IDf_GET
#define ARLA_VTBL_ENTRYr_POLICER_IDf_SET BCM53101_A0_ARLA_VTBL_ENTRYr_POLICER_IDf_SET
#define ARLA_VTBL_ENTRYr_RESERVEDf_GET BCM53101_A0_ARLA_VTBL_ENTRYr_RESERVEDf_GET
#define ARLA_VTBL_ENTRYr_RESERVEDf_SET BCM53101_A0_ARLA_VTBL_ENTRYr_RESERVEDf_SET
#define READ_ARLA_VTBL_ENTRYr BCM53101_A0_READ_ARLA_VTBL_ENTRYr
#define WRITE_ARLA_VTBL_ENTRYr BCM53101_A0_WRITE_ARLA_VTBL_ENTRYr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_ARLA_VTBL_ENTRYr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  ARLA_VTBL_RWCTRL
 * BLOCKS:   SYS
 * DESC:     VTBL Read/Write/Clear Control Register
 * SIZE:     8
 * FIELDS:
 *     ARLA_VTBL_RW_CLR VTBL Read/Write/Clear-table11 = Reserved10 = Clear-table01 = Read00 = Write
 *     RESERVED         Reserved
 *     ARLA_VTBL_STDN   Start/Done.Write as 1 to initiate a sequential search of the ARL entries, returning each entry that is currently occupied (Valid = 1 and AGE = 0) in the ARL Search Result register. Reading the ARL Search Result Register causes the ARL search to continue.The Lotus will clear this bit to indicate the entire ARL entry database has been searched.)
 *
 ******************************************************************************/
#define BCM53101_A0_ARLA_VTBL_RWCTRLr 0x00000580

#define BCM53101_A0_ARLA_VTBL_RWCTRLr_SIZE 1

/*
 * This structure should be used to declare and program ARLA_VTBL_RWCTRL.
 *
 */
typedef union BCM53101_A0_ARLA_VTBL_RWCTRLr_s {
	uint32_t v[1];
	uint32_t arla_vtbl_rwctrl[1];
	uint32_t _arla_vtbl_rwctrl;
} BCM53101_A0_ARLA_VTBL_RWCTRLr_t;

#define BCM53101_A0_ARLA_VTBL_RWCTRLr_CLR(r) (r).arla_vtbl_rwctrl[0] = 0
#define BCM53101_A0_ARLA_VTBL_RWCTRLr_SET(r,d) (r).arla_vtbl_rwctrl[0] = d
#define BCM53101_A0_ARLA_VTBL_RWCTRLr_GET(r) (r).arla_vtbl_rwctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_RW_CLRf_GET(r) (((r).arla_vtbl_rwctrl[0]) & 0x3)
#define BCM53101_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_RW_CLRf_SET(r,f) (r).arla_vtbl_rwctrl[0]=(((r).arla_vtbl_rwctrl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53101_A0_ARLA_VTBL_RWCTRLr_RESERVEDf_GET(r) ((((r).arla_vtbl_rwctrl[0]) >> 2) & 0x1f)
#define BCM53101_A0_ARLA_VTBL_RWCTRLr_RESERVEDf_SET(r,f) (r).arla_vtbl_rwctrl[0]=(((r).arla_vtbl_rwctrl[0] & ~((uint32_t)0x1f << 2)) | ((((uint32_t)f) & 0x1f) << 2))
#define BCM53101_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_STDNf_GET(r) ((((r).arla_vtbl_rwctrl[0]) >> 7) & 0x1)
#define BCM53101_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_STDNf_SET(r,f) (r).arla_vtbl_rwctrl[0]=(((r).arla_vtbl_rwctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access ARLA_VTBL_RWCTRL.
 *
 */
#define BCM53101_A0_READ_ARLA_VTBL_RWCTRLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_ARLA_VTBL_RWCTRLr,(r._arla_vtbl_rwctrl),1)
#define BCM53101_A0_WRITE_ARLA_VTBL_RWCTRLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_ARLA_VTBL_RWCTRLr,&(r._arla_vtbl_rwctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ARLA_VTBL_RWCTRLr BCM53101_A0_ARLA_VTBL_RWCTRLr
#define ARLA_VTBL_RWCTRLr_SIZE BCM53101_A0_ARLA_VTBL_RWCTRLr_SIZE
typedef BCM53101_A0_ARLA_VTBL_RWCTRLr_t ARLA_VTBL_RWCTRLr_t;
#define ARLA_VTBL_RWCTRLr_CLR BCM53101_A0_ARLA_VTBL_RWCTRLr_CLR
#define ARLA_VTBL_RWCTRLr_SET BCM53101_A0_ARLA_VTBL_RWCTRLr_SET
#define ARLA_VTBL_RWCTRLr_GET BCM53101_A0_ARLA_VTBL_RWCTRLr_GET
#define ARLA_VTBL_RWCTRLr_ARLA_VTBL_RW_CLRf_GET BCM53101_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_RW_CLRf_GET
#define ARLA_VTBL_RWCTRLr_ARLA_VTBL_RW_CLRf_SET BCM53101_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_RW_CLRf_SET
#define ARLA_VTBL_RWCTRLr_RESERVEDf_GET BCM53101_A0_ARLA_VTBL_RWCTRLr_RESERVEDf_GET
#define ARLA_VTBL_RWCTRLr_RESERVEDf_SET BCM53101_A0_ARLA_VTBL_RWCTRLr_RESERVEDf_SET
#define ARLA_VTBL_RWCTRLr_ARLA_VTBL_STDNf_GET BCM53101_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_STDNf_GET
#define ARLA_VTBL_RWCTRLr_ARLA_VTBL_STDNf_SET BCM53101_A0_ARLA_VTBL_RWCTRLr_ARLA_VTBL_STDNf_SET
#define READ_ARLA_VTBL_RWCTRLr BCM53101_A0_READ_ARLA_VTBL_RWCTRLr
#define WRITE_ARLA_VTBL_RWCTRLr BCM53101_A0_WRITE_ARLA_VTBL_RWCTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_ARLA_VTBL_RWCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  AUX_CONTROL_STATUS
 * BLOCKS:   EPIC0
 * DESC:     AUXILIARY CONTROL/STATUS REGISTER
 * SIZE:     16
 * FIELDS:
 *     FDX_INDICATION   1 = Full-duplex active.0 = Full-duplex inactive.
 *     SPEED_INDICATION 1 = 100BASE-X.0 = 10BASE-T.
 *     FORCE100_INDICATION 1 = Speed forced to 100BASE-X.0 = Speed forced to 10BASE-T.
 *     AN_INDICATOR     1 = Auto-negotiation activated.0 = Speed forced manually.
 *     EDGE_RATE        00 = 1 nanoseconds01 = 2 nanoseconds10 = 3 nanoseconds  11 = 4 nanoseconds  
 *     HSQ_LSQ          These two bits define the squelch mode of the 10BASE-T carrier sense mechanism:00 = normal squelch01 = low squelch10 = high squelch11 = not allowed
 *     RESERVED         Reserved
 *     LINK_DISABLE     1 = Link integrity test disabled in PHY.0 = Link integrity test is enabled in PHYNormal.
 *     JABBER_DISABLE   1 = Jabber function disabled in PHY.0 = Jabber function enabled in PHY.
 *
 ******************************************************************************/
#define BCM53101_A0_AUX_CONTROL_STATUSr 0x00001030

#define BCM53101_A0_AUX_CONTROL_STATUSr_SIZE 2

/*
 * This structure should be used to declare and program AUX_CONTROL_STATUS.
 *
 */
typedef union BCM53101_A0_AUX_CONTROL_STATUSr_s {
	uint32_t v[1];
	uint32_t aux_control_status[1];
	uint32_t _aux_control_status;
} BCM53101_A0_AUX_CONTROL_STATUSr_t;

#define BCM53101_A0_AUX_CONTROL_STATUSr_CLR(r) (r).aux_control_status[0] = 0
#define BCM53101_A0_AUX_CONTROL_STATUSr_SET(r,d) (r).aux_control_status[0] = d
#define BCM53101_A0_AUX_CONTROL_STATUSr_GET(r) (r).aux_control_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_AUX_CONTROL_STATUSr_FDX_INDICATIONf_GET(r) (((r).aux_control_status[0]) & 0x1)
#define BCM53101_A0_AUX_CONTROL_STATUSr_FDX_INDICATIONf_SET(r,f) (r).aux_control_status[0]=(((r).aux_control_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_AUX_CONTROL_STATUSr_SPEED_INDICATIONf_GET(r) ((((r).aux_control_status[0]) >> 1) & 0x1)
#define BCM53101_A0_AUX_CONTROL_STATUSr_SPEED_INDICATIONf_SET(r,f) (r).aux_control_status[0]=(((r).aux_control_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_AUX_CONTROL_STATUSr_FORCE100_INDICATIONf_GET(r) ((((r).aux_control_status[0]) >> 2) & 0x1)
#define BCM53101_A0_AUX_CONTROL_STATUSr_FORCE100_INDICATIONf_SET(r,f) (r).aux_control_status[0]=(((r).aux_control_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_AUX_CONTROL_STATUSr_AN_INDICATORf_GET(r) ((((r).aux_control_status[0]) >> 3) & 0x1)
#define BCM53101_A0_AUX_CONTROL_STATUSr_AN_INDICATORf_SET(r,f) (r).aux_control_status[0]=(((r).aux_control_status[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_AUX_CONTROL_STATUSr_EDGE_RATEf_GET(r) ((((r).aux_control_status[0]) >> 4) & 0x3)
#define BCM53101_A0_AUX_CONTROL_STATUSr_EDGE_RATEf_SET(r,f) (r).aux_control_status[0]=(((r).aux_control_status[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53101_A0_AUX_CONTROL_STATUSr_HSQ_LSQf_GET(r) ((((r).aux_control_status[0]) >> 6) & 0x3)
#define BCM53101_A0_AUX_CONTROL_STATUSr_HSQ_LSQf_SET(r,f) (r).aux_control_status[0]=(((r).aux_control_status[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53101_A0_AUX_CONTROL_STATUSr_RESERVEDf_GET(r) ((((r).aux_control_status[0]) >> 8) & 0x3f)
#define BCM53101_A0_AUX_CONTROL_STATUSr_RESERVEDf_SET(r,f) (r).aux_control_status[0]=(((r).aux_control_status[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM53101_A0_AUX_CONTROL_STATUSr_LINK_DISABLEf_GET(r) ((((r).aux_control_status[0]) >> 14) & 0x1)
#define BCM53101_A0_AUX_CONTROL_STATUSr_LINK_DISABLEf_SET(r,f) (r).aux_control_status[0]=(((r).aux_control_status[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_AUX_CONTROL_STATUSr_JABBER_DISABLEf_GET(r) ((((r).aux_control_status[0]) >> 15) & 0x1)
#define BCM53101_A0_AUX_CONTROL_STATUSr_JABBER_DISABLEf_SET(r,f) (r).aux_control_status[0]=(((r).aux_control_status[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access AUX_CONTROL_STATUS.
 *
 */
#define BCM53101_A0_READ_AUX_CONTROL_STATUSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_AUX_CONTROL_STATUSr,(r._aux_control_status),2)
#define BCM53101_A0_WRITE_AUX_CONTROL_STATUSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_AUX_CONTROL_STATUSr,&(r._aux_control_status),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AUX_CONTROL_STATUSr BCM53101_A0_AUX_CONTROL_STATUSr
#define AUX_CONTROL_STATUSr_SIZE BCM53101_A0_AUX_CONTROL_STATUSr_SIZE
typedef BCM53101_A0_AUX_CONTROL_STATUSr_t AUX_CONTROL_STATUSr_t;
#define AUX_CONTROL_STATUSr_CLR BCM53101_A0_AUX_CONTROL_STATUSr_CLR
#define AUX_CONTROL_STATUSr_SET BCM53101_A0_AUX_CONTROL_STATUSr_SET
#define AUX_CONTROL_STATUSr_GET BCM53101_A0_AUX_CONTROL_STATUSr_GET
#define AUX_CONTROL_STATUSr_FDX_INDICATIONf_GET BCM53101_A0_AUX_CONTROL_STATUSr_FDX_INDICATIONf_GET
#define AUX_CONTROL_STATUSr_FDX_INDICATIONf_SET BCM53101_A0_AUX_CONTROL_STATUSr_FDX_INDICATIONf_SET
#define AUX_CONTROL_STATUSr_SPEED_INDICATIONf_GET BCM53101_A0_AUX_CONTROL_STATUSr_SPEED_INDICATIONf_GET
#define AUX_CONTROL_STATUSr_SPEED_INDICATIONf_SET BCM53101_A0_AUX_CONTROL_STATUSr_SPEED_INDICATIONf_SET
#define AUX_CONTROL_STATUSr_FORCE100_INDICATIONf_GET BCM53101_A0_AUX_CONTROL_STATUSr_FORCE100_INDICATIONf_GET
#define AUX_CONTROL_STATUSr_FORCE100_INDICATIONf_SET BCM53101_A0_AUX_CONTROL_STATUSr_FORCE100_INDICATIONf_SET
#define AUX_CONTROL_STATUSr_AN_INDICATORf_GET BCM53101_A0_AUX_CONTROL_STATUSr_AN_INDICATORf_GET
#define AUX_CONTROL_STATUSr_AN_INDICATORf_SET BCM53101_A0_AUX_CONTROL_STATUSr_AN_INDICATORf_SET
#define AUX_CONTROL_STATUSr_EDGE_RATEf_GET BCM53101_A0_AUX_CONTROL_STATUSr_EDGE_RATEf_GET
#define AUX_CONTROL_STATUSr_EDGE_RATEf_SET BCM53101_A0_AUX_CONTROL_STATUSr_EDGE_RATEf_SET
#define AUX_CONTROL_STATUSr_HSQ_LSQf_GET BCM53101_A0_AUX_CONTROL_STATUSr_HSQ_LSQf_GET
#define AUX_CONTROL_STATUSr_HSQ_LSQf_SET BCM53101_A0_AUX_CONTROL_STATUSr_HSQ_LSQf_SET
#define AUX_CONTROL_STATUSr_RESERVEDf_GET BCM53101_A0_AUX_CONTROL_STATUSr_RESERVEDf_GET
#define AUX_CONTROL_STATUSr_RESERVEDf_SET BCM53101_A0_AUX_CONTROL_STATUSr_RESERVEDf_SET
#define AUX_CONTROL_STATUSr_LINK_DISABLEf_GET BCM53101_A0_AUX_CONTROL_STATUSr_LINK_DISABLEf_GET
#define AUX_CONTROL_STATUSr_LINK_DISABLEf_SET BCM53101_A0_AUX_CONTROL_STATUSr_LINK_DISABLEf_SET
#define AUX_CONTROL_STATUSr_JABBER_DISABLEf_GET BCM53101_A0_AUX_CONTROL_STATUSr_JABBER_DISABLEf_GET
#define AUX_CONTROL_STATUSr_JABBER_DISABLEf_SET BCM53101_A0_AUX_CONTROL_STATUSr_JABBER_DISABLEf_SET
#define READ_AUX_CONTROL_STATUSr BCM53101_A0_READ_AUX_CONTROL_STATUSr
#define WRITE_AUX_CONTROL_STATUSr BCM53101_A0_WRITE_AUX_CONTROL_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_AUX_CONTROL_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  AUX_CONTROL_STATUS_EXT_P5
 * BLOCKS:   SYS
 * DESC:     AUXILIARY CONTROL/STATUS REGISTER
 * SIZE:     16
 * FIELDS:
 *     FDX_INDICATION   1 = Full-duplex active.0 = Full-duplex inactive.
 *     SPEED_INDICATION 1 = 100BASE-X.0 = 10BASE-T.
 *     FORCE100_INDICATION 1 = Speed forced to 100BASE-X.0 = Speed forced to 10BASE-T.
 *     AN_INDICATOR     1 = Auto-negotiation activated.0 = Speed forced manually.
 *     EDGE_RATE        00 = 1 nanoseconds01 = 2 nanoseconds10 = 3 nanoseconds  11 = 4 nanoseconds  
 *     HSQ_LSQ          These two bits define the squelch mode of the 10BASE-T carrier sense mechanism:00 = normal squelch01 = low squelch10 = high squelch11 = not allowed
 *     RESERVED         Reserved
 *     LINK_DISABLE     1 = Link integrity test disabled in PHY.0 = Link integrity test is enabled in PHYNormal.
 *     JABBER_DISABLE   1 = Jabber function disabled in PHY.0 = Jabber function enabled in PHY.
 *
 ******************************************************************************/
#define BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r 0x00008530

#define BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program AUX_CONTROL_STATUS_EXT_P5.
 *
 */
typedef union BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_s {
	uint32_t v[1];
	uint32_t aux_control_status_ext_p5[1];
	uint32_t _aux_control_status_ext_p5;
} BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_t;

#define BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_CLR(r) (r).aux_control_status_ext_p5[0] = 0
#define BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_SET(r,d) (r).aux_control_status_ext_p5[0] = d
#define BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_GET(r) (r).aux_control_status_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_FDX_INDICATIONf_GET(r) (((r).aux_control_status_ext_p5[0]) & 0x1)
#define BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_FDX_INDICATIONf_SET(r,f) (r).aux_control_status_ext_p5[0]=(((r).aux_control_status_ext_p5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_SPEED_INDICATIONf_GET(r) ((((r).aux_control_status_ext_p5[0]) >> 1) & 0x1)
#define BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_SPEED_INDICATIONf_SET(r,f) (r).aux_control_status_ext_p5[0]=(((r).aux_control_status_ext_p5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_FORCE100_INDICATIONf_GET(r) ((((r).aux_control_status_ext_p5[0]) >> 2) & 0x1)
#define BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_FORCE100_INDICATIONf_SET(r,f) (r).aux_control_status_ext_p5[0]=(((r).aux_control_status_ext_p5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_AN_INDICATORf_GET(r) ((((r).aux_control_status_ext_p5[0]) >> 3) & 0x1)
#define BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_AN_INDICATORf_SET(r,f) (r).aux_control_status_ext_p5[0]=(((r).aux_control_status_ext_p5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_EDGE_RATEf_GET(r) ((((r).aux_control_status_ext_p5[0]) >> 4) & 0x3)
#define BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_EDGE_RATEf_SET(r,f) (r).aux_control_status_ext_p5[0]=(((r).aux_control_status_ext_p5[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_HSQ_LSQf_GET(r) ((((r).aux_control_status_ext_p5[0]) >> 6) & 0x3)
#define BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_HSQ_LSQf_SET(r,f) (r).aux_control_status_ext_p5[0]=(((r).aux_control_status_ext_p5[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_RESERVEDf_GET(r) ((((r).aux_control_status_ext_p5[0]) >> 8) & 0x3f)
#define BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_RESERVEDf_SET(r,f) (r).aux_control_status_ext_p5[0]=(((r).aux_control_status_ext_p5[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8))
#define BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_LINK_DISABLEf_GET(r) ((((r).aux_control_status_ext_p5[0]) >> 14) & 0x1)
#define BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_LINK_DISABLEf_SET(r,f) (r).aux_control_status_ext_p5[0]=(((r).aux_control_status_ext_p5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_JABBER_DISABLEf_GET(r) ((((r).aux_control_status_ext_p5[0]) >> 15) & 0x1)
#define BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_JABBER_DISABLEf_SET(r,f) (r).aux_control_status_ext_p5[0]=(((r).aux_control_status_ext_p5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access AUX_CONTROL_STATUS_EXT_P5.
 *
 */
#define BCM53101_A0_READ_AUX_CONTROL_STATUS_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r,(r._aux_control_status_ext_p5),2)
#define BCM53101_A0_WRITE_AUX_CONTROL_STATUS_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r,&(r._aux_control_status_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AUX_CONTROL_STATUS_EXT_P5r BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r
#define AUX_CONTROL_STATUS_EXT_P5r_SIZE BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_SIZE
typedef BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_t AUX_CONTROL_STATUS_EXT_P5r_t;
#define AUX_CONTROL_STATUS_EXT_P5r_CLR BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_CLR
#define AUX_CONTROL_STATUS_EXT_P5r_SET BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_SET
#define AUX_CONTROL_STATUS_EXT_P5r_GET BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_GET
#define AUX_CONTROL_STATUS_EXT_P5r_FDX_INDICATIONf_GET BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_FDX_INDICATIONf_GET
#define AUX_CONTROL_STATUS_EXT_P5r_FDX_INDICATIONf_SET BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_FDX_INDICATIONf_SET
#define AUX_CONTROL_STATUS_EXT_P5r_SPEED_INDICATIONf_GET BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_SPEED_INDICATIONf_GET
#define AUX_CONTROL_STATUS_EXT_P5r_SPEED_INDICATIONf_SET BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_SPEED_INDICATIONf_SET
#define AUX_CONTROL_STATUS_EXT_P5r_FORCE100_INDICATIONf_GET BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_FORCE100_INDICATIONf_GET
#define AUX_CONTROL_STATUS_EXT_P5r_FORCE100_INDICATIONf_SET BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_FORCE100_INDICATIONf_SET
#define AUX_CONTROL_STATUS_EXT_P5r_AN_INDICATORf_GET BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_AN_INDICATORf_GET
#define AUX_CONTROL_STATUS_EXT_P5r_AN_INDICATORf_SET BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_AN_INDICATORf_SET
#define AUX_CONTROL_STATUS_EXT_P5r_EDGE_RATEf_GET BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_EDGE_RATEf_GET
#define AUX_CONTROL_STATUS_EXT_P5r_EDGE_RATEf_SET BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_EDGE_RATEf_SET
#define AUX_CONTROL_STATUS_EXT_P5r_HSQ_LSQf_GET BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_HSQ_LSQf_GET
#define AUX_CONTROL_STATUS_EXT_P5r_HSQ_LSQf_SET BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_HSQ_LSQf_SET
#define AUX_CONTROL_STATUS_EXT_P5r_RESERVEDf_GET BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_RESERVEDf_GET
#define AUX_CONTROL_STATUS_EXT_P5r_RESERVEDf_SET BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_RESERVEDf_SET
#define AUX_CONTROL_STATUS_EXT_P5r_LINK_DISABLEf_GET BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_LINK_DISABLEf_GET
#define AUX_CONTROL_STATUS_EXT_P5r_LINK_DISABLEf_SET BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_LINK_DISABLEf_SET
#define AUX_CONTROL_STATUS_EXT_P5r_JABBER_DISABLEf_GET BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_JABBER_DISABLEf_GET
#define AUX_CONTROL_STATUS_EXT_P5r_JABBER_DISABLEf_SET BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r_JABBER_DISABLEf_SET
#define READ_AUX_CONTROL_STATUS_EXT_P5r BCM53101_A0_READ_AUX_CONTROL_STATUS_EXT_P5r
#define WRITE_AUX_CONTROL_STATUS_EXT_P5r BCM53101_A0_WRITE_AUX_CONTROL_STATUS_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_AUX_CONTROL_STATUS_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  AUX_MODE
 * BLOCKS:   EPIC0
 * DESC:     AUXILIARY MODE REGISTER
 * SIZE:     16
 * FIELDS:
 *     RESERVED         Reserved
 *     BLOCK_TXEN_MODE  1 = Enable Block TXEN mode.0 = Disable Block TXEN mode.
 *     LINK_LED_DISABLE 1 = Disable Link LED output.0 = Enable Link LED output.
 *     ACT_LED_DISABLE  1 = Disable XMT/RCV Activity LED outputs.0 = Enable XMT/RCV Activity LED outputs.
 *
 ******************************************************************************/
#define BCM53101_A0_AUX_MODEr 0x0000103a

#define BCM53101_A0_AUX_MODEr_SIZE 2

/*
 * This structure should be used to declare and program AUX_MODE.
 *
 */
typedef union BCM53101_A0_AUX_MODEr_s {
	uint32_t v[1];
	uint32_t aux_mode[1];
	uint32_t _aux_mode;
} BCM53101_A0_AUX_MODEr_t;

#define BCM53101_A0_AUX_MODEr_CLR(r) (r).aux_mode[0] = 0
#define BCM53101_A0_AUX_MODEr_SET(r,d) (r).aux_mode[0] = d
#define BCM53101_A0_AUX_MODEr_GET(r) (r).aux_mode[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_AUX_MODEr_RESERVEDf_GET(r) (((r).aux_mode[0]) & 0x1)
#define BCM53101_A0_AUX_MODEr_RESERVEDf_SET(r,f) (r).aux_mode[0]=(((r).aux_mode[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_AUX_MODEr_BLOCK_TXEN_MODEf_GET(r) ((((r).aux_mode[0]) >> 1) & 0x1)
#define BCM53101_A0_AUX_MODEr_BLOCK_TXEN_MODEf_SET(r,f) (r).aux_mode[0]=(((r).aux_mode[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_AUX_MODEr_LINK_LED_DISABLEf_GET(r) ((((r).aux_mode[0]) >> 3) & 0x1)
#define BCM53101_A0_AUX_MODEr_LINK_LED_DISABLEf_SET(r,f) (r).aux_mode[0]=(((r).aux_mode[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_AUX_MODEr_ACT_LED_DISABLEf_GET(r) ((((r).aux_mode[0]) >> 4) & 0x1)
#define BCM53101_A0_AUX_MODEr_ACT_LED_DISABLEf_SET(r,f) (r).aux_mode[0]=(((r).aux_mode[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access AUX_MODE.
 *
 */
#define BCM53101_A0_READ_AUX_MODEr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_AUX_MODEr,(r._aux_mode),2)
#define BCM53101_A0_WRITE_AUX_MODEr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_AUX_MODEr,&(r._aux_mode),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AUX_MODEr BCM53101_A0_AUX_MODEr
#define AUX_MODEr_SIZE BCM53101_A0_AUX_MODEr_SIZE
typedef BCM53101_A0_AUX_MODEr_t AUX_MODEr_t;
#define AUX_MODEr_CLR BCM53101_A0_AUX_MODEr_CLR
#define AUX_MODEr_SET BCM53101_A0_AUX_MODEr_SET
#define AUX_MODEr_GET BCM53101_A0_AUX_MODEr_GET
#define AUX_MODEr_RESERVEDf_GET BCM53101_A0_AUX_MODEr_RESERVEDf_GET
#define AUX_MODEr_RESERVEDf_SET BCM53101_A0_AUX_MODEr_RESERVEDf_SET
#define AUX_MODEr_BLOCK_TXEN_MODEf_GET BCM53101_A0_AUX_MODEr_BLOCK_TXEN_MODEf_GET
#define AUX_MODEr_BLOCK_TXEN_MODEf_SET BCM53101_A0_AUX_MODEr_BLOCK_TXEN_MODEf_SET
#define AUX_MODEr_LINK_LED_DISABLEf_GET BCM53101_A0_AUX_MODEr_LINK_LED_DISABLEf_GET
#define AUX_MODEr_LINK_LED_DISABLEf_SET BCM53101_A0_AUX_MODEr_LINK_LED_DISABLEf_SET
#define AUX_MODEr_ACT_LED_DISABLEf_GET BCM53101_A0_AUX_MODEr_ACT_LED_DISABLEf_GET
#define AUX_MODEr_ACT_LED_DISABLEf_SET BCM53101_A0_AUX_MODEr_ACT_LED_DISABLEf_SET
#define READ_AUX_MODEr BCM53101_A0_READ_AUX_MODEr
#define WRITE_AUX_MODEr BCM53101_A0_WRITE_AUX_MODEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_AUX_MODEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  AUX_MODE2
 * BLOCKS:   EPIC0
 * DESC:     AUXILIARY MODE 2 REGISTER
 * SIZE:     16
 * FIELDS:
 *     RESERVED         Reserved
 *     QP_DETECT_MODE   1 = Enable, 0 = Disable.    
 *     ACT_LINK_LED_MODE 1 = Enable, 0 = Disable.
 *     SERIAL_LED_MODE  1 = Enable Serial LED mode. (this bit is available only in PHY 1 of 8)
 *     ACT_LED_FORCE_ON 1 = ON, 0 = Normal operation.
 *     TRAFFIC_METER_LED 1 = Enable, 0 = Disable.
 *     BLOCK_10BT_ECHO  1 = Enable, 0 = Disable.
 *     JUMBO_PKT_FIFO_ENABLE 1 = Enable, 0 = Disable.
 *     JUMBO_PKT_MODE   1 = Enable, 0 = Disable.
 *     B10T_DRIBBLE_CORRECT 1 = Enable, 0 = Disable.
 *
 ******************************************************************************/
#define BCM53101_A0_AUX_MODE2r 0x00001036

#define BCM53101_A0_AUX_MODE2r_SIZE 2

/*
 * This structure should be used to declare and program AUX_MODE2.
 *
 */
typedef union BCM53101_A0_AUX_MODE2r_s {
	uint32_t v[1];
	uint32_t aux_mode2[1];
	uint32_t _aux_mode2;
} BCM53101_A0_AUX_MODE2r_t;

#define BCM53101_A0_AUX_MODE2r_CLR(r) (r).aux_mode2[0] = 0
#define BCM53101_A0_AUX_MODE2r_SET(r,d) (r).aux_mode2[0] = d
#define BCM53101_A0_AUX_MODE2r_GET(r) (r).aux_mode2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_AUX_MODE2r_RESERVEDf_GET(r) (((r).aux_mode2[0]) & 0x1)
#define BCM53101_A0_AUX_MODE2r_RESERVEDf_SET(r,f) (r).aux_mode2[0]=(((r).aux_mode2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_AUX_MODE2r_QP_DETECT_MODEf_GET(r) ((((r).aux_mode2[0]) >> 1) & 0x1)
#define BCM53101_A0_AUX_MODE2r_QP_DETECT_MODEf_SET(r,f) (r).aux_mode2[0]=(((r).aux_mode2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_AUX_MODE2r_ACT_LINK_LED_MODEf_GET(r) ((((r).aux_mode2[0]) >> 2) & 0x1)
#define BCM53101_A0_AUX_MODE2r_ACT_LINK_LED_MODEf_SET(r,f) (r).aux_mode2[0]=(((r).aux_mode2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_AUX_MODE2r_SERIAL_LED_MODEf_GET(r) ((((r).aux_mode2[0]) >> 4) & 0x1)
#define BCM53101_A0_AUX_MODE2r_SERIAL_LED_MODEf_SET(r,f) (r).aux_mode2[0]=(((r).aux_mode2[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_AUX_MODE2r_ACT_LED_FORCE_ONf_GET(r) ((((r).aux_mode2[0]) >> 5) & 0x1)
#define BCM53101_A0_AUX_MODE2r_ACT_LED_FORCE_ONf_SET(r,f) (r).aux_mode2[0]=(((r).aux_mode2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_AUX_MODE2r_TRAFFIC_METER_LEDf_GET(r) ((((r).aux_mode2[0]) >> 6) & 0x1)
#define BCM53101_A0_AUX_MODE2r_TRAFFIC_METER_LEDf_SET(r,f) (r).aux_mode2[0]=(((r).aux_mode2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_AUX_MODE2r_BLOCK_10BT_ECHOf_GET(r) ((((r).aux_mode2[0]) >> 7) & 0x1)
#define BCM53101_A0_AUX_MODE2r_BLOCK_10BT_ECHOf_SET(r,f) (r).aux_mode2[0]=(((r).aux_mode2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53101_A0_AUX_MODE2r_JUMBO_PKT_FIFO_ENABLEf_GET(r) ((((r).aux_mode2[0]) >> 9) & 0x1)
#define BCM53101_A0_AUX_MODE2r_JUMBO_PKT_FIFO_ENABLEf_SET(r,f) (r).aux_mode2[0]=(((r).aux_mode2[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53101_A0_AUX_MODE2r_JUMBO_PKT_MODEf_GET(r) ((((r).aux_mode2[0]) >> 10) & 0x1)
#define BCM53101_A0_AUX_MODE2r_JUMBO_PKT_MODEf_SET(r,f) (r).aux_mode2[0]=(((r).aux_mode2[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53101_A0_AUX_MODE2r_B10T_DRIBBLE_CORRECTf_GET(r) ((((r).aux_mode2[0]) >> 11) & 0x1)
#define BCM53101_A0_AUX_MODE2r_B10T_DRIBBLE_CORRECTf_SET(r,f) (r).aux_mode2[0]=(((r).aux_mode2[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))

/*
 * These macros can be used to access AUX_MODE2.
 *
 */
#define BCM53101_A0_READ_AUX_MODE2r(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_AUX_MODE2r,(r._aux_mode2),2)
#define BCM53101_A0_WRITE_AUX_MODE2r(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_AUX_MODE2r,&(r._aux_mode2),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AUX_MODE2r BCM53101_A0_AUX_MODE2r
#define AUX_MODE2r_SIZE BCM53101_A0_AUX_MODE2r_SIZE
typedef BCM53101_A0_AUX_MODE2r_t AUX_MODE2r_t;
#define AUX_MODE2r_CLR BCM53101_A0_AUX_MODE2r_CLR
#define AUX_MODE2r_SET BCM53101_A0_AUX_MODE2r_SET
#define AUX_MODE2r_GET BCM53101_A0_AUX_MODE2r_GET
#define AUX_MODE2r_RESERVEDf_GET BCM53101_A0_AUX_MODE2r_RESERVEDf_GET
#define AUX_MODE2r_RESERVEDf_SET BCM53101_A0_AUX_MODE2r_RESERVEDf_SET
#define AUX_MODE2r_QP_DETECT_MODEf_GET BCM53101_A0_AUX_MODE2r_QP_DETECT_MODEf_GET
#define AUX_MODE2r_QP_DETECT_MODEf_SET BCM53101_A0_AUX_MODE2r_QP_DETECT_MODEf_SET
#define AUX_MODE2r_ACT_LINK_LED_MODEf_GET BCM53101_A0_AUX_MODE2r_ACT_LINK_LED_MODEf_GET
#define AUX_MODE2r_ACT_LINK_LED_MODEf_SET BCM53101_A0_AUX_MODE2r_ACT_LINK_LED_MODEf_SET
#define AUX_MODE2r_SERIAL_LED_MODEf_GET BCM53101_A0_AUX_MODE2r_SERIAL_LED_MODEf_GET
#define AUX_MODE2r_SERIAL_LED_MODEf_SET BCM53101_A0_AUX_MODE2r_SERIAL_LED_MODEf_SET
#define AUX_MODE2r_ACT_LED_FORCE_ONf_GET BCM53101_A0_AUX_MODE2r_ACT_LED_FORCE_ONf_GET
#define AUX_MODE2r_ACT_LED_FORCE_ONf_SET BCM53101_A0_AUX_MODE2r_ACT_LED_FORCE_ONf_SET
#define AUX_MODE2r_TRAFFIC_METER_LEDf_GET BCM53101_A0_AUX_MODE2r_TRAFFIC_METER_LEDf_GET
#define AUX_MODE2r_TRAFFIC_METER_LEDf_SET BCM53101_A0_AUX_MODE2r_TRAFFIC_METER_LEDf_SET
#define AUX_MODE2r_BLOCK_10BT_ECHOf_GET BCM53101_A0_AUX_MODE2r_BLOCK_10BT_ECHOf_GET
#define AUX_MODE2r_BLOCK_10BT_ECHOf_SET BCM53101_A0_AUX_MODE2r_BLOCK_10BT_ECHOf_SET
#define AUX_MODE2r_JUMBO_PKT_FIFO_ENABLEf_GET BCM53101_A0_AUX_MODE2r_JUMBO_PKT_FIFO_ENABLEf_GET
#define AUX_MODE2r_JUMBO_PKT_FIFO_ENABLEf_SET BCM53101_A0_AUX_MODE2r_JUMBO_PKT_FIFO_ENABLEf_SET
#define AUX_MODE2r_JUMBO_PKT_MODEf_GET BCM53101_A0_AUX_MODE2r_JUMBO_PKT_MODEf_GET
#define AUX_MODE2r_JUMBO_PKT_MODEf_SET BCM53101_A0_AUX_MODE2r_JUMBO_PKT_MODEf_SET
#define AUX_MODE2r_B10T_DRIBBLE_CORRECTf_GET BCM53101_A0_AUX_MODE2r_B10T_DRIBBLE_CORRECTf_GET
#define AUX_MODE2r_B10T_DRIBBLE_CORRECTf_SET BCM53101_A0_AUX_MODE2r_B10T_DRIBBLE_CORRECTf_SET
#define READ_AUX_MODE2r BCM53101_A0_READ_AUX_MODE2r
#define WRITE_AUX_MODE2r BCM53101_A0_WRITE_AUX_MODE2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_AUX_MODE2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  AUX_MODE2_EXT_P5
 * BLOCKS:   SYS
 * DESC:     AUXILIARY MODE 2 REGISTER
 * SIZE:     16
 * FIELDS:
 *     RESERVED         Reserved
 *     QP_DETECT_MODE   1 = Enable, 0 = Disable.    
 *     ACT_LINK_LED_MODE 1 = Enable, 0 = Disable.
 *     SERIAL_LED_MODE  1 = Enable Serial LED mode. (this bit is available only in PHY 1 of 8)
 *     ACT_LED_FORCE_ON 1 = ON, 0 = Normal operation.
 *     TRAFFIC_METER_LED 1 = Enable, 0 = Disable.
 *     BLOCK_10BT_ECHO  1 = Enable, 0 = Disable.
 *     JUMBO_PKT_FIFO_ENABLE 1 = Enable, 0 = Disable.
 *     JUMBO_PKT_MODE   1 = Enable, 0 = Disable.
 *     B10T_DRIBBLE_CORRECT 1 = Enable, 0 = Disable.
 *
 ******************************************************************************/
#define BCM53101_A0_AUX_MODE2_EXT_P5r 0x00008536

#define BCM53101_A0_AUX_MODE2_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program AUX_MODE2_EXT_P5.
 *
 */
typedef union BCM53101_A0_AUX_MODE2_EXT_P5r_s {
	uint32_t v[1];
	uint32_t aux_mode2_ext_p5[1];
	uint32_t _aux_mode2_ext_p5;
} BCM53101_A0_AUX_MODE2_EXT_P5r_t;

#define BCM53101_A0_AUX_MODE2_EXT_P5r_CLR(r) (r).aux_mode2_ext_p5[0] = 0
#define BCM53101_A0_AUX_MODE2_EXT_P5r_SET(r,d) (r).aux_mode2_ext_p5[0] = d
#define BCM53101_A0_AUX_MODE2_EXT_P5r_GET(r) (r).aux_mode2_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_AUX_MODE2_EXT_P5r_RESERVEDf_GET(r) (((r).aux_mode2_ext_p5[0]) & 0x1)
#define BCM53101_A0_AUX_MODE2_EXT_P5r_RESERVEDf_SET(r,f) (r).aux_mode2_ext_p5[0]=(((r).aux_mode2_ext_p5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_AUX_MODE2_EXT_P5r_QP_DETECT_MODEf_GET(r) ((((r).aux_mode2_ext_p5[0]) >> 1) & 0x1)
#define BCM53101_A0_AUX_MODE2_EXT_P5r_QP_DETECT_MODEf_SET(r,f) (r).aux_mode2_ext_p5[0]=(((r).aux_mode2_ext_p5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_AUX_MODE2_EXT_P5r_ACT_LINK_LED_MODEf_GET(r) ((((r).aux_mode2_ext_p5[0]) >> 2) & 0x1)
#define BCM53101_A0_AUX_MODE2_EXT_P5r_ACT_LINK_LED_MODEf_SET(r,f) (r).aux_mode2_ext_p5[0]=(((r).aux_mode2_ext_p5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_AUX_MODE2_EXT_P5r_SERIAL_LED_MODEf_GET(r) ((((r).aux_mode2_ext_p5[0]) >> 4) & 0x1)
#define BCM53101_A0_AUX_MODE2_EXT_P5r_SERIAL_LED_MODEf_SET(r,f) (r).aux_mode2_ext_p5[0]=(((r).aux_mode2_ext_p5[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_AUX_MODE2_EXT_P5r_ACT_LED_FORCE_ONf_GET(r) ((((r).aux_mode2_ext_p5[0]) >> 5) & 0x1)
#define BCM53101_A0_AUX_MODE2_EXT_P5r_ACT_LED_FORCE_ONf_SET(r,f) (r).aux_mode2_ext_p5[0]=(((r).aux_mode2_ext_p5[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_AUX_MODE2_EXT_P5r_TRAFFIC_METER_LEDf_GET(r) ((((r).aux_mode2_ext_p5[0]) >> 6) & 0x1)
#define BCM53101_A0_AUX_MODE2_EXT_P5r_TRAFFIC_METER_LEDf_SET(r,f) (r).aux_mode2_ext_p5[0]=(((r).aux_mode2_ext_p5[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_AUX_MODE2_EXT_P5r_BLOCK_10BT_ECHOf_GET(r) ((((r).aux_mode2_ext_p5[0]) >> 7) & 0x1)
#define BCM53101_A0_AUX_MODE2_EXT_P5r_BLOCK_10BT_ECHOf_SET(r,f) (r).aux_mode2_ext_p5[0]=(((r).aux_mode2_ext_p5[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53101_A0_AUX_MODE2_EXT_P5r_JUMBO_PKT_FIFO_ENABLEf_GET(r) ((((r).aux_mode2_ext_p5[0]) >> 9) & 0x1)
#define BCM53101_A0_AUX_MODE2_EXT_P5r_JUMBO_PKT_FIFO_ENABLEf_SET(r,f) (r).aux_mode2_ext_p5[0]=(((r).aux_mode2_ext_p5[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53101_A0_AUX_MODE2_EXT_P5r_JUMBO_PKT_MODEf_GET(r) ((((r).aux_mode2_ext_p5[0]) >> 10) & 0x1)
#define BCM53101_A0_AUX_MODE2_EXT_P5r_JUMBO_PKT_MODEf_SET(r,f) (r).aux_mode2_ext_p5[0]=(((r).aux_mode2_ext_p5[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53101_A0_AUX_MODE2_EXT_P5r_B10T_DRIBBLE_CORRECTf_GET(r) ((((r).aux_mode2_ext_p5[0]) >> 11) & 0x1)
#define BCM53101_A0_AUX_MODE2_EXT_P5r_B10T_DRIBBLE_CORRECTf_SET(r,f) (r).aux_mode2_ext_p5[0]=(((r).aux_mode2_ext_p5[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))

/*
 * These macros can be used to access AUX_MODE2_EXT_P5.
 *
 */
#define BCM53101_A0_READ_AUX_MODE2_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53101_A0_AUX_MODE2_EXT_P5r,(r._aux_mode2_ext_p5),2)
#define BCM53101_A0_WRITE_AUX_MODE2_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53101_A0_AUX_MODE2_EXT_P5r,&(r._aux_mode2_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AUX_MODE2_EXT_P5r BCM53101_A0_AUX_MODE2_EXT_P5r
#define AUX_MODE2_EXT_P5r_SIZE BCM53101_A0_AUX_MODE2_EXT_P5r_SIZE
typedef BCM53101_A0_AUX_MODE2_EXT_P5r_t AUX_MODE2_EXT_P5r_t;
#define AUX_MODE2_EXT_P5r_CLR BCM53101_A0_AUX_MODE2_EXT_P5r_CLR
#define AUX_MODE2_EXT_P5r_SET BCM53101_A0_AUX_MODE2_EXT_P5r_SET
#define AUX_MODE2_EXT_P5r_GET BCM53101_A0_AUX_MODE2_EXT_P5r_GET
#define AUX_MODE2_EXT_P5r_RESERVEDf_GET BCM53101_A0_AUX_MODE2_EXT_P5r_RESERVEDf_GET
#define AUX_MODE2_EXT_P5r_RESERVEDf_SET BCM53101_A0_AUX_MODE2_EXT_P5r_RESERVEDf_SET
#define AUX_MODE2_EXT_P5r_QP_DETECT_MODEf_GET BCM53101_A0_AUX_MODE2_EXT_P5r_QP_DETECT_MODEf_GET
#define AUX_MODE2_EXT_P5r_QP_DETECT_MODEf_SET BCM53101_A0_AUX_MODE2_EXT_P5r_QP_DETECT_MODEf_SET
#define AUX_MODE2_EXT_P5r_ACT_LINK_LED_MODEf_GET BCM53101_A0_AUX_MODE2_EXT_P5r_ACT_LINK_LED_MODEf_GET
#define AUX_MODE2_EXT_P5r_ACT_LINK_LED_MODEf_SET BCM53101_A0_AUX_MODE2_EXT_P5r_ACT_LINK_LED_MODEf_SET
#define AUX_MODE2_EXT_P5r_SERIAL_LED_MODEf_GET BCM53101_A0_AUX_MODE2_EXT_P5r_SERIAL_LED_MODEf_GET
#define AUX_MODE2_EXT_P5r_SERIAL_LED_MODEf_SET BCM53101_A0_AUX_MODE2_EXT_P5r_SERIAL_LED_MODEf_SET
#define AUX_MODE2_EXT_P5r_ACT_LED_FORCE_ONf_GET BCM53101_A0_AUX_MODE2_EXT_P5r_ACT_LED_FORCE_ONf_GET
#define AUX_MODE2_EXT_P5r_ACT_LED_FORCE_ONf_SET BCM53101_A0_AUX_MODE2_EXT_P5r_ACT_LED_FORCE_ONf_SET
#define AUX_MODE2_EXT_P5r_TRAFFIC_METER_LEDf_GET BCM53101_A0_AUX_MODE2_EXT_P5r_TRAFFIC_METER_LEDf_GET
#define AUX_MODE2_EXT_P5r_TRAFFIC_METER_LEDf_SET BCM53101_A0_AUX_MODE2_EXT_P5r_TRAFFIC_METER_LEDf_SET
#define AUX_MODE2_EXT_P5r_BLOCK_10BT_ECHOf_GET BCM53101_A0_AUX_MODE2_EXT_P5r_BLOCK_10BT_ECHOf_GET
#define AUX_MODE2_EXT_P5r_BLOCK_10BT_ECHOf_SET BCM53101_A0_AUX_MODE2_EXT_P5r_BLOCK_10BT_ECHOf_SET
#define AUX_MODE2_EXT_P5r_JUMBO_PKT_FIFO_ENABLEf_GET BCM53101_A0_AUX_MODE2_EXT_P5r_JUMBO_PKT_FIFO_ENABLEf_GET
#define AUX_MODE2_EXT_P5r_JUMBO_PKT_FIFO_ENABLEf_SET BCM53101_A0_AUX_MODE2_EXT_P5r_JUMBO_PKT_FIFO_ENABLEf_SET
#define AUX_MODE2_EXT_P5r_JUMBO_PKT_MODEf_GET BCM53101_A0_AUX_MODE2_EXT_P5r_JUMBO_PKT_MODEf_GET
#define AUX_MODE2_EXT_P5r_JUMBO_PKT_MODEf_SET BCM53101_A0_AUX_MODE2_EXT_P5r_JUMBO_PKT_MODEf_SET
#define AUX_MODE2_EXT_P5r_B10T_DRIBBLE_CORRECTf_GET BCM53101_A0_AUX_MODE2_EXT_P5r_B10T_DRIBBLE_CORRECTf_GET
#define AUX_MODE2_EXT_P5r_B10T_DRIBBLE_CORRECTf_SET BCM53101_A0_AUX_MODE2_EXT_P5r_B10T_DRIBBLE_CORRECTf_SET
#define READ_AUX_MODE2_EXT_P5r BCM53101_A0_READ_AUX_MODE2_EXT_P5r
#define WRITE_AUX_MODE2_EXT_P5r BCM53101_A0_WRITE_AUX_MODE2_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_AUX_MODE2_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  AUX_MODE_EXT_P5
 * BLOCKS:   SYS
 * DESC:     AUXILIARY MODE REGISTER
 * SIZE:     16
 * FIELDS:
 *     RESERVED         Reserved
 *     BLOCK_TXEN_MODE  1 = Enable Block TXEN mode.0 = Disable Block TXEN mode.
 *     LINK_LED_DISABLE 1 = Disable Link LED output.0 = Enable Link LED output.
 *     ACT_LED_DISABLE  1 = Disable XMT/RCV Activity LED outputs.0 = Enable XMT/RCV Activity LED outputs.
 *
 ******************************************************************************/
#define BCM53101_A0_AUX_MODE_EXT_P5r 0x0000853a

#define BCM53101_A0_AUX_MODE_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program AUX_MODE_EXT_P5.
 *
 */
typedef union BCM53101_A0_AUX_MODE_EXT_P5r_s {
	uint32_t v[1];
	uint32_t aux_mode_ext_p5[1];
	uint32_t _aux_mode_ext_p5;
} BCM53101_A0_AUX_MODE_EXT_P5r_t;

#define BCM53101_A0_AUX_MODE_EXT_P5r_CLR(r) (r).aux_mode_ext_p5[0] = 0
#define BCM53101_A0_AUX_MODE_EXT_P5r_SET(r,d) (r).aux_mode_ext_p5[0] = d
#define BCM53101_A0_AUX_MODE_EXT_P5r_GET(r) (r).aux_mode_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_AUX_MODE_EXT_P5r_RESERVEDf_GET(r) (((r).aux_mode_ext_p5[0]) & 0x1)
#define BCM53101_A0_AUX_MODE_EXT_P5r_RESERVEDf_SET(r,f) (r).aux_mode_ext_p5[0]=(((r).aux_mode_ext_p5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_AUX_MODE_EXT_P5r_BLOCK_TXEN_MODEf_GET(r) ((((r).aux_mode_ext_p5[0]) >> 1) & 0x1)
#define BCM53101_A0_AUX_MODE_EXT_P5r_BLOCK_TXEN_MODEf_SET(r,f) (r).aux_mode_ext_p5[0]=(((r).aux_mode_ext_p5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_AUX_MODE_EXT_P5r_LINK_LED_DISABLEf_GET(r) ((((r).aux_mode_ext_p5[0]) >> 3) & 0x1)
#define BCM53101_A0_AUX_MODE_EXT_P5r_LINK_LED_DISABLEf_SET(r,f) (r).aux_mode_ext_p5[0]=(((r).aux_mode_ext_p5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_AUX_MODE_EXT_P5r_ACT_LED_DISABLEf_GET(r) ((((r).aux_mode_ext_p5[0]) >> 4) & 0x1)
#define BCM53101_A0_AUX_MODE_EXT_P5r_ACT_LED_DISABLEf_SET(r,f) (r).aux_mode_ext_p5[0]=(((r).aux_mode_ext_p5[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * These macros can be used to access AUX_MODE_EXT_P5.
 *
 */
#define BCM53101_A0_READ_AUX_MODE_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53101_A0_AUX_MODE_EXT_P5r,(r._aux_mode_ext_p5),2)
#define BCM53101_A0_WRITE_AUX_MODE_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53101_A0_AUX_MODE_EXT_P5r,&(r._aux_mode_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AUX_MODE_EXT_P5r BCM53101_A0_AUX_MODE_EXT_P5r
#define AUX_MODE_EXT_P5r_SIZE BCM53101_A0_AUX_MODE_EXT_P5r_SIZE
typedef BCM53101_A0_AUX_MODE_EXT_P5r_t AUX_MODE_EXT_P5r_t;
#define AUX_MODE_EXT_P5r_CLR BCM53101_A0_AUX_MODE_EXT_P5r_CLR
#define AUX_MODE_EXT_P5r_SET BCM53101_A0_AUX_MODE_EXT_P5r_SET
#define AUX_MODE_EXT_P5r_GET BCM53101_A0_AUX_MODE_EXT_P5r_GET
#define AUX_MODE_EXT_P5r_RESERVEDf_GET BCM53101_A0_AUX_MODE_EXT_P5r_RESERVEDf_GET
#define AUX_MODE_EXT_P5r_RESERVEDf_SET BCM53101_A0_AUX_MODE_EXT_P5r_RESERVEDf_SET
#define AUX_MODE_EXT_P5r_BLOCK_TXEN_MODEf_GET BCM53101_A0_AUX_MODE_EXT_P5r_BLOCK_TXEN_MODEf_GET
#define AUX_MODE_EXT_P5r_BLOCK_TXEN_MODEf_SET BCM53101_A0_AUX_MODE_EXT_P5r_BLOCK_TXEN_MODEf_SET
#define AUX_MODE_EXT_P5r_LINK_LED_DISABLEf_GET BCM53101_A0_AUX_MODE_EXT_P5r_LINK_LED_DISABLEf_GET
#define AUX_MODE_EXT_P5r_LINK_LED_DISABLEf_SET BCM53101_A0_AUX_MODE_EXT_P5r_LINK_LED_DISABLEf_SET
#define AUX_MODE_EXT_P5r_ACT_LED_DISABLEf_GET BCM53101_A0_AUX_MODE_EXT_P5r_ACT_LED_DISABLEf_GET
#define AUX_MODE_EXT_P5r_ACT_LED_DISABLEf_SET BCM53101_A0_AUX_MODE_EXT_P5r_ACT_LED_DISABLEf_SET
#define READ_AUX_MODE_EXT_P5r BCM53101_A0_READ_AUX_MODE_EXT_P5r
#define WRITE_AUX_MODE_EXT_P5r BCM53101_A0_WRITE_AUX_MODE_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_AUX_MODE_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  AUX_MULTI_PHY
 * BLOCKS:   EPIC0
 * DESC:     AUXILIARY MULTIPLE PHY REGISTER
 * SIZE:     16
 * FIELDS:
 *     RESERVED         Reserved
 *     B10T_SERIAL_MODE 1 = Enable 10BASE-T Serial mode.0 = Disable 10BASE-T Serial mode.
 *     SUPER_ISOLATE    1 = Super Isolate mode0 = Normal operation.    
 *     ABILITY_DETECT   1 = Auto-Negotiation Waiting for LP ability.
 *     ACK_DETECTED     1 = Auto-Negotiation Acknowledge detected.
 *     ACK_COMPLETE     1 = Auto-Negotiation Acknowledge completed.
 *     AN_COMPLETE      1 = Auto-negotiation process completed.0 = Auto-negotiation process not completed.
 *     RESTART_AN       1 = Restart auto-negotiation process.0 = (No effect).
 *     HCD_B10T         1 = Auto-negotiation result is 10BASE-T.
 *     HCD_B10T_FDX     1 = Auto-negotiation result is 10BASE-T fullduplex.
 *     HCD_TX           1 = Auto-negotiation result is 100BASE-TX.
 *     HCD_T4           1 = Auto-negotiation result is 100BASE-T4.
 *     HCD_TX_FDX       1 = Auto-negotiation result is 100BASE-TX fullduplex.
 *
 ******************************************************************************/
#define BCM53101_A0_AUX_MULTI_PHYr 0x0000103c

#define BCM53101_A0_AUX_MULTI_PHYr_SIZE 2

/*
 * This structure should be used to declare and program AUX_MULTI_PHY.
 *
 */
typedef union BCM53101_A0_AUX_MULTI_PHYr_s {
	uint32_t v[1];
	uint32_t aux_multi_phy[1];
	uint32_t _aux_multi_phy;
} BCM53101_A0_AUX_MULTI_PHYr_t;

#define BCM53101_A0_AUX_MULTI_PHYr_CLR(r) (r).aux_multi_phy[0] = 0
#define BCM53101_A0_AUX_MULTI_PHYr_SET(r,d) (r).aux_multi_phy[0] = d
#define BCM53101_A0_AUX_MULTI_PHYr_GET(r) (r).aux_multi_phy[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_AUX_MULTI_PHYr_RESERVEDf_GET(r) (((r).aux_multi_phy[0]) & 0x1)
#define BCM53101_A0_AUX_MULTI_PHYr_RESERVEDf_SET(r,f) (r).aux_multi_phy[0]=(((r).aux_multi_phy[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_AUX_MULTI_PHYr_B10T_SERIAL_MODEf_GET(r) ((((r).aux_multi_phy[0]) >> 1) & 0x1)
#define BCM53101_A0_AUX_MULTI_PHYr_B10T_SERIAL_MODEf_SET(r,f) (r).aux_multi_phy[0]=(((r).aux_multi_phy[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_AUX_MULTI_PHYr_SUPER_ISOLATEf_GET(r) ((((r).aux_multi_phy[0]) >> 3) & 0x1)
#define BCM53101_A0_AUX_MULTI_PHYr_SUPER_ISOLATEf_SET(r,f) (r).aux_multi_phy[0]=(((r).aux_multi_phy[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_AUX_MULTI_PHYr_ABILITY_DETECTf_GET(r) ((((r).aux_multi_phy[0]) >> 4) & 0x1)
#define BCM53101_A0_AUX_MULTI_PHYr_ABILITY_DETECTf_SET(r,f) (r).aux_multi_phy[0]=(((r).aux_multi_phy[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_AUX_MULTI_PHYr_ACK_DETECTEDf_GET(r) ((((r).aux_multi_phy[0]) >> 5) & 0x1)
#define BCM53101_A0_AUX_MULTI_PHYr_ACK_DETECTEDf_SET(r,f) (r).aux_multi_phy[0]=(((r).aux_multi_phy[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_AUX_MULTI_PHYr_ACK_COMPLETEf_GET(r) ((((r).aux_multi_phy[0]) >> 6) & 0x1)
#define BCM53101_A0_AUX_MULTI_PHYr_ACK_COMPLETEf_SET(r,f) (r).aux_multi_phy[0]=(((r).aux_multi_phy[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_AUX_MULTI_PHYr_AN_COMPLETEf_GET(r) ((((r).aux_multi_phy[0]) >> 7) & 0x1)
#define BCM53101_A0_AUX_MULTI_PHYr_AN_COMPLETEf_SET(r,f) (r).aux_multi_phy[0]=(((r).aux_multi_phy[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53101_A0_AUX_MULTI_PHYr_RESTART_ANf_GET(r) ((((r).aux_multi_phy[0]) >> 8) & 0x1)
#define BCM53101_A0_AUX_MULTI_PHYr_RESTART_ANf_SET(r,f) (r).aux_multi_phy[0]=(((r).aux_multi_phy[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53101_A0_AUX_MULTI_PHYr_HCD_B10Tf_GET(r) ((((r).aux_multi_phy[0]) >> 11) & 0x1)
#define BCM53101_A0_AUX_MULTI_PHYr_HCD_B10Tf_SET(r,f) (r).aux_multi_phy[0]=(((r).aux_multi_phy[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53101_A0_AUX_MULTI_PHYr_HCD_B10T_FDXf_GET(r) ((((r).aux_multi_phy[0]) >> 12) & 0x1)
#define BCM53101_A0_AUX_MULTI_PHYr_HCD_B10T_FDXf_SET(r,f) (r).aux_multi_phy[0]=(((r).aux_multi_phy[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53101_A0_AUX_MULTI_PHYr_HCD_TXf_GET(r) ((((r).aux_multi_phy[0]) >> 13) & 0x1)
#define BCM53101_A0_AUX_MULTI_PHYr_HCD_TXf_SET(r,f) (r).aux_multi_phy[0]=(((r).aux_multi_phy[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53101_A0_AUX_MULTI_PHYr_HCD_T4f_GET(r) ((((r).aux_multi_phy[0]) >> 14) & 0x1)
#define BCM53101_A0_AUX_MULTI_PHYr_HCD_T4f_SET(r,f) (r).aux_multi_phy[0]=(((r).aux_multi_phy[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_AUX_MULTI_PHYr_HCD_TX_FDXf_GET(r) ((((r).aux_multi_phy[0]) >> 15) & 0x1)
#define BCM53101_A0_AUX_MULTI_PHYr_HCD_TX_FDXf_SET(r,f) (r).aux_multi_phy[0]=(((r).aux_multi_phy[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access AUX_MULTI_PHY.
 *
 */
#define BCM53101_A0_READ_AUX_MULTI_PHYr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_AUX_MULTI_PHYr,(r._aux_multi_phy),2)
#define BCM53101_A0_WRITE_AUX_MULTI_PHYr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_AUX_MULTI_PHYr,&(r._aux_multi_phy),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AUX_MULTI_PHYr BCM53101_A0_AUX_MULTI_PHYr
#define AUX_MULTI_PHYr_SIZE BCM53101_A0_AUX_MULTI_PHYr_SIZE
typedef BCM53101_A0_AUX_MULTI_PHYr_t AUX_MULTI_PHYr_t;
#define AUX_MULTI_PHYr_CLR BCM53101_A0_AUX_MULTI_PHYr_CLR
#define AUX_MULTI_PHYr_SET BCM53101_A0_AUX_MULTI_PHYr_SET
#define AUX_MULTI_PHYr_GET BCM53101_A0_AUX_MULTI_PHYr_GET
#define AUX_MULTI_PHYr_RESERVEDf_GET BCM53101_A0_AUX_MULTI_PHYr_RESERVEDf_GET
#define AUX_MULTI_PHYr_RESERVEDf_SET BCM53101_A0_AUX_MULTI_PHYr_RESERVEDf_SET
#define AUX_MULTI_PHYr_B10T_SERIAL_MODEf_GET BCM53101_A0_AUX_MULTI_PHYr_B10T_SERIAL_MODEf_GET
#define AUX_MULTI_PHYr_B10T_SERIAL_MODEf_SET BCM53101_A0_AUX_MULTI_PHYr_B10T_SERIAL_MODEf_SET
#define AUX_MULTI_PHYr_SUPER_ISOLATEf_GET BCM53101_A0_AUX_MULTI_PHYr_SUPER_ISOLATEf_GET
#define AUX_MULTI_PHYr_SUPER_ISOLATEf_SET BCM53101_A0_AUX_MULTI_PHYr_SUPER_ISOLATEf_SET
#define AUX_MULTI_PHYr_ABILITY_DETECTf_GET BCM53101_A0_AUX_MULTI_PHYr_ABILITY_DETECTf_GET
#define AUX_MULTI_PHYr_ABILITY_DETECTf_SET BCM53101_A0_AUX_MULTI_PHYr_ABILITY_DETECTf_SET
#define AUX_MULTI_PHYr_ACK_DETECTEDf_GET BCM53101_A0_AUX_MULTI_PHYr_ACK_DETECTEDf_GET
#define AUX_MULTI_PHYr_ACK_DETECTEDf_SET BCM53101_A0_AUX_MULTI_PHYr_ACK_DETECTEDf_SET
#define AUX_MULTI_PHYr_ACK_COMPLETEf_GET BCM53101_A0_AUX_MULTI_PHYr_ACK_COMPLETEf_GET
#define AUX_MULTI_PHYr_ACK_COMPLETEf_SET BCM53101_A0_AUX_MULTI_PHYr_ACK_COMPLETEf_SET
#define AUX_MULTI_PHYr_AN_COMPLETEf_GET BCM53101_A0_AUX_MULTI_PHYr_AN_COMPLETEf_GET
#define AUX_MULTI_PHYr_AN_COMPLETEf_SET BCM53101_A0_AUX_MULTI_PHYr_AN_COMPLETEf_SET
#define AUX_MULTI_PHYr_RESTART_ANf_GET BCM53101_A0_AUX_MULTI_PHYr_RESTART_ANf_GET
#define AUX_MULTI_PHYr_RESTART_ANf_SET BCM53101_A0_AUX_MULTI_PHYr_RESTART_ANf_SET
#define AUX_MULTI_PHYr_HCD_B10Tf_GET BCM53101_A0_AUX_MULTI_PHYr_HCD_B10Tf_GET
#define AUX_MULTI_PHYr_HCD_B10Tf_SET BCM53101_A0_AUX_MULTI_PHYr_HCD_B10Tf_SET
#define AUX_MULTI_PHYr_HCD_B10T_FDXf_GET BCM53101_A0_AUX_MULTI_PHYr_HCD_B10T_FDXf_GET
#define AUX_MULTI_PHYr_HCD_B10T_FDXf_SET BCM53101_A0_AUX_MULTI_PHYr_HCD_B10T_FDXf_SET
#define AUX_MULTI_PHYr_HCD_TXf_GET BCM53101_A0_AUX_MULTI_PHYr_HCD_TXf_GET
#define AUX_MULTI_PHYr_HCD_TXf_SET BCM53101_A0_AUX_MULTI_PHYr_HCD_TXf_SET
#define AUX_MULTI_PHYr_HCD_T4f_GET BCM53101_A0_AUX_MULTI_PHYr_HCD_T4f_GET
#define AUX_MULTI_PHYr_HCD_T4f_SET BCM53101_A0_AUX_MULTI_PHYr_HCD_T4f_SET
#define AUX_MULTI_PHYr_HCD_TX_FDXf_GET BCM53101_A0_AUX_MULTI_PHYr_HCD_TX_FDXf_GET
#define AUX_MULTI_PHYr_HCD_TX_FDXf_SET BCM53101_A0_AUX_MULTI_PHYr_HCD_TX_FDXf_SET
#define READ_AUX_MULTI_PHYr BCM53101_A0_READ_AUX_MULTI_PHYr
#define WRITE_AUX_MULTI_PHYr BCM53101_A0_WRITE_AUX_MULTI_PHYr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_AUX_MULTI_PHYr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  AUX_MULTI_PHY_EXT_P5
 * BLOCKS:   SYS
 * DESC:     AUXILIARY MULTIPLE PHY REGISTER
 * SIZE:     16
 * FIELDS:
 *     RESERVED         Reserved
 *     B10T_SERIAL_MODE 1 = Enable 10BASE-T Serial mode.0 = Disable 10BASE-T Serial mode.
 *     SUPER_ISOLATE    1 = Super Isolate mode0 = Normal operation.    
 *     ABILITY_DETECT   1 = Auto-Negotiation Waiting for LP ability.
 *     ACK_DETECTED     1 = Auto-Negotiation Acknowledge detected.
 *     ACK_COMPLETE     1 = Auto-Negotiation Acknowledge completed.
 *     AN_COMPLETE      1 = Auto-negotiation process completed.0 = Auto-negotiation process not completed.
 *     RESTART_AN       1 = Restart auto-negotiation process.0 = (No effect).
 *     HCD_B10T         1 = Auto-negotiation result is 10BASE-T.
 *     HCD_B10T_FDX     1 = Auto-negotiation result is 10BASE-T fullduplex.
 *     HCD_TX           1 = Auto-negotiation result is 100BASE-TX.
 *     HCD_T4           1 = Auto-negotiation result is 100BASE-T4.
 *     HCD_TX_FDX       1 = Auto-negotiation result is 100BASE-TX fullduplex.
 *
 ******************************************************************************/
#define BCM53101_A0_AUX_MULTI_PHY_EXT_P5r 0x0000853c

#define BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program AUX_MULTI_PHY_EXT_P5.
 *
 */
typedef union BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_s {
	uint32_t v[1];
	uint32_t aux_multi_phy_ext_p5[1];
	uint32_t _aux_multi_phy_ext_p5;
} BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_t;

#define BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_CLR(r) (r).aux_multi_phy_ext_p5[0] = 0
#define BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_SET(r,d) (r).aux_multi_phy_ext_p5[0] = d
#define BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_GET(r) (r).aux_multi_phy_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_RESERVEDf_GET(r) (((r).aux_multi_phy_ext_p5[0]) & 0x1)
#define BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_RESERVEDf_SET(r,f) (r).aux_multi_phy_ext_p5[0]=(((r).aux_multi_phy_ext_p5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_B10T_SERIAL_MODEf_GET(r) ((((r).aux_multi_phy_ext_p5[0]) >> 1) & 0x1)
#define BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_B10T_SERIAL_MODEf_SET(r,f) (r).aux_multi_phy_ext_p5[0]=(((r).aux_multi_phy_ext_p5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_SUPER_ISOLATEf_GET(r) ((((r).aux_multi_phy_ext_p5[0]) >> 3) & 0x1)
#define BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_SUPER_ISOLATEf_SET(r,f) (r).aux_multi_phy_ext_p5[0]=(((r).aux_multi_phy_ext_p5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_ABILITY_DETECTf_GET(r) ((((r).aux_multi_phy_ext_p5[0]) >> 4) & 0x1)
#define BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_ABILITY_DETECTf_SET(r,f) (r).aux_multi_phy_ext_p5[0]=(((r).aux_multi_phy_ext_p5[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_ACK_DETECTEDf_GET(r) ((((r).aux_multi_phy_ext_p5[0]) >> 5) & 0x1)
#define BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_ACK_DETECTEDf_SET(r,f) (r).aux_multi_phy_ext_p5[0]=(((r).aux_multi_phy_ext_p5[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_ACK_COMPLETEf_GET(r) ((((r).aux_multi_phy_ext_p5[0]) >> 6) & 0x1)
#define BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_ACK_COMPLETEf_SET(r,f) (r).aux_multi_phy_ext_p5[0]=(((r).aux_multi_phy_ext_p5[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_AN_COMPLETEf_GET(r) ((((r).aux_multi_phy_ext_p5[0]) >> 7) & 0x1)
#define BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_AN_COMPLETEf_SET(r,f) (r).aux_multi_phy_ext_p5[0]=(((r).aux_multi_phy_ext_p5[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_RESTART_ANf_GET(r) ((((r).aux_multi_phy_ext_p5[0]) >> 8) & 0x1)
#define BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_RESTART_ANf_SET(r,f) (r).aux_multi_phy_ext_p5[0]=(((r).aux_multi_phy_ext_p5[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_HCD_B10Tf_GET(r) ((((r).aux_multi_phy_ext_p5[0]) >> 11) & 0x1)
#define BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_HCD_B10Tf_SET(r,f) (r).aux_multi_phy_ext_p5[0]=(((r).aux_multi_phy_ext_p5[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_HCD_B10T_FDXf_GET(r) ((((r).aux_multi_phy_ext_p5[0]) >> 12) & 0x1)
#define BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_HCD_B10T_FDXf_SET(r,f) (r).aux_multi_phy_ext_p5[0]=(((r).aux_multi_phy_ext_p5[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_HCD_TXf_GET(r) ((((r).aux_multi_phy_ext_p5[0]) >> 13) & 0x1)
#define BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_HCD_TXf_SET(r,f) (r).aux_multi_phy_ext_p5[0]=(((r).aux_multi_phy_ext_p5[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_HCD_T4f_GET(r) ((((r).aux_multi_phy_ext_p5[0]) >> 14) & 0x1)
#define BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_HCD_T4f_SET(r,f) (r).aux_multi_phy_ext_p5[0]=(((r).aux_multi_phy_ext_p5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_HCD_TX_FDXf_GET(r) ((((r).aux_multi_phy_ext_p5[0]) >> 15) & 0x1)
#define BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_HCD_TX_FDXf_SET(r,f) (r).aux_multi_phy_ext_p5[0]=(((r).aux_multi_phy_ext_p5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access AUX_MULTI_PHY_EXT_P5.
 *
 */
#define BCM53101_A0_READ_AUX_MULTI_PHY_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53101_A0_AUX_MULTI_PHY_EXT_P5r,(r._aux_multi_phy_ext_p5),2)
#define BCM53101_A0_WRITE_AUX_MULTI_PHY_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53101_A0_AUX_MULTI_PHY_EXT_P5r,&(r._aux_multi_phy_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AUX_MULTI_PHY_EXT_P5r BCM53101_A0_AUX_MULTI_PHY_EXT_P5r
#define AUX_MULTI_PHY_EXT_P5r_SIZE BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_SIZE
typedef BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_t AUX_MULTI_PHY_EXT_P5r_t;
#define AUX_MULTI_PHY_EXT_P5r_CLR BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_CLR
#define AUX_MULTI_PHY_EXT_P5r_SET BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_SET
#define AUX_MULTI_PHY_EXT_P5r_GET BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_GET
#define AUX_MULTI_PHY_EXT_P5r_RESERVEDf_GET BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_RESERVEDf_GET
#define AUX_MULTI_PHY_EXT_P5r_RESERVEDf_SET BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_RESERVEDf_SET
#define AUX_MULTI_PHY_EXT_P5r_B10T_SERIAL_MODEf_GET BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_B10T_SERIAL_MODEf_GET
#define AUX_MULTI_PHY_EXT_P5r_B10T_SERIAL_MODEf_SET BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_B10T_SERIAL_MODEf_SET
#define AUX_MULTI_PHY_EXT_P5r_SUPER_ISOLATEf_GET BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_SUPER_ISOLATEf_GET
#define AUX_MULTI_PHY_EXT_P5r_SUPER_ISOLATEf_SET BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_SUPER_ISOLATEf_SET
#define AUX_MULTI_PHY_EXT_P5r_ABILITY_DETECTf_GET BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_ABILITY_DETECTf_GET
#define AUX_MULTI_PHY_EXT_P5r_ABILITY_DETECTf_SET BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_ABILITY_DETECTf_SET
#define AUX_MULTI_PHY_EXT_P5r_ACK_DETECTEDf_GET BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_ACK_DETECTEDf_GET
#define AUX_MULTI_PHY_EXT_P5r_ACK_DETECTEDf_SET BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_ACK_DETECTEDf_SET
#define AUX_MULTI_PHY_EXT_P5r_ACK_COMPLETEf_GET BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_ACK_COMPLETEf_GET
#define AUX_MULTI_PHY_EXT_P5r_ACK_COMPLETEf_SET BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_ACK_COMPLETEf_SET
#define AUX_MULTI_PHY_EXT_P5r_AN_COMPLETEf_GET BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_AN_COMPLETEf_GET
#define AUX_MULTI_PHY_EXT_P5r_AN_COMPLETEf_SET BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_AN_COMPLETEf_SET
#define AUX_MULTI_PHY_EXT_P5r_RESTART_ANf_GET BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_RESTART_ANf_GET
#define AUX_MULTI_PHY_EXT_P5r_RESTART_ANf_SET BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_RESTART_ANf_SET
#define AUX_MULTI_PHY_EXT_P5r_HCD_B10Tf_GET BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_HCD_B10Tf_GET
#define AUX_MULTI_PHY_EXT_P5r_HCD_B10Tf_SET BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_HCD_B10Tf_SET
#define AUX_MULTI_PHY_EXT_P5r_HCD_B10T_FDXf_GET BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_HCD_B10T_FDXf_GET
#define AUX_MULTI_PHY_EXT_P5r_HCD_B10T_FDXf_SET BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_HCD_B10T_FDXf_SET
#define AUX_MULTI_PHY_EXT_P5r_HCD_TXf_GET BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_HCD_TXf_GET
#define AUX_MULTI_PHY_EXT_P5r_HCD_TXf_SET BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_HCD_TXf_SET
#define AUX_MULTI_PHY_EXT_P5r_HCD_T4f_GET BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_HCD_T4f_GET
#define AUX_MULTI_PHY_EXT_P5r_HCD_T4f_SET BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_HCD_T4f_SET
#define AUX_MULTI_PHY_EXT_P5r_HCD_TX_FDXf_GET BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_HCD_TX_FDXf_GET
#define AUX_MULTI_PHY_EXT_P5r_HCD_TX_FDXf_SET BCM53101_A0_AUX_MULTI_PHY_EXT_P5r_HCD_TX_FDXf_SET
#define READ_AUX_MULTI_PHY_EXT_P5r BCM53101_A0_READ_AUX_MULTI_PHY_EXT_P5r
#define WRITE_AUX_MULTI_PHY_EXT_P5r BCM53101_A0_WRITE_AUX_MULTI_PHY_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_AUX_MULTI_PHY_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  AUX_STATUS_SUMMARY
 * BLOCKS:   EPIC0
 * DESC:     AUXILIARY STATUS SUMMARY REGISTER
 * SIZE:     16
 * FIELDS:
 *     FDX_INDICATION   1 = Full-duplex active.0 = Full-duplex inactive.
 *     AN_ENABLED       1 = Auto-negotiation enabled.
 *     LINK_STATUS      1 = Link is up (link pass state).
 *     SPEED_INDICATOR  1 = 100 Mbps.0 = 10 Mbps.
 *     LP_AN_CAP        1 = Link partner is auto-negotiation capable.
 *     LP_PAGE_RECEIVED 1 = New page has been received.
 *     RESERVED         Reserved
 *     AN_PARALLEL_DETECT_FAULT 1 = Parallel Detection fault.
 *     AN_HCD           000 = No highest common denominator001 = 10BASE-T010 = 10BASE-T full-duplex011 = 100BASE-TX100 = 100BASE-T4    101 = 100BASE-TX full-duplex11x = undefined
 *     AN_PAUSE         PHY and link partner pause operation bit set
 *     AN_ABILITY_DETECT 1 = Auto-negotiation for link partner ability
 *     AN_ACK_DETECTED  1 = Auto-negotiation acknowledge detected.
 *     AN_COMPLETE_ACK  1 = Auto-negotiation completed acknowledge state.
 *     AN_COMPLETE      1 = Auto-negotiation process completed.
 *
 ******************************************************************************/
#define BCM53101_A0_AUX_STATUS_SUMMARYr 0x00001032

#define BCM53101_A0_AUX_STATUS_SUMMARYr_SIZE 2

/*
 * This structure should be used to declare and program AUX_STATUS_SUMMARY.
 *
 */
typedef union BCM53101_A0_AUX_STATUS_SUMMARYr_s {
	uint32_t v[1];
	uint32_t aux_status_summary[1];
	uint32_t _aux_status_summary;
} BCM53101_A0_AUX_STATUS_SUMMARYr_t;

#define BCM53101_A0_AUX_STATUS_SUMMARYr_CLR(r) (r).aux_status_summary[0] = 0
#define BCM53101_A0_AUX_STATUS_SUMMARYr_SET(r,d) (r).aux_status_summary[0] = d
#define BCM53101_A0_AUX_STATUS_SUMMARYr_GET(r) (r).aux_status_summary[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_AUX_STATUS_SUMMARYr_FDX_INDICATIONf_GET(r) (((r).aux_status_summary[0]) & 0x1)
#define BCM53101_A0_AUX_STATUS_SUMMARYr_FDX_INDICATIONf_SET(r,f) (r).aux_status_summary[0]=(((r).aux_status_summary[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_AUX_STATUS_SUMMARYr_AN_ENABLEDf_GET(r) ((((r).aux_status_summary[0]) >> 1) & 0x1)
#define BCM53101_A0_AUX_STATUS_SUMMARYr_AN_ENABLEDf_SET(r,f) (r).aux_status_summary[0]=(((r).aux_status_summary[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_AUX_STATUS_SUMMARYr_LINK_STATUSf_GET(r) ((((r).aux_status_summary[0]) >> 2) & 0x1)
#define BCM53101_A0_AUX_STATUS_SUMMARYr_LINK_STATUSf_SET(r,f) (r).aux_status_summary[0]=(((r).aux_status_summary[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_AUX_STATUS_SUMMARYr_SPEED_INDICATORf_GET(r) ((((r).aux_status_summary[0]) >> 3) & 0x1)
#define BCM53101_A0_AUX_STATUS_SUMMARYr_SPEED_INDICATORf_SET(r,f) (r).aux_status_summary[0]=(((r).aux_status_summary[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_AUX_STATUS_SUMMARYr_LP_AN_CAPf_GET(r) ((((r).aux_status_summary[0]) >> 4) & 0x1)
#define BCM53101_A0_AUX_STATUS_SUMMARYr_LP_AN_CAPf_SET(r,f) (r).aux_status_summary[0]=(((r).aux_status_summary[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_AUX_STATUS_SUMMARYr_LP_PAGE_RECEIVEDf_GET(r) ((((r).aux_status_summary[0]) >> 5) & 0x1)
#define BCM53101_A0_AUX_STATUS_SUMMARYr_LP_PAGE_RECEIVEDf_SET(r,f) (r).aux_status_summary[0]=(((r).aux_status_summary[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_AUX_STATUS_SUMMARYr_RESERVEDf_GET(r) ((((r).aux_status_summary[0]) >> 6) & 0x1)
#define BCM53101_A0_AUX_STATUS_SUMMARYr_RESERVEDf_SET(r,f) (r).aux_status_summary[0]=(((r).aux_status_summary[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_AUX_STATUS_SUMMARYr_AN_PARALLEL_DETECT_FAULTf_GET(r) ((((r).aux_status_summary[0]) >> 7) & 0x1)
#define BCM53101_A0_AUX_STATUS_SUMMARYr_AN_PARALLEL_DETECT_FAULTf_SET(r,f) (r).aux_status_summary[0]=(((r).aux_status_summary[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53101_A0_AUX_STATUS_SUMMARYr_AN_HCDf_GET(r) ((((r).aux_status_summary[0]) >> 8) & 0x7)
#define BCM53101_A0_AUX_STATUS_SUMMARYr_AN_HCDf_SET(r,f) (r).aux_status_summary[0]=(((r).aux_status_summary[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCM53101_A0_AUX_STATUS_SUMMARYr_AN_PAUSEf_GET(r) ((((r).aux_status_summary[0]) >> 11) & 0x1)
#define BCM53101_A0_AUX_STATUS_SUMMARYr_AN_PAUSEf_SET(r,f) (r).aux_status_summary[0]=(((r).aux_status_summary[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53101_A0_AUX_STATUS_SUMMARYr_AN_ABILITY_DETECTf_GET(r) ((((r).aux_status_summary[0]) >> 12) & 0x1)
#define BCM53101_A0_AUX_STATUS_SUMMARYr_AN_ABILITY_DETECTf_SET(r,f) (r).aux_status_summary[0]=(((r).aux_status_summary[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53101_A0_AUX_STATUS_SUMMARYr_AN_ACK_DETECTEDf_GET(r) ((((r).aux_status_summary[0]) >> 13) & 0x1)
#define BCM53101_A0_AUX_STATUS_SUMMARYr_AN_ACK_DETECTEDf_SET(r,f) (r).aux_status_summary[0]=(((r).aux_status_summary[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53101_A0_AUX_STATUS_SUMMARYr_AN_COMPLETE_ACKf_GET(r) ((((r).aux_status_summary[0]) >> 14) & 0x1)
#define BCM53101_A0_AUX_STATUS_SUMMARYr_AN_COMPLETE_ACKf_SET(r,f) (r).aux_status_summary[0]=(((r).aux_status_summary[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_AUX_STATUS_SUMMARYr_AN_COMPLETEf_GET(r) ((((r).aux_status_summary[0]) >> 15) & 0x1)
#define BCM53101_A0_AUX_STATUS_SUMMARYr_AN_COMPLETEf_SET(r,f) (r).aux_status_summary[0]=(((r).aux_status_summary[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access AUX_STATUS_SUMMARY.
 *
 */
#define BCM53101_A0_READ_AUX_STATUS_SUMMARYr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_AUX_STATUS_SUMMARYr,(r._aux_status_summary),2)
#define BCM53101_A0_WRITE_AUX_STATUS_SUMMARYr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_AUX_STATUS_SUMMARYr,&(r._aux_status_summary),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AUX_STATUS_SUMMARYr BCM53101_A0_AUX_STATUS_SUMMARYr
#define AUX_STATUS_SUMMARYr_SIZE BCM53101_A0_AUX_STATUS_SUMMARYr_SIZE
typedef BCM53101_A0_AUX_STATUS_SUMMARYr_t AUX_STATUS_SUMMARYr_t;
#define AUX_STATUS_SUMMARYr_CLR BCM53101_A0_AUX_STATUS_SUMMARYr_CLR
#define AUX_STATUS_SUMMARYr_SET BCM53101_A0_AUX_STATUS_SUMMARYr_SET
#define AUX_STATUS_SUMMARYr_GET BCM53101_A0_AUX_STATUS_SUMMARYr_GET
#define AUX_STATUS_SUMMARYr_FDX_INDICATIONf_GET BCM53101_A0_AUX_STATUS_SUMMARYr_FDX_INDICATIONf_GET
#define AUX_STATUS_SUMMARYr_FDX_INDICATIONf_SET BCM53101_A0_AUX_STATUS_SUMMARYr_FDX_INDICATIONf_SET
#define AUX_STATUS_SUMMARYr_AN_ENABLEDf_GET BCM53101_A0_AUX_STATUS_SUMMARYr_AN_ENABLEDf_GET
#define AUX_STATUS_SUMMARYr_AN_ENABLEDf_SET BCM53101_A0_AUX_STATUS_SUMMARYr_AN_ENABLEDf_SET
#define AUX_STATUS_SUMMARYr_LINK_STATUSf_GET BCM53101_A0_AUX_STATUS_SUMMARYr_LINK_STATUSf_GET
#define AUX_STATUS_SUMMARYr_LINK_STATUSf_SET BCM53101_A0_AUX_STATUS_SUMMARYr_LINK_STATUSf_SET
#define AUX_STATUS_SUMMARYr_SPEED_INDICATORf_GET BCM53101_A0_AUX_STATUS_SUMMARYr_SPEED_INDICATORf_GET
#define AUX_STATUS_SUMMARYr_SPEED_INDICATORf_SET BCM53101_A0_AUX_STATUS_SUMMARYr_SPEED_INDICATORf_SET
#define AUX_STATUS_SUMMARYr_LP_AN_CAPf_GET BCM53101_A0_AUX_STATUS_SUMMARYr_LP_AN_CAPf_GET
#define AUX_STATUS_SUMMARYr_LP_AN_CAPf_SET BCM53101_A0_AUX_STATUS_SUMMARYr_LP_AN_CAPf_SET
#define AUX_STATUS_SUMMARYr_LP_PAGE_RECEIVEDf_GET BCM53101_A0_AUX_STATUS_SUMMARYr_LP_PAGE_RECEIVEDf_GET
#define AUX_STATUS_SUMMARYr_LP_PAGE_RECEIVEDf_SET BCM53101_A0_AUX_STATUS_SUMMARYr_LP_PAGE_RECEIVEDf_SET
#define AUX_STATUS_SUMMARYr_RESERVEDf_GET BCM53101_A0_AUX_STATUS_SUMMARYr_RESERVEDf_GET
#define AUX_STATUS_SUMMARYr_RESERVEDf_SET BCM53101_A0_AUX_STATUS_SUMMARYr_RESERVEDf_SET
#define AUX_STATUS_SUMMARYr_AN_PARALLEL_DETECT_FAULTf_GET BCM53101_A0_AUX_STATUS_SUMMARYr_AN_PARALLEL_DETECT_FAULTf_GET
#define AUX_STATUS_SUMMARYr_AN_PARALLEL_DETECT_FAULTf_SET BCM53101_A0_AUX_STATUS_SUMMARYr_AN_PARALLEL_DETECT_FAULTf_SET
#define AUX_STATUS_SUMMARYr_AN_HCDf_GET BCM53101_A0_AUX_STATUS_SUMMARYr_AN_HCDf_GET
#define AUX_STATUS_SUMMARYr_AN_HCDf_SET BCM53101_A0_AUX_STATUS_SUMMARYr_AN_HCDf_SET
#define AUX_STATUS_SUMMARYr_AN_PAUSEf_GET BCM53101_A0_AUX_STATUS_SUMMARYr_AN_PAUSEf_GET
#define AUX_STATUS_SUMMARYr_AN_PAUSEf_SET BCM53101_A0_AUX_STATUS_SUMMARYr_AN_PAUSEf_SET
#define AUX_STATUS_SUMMARYr_AN_ABILITY_DETECTf_GET BCM53101_A0_AUX_STATUS_SUMMARYr_AN_ABILITY_DETECTf_GET
#define AUX_STATUS_SUMMARYr_AN_ABILITY_DETECTf_SET BCM53101_A0_AUX_STATUS_SUMMARYr_AN_ABILITY_DETECTf_SET
#define AUX_STATUS_SUMMARYr_AN_ACK_DETECTEDf_GET BCM53101_A0_AUX_STATUS_SUMMARYr_AN_ACK_DETECTEDf_GET
#define AUX_STATUS_SUMMARYr_AN_ACK_DETECTEDf_SET BCM53101_A0_AUX_STATUS_SUMMARYr_AN_ACK_DETECTEDf_SET
#define AUX_STATUS_SUMMARYr_AN_COMPLETE_ACKf_GET BCM53101_A0_AUX_STATUS_SUMMARYr_AN_COMPLETE_ACKf_GET
#define AUX_STATUS_SUMMARYr_AN_COMPLETE_ACKf_SET BCM53101_A0_AUX_STATUS_SUMMARYr_AN_COMPLETE_ACKf_SET
#define AUX_STATUS_SUMMARYr_AN_COMPLETEf_GET BCM53101_A0_AUX_STATUS_SUMMARYr_AN_COMPLETEf_GET
#define AUX_STATUS_SUMMARYr_AN_COMPLETEf_SET BCM53101_A0_AUX_STATUS_SUMMARYr_AN_COMPLETEf_SET
#define READ_AUX_STATUS_SUMMARYr BCM53101_A0_READ_AUX_STATUS_SUMMARYr
#define WRITE_AUX_STATUS_SUMMARYr BCM53101_A0_WRITE_AUX_STATUS_SUMMARYr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_AUX_STATUS_SUMMARYr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  AUX_STATUS_SUMMARY_EXT_P5
 * BLOCKS:   SYS
 * DESC:     AUXILIARY STATUS SUMMARY REGISTER
 * SIZE:     16
 * FIELDS:
 *     FDX_INDICATION   1 = Full-duplex active.0 = Full-duplex inactive.
 *     AN_ENABLED       1 = Auto-negotiation enabled.
 *     LINK_STATUS      1 = Link is up (link pass state).
 *     SPEED_INDICATOR  1 = 100 Mbps.0 = 10 Mbps.
 *     LP_AN_CAP        1 = Link partner is auto-negotiation capable.
 *     LP_PAGE_RECEIVED 1 = New page has been received.
 *     RESERVED         Reserved
 *     AN_PARALLEL_DETECT_FAULT 1 = Parallel Detection fault.
 *     AN_HCD           000 = No highest common denominator001 = 10BASE-T010 = 10BASE-T full-duplex011 = 100BASE-TX100 = 100BASE-T4    101 = 100BASE-TX full-duplex11x = undefined
 *     AN_PAUSE         PHY and link partner pause operation bit set
 *     AN_ABILITY_DETECT 1 = Auto-negotiation for link partner ability
 *     AN_ACK_DETECTED  1 = Auto-negotiation acknowledge detected.
 *     AN_COMPLETE_ACK  1 = Auto-negotiation completed acknowledge state.
 *     AN_COMPLETE      1 = Auto-negotiation process completed.
 *
 ******************************************************************************/
#define BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r 0x00008532

#define BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program AUX_STATUS_SUMMARY_EXT_P5.
 *
 */
typedef union BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_s {
	uint32_t v[1];
	uint32_t aux_status_summary_ext_p5[1];
	uint32_t _aux_status_summary_ext_p5;
} BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_t;

#define BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_CLR(r) (r).aux_status_summary_ext_p5[0] = 0
#define BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_SET(r,d) (r).aux_status_summary_ext_p5[0] = d
#define BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_GET(r) (r).aux_status_summary_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_FDX_INDICATIONf_GET(r) (((r).aux_status_summary_ext_p5[0]) & 0x1)
#define BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_FDX_INDICATIONf_SET(r,f) (r).aux_status_summary_ext_p5[0]=(((r).aux_status_summary_ext_p5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_AN_ENABLEDf_GET(r) ((((r).aux_status_summary_ext_p5[0]) >> 1) & 0x1)
#define BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_AN_ENABLEDf_SET(r,f) (r).aux_status_summary_ext_p5[0]=(((r).aux_status_summary_ext_p5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_LINK_STATUSf_GET(r) ((((r).aux_status_summary_ext_p5[0]) >> 2) & 0x1)
#define BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_LINK_STATUSf_SET(r,f) (r).aux_status_summary_ext_p5[0]=(((r).aux_status_summary_ext_p5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_SPEED_INDICATORf_GET(r) ((((r).aux_status_summary_ext_p5[0]) >> 3) & 0x1)
#define BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_SPEED_INDICATORf_SET(r,f) (r).aux_status_summary_ext_p5[0]=(((r).aux_status_summary_ext_p5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_LP_AN_CAPf_GET(r) ((((r).aux_status_summary_ext_p5[0]) >> 4) & 0x1)
#define BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_LP_AN_CAPf_SET(r,f) (r).aux_status_summary_ext_p5[0]=(((r).aux_status_summary_ext_p5[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_LP_PAGE_RECEIVEDf_GET(r) ((((r).aux_status_summary_ext_p5[0]) >> 5) & 0x1)
#define BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_LP_PAGE_RECEIVEDf_SET(r,f) (r).aux_status_summary_ext_p5[0]=(((r).aux_status_summary_ext_p5[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_RESERVEDf_GET(r) ((((r).aux_status_summary_ext_p5[0]) >> 6) & 0x1)
#define BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_RESERVEDf_SET(r,f) (r).aux_status_summary_ext_p5[0]=(((r).aux_status_summary_ext_p5[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_AN_PARALLEL_DETECT_FAULTf_GET(r) ((((r).aux_status_summary_ext_p5[0]) >> 7) & 0x1)
#define BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_AN_PARALLEL_DETECT_FAULTf_SET(r,f) (r).aux_status_summary_ext_p5[0]=(((r).aux_status_summary_ext_p5[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_AN_HCDf_GET(r) ((((r).aux_status_summary_ext_p5[0]) >> 8) & 0x7)
#define BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_AN_HCDf_SET(r,f) (r).aux_status_summary_ext_p5[0]=(((r).aux_status_summary_ext_p5[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_AN_PAUSEf_GET(r) ((((r).aux_status_summary_ext_p5[0]) >> 11) & 0x1)
#define BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_AN_PAUSEf_SET(r,f) (r).aux_status_summary_ext_p5[0]=(((r).aux_status_summary_ext_p5[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_AN_ABILITY_DETECTf_GET(r) ((((r).aux_status_summary_ext_p5[0]) >> 12) & 0x1)
#define BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_AN_ABILITY_DETECTf_SET(r,f) (r).aux_status_summary_ext_p5[0]=(((r).aux_status_summary_ext_p5[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_AN_ACK_DETECTEDf_GET(r) ((((r).aux_status_summary_ext_p5[0]) >> 13) & 0x1)
#define BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_AN_ACK_DETECTEDf_SET(r,f) (r).aux_status_summary_ext_p5[0]=(((r).aux_status_summary_ext_p5[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_AN_COMPLETE_ACKf_GET(r) ((((r).aux_status_summary_ext_p5[0]) >> 14) & 0x1)
#define BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_AN_COMPLETE_ACKf_SET(r,f) (r).aux_status_summary_ext_p5[0]=(((r).aux_status_summary_ext_p5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_AN_COMPLETEf_GET(r) ((((r).aux_status_summary_ext_p5[0]) >> 15) & 0x1)
#define BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_AN_COMPLETEf_SET(r,f) (r).aux_status_summary_ext_p5[0]=(((r).aux_status_summary_ext_p5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access AUX_STATUS_SUMMARY_EXT_P5.
 *
 */
#define BCM53101_A0_READ_AUX_STATUS_SUMMARY_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r,(r._aux_status_summary_ext_p5),2)
#define BCM53101_A0_WRITE_AUX_STATUS_SUMMARY_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r,&(r._aux_status_summary_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define AUX_STATUS_SUMMARY_EXT_P5r BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r
#define AUX_STATUS_SUMMARY_EXT_P5r_SIZE BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_SIZE
typedef BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_t AUX_STATUS_SUMMARY_EXT_P5r_t;
#define AUX_STATUS_SUMMARY_EXT_P5r_CLR BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_CLR
#define AUX_STATUS_SUMMARY_EXT_P5r_SET BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_SET
#define AUX_STATUS_SUMMARY_EXT_P5r_GET BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_GET
#define AUX_STATUS_SUMMARY_EXT_P5r_FDX_INDICATIONf_GET BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_FDX_INDICATIONf_GET
#define AUX_STATUS_SUMMARY_EXT_P5r_FDX_INDICATIONf_SET BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_FDX_INDICATIONf_SET
#define AUX_STATUS_SUMMARY_EXT_P5r_AN_ENABLEDf_GET BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_AN_ENABLEDf_GET
#define AUX_STATUS_SUMMARY_EXT_P5r_AN_ENABLEDf_SET BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_AN_ENABLEDf_SET
#define AUX_STATUS_SUMMARY_EXT_P5r_LINK_STATUSf_GET BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_LINK_STATUSf_GET
#define AUX_STATUS_SUMMARY_EXT_P5r_LINK_STATUSf_SET BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_LINK_STATUSf_SET
#define AUX_STATUS_SUMMARY_EXT_P5r_SPEED_INDICATORf_GET BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_SPEED_INDICATORf_GET
#define AUX_STATUS_SUMMARY_EXT_P5r_SPEED_INDICATORf_SET BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_SPEED_INDICATORf_SET
#define AUX_STATUS_SUMMARY_EXT_P5r_LP_AN_CAPf_GET BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_LP_AN_CAPf_GET
#define AUX_STATUS_SUMMARY_EXT_P5r_LP_AN_CAPf_SET BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_LP_AN_CAPf_SET
#define AUX_STATUS_SUMMARY_EXT_P5r_LP_PAGE_RECEIVEDf_GET BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_LP_PAGE_RECEIVEDf_GET
#define AUX_STATUS_SUMMARY_EXT_P5r_LP_PAGE_RECEIVEDf_SET BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_LP_PAGE_RECEIVEDf_SET
#define AUX_STATUS_SUMMARY_EXT_P5r_RESERVEDf_GET BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_RESERVEDf_GET
#define AUX_STATUS_SUMMARY_EXT_P5r_RESERVEDf_SET BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_RESERVEDf_SET
#define AUX_STATUS_SUMMARY_EXT_P5r_AN_PARALLEL_DETECT_FAULTf_GET BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_AN_PARALLEL_DETECT_FAULTf_GET
#define AUX_STATUS_SUMMARY_EXT_P5r_AN_PARALLEL_DETECT_FAULTf_SET BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_AN_PARALLEL_DETECT_FAULTf_SET
#define AUX_STATUS_SUMMARY_EXT_P5r_AN_HCDf_GET BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_AN_HCDf_GET
#define AUX_STATUS_SUMMARY_EXT_P5r_AN_HCDf_SET BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_AN_HCDf_SET
#define AUX_STATUS_SUMMARY_EXT_P5r_AN_PAUSEf_GET BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_AN_PAUSEf_GET
#define AUX_STATUS_SUMMARY_EXT_P5r_AN_PAUSEf_SET BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_AN_PAUSEf_SET
#define AUX_STATUS_SUMMARY_EXT_P5r_AN_ABILITY_DETECTf_GET BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_AN_ABILITY_DETECTf_GET
#define AUX_STATUS_SUMMARY_EXT_P5r_AN_ABILITY_DETECTf_SET BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_AN_ABILITY_DETECTf_SET
#define AUX_STATUS_SUMMARY_EXT_P5r_AN_ACK_DETECTEDf_GET BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_AN_ACK_DETECTEDf_GET
#define AUX_STATUS_SUMMARY_EXT_P5r_AN_ACK_DETECTEDf_SET BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_AN_ACK_DETECTEDf_SET
#define AUX_STATUS_SUMMARY_EXT_P5r_AN_COMPLETE_ACKf_GET BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_AN_COMPLETE_ACKf_GET
#define AUX_STATUS_SUMMARY_EXT_P5r_AN_COMPLETE_ACKf_SET BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_AN_COMPLETE_ACKf_SET
#define AUX_STATUS_SUMMARY_EXT_P5r_AN_COMPLETEf_GET BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_AN_COMPLETEf_GET
#define AUX_STATUS_SUMMARY_EXT_P5r_AN_COMPLETEf_SET BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r_AN_COMPLETEf_SET
#define READ_AUX_STATUS_SUMMARY_EXT_P5r BCM53101_A0_READ_AUX_STATUS_SUMMARY_EXT_P5r
#define WRITE_AUX_STATUS_SUMMARY_EXT_P5r BCM53101_A0_WRITE_AUX_STATUS_SUMMARY_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_AUX_STATUS_SUMMARY_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  B100X_AUX_CONTROL
 * BLOCKS:   EPIC0
 * DESC:     100BASE-X AUXILIARY CONTROL REGISTER
 * SIZE:     16
 * FIELDS:
 *     RESERVED         Reserved
 *     EXT_FIFO_EN      1 = Extended FIFO mode.0 = Normal FIFO mode.
 *     FEF_ENABLE       1 = Far End Fault enabled.0 = Far End Fault disabled.
 *     BASELINE_WANDER_DISABLE 1 = Baseline Wander Correction disabled.0 = Baseline Wander Correction enabled.
 *     BYPASS_RX_ALIGNMENT 1 = 5B receive symbols not aligned.0 = Receive symbols aligned to 5B boundaries.
 *     BYPASS_NRZI      1 = NRZI encoder and decoder is disabled.0 = NRZI encoder and decoder is enabled.
 *     BYPASS_SCRAMBLER_DESCRAMBLER 1 = Scrambler and descrambler disabled.0 = Scrambler and descrambler enabled.
 *     BYPASS_4B5B      1 = Transmit and receive 5B codes over SMII pins.0 = Normal SMII interface.
 *     TRANSMIT_DISABLE 1 = Transmitter disabled in PHY.0 = Normal operation.
 *
 ******************************************************************************/
#define BCM53101_A0_B100X_AUX_CONTROLr 0x00001020

#define BCM53101_A0_B100X_AUX_CONTROLr_SIZE 2

/*
 * This structure should be used to declare and program B100X_AUX_CONTROL.
 *
 */
typedef union BCM53101_A0_B100X_AUX_CONTROLr_s {
	uint32_t v[1];
	uint32_t b100x_aux_control[1];
	uint32_t _b100x_aux_control;
} BCM53101_A0_B100X_AUX_CONTROLr_t;

#define BCM53101_A0_B100X_AUX_CONTROLr_CLR(r) (r).b100x_aux_control[0] = 0
#define BCM53101_A0_B100X_AUX_CONTROLr_SET(r,d) (r).b100x_aux_control[0] = d
#define BCM53101_A0_B100X_AUX_CONTROLr_GET(r) (r).b100x_aux_control[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_B100X_AUX_CONTROLr_RESERVEDf_GET(r) (((r).b100x_aux_control[0]) & 0x3)
#define BCM53101_A0_B100X_AUX_CONTROLr_RESERVEDf_SET(r,f) (r).b100x_aux_control[0]=(((r).b100x_aux_control[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53101_A0_B100X_AUX_CONTROLr_EXT_FIFO_ENf_GET(r) ((((r).b100x_aux_control[0]) >> 2) & 0x1)
#define BCM53101_A0_B100X_AUX_CONTROLr_EXT_FIFO_ENf_SET(r,f) (r).b100x_aux_control[0]=(((r).b100x_aux_control[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_B100X_AUX_CONTROLr_FEF_ENABLEf_GET(r) ((((r).b100x_aux_control[0]) >> 5) & 0x1)
#define BCM53101_A0_B100X_AUX_CONTROLr_FEF_ENABLEf_SET(r,f) (r).b100x_aux_control[0]=(((r).b100x_aux_control[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_B100X_AUX_CONTROLr_BASELINE_WANDER_DISABLEf_GET(r) ((((r).b100x_aux_control[0]) >> 6) & 0x1)
#define BCM53101_A0_B100X_AUX_CONTROLr_BASELINE_WANDER_DISABLEf_SET(r,f) (r).b100x_aux_control[0]=(((r).b100x_aux_control[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_B100X_AUX_CONTROLr_BYPASS_RX_ALIGNMENTf_GET(r) ((((r).b100x_aux_control[0]) >> 7) & 0x1)
#define BCM53101_A0_B100X_AUX_CONTROLr_BYPASS_RX_ALIGNMENTf_SET(r,f) (r).b100x_aux_control[0]=(((r).b100x_aux_control[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53101_A0_B100X_AUX_CONTROLr_BYPASS_NRZIf_GET(r) ((((r).b100x_aux_control[0]) >> 8) & 0x1)
#define BCM53101_A0_B100X_AUX_CONTROLr_BYPASS_NRZIf_SET(r,f) (r).b100x_aux_control[0]=(((r).b100x_aux_control[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53101_A0_B100X_AUX_CONTROLr_BYPASS_SCRAMBLER_DESCRAMBLERf_GET(r) ((((r).b100x_aux_control[0]) >> 9) & 0x1)
#define BCM53101_A0_B100X_AUX_CONTROLr_BYPASS_SCRAMBLER_DESCRAMBLERf_SET(r,f) (r).b100x_aux_control[0]=(((r).b100x_aux_control[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53101_A0_B100X_AUX_CONTROLr_BYPASS_4B5Bf_GET(r) ((((r).b100x_aux_control[0]) >> 10) & 0x1)
#define BCM53101_A0_B100X_AUX_CONTROLr_BYPASS_4B5Bf_SET(r,f) (r).b100x_aux_control[0]=(((r).b100x_aux_control[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53101_A0_B100X_AUX_CONTROLr_TRANSMIT_DISABLEf_GET(r) ((((r).b100x_aux_control[0]) >> 13) & 0x1)
#define BCM53101_A0_B100X_AUX_CONTROLr_TRANSMIT_DISABLEf_SET(r,f) (r).b100x_aux_control[0]=(((r).b100x_aux_control[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))

/*
 * These macros can be used to access B100X_AUX_CONTROL.
 *
 */
#define BCM53101_A0_READ_B100X_AUX_CONTROLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_B100X_AUX_CONTROLr,(r._b100x_aux_control),2)
#define BCM53101_A0_WRITE_B100X_AUX_CONTROLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_B100X_AUX_CONTROLr,&(r._b100x_aux_control),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define B100X_AUX_CONTROLr BCM53101_A0_B100X_AUX_CONTROLr
#define B100X_AUX_CONTROLr_SIZE BCM53101_A0_B100X_AUX_CONTROLr_SIZE
typedef BCM53101_A0_B100X_AUX_CONTROLr_t B100X_AUX_CONTROLr_t;
#define B100X_AUX_CONTROLr_CLR BCM53101_A0_B100X_AUX_CONTROLr_CLR
#define B100X_AUX_CONTROLr_SET BCM53101_A0_B100X_AUX_CONTROLr_SET
#define B100X_AUX_CONTROLr_GET BCM53101_A0_B100X_AUX_CONTROLr_GET
#define B100X_AUX_CONTROLr_RESERVEDf_GET BCM53101_A0_B100X_AUX_CONTROLr_RESERVEDf_GET
#define B100X_AUX_CONTROLr_RESERVEDf_SET BCM53101_A0_B100X_AUX_CONTROLr_RESERVEDf_SET
#define B100X_AUX_CONTROLr_EXT_FIFO_ENf_GET BCM53101_A0_B100X_AUX_CONTROLr_EXT_FIFO_ENf_GET
#define B100X_AUX_CONTROLr_EXT_FIFO_ENf_SET BCM53101_A0_B100X_AUX_CONTROLr_EXT_FIFO_ENf_SET
#define B100X_AUX_CONTROLr_FEF_ENABLEf_GET BCM53101_A0_B100X_AUX_CONTROLr_FEF_ENABLEf_GET
#define B100X_AUX_CONTROLr_FEF_ENABLEf_SET BCM53101_A0_B100X_AUX_CONTROLr_FEF_ENABLEf_SET
#define B100X_AUX_CONTROLr_BASELINE_WANDER_DISABLEf_GET BCM53101_A0_B100X_AUX_CONTROLr_BASELINE_WANDER_DISABLEf_GET
#define B100X_AUX_CONTROLr_BASELINE_WANDER_DISABLEf_SET BCM53101_A0_B100X_AUX_CONTROLr_BASELINE_WANDER_DISABLEf_SET
#define B100X_AUX_CONTROLr_BYPASS_RX_ALIGNMENTf_GET BCM53101_A0_B100X_AUX_CONTROLr_BYPASS_RX_ALIGNMENTf_GET
#define B100X_AUX_CONTROLr_BYPASS_RX_ALIGNMENTf_SET BCM53101_A0_B100X_AUX_CONTROLr_BYPASS_RX_ALIGNMENTf_SET
#define B100X_AUX_CONTROLr_BYPASS_NRZIf_GET BCM53101_A0_B100X_AUX_CONTROLr_BYPASS_NRZIf_GET
#define B100X_AUX_CONTROLr_BYPASS_NRZIf_SET BCM53101_A0_B100X_AUX_CONTROLr_BYPASS_NRZIf_SET
#define B100X_AUX_CONTROLr_BYPASS_SCRAMBLER_DESCRAMBLERf_GET BCM53101_A0_B100X_AUX_CONTROLr_BYPASS_SCRAMBLER_DESCRAMBLERf_GET
#define B100X_AUX_CONTROLr_BYPASS_SCRAMBLER_DESCRAMBLERf_SET BCM53101_A0_B100X_AUX_CONTROLr_BYPASS_SCRAMBLER_DESCRAMBLERf_SET
#define B100X_AUX_CONTROLr_BYPASS_4B5Bf_GET BCM53101_A0_B100X_AUX_CONTROLr_BYPASS_4B5Bf_GET
#define B100X_AUX_CONTROLr_BYPASS_4B5Bf_SET BCM53101_A0_B100X_AUX_CONTROLr_BYPASS_4B5Bf_SET
#define B100X_AUX_CONTROLr_TRANSMIT_DISABLEf_GET BCM53101_A0_B100X_AUX_CONTROLr_TRANSMIT_DISABLEf_GET
#define B100X_AUX_CONTROLr_TRANSMIT_DISABLEf_SET BCM53101_A0_B100X_AUX_CONTROLr_TRANSMIT_DISABLEf_SET
#define READ_B100X_AUX_CONTROLr BCM53101_A0_READ_B100X_AUX_CONTROLr
#define WRITE_B100X_AUX_CONTROLr BCM53101_A0_WRITE_B100X_AUX_CONTROLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_B100X_AUX_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  B100X_AUX_CONTROL_EXT_P5
 * BLOCKS:   SYS
 * DESC:     100BASE-X AUXILIARY CONTROL REGISTER
 * SIZE:     16
 * FIELDS:
 *     RESERVED         Reserved
 *     EXT_FIFO_EN      1 = Extended FIFO mode.0 = Normal FIFO mode.
 *     FEF_ENABLE       1 = Far End Fault enabled.0 = Far End Fault disabled.
 *     BASELINE_WANDER_DISABLE 1 = Baseline Wander Correction disabled.0 = Baseline Wander Correction enabled.
 *     BYPASS_RX_ALIGNMENT 1 = 5B receive symbols not aligned.0 = Receive symbols aligned to 5B boundaries.
 *     BYPASS_NRZI      1 = NRZI encoder and decoder is disabled.0 = NRZI encoder and decoder is enabled.
 *     BYPASS_SCRAMBLER_DESCRAMBLER 1 = Scrambler and descrambler disabled.0 = Scrambler and descrambler enabled.
 *     BYPASS_4B5B      1 = Transmit and receive 5B codes over SMII pins.0 = Normal SMII interface.
 *     TRANSMIT_DISABLE 1 = Transmitter disabled in PHY.0 = Normal operation.
 *
 ******************************************************************************/
#define BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r 0x00008520

#define BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program B100X_AUX_CONTROL_EXT_P5.
 *
 */
typedef union BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_s {
	uint32_t v[1];
	uint32_t b100x_aux_control_ext_p5[1];
	uint32_t _b100x_aux_control_ext_p5;
} BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_t;

#define BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_CLR(r) (r).b100x_aux_control_ext_p5[0] = 0
#define BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_SET(r,d) (r).b100x_aux_control_ext_p5[0] = d
#define BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_GET(r) (r).b100x_aux_control_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_RESERVEDf_GET(r) (((r).b100x_aux_control_ext_p5[0]) & 0x3)
#define BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_RESERVEDf_SET(r,f) (r).b100x_aux_control_ext_p5[0]=(((r).b100x_aux_control_ext_p5[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_EXT_FIFO_ENf_GET(r) ((((r).b100x_aux_control_ext_p5[0]) >> 2) & 0x1)
#define BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_EXT_FIFO_ENf_SET(r,f) (r).b100x_aux_control_ext_p5[0]=(((r).b100x_aux_control_ext_p5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_FEF_ENABLEf_GET(r) ((((r).b100x_aux_control_ext_p5[0]) >> 5) & 0x1)
#define BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_FEF_ENABLEf_SET(r,f) (r).b100x_aux_control_ext_p5[0]=(((r).b100x_aux_control_ext_p5[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_BASELINE_WANDER_DISABLEf_GET(r) ((((r).b100x_aux_control_ext_p5[0]) >> 6) & 0x1)
#define BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_BASELINE_WANDER_DISABLEf_SET(r,f) (r).b100x_aux_control_ext_p5[0]=(((r).b100x_aux_control_ext_p5[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_BYPASS_RX_ALIGNMENTf_GET(r) ((((r).b100x_aux_control_ext_p5[0]) >> 7) & 0x1)
#define BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_BYPASS_RX_ALIGNMENTf_SET(r,f) (r).b100x_aux_control_ext_p5[0]=(((r).b100x_aux_control_ext_p5[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_BYPASS_NRZIf_GET(r) ((((r).b100x_aux_control_ext_p5[0]) >> 8) & 0x1)
#define BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_BYPASS_NRZIf_SET(r,f) (r).b100x_aux_control_ext_p5[0]=(((r).b100x_aux_control_ext_p5[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_BYPASS_SCRAMBLER_DESCRAMBLERf_GET(r) ((((r).b100x_aux_control_ext_p5[0]) >> 9) & 0x1)
#define BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_BYPASS_SCRAMBLER_DESCRAMBLERf_SET(r,f) (r).b100x_aux_control_ext_p5[0]=(((r).b100x_aux_control_ext_p5[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_BYPASS_4B5Bf_GET(r) ((((r).b100x_aux_control_ext_p5[0]) >> 10) & 0x1)
#define BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_BYPASS_4B5Bf_SET(r,f) (r).b100x_aux_control_ext_p5[0]=(((r).b100x_aux_control_ext_p5[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_TRANSMIT_DISABLEf_GET(r) ((((r).b100x_aux_control_ext_p5[0]) >> 13) & 0x1)
#define BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_TRANSMIT_DISABLEf_SET(r,f) (r).b100x_aux_control_ext_p5[0]=(((r).b100x_aux_control_ext_p5[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))

/*
 * These macros can be used to access B100X_AUX_CONTROL_EXT_P5.
 *
 */
#define BCM53101_A0_READ_B100X_AUX_CONTROL_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r,(r._b100x_aux_control_ext_p5),2)
#define BCM53101_A0_WRITE_B100X_AUX_CONTROL_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r,&(r._b100x_aux_control_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define B100X_AUX_CONTROL_EXT_P5r BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r
#define B100X_AUX_CONTROL_EXT_P5r_SIZE BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_SIZE
typedef BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_t B100X_AUX_CONTROL_EXT_P5r_t;
#define B100X_AUX_CONTROL_EXT_P5r_CLR BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_CLR
#define B100X_AUX_CONTROL_EXT_P5r_SET BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_SET
#define B100X_AUX_CONTROL_EXT_P5r_GET BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_GET
#define B100X_AUX_CONTROL_EXT_P5r_RESERVEDf_GET BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_RESERVEDf_GET
#define B100X_AUX_CONTROL_EXT_P5r_RESERVEDf_SET BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_RESERVEDf_SET
#define B100X_AUX_CONTROL_EXT_P5r_EXT_FIFO_ENf_GET BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_EXT_FIFO_ENf_GET
#define B100X_AUX_CONTROL_EXT_P5r_EXT_FIFO_ENf_SET BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_EXT_FIFO_ENf_SET
#define B100X_AUX_CONTROL_EXT_P5r_FEF_ENABLEf_GET BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_FEF_ENABLEf_GET
#define B100X_AUX_CONTROL_EXT_P5r_FEF_ENABLEf_SET BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_FEF_ENABLEf_SET
#define B100X_AUX_CONTROL_EXT_P5r_BASELINE_WANDER_DISABLEf_GET BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_BASELINE_WANDER_DISABLEf_GET
#define B100X_AUX_CONTROL_EXT_P5r_BASELINE_WANDER_DISABLEf_SET BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_BASELINE_WANDER_DISABLEf_SET
#define B100X_AUX_CONTROL_EXT_P5r_BYPASS_RX_ALIGNMENTf_GET BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_BYPASS_RX_ALIGNMENTf_GET
#define B100X_AUX_CONTROL_EXT_P5r_BYPASS_RX_ALIGNMENTf_SET BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_BYPASS_RX_ALIGNMENTf_SET
#define B100X_AUX_CONTROL_EXT_P5r_BYPASS_NRZIf_GET BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_BYPASS_NRZIf_GET
#define B100X_AUX_CONTROL_EXT_P5r_BYPASS_NRZIf_SET BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_BYPASS_NRZIf_SET
#define B100X_AUX_CONTROL_EXT_P5r_BYPASS_SCRAMBLER_DESCRAMBLERf_GET BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_BYPASS_SCRAMBLER_DESCRAMBLERf_GET
#define B100X_AUX_CONTROL_EXT_P5r_BYPASS_SCRAMBLER_DESCRAMBLERf_SET BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_BYPASS_SCRAMBLER_DESCRAMBLERf_SET
#define B100X_AUX_CONTROL_EXT_P5r_BYPASS_4B5Bf_GET BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_BYPASS_4B5Bf_GET
#define B100X_AUX_CONTROL_EXT_P5r_BYPASS_4B5Bf_SET BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_BYPASS_4B5Bf_SET
#define B100X_AUX_CONTROL_EXT_P5r_TRANSMIT_DISABLEf_GET BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_TRANSMIT_DISABLEf_GET
#define B100X_AUX_CONTROL_EXT_P5r_TRANSMIT_DISABLEf_SET BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r_TRANSMIT_DISABLEf_SET
#define READ_B100X_AUX_CONTROL_EXT_P5r BCM53101_A0_READ_B100X_AUX_CONTROL_EXT_P5r
#define WRITE_B100X_AUX_CONTROL_EXT_P5r BCM53101_A0_WRITE_B100X_AUX_CONTROL_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_B100X_AUX_CONTROL_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  B100X_AUX_STATUS
 * BLOCKS:   EPIC0
 * DESC:     100BASE-X AUXILIARY STATUS REGISTER
 * SIZE:     16
 * FIELDS:
 *     RX_ERROR_DETECTED 1 = Receive error detected since last read.0 = No receive error since last read.EOT             },            Tx_Error_Detected     => {                MAXBIT      => 2,   MINBIT => 2,    RESETVAL => 0x0,                READONLY    => 1,                 DESC        => <<'EOT'1 = Transmit error code received since last read.0 = No transmit error code received since last read.EOT             },            Lock_Error     => {                MAXBIT      => 1,   MINBIT => 1,    RESETVAL => 0x0,                READONLY    => 1,                DESC        => <<'EOT'1 = Lock error detected since last read.0 = No lock error since last read.EOT             },            MLT3_Code_Error     => {                MAXBIT      => 0,   MINBIT => 0,    RESETVAL => 0x0,                READONLY    => 1,                DESC        => <<'EOT'1 = MLT3 code error detected since last read.0 = No MLT3 code error since last read.
 *     BAD_ESD_DETECTED 1 = ESD error detected since last read.0 = No ESD error since last read.
 *     FALSE_CARRIER_DETECTED 1 = False carrier detected since last read.0 = No false carrier since last read.
 *     RESERVED         Reserved
 *     REMOTE_FAULT     1 = Remote fault detected.0 = No remote fault detected.
 *     B100X_LINK_STATUS 1 = Link pass.0 = Link fail.
 *     LOCKED           1 = Descrambler locked.0 = Descrambler unlocked.
 *     SMII_OVERRUN_UNDERRUN_DETECTED 1 = Error detected.0 = No error.
 *
 ******************************************************************************/
#define BCM53101_A0_B100X_AUX_STATUSr 0x00001022

#define BCM53101_A0_B100X_AUX_STATUSr_SIZE 2

/*
 * This structure should be used to declare and program B100X_AUX_STATUS.
 *
 */
typedef union BCM53101_A0_B100X_AUX_STATUSr_s {
	uint32_t v[1];
	uint32_t b100x_aux_status[1];
	uint32_t _b100x_aux_status;
} BCM53101_A0_B100X_AUX_STATUSr_t;

#define BCM53101_A0_B100X_AUX_STATUSr_CLR(r) (r).b100x_aux_status[0] = 0
#define BCM53101_A0_B100X_AUX_STATUSr_SET(r,d) (r).b100x_aux_status[0] = d
#define BCM53101_A0_B100X_AUX_STATUSr_GET(r) (r).b100x_aux_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_B100X_AUX_STATUSr_RX_ERROR_DETECTEDf_GET(r) ((((r).b100x_aux_status[0]) >> 3) & 0x1)
#define BCM53101_A0_B100X_AUX_STATUSr_RX_ERROR_DETECTEDf_SET(r,f) (r).b100x_aux_status[0]=(((r).b100x_aux_status[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_B100X_AUX_STATUSr_BAD_ESD_DETECTEDf_GET(r) ((((r).b100x_aux_status[0]) >> 4) & 0x1)
#define BCM53101_A0_B100X_AUX_STATUSr_BAD_ESD_DETECTEDf_SET(r,f) (r).b100x_aux_status[0]=(((r).b100x_aux_status[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_B100X_AUX_STATUSr_FALSE_CARRIER_DETECTEDf_GET(r) ((((r).b100x_aux_status[0]) >> 5) & 0x1)
#define BCM53101_A0_B100X_AUX_STATUSr_FALSE_CARRIER_DETECTEDf_SET(r,f) (r).b100x_aux_status[0]=(((r).b100x_aux_status[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_B100X_AUX_STATUSr_RESERVEDf_GET(r) ((((r).b100x_aux_status[0]) >> 6) & 0x1)
#define BCM53101_A0_B100X_AUX_STATUSr_RESERVEDf_SET(r,f) (r).b100x_aux_status[0]=(((r).b100x_aux_status[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_B100X_AUX_STATUSr_REMOTE_FAULTf_GET(r) ((((r).b100x_aux_status[0]) >> 7) & 0x1)
#define BCM53101_A0_B100X_AUX_STATUSr_REMOTE_FAULTf_SET(r,f) (r).b100x_aux_status[0]=(((r).b100x_aux_status[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53101_A0_B100X_AUX_STATUSr_B100X_LINK_STATUSf_GET(r) ((((r).b100x_aux_status[0]) >> 8) & 0x1)
#define BCM53101_A0_B100X_AUX_STATUSr_B100X_LINK_STATUSf_SET(r,f) (r).b100x_aux_status[0]=(((r).b100x_aux_status[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53101_A0_B100X_AUX_STATUSr_LOCKEDf_GET(r) ((((r).b100x_aux_status[0]) >> 9) & 0x1)
#define BCM53101_A0_B100X_AUX_STATUSr_LOCKEDf_SET(r,f) (r).b100x_aux_status[0]=(((r).b100x_aux_status[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53101_A0_B100X_AUX_STATUSr_SMII_OVERRUN_UNDERRUN_DETECTEDf_GET(r) ((((r).b100x_aux_status[0]) >> 11) & 0x1)
#define BCM53101_A0_B100X_AUX_STATUSr_SMII_OVERRUN_UNDERRUN_DETECTEDf_SET(r,f) (r).b100x_aux_status[0]=(((r).b100x_aux_status[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))

/*
 * These macros can be used to access B100X_AUX_STATUS.
 *
 */
#define BCM53101_A0_READ_B100X_AUX_STATUSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_B100X_AUX_STATUSr,(r._b100x_aux_status),2)
#define BCM53101_A0_WRITE_B100X_AUX_STATUSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_B100X_AUX_STATUSr,&(r._b100x_aux_status),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define B100X_AUX_STATUSr BCM53101_A0_B100X_AUX_STATUSr
#define B100X_AUX_STATUSr_SIZE BCM53101_A0_B100X_AUX_STATUSr_SIZE
typedef BCM53101_A0_B100X_AUX_STATUSr_t B100X_AUX_STATUSr_t;
#define B100X_AUX_STATUSr_CLR BCM53101_A0_B100X_AUX_STATUSr_CLR
#define B100X_AUX_STATUSr_SET BCM53101_A0_B100X_AUX_STATUSr_SET
#define B100X_AUX_STATUSr_GET BCM53101_A0_B100X_AUX_STATUSr_GET
#define B100X_AUX_STATUSr_RX_ERROR_DETECTEDf_GET BCM53101_A0_B100X_AUX_STATUSr_RX_ERROR_DETECTEDf_GET
#define B100X_AUX_STATUSr_RX_ERROR_DETECTEDf_SET BCM53101_A0_B100X_AUX_STATUSr_RX_ERROR_DETECTEDf_SET
#define B100X_AUX_STATUSr_BAD_ESD_DETECTEDf_GET BCM53101_A0_B100X_AUX_STATUSr_BAD_ESD_DETECTEDf_GET
#define B100X_AUX_STATUSr_BAD_ESD_DETECTEDf_SET BCM53101_A0_B100X_AUX_STATUSr_BAD_ESD_DETECTEDf_SET
#define B100X_AUX_STATUSr_FALSE_CARRIER_DETECTEDf_GET BCM53101_A0_B100X_AUX_STATUSr_FALSE_CARRIER_DETECTEDf_GET
#define B100X_AUX_STATUSr_FALSE_CARRIER_DETECTEDf_SET BCM53101_A0_B100X_AUX_STATUSr_FALSE_CARRIER_DETECTEDf_SET
#define B100X_AUX_STATUSr_RESERVEDf_GET BCM53101_A0_B100X_AUX_STATUSr_RESERVEDf_GET
#define B100X_AUX_STATUSr_RESERVEDf_SET BCM53101_A0_B100X_AUX_STATUSr_RESERVEDf_SET
#define B100X_AUX_STATUSr_REMOTE_FAULTf_GET BCM53101_A0_B100X_AUX_STATUSr_REMOTE_FAULTf_GET
#define B100X_AUX_STATUSr_REMOTE_FAULTf_SET BCM53101_A0_B100X_AUX_STATUSr_REMOTE_FAULTf_SET
#define B100X_AUX_STATUSr_B100X_LINK_STATUSf_GET BCM53101_A0_B100X_AUX_STATUSr_B100X_LINK_STATUSf_GET
#define B100X_AUX_STATUSr_B100X_LINK_STATUSf_SET BCM53101_A0_B100X_AUX_STATUSr_B100X_LINK_STATUSf_SET
#define B100X_AUX_STATUSr_LOCKEDf_GET BCM53101_A0_B100X_AUX_STATUSr_LOCKEDf_GET
#define B100X_AUX_STATUSr_LOCKEDf_SET BCM53101_A0_B100X_AUX_STATUSr_LOCKEDf_SET
#define B100X_AUX_STATUSr_SMII_OVERRUN_UNDERRUN_DETECTEDf_GET BCM53101_A0_B100X_AUX_STATUSr_SMII_OVERRUN_UNDERRUN_DETECTEDf_GET
#define B100X_AUX_STATUSr_SMII_OVERRUN_UNDERRUN_DETECTEDf_SET BCM53101_A0_B100X_AUX_STATUSr_SMII_OVERRUN_UNDERRUN_DETECTEDf_SET
#define READ_B100X_AUX_STATUSr BCM53101_A0_READ_B100X_AUX_STATUSr
#define WRITE_B100X_AUX_STATUSr BCM53101_A0_WRITE_B100X_AUX_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_B100X_AUX_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  B100X_AUX_STATUS_EXT_P5
 * BLOCKS:   SYS
 * DESC:     100BASE-X AUXILIARY STATUS REGISTER
 * SIZE:     16
 * FIELDS:
 *     RX_ERROR_DETECTED 1 = Receive error detected since last read.0 = No receive error since last read.EOT             },            Tx_Error_Detected     => {                MAXBIT      => 2,   MINBIT => 2,    RESETVAL => 0x0,                READONLY    => 1,                 DESC        => <<'EOT'1 = Transmit error code received since last read.0 = No transmit error code received since last read.EOT             },            Lock_Error     => {                MAXBIT      => 1,   MINBIT => 1,    RESETVAL => 0x0,                READONLY    => 1,                DESC        => <<'EOT'1 = Lock error detected since last read.0 = No lock error since last read.EOT             },            MLT3_Code_Error     => {                MAXBIT      => 0,   MINBIT => 0,    RESETVAL => 0x0,                READONLY    => 1,                DESC        => <<'EOT'1 = MLT3 code error detected since last read.0 = No MLT3 code error since last read.
 *     BAD_ESD_DETECTED 1 = ESD error detected since last read.0 = No ESD error since last read.
 *     FALSE_CARRIER_DETECTED 1 = False carrier detected since last read.0 = No false carrier since last read.
 *     RESERVED         Reserved
 *     REMOTE_FAULT     1 = Remote fault detected.0 = No remote fault detected.
 *     B100X_LINK_STATUS 1 = Link pass.0 = Link fail.
 *     LOCKED           1 = Descrambler locked.0 = Descrambler unlocked.
 *     SMII_OVERRUN_UNDERRUN_DETECTED 1 = Error detected.0 = No error.
 *
 ******************************************************************************/
#define BCM53101_A0_B100X_AUX_STATUS_EXT_P5r 0x00008522

#define BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program B100X_AUX_STATUS_EXT_P5.
 *
 */
typedef union BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_s {
	uint32_t v[1];
	uint32_t b100x_aux_status_ext_p5[1];
	uint32_t _b100x_aux_status_ext_p5;
} BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_t;

#define BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_CLR(r) (r).b100x_aux_status_ext_p5[0] = 0
#define BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_SET(r,d) (r).b100x_aux_status_ext_p5[0] = d
#define BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_GET(r) (r).b100x_aux_status_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_RX_ERROR_DETECTEDf_GET(r) ((((r).b100x_aux_status_ext_p5[0]) >> 3) & 0x1)
#define BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_RX_ERROR_DETECTEDf_SET(r,f) (r).b100x_aux_status_ext_p5[0]=(((r).b100x_aux_status_ext_p5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_BAD_ESD_DETECTEDf_GET(r) ((((r).b100x_aux_status_ext_p5[0]) >> 4) & 0x1)
#define BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_BAD_ESD_DETECTEDf_SET(r,f) (r).b100x_aux_status_ext_p5[0]=(((r).b100x_aux_status_ext_p5[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_FALSE_CARRIER_DETECTEDf_GET(r) ((((r).b100x_aux_status_ext_p5[0]) >> 5) & 0x1)
#define BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_FALSE_CARRIER_DETECTEDf_SET(r,f) (r).b100x_aux_status_ext_p5[0]=(((r).b100x_aux_status_ext_p5[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_RESERVEDf_GET(r) ((((r).b100x_aux_status_ext_p5[0]) >> 6) & 0x1)
#define BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_RESERVEDf_SET(r,f) (r).b100x_aux_status_ext_p5[0]=(((r).b100x_aux_status_ext_p5[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_REMOTE_FAULTf_GET(r) ((((r).b100x_aux_status_ext_p5[0]) >> 7) & 0x1)
#define BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_REMOTE_FAULTf_SET(r,f) (r).b100x_aux_status_ext_p5[0]=(((r).b100x_aux_status_ext_p5[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_B100X_LINK_STATUSf_GET(r) ((((r).b100x_aux_status_ext_p5[0]) >> 8) & 0x1)
#define BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_B100X_LINK_STATUSf_SET(r,f) (r).b100x_aux_status_ext_p5[0]=(((r).b100x_aux_status_ext_p5[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_LOCKEDf_GET(r) ((((r).b100x_aux_status_ext_p5[0]) >> 9) & 0x1)
#define BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_LOCKEDf_SET(r,f) (r).b100x_aux_status_ext_p5[0]=(((r).b100x_aux_status_ext_p5[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_SMII_OVERRUN_UNDERRUN_DETECTEDf_GET(r) ((((r).b100x_aux_status_ext_p5[0]) >> 11) & 0x1)
#define BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_SMII_OVERRUN_UNDERRUN_DETECTEDf_SET(r,f) (r).b100x_aux_status_ext_p5[0]=(((r).b100x_aux_status_ext_p5[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))

/*
 * These macros can be used to access B100X_AUX_STATUS_EXT_P5.
 *
 */
#define BCM53101_A0_READ_B100X_AUX_STATUS_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53101_A0_B100X_AUX_STATUS_EXT_P5r,(r._b100x_aux_status_ext_p5),2)
#define BCM53101_A0_WRITE_B100X_AUX_STATUS_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53101_A0_B100X_AUX_STATUS_EXT_P5r,&(r._b100x_aux_status_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define B100X_AUX_STATUS_EXT_P5r BCM53101_A0_B100X_AUX_STATUS_EXT_P5r
#define B100X_AUX_STATUS_EXT_P5r_SIZE BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_SIZE
typedef BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_t B100X_AUX_STATUS_EXT_P5r_t;
#define B100X_AUX_STATUS_EXT_P5r_CLR BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_CLR
#define B100X_AUX_STATUS_EXT_P5r_SET BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_SET
#define B100X_AUX_STATUS_EXT_P5r_GET BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_GET
#define B100X_AUX_STATUS_EXT_P5r_RX_ERROR_DETECTEDf_GET BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_RX_ERROR_DETECTEDf_GET
#define B100X_AUX_STATUS_EXT_P5r_RX_ERROR_DETECTEDf_SET BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_RX_ERROR_DETECTEDf_SET
#define B100X_AUX_STATUS_EXT_P5r_BAD_ESD_DETECTEDf_GET BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_BAD_ESD_DETECTEDf_GET
#define B100X_AUX_STATUS_EXT_P5r_BAD_ESD_DETECTEDf_SET BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_BAD_ESD_DETECTEDf_SET
#define B100X_AUX_STATUS_EXT_P5r_FALSE_CARRIER_DETECTEDf_GET BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_FALSE_CARRIER_DETECTEDf_GET
#define B100X_AUX_STATUS_EXT_P5r_FALSE_CARRIER_DETECTEDf_SET BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_FALSE_CARRIER_DETECTEDf_SET
#define B100X_AUX_STATUS_EXT_P5r_RESERVEDf_GET BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_RESERVEDf_GET
#define B100X_AUX_STATUS_EXT_P5r_RESERVEDf_SET BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_RESERVEDf_SET
#define B100X_AUX_STATUS_EXT_P5r_REMOTE_FAULTf_GET BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_REMOTE_FAULTf_GET
#define B100X_AUX_STATUS_EXT_P5r_REMOTE_FAULTf_SET BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_REMOTE_FAULTf_SET
#define B100X_AUX_STATUS_EXT_P5r_B100X_LINK_STATUSf_GET BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_B100X_LINK_STATUSf_GET
#define B100X_AUX_STATUS_EXT_P5r_B100X_LINK_STATUSf_SET BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_B100X_LINK_STATUSf_SET
#define B100X_AUX_STATUS_EXT_P5r_LOCKEDf_GET BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_LOCKEDf_GET
#define B100X_AUX_STATUS_EXT_P5r_LOCKEDf_SET BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_LOCKEDf_SET
#define B100X_AUX_STATUS_EXT_P5r_SMII_OVERRUN_UNDERRUN_DETECTEDf_GET BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_SMII_OVERRUN_UNDERRUN_DETECTEDf_GET
#define B100X_AUX_STATUS_EXT_P5r_SMII_OVERRUN_UNDERRUN_DETECTEDf_SET BCM53101_A0_B100X_AUX_STATUS_EXT_P5r_SMII_OVERRUN_UNDERRUN_DETECTEDf_SET
#define READ_B100X_AUX_STATUS_EXT_P5r BCM53101_A0_READ_B100X_AUX_STATUS_EXT_P5r
#define WRITE_B100X_AUX_STATUS_EXT_P5r BCM53101_A0_WRITE_B100X_AUX_STATUS_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_B100X_AUX_STATUS_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  B100X_DISCONNECT_COUNTER
 * BLOCKS:   EPIC0
 * DESC:     100BASE-X DISCONNECT COUNTER
 * SIZE:     16
 * FIELDS:
 *     RESERVED         Reserved
 *     SMII_SLOW_RXD    1 = In extended FIFO mode, detect slow receive data.0 = Normal.
 *     SMII_FAST_RXD    1 = In extended FIFO mode, detect fast receive data.0 = Normal.
 *
 ******************************************************************************/
#define BCM53101_A0_B100X_DISCONNECT_COUNTERr 0x00001028

#define BCM53101_A0_B100X_DISCONNECT_COUNTERr_SIZE 2

/*
 * This structure should be used to declare and program B100X_DISCONNECT_COUNTER.
 *
 */
typedef union BCM53101_A0_B100X_DISCONNECT_COUNTERr_s {
	uint32_t v[1];
	uint32_t b100x_disconnect_counter[1];
	uint32_t _b100x_disconnect_counter;
} BCM53101_A0_B100X_DISCONNECT_COUNTERr_t;

#define BCM53101_A0_B100X_DISCONNECT_COUNTERr_CLR(r) (r).b100x_disconnect_counter[0] = 0
#define BCM53101_A0_B100X_DISCONNECT_COUNTERr_SET(r,d) (r).b100x_disconnect_counter[0] = d
#define BCM53101_A0_B100X_DISCONNECT_COUNTERr_GET(r) (r).b100x_disconnect_counter[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_B100X_DISCONNECT_COUNTERr_RESERVEDf_GET(r) (((r).b100x_disconnect_counter[0]) & 0xff)
#define BCM53101_A0_B100X_DISCONNECT_COUNTERr_RESERVEDf_SET(r,f) (r).b100x_disconnect_counter[0]=(((r).b100x_disconnect_counter[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53101_A0_B100X_DISCONNECT_COUNTERr_SMII_SLOW_RXDf_GET(r) ((((r).b100x_disconnect_counter[0]) >> 14) & 0x1)
#define BCM53101_A0_B100X_DISCONNECT_COUNTERr_SMII_SLOW_RXDf_SET(r,f) (r).b100x_disconnect_counter[0]=(((r).b100x_disconnect_counter[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_B100X_DISCONNECT_COUNTERr_SMII_FAST_RXDf_GET(r) ((((r).b100x_disconnect_counter[0]) >> 15) & 0x1)
#define BCM53101_A0_B100X_DISCONNECT_COUNTERr_SMII_FAST_RXDf_SET(r,f) (r).b100x_disconnect_counter[0]=(((r).b100x_disconnect_counter[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access B100X_DISCONNECT_COUNTER.
 *
 */
#define BCM53101_A0_READ_B100X_DISCONNECT_COUNTERr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_B100X_DISCONNECT_COUNTERr,(r._b100x_disconnect_counter),2)
#define BCM53101_A0_WRITE_B100X_DISCONNECT_COUNTERr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_B100X_DISCONNECT_COUNTERr,&(r._b100x_disconnect_counter),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define B100X_DISCONNECT_COUNTERr BCM53101_A0_B100X_DISCONNECT_COUNTERr
#define B100X_DISCONNECT_COUNTERr_SIZE BCM53101_A0_B100X_DISCONNECT_COUNTERr_SIZE
typedef BCM53101_A0_B100X_DISCONNECT_COUNTERr_t B100X_DISCONNECT_COUNTERr_t;
#define B100X_DISCONNECT_COUNTERr_CLR BCM53101_A0_B100X_DISCONNECT_COUNTERr_CLR
#define B100X_DISCONNECT_COUNTERr_SET BCM53101_A0_B100X_DISCONNECT_COUNTERr_SET
#define B100X_DISCONNECT_COUNTERr_GET BCM53101_A0_B100X_DISCONNECT_COUNTERr_GET
#define B100X_DISCONNECT_COUNTERr_RESERVEDf_GET BCM53101_A0_B100X_DISCONNECT_COUNTERr_RESERVEDf_GET
#define B100X_DISCONNECT_COUNTERr_RESERVEDf_SET BCM53101_A0_B100X_DISCONNECT_COUNTERr_RESERVEDf_SET
#define B100X_DISCONNECT_COUNTERr_SMII_SLOW_RXDf_GET BCM53101_A0_B100X_DISCONNECT_COUNTERr_SMII_SLOW_RXDf_GET
#define B100X_DISCONNECT_COUNTERr_SMII_SLOW_RXDf_SET BCM53101_A0_B100X_DISCONNECT_COUNTERr_SMII_SLOW_RXDf_SET
#define B100X_DISCONNECT_COUNTERr_SMII_FAST_RXDf_GET BCM53101_A0_B100X_DISCONNECT_COUNTERr_SMII_FAST_RXDf_GET
#define B100X_DISCONNECT_COUNTERr_SMII_FAST_RXDf_SET BCM53101_A0_B100X_DISCONNECT_COUNTERr_SMII_FAST_RXDf_SET
#define READ_B100X_DISCONNECT_COUNTERr BCM53101_A0_READ_B100X_DISCONNECT_COUNTERr
#define WRITE_B100X_DISCONNECT_COUNTERr BCM53101_A0_WRITE_B100X_DISCONNECT_COUNTERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_B100X_DISCONNECT_COUNTERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  B100X_DISCONNECT_COUNTER_EXT_P5
 * BLOCKS:   SYS
 * DESC:     100BASE-X DISCONNECT COUNTER
 * SIZE:     16
 * FIELDS:
 *     RESERVED         Reserved
 *     SMII_SLOW_RXD    1 = In extended FIFO mode, detect slow receive data.0 = Normal.
 *     SMII_FAST_RXD    1 = In extended FIFO mode, detect fast receive data.0 = Normal.
 *
 ******************************************************************************/
#define BCM53101_A0_B100X_DISCONNECT_COUNTER_EXT_P5r 0x00008528

#define BCM53101_A0_B100X_DISCONNECT_COUNTER_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program B100X_DISCONNECT_COUNTER_EXT_P5.
 *
 */
typedef union BCM53101_A0_B100X_DISCONNECT_COUNTER_EXT_P5r_s {
	uint32_t v[1];
	uint32_t b100x_disconnect_counter_ext_p5[1];
	uint32_t _b100x_disconnect_counter_ext_p5;
} BCM53101_A0_B100X_DISCONNECT_COUNTER_EXT_P5r_t;

#define BCM53101_A0_B100X_DISCONNECT_COUNTER_EXT_P5r_CLR(r) (r).b100x_disconnect_counter_ext_p5[0] = 0
#define BCM53101_A0_B100X_DISCONNECT_COUNTER_EXT_P5r_SET(r,d) (r).b100x_disconnect_counter_ext_p5[0] = d
#define BCM53101_A0_B100X_DISCONNECT_COUNTER_EXT_P5r_GET(r) (r).b100x_disconnect_counter_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_B100X_DISCONNECT_COUNTER_EXT_P5r_RESERVEDf_GET(r) (((r).b100x_disconnect_counter_ext_p5[0]) & 0xff)
#define BCM53101_A0_B100X_DISCONNECT_COUNTER_EXT_P5r_RESERVEDf_SET(r,f) (r).b100x_disconnect_counter_ext_p5[0]=(((r).b100x_disconnect_counter_ext_p5[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53101_A0_B100X_DISCONNECT_COUNTER_EXT_P5r_SMII_SLOW_RXDf_GET(r) ((((r).b100x_disconnect_counter_ext_p5[0]) >> 14) & 0x1)
#define BCM53101_A0_B100X_DISCONNECT_COUNTER_EXT_P5r_SMII_SLOW_RXDf_SET(r,f) (r).b100x_disconnect_counter_ext_p5[0]=(((r).b100x_disconnect_counter_ext_p5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_B100X_DISCONNECT_COUNTER_EXT_P5r_SMII_FAST_RXDf_GET(r) ((((r).b100x_disconnect_counter_ext_p5[0]) >> 15) & 0x1)
#define BCM53101_A0_B100X_DISCONNECT_COUNTER_EXT_P5r_SMII_FAST_RXDf_SET(r,f) (r).b100x_disconnect_counter_ext_p5[0]=(((r).b100x_disconnect_counter_ext_p5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access B100X_DISCONNECT_COUNTER_EXT_P5.
 *
 */
#define BCM53101_A0_READ_B100X_DISCONNECT_COUNTER_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53101_A0_B100X_DISCONNECT_COUNTER_EXT_P5r,(r._b100x_disconnect_counter_ext_p5),2)
#define BCM53101_A0_WRITE_B100X_DISCONNECT_COUNTER_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53101_A0_B100X_DISCONNECT_COUNTER_EXT_P5r,&(r._b100x_disconnect_counter_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define B100X_DISCONNECT_COUNTER_EXT_P5r BCM53101_A0_B100X_DISCONNECT_COUNTER_EXT_P5r
#define B100X_DISCONNECT_COUNTER_EXT_P5r_SIZE BCM53101_A0_B100X_DISCONNECT_COUNTER_EXT_P5r_SIZE
typedef BCM53101_A0_B100X_DISCONNECT_COUNTER_EXT_P5r_t B100X_DISCONNECT_COUNTER_EXT_P5r_t;
#define B100X_DISCONNECT_COUNTER_EXT_P5r_CLR BCM53101_A0_B100X_DISCONNECT_COUNTER_EXT_P5r_CLR
#define B100X_DISCONNECT_COUNTER_EXT_P5r_SET BCM53101_A0_B100X_DISCONNECT_COUNTER_EXT_P5r_SET
#define B100X_DISCONNECT_COUNTER_EXT_P5r_GET BCM53101_A0_B100X_DISCONNECT_COUNTER_EXT_P5r_GET
#define B100X_DISCONNECT_COUNTER_EXT_P5r_RESERVEDf_GET BCM53101_A0_B100X_DISCONNECT_COUNTER_EXT_P5r_RESERVEDf_GET
#define B100X_DISCONNECT_COUNTER_EXT_P5r_RESERVEDf_SET BCM53101_A0_B100X_DISCONNECT_COUNTER_EXT_P5r_RESERVEDf_SET
#define B100X_DISCONNECT_COUNTER_EXT_P5r_SMII_SLOW_RXDf_GET BCM53101_A0_B100X_DISCONNECT_COUNTER_EXT_P5r_SMII_SLOW_RXDf_GET
#define B100X_DISCONNECT_COUNTER_EXT_P5r_SMII_SLOW_RXDf_SET BCM53101_A0_B100X_DISCONNECT_COUNTER_EXT_P5r_SMII_SLOW_RXDf_SET
#define B100X_DISCONNECT_COUNTER_EXT_P5r_SMII_FAST_RXDf_GET BCM53101_A0_B100X_DISCONNECT_COUNTER_EXT_P5r_SMII_FAST_RXDf_GET
#define B100X_DISCONNECT_COUNTER_EXT_P5r_SMII_FAST_RXDf_SET BCM53101_A0_B100X_DISCONNECT_COUNTER_EXT_P5r_SMII_FAST_RXDf_SET
#define READ_B100X_DISCONNECT_COUNTER_EXT_P5r BCM53101_A0_READ_B100X_DISCONNECT_COUNTER_EXT_P5r
#define WRITE_B100X_DISCONNECT_COUNTER_EXT_P5r BCM53101_A0_WRITE_B100X_DISCONNECT_COUNTER_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_B100X_DISCONNECT_COUNTER_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  B100X_FALSE_CARRIER_SENSE_COUNTER
 * BLOCKS:   EPIC0
 * DESC:     100BASE-X FALSE CARRIER SENSE COUNTER
 * SIZE:     16
 * FIELDS:
 *     FALSE_CARRIER_SENSE_COUNTER Number of false carrier sense events since last read.
 *     SMII_OVERRUN_UNDERRUN_COUNTER Number of overruns/underruns since last read.
 *
 ******************************************************************************/
#define BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTERr 0x00001026

#define BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTERr_SIZE 2

/*
 * This structure should be used to declare and program B100X_FALSE_CARRIER_SENSE_COUNTER.
 *
 */
typedef union BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTERr_s {
	uint32_t v[1];
	uint32_t b100x_false_carrier_sense_counter[1];
	uint32_t _b100x_false_carrier_sense_counter;
} BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTERr_t;

#define BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTERr_CLR(r) (r).b100x_false_carrier_sense_counter[0] = 0
#define BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTERr_SET(r,d) (r).b100x_false_carrier_sense_counter[0] = d
#define BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTERr_GET(r) (r).b100x_false_carrier_sense_counter[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTERr_FALSE_CARRIER_SENSE_COUNTERf_GET(r) (((r).b100x_false_carrier_sense_counter[0]) & 0xff)
#define BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTERr_FALSE_CARRIER_SENSE_COUNTERf_SET(r,f) (r).b100x_false_carrier_sense_counter[0]=(((r).b100x_false_carrier_sense_counter[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTERr_SMII_OVERRUN_UNDERRUN_COUNTERf_GET(r) ((((r).b100x_false_carrier_sense_counter[0]) >> 8) & 0xff)
#define BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTERr_SMII_OVERRUN_UNDERRUN_COUNTERf_SET(r,f) (r).b100x_false_carrier_sense_counter[0]=(((r).b100x_false_carrier_sense_counter[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access B100X_FALSE_CARRIER_SENSE_COUNTER.
 *
 */
#define BCM53101_A0_READ_B100X_FALSE_CARRIER_SENSE_COUNTERr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTERr,(r._b100x_false_carrier_sense_counter),2)
#define BCM53101_A0_WRITE_B100X_FALSE_CARRIER_SENSE_COUNTERr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTERr,&(r._b100x_false_carrier_sense_counter),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define B100X_FALSE_CARRIER_SENSE_COUNTERr BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTERr
#define B100X_FALSE_CARRIER_SENSE_COUNTERr_SIZE BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTERr_SIZE
typedef BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTERr_t B100X_FALSE_CARRIER_SENSE_COUNTERr_t;
#define B100X_FALSE_CARRIER_SENSE_COUNTERr_CLR BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTERr_CLR
#define B100X_FALSE_CARRIER_SENSE_COUNTERr_SET BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTERr_SET
#define B100X_FALSE_CARRIER_SENSE_COUNTERr_GET BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTERr_GET
#define B100X_FALSE_CARRIER_SENSE_COUNTERr_FALSE_CARRIER_SENSE_COUNTERf_GET BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTERr_FALSE_CARRIER_SENSE_COUNTERf_GET
#define B100X_FALSE_CARRIER_SENSE_COUNTERr_FALSE_CARRIER_SENSE_COUNTERf_SET BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTERr_FALSE_CARRIER_SENSE_COUNTERf_SET
#define B100X_FALSE_CARRIER_SENSE_COUNTERr_SMII_OVERRUN_UNDERRUN_COUNTERf_GET BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTERr_SMII_OVERRUN_UNDERRUN_COUNTERf_GET
#define B100X_FALSE_CARRIER_SENSE_COUNTERr_SMII_OVERRUN_UNDERRUN_COUNTERf_SET BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTERr_SMII_OVERRUN_UNDERRUN_COUNTERf_SET
#define READ_B100X_FALSE_CARRIER_SENSE_COUNTERr BCM53101_A0_READ_B100X_FALSE_CARRIER_SENSE_COUNTERr
#define WRITE_B100X_FALSE_CARRIER_SENSE_COUNTERr BCM53101_A0_WRITE_B100X_FALSE_CARRIER_SENSE_COUNTERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5
 * BLOCKS:   SYS
 * DESC:     100BASE-X FALSE CARRIER SENSE COUNTER
 * SIZE:     16
 * FIELDS:
 *     FALSE_CARRIER_SENSE_COUNTER Number of false carrier sense events since last read.
 *     SMII_OVERRUN_UNDERRUN_COUNTER Number of overruns/underruns since last read.
 *
 ******************************************************************************/
#define BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r 0x00008526

#define BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5.
 *
 */
typedef union BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r_s {
	uint32_t v[1];
	uint32_t b100x_false_carrier_sense_counter_ext_p5[1];
	uint32_t _b100x_false_carrier_sense_counter_ext_p5;
} BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r_t;

#define BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r_CLR(r) (r).b100x_false_carrier_sense_counter_ext_p5[0] = 0
#define BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r_SET(r,d) (r).b100x_false_carrier_sense_counter_ext_p5[0] = d
#define BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r_GET(r) (r).b100x_false_carrier_sense_counter_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r_FALSE_CARRIER_SENSE_COUNTERf_GET(r) (((r).b100x_false_carrier_sense_counter_ext_p5[0]) & 0xff)
#define BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r_FALSE_CARRIER_SENSE_COUNTERf_SET(r,f) (r).b100x_false_carrier_sense_counter_ext_p5[0]=(((r).b100x_false_carrier_sense_counter_ext_p5[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r_SMII_OVERRUN_UNDERRUN_COUNTERf_GET(r) ((((r).b100x_false_carrier_sense_counter_ext_p5[0]) >> 8) & 0xff)
#define BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r_SMII_OVERRUN_UNDERRUN_COUNTERf_SET(r,f) (r).b100x_false_carrier_sense_counter_ext_p5[0]=(((r).b100x_false_carrier_sense_counter_ext_p5[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5.
 *
 */
#define BCM53101_A0_READ_B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r,(r._b100x_false_carrier_sense_counter_ext_p5),2)
#define BCM53101_A0_WRITE_B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r,&(r._b100x_false_carrier_sense_counter_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r
#define B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r_SIZE BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r_SIZE
typedef BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r_t B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r_t;
#define B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r_CLR BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r_CLR
#define B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r_SET BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r_SET
#define B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r_GET BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r_GET
#define B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r_FALSE_CARRIER_SENSE_COUNTERf_GET BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r_FALSE_CARRIER_SENSE_COUNTERf_GET
#define B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r_FALSE_CARRIER_SENSE_COUNTERf_SET BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r_FALSE_CARRIER_SENSE_COUNTERf_SET
#define B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r_SMII_OVERRUN_UNDERRUN_COUNTERf_GET BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r_SMII_OVERRUN_UNDERRUN_COUNTERf_GET
#define B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r_SMII_OVERRUN_UNDERRUN_COUNTERf_SET BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r_SMII_OVERRUN_UNDERRUN_COUNTERf_SET
#define READ_B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r BCM53101_A0_READ_B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r
#define WRITE_B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r BCM53101_A0_WRITE_B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_B100X_FALSE_CARRIER_SENSE_COUNTER_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  B100X_RX_ERROR_COUNTER
 * BLOCKS:   EPIC0
 * DESC:     100BASE-X RECEIVE ERROR COUNTER REGISTER
 * SIZE:     16
 * FIELDS:
 *     RX_ERROR_COUNTER Number of non-collision packets with receive errors since last read.
 *
 ******************************************************************************/
#define BCM53101_A0_B100X_RX_ERROR_COUNTERr 0x00001024

#define BCM53101_A0_B100X_RX_ERROR_COUNTERr_SIZE 2

/*
 * This structure should be used to declare and program B100X_RX_ERROR_COUNTER.
 *
 */
typedef union BCM53101_A0_B100X_RX_ERROR_COUNTERr_s {
	uint32_t v[1];
	uint32_t b100x_rx_error_counter[1];
	uint32_t _b100x_rx_error_counter;
} BCM53101_A0_B100X_RX_ERROR_COUNTERr_t;

#define BCM53101_A0_B100X_RX_ERROR_COUNTERr_CLR(r) (r).b100x_rx_error_counter[0] = 0
#define BCM53101_A0_B100X_RX_ERROR_COUNTERr_SET(r,d) (r).b100x_rx_error_counter[0] = d
#define BCM53101_A0_B100X_RX_ERROR_COUNTERr_GET(r) (r).b100x_rx_error_counter[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_B100X_RX_ERROR_COUNTERr_RX_ERROR_COUNTERf_GET(r) (((r).b100x_rx_error_counter[0]) & 0xffff)
#define BCM53101_A0_B100X_RX_ERROR_COUNTERr_RX_ERROR_COUNTERf_SET(r,f) (r).b100x_rx_error_counter[0]=(((r).b100x_rx_error_counter[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access B100X_RX_ERROR_COUNTER.
 *
 */
#define BCM53101_A0_READ_B100X_RX_ERROR_COUNTERr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_B100X_RX_ERROR_COUNTERr,(r._b100x_rx_error_counter),2)
#define BCM53101_A0_WRITE_B100X_RX_ERROR_COUNTERr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_B100X_RX_ERROR_COUNTERr,&(r._b100x_rx_error_counter),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define B100X_RX_ERROR_COUNTERr BCM53101_A0_B100X_RX_ERROR_COUNTERr
#define B100X_RX_ERROR_COUNTERr_SIZE BCM53101_A0_B100X_RX_ERROR_COUNTERr_SIZE
typedef BCM53101_A0_B100X_RX_ERROR_COUNTERr_t B100X_RX_ERROR_COUNTERr_t;
#define B100X_RX_ERROR_COUNTERr_CLR BCM53101_A0_B100X_RX_ERROR_COUNTERr_CLR
#define B100X_RX_ERROR_COUNTERr_SET BCM53101_A0_B100X_RX_ERROR_COUNTERr_SET
#define B100X_RX_ERROR_COUNTERr_GET BCM53101_A0_B100X_RX_ERROR_COUNTERr_GET
#define B100X_RX_ERROR_COUNTERr_RX_ERROR_COUNTERf_GET BCM53101_A0_B100X_RX_ERROR_COUNTERr_RX_ERROR_COUNTERf_GET
#define B100X_RX_ERROR_COUNTERr_RX_ERROR_COUNTERf_SET BCM53101_A0_B100X_RX_ERROR_COUNTERr_RX_ERROR_COUNTERf_SET
#define READ_B100X_RX_ERROR_COUNTERr BCM53101_A0_READ_B100X_RX_ERROR_COUNTERr
#define WRITE_B100X_RX_ERROR_COUNTERr BCM53101_A0_WRITE_B100X_RX_ERROR_COUNTERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_B100X_RX_ERROR_COUNTERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  B100X_RX_ERROR_COUNTER_EXT_P5
 * BLOCKS:   SYS
 * DESC:     100BASE-X RECEIVE ERROR COUNTER REGISTER
 * SIZE:     16
 * FIELDS:
 *     RX_ERROR_COUNTER Number of non-collision packets with receive errors since last read.
 *
 ******************************************************************************/
#define BCM53101_A0_B100X_RX_ERROR_COUNTER_EXT_P5r 0x00008524

#define BCM53101_A0_B100X_RX_ERROR_COUNTER_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program B100X_RX_ERROR_COUNTER_EXT_P5.
 *
 */
typedef union BCM53101_A0_B100X_RX_ERROR_COUNTER_EXT_P5r_s {
	uint32_t v[1];
	uint32_t b100x_rx_error_counter_ext_p5[1];
	uint32_t _b100x_rx_error_counter_ext_p5;
} BCM53101_A0_B100X_RX_ERROR_COUNTER_EXT_P5r_t;

#define BCM53101_A0_B100X_RX_ERROR_COUNTER_EXT_P5r_CLR(r) (r).b100x_rx_error_counter_ext_p5[0] = 0
#define BCM53101_A0_B100X_RX_ERROR_COUNTER_EXT_P5r_SET(r,d) (r).b100x_rx_error_counter_ext_p5[0] = d
#define BCM53101_A0_B100X_RX_ERROR_COUNTER_EXT_P5r_GET(r) (r).b100x_rx_error_counter_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_B100X_RX_ERROR_COUNTER_EXT_P5r_RX_ERROR_COUNTERf_GET(r) (((r).b100x_rx_error_counter_ext_p5[0]) & 0xffff)
#define BCM53101_A0_B100X_RX_ERROR_COUNTER_EXT_P5r_RX_ERROR_COUNTERf_SET(r,f) (r).b100x_rx_error_counter_ext_p5[0]=(((r).b100x_rx_error_counter_ext_p5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access B100X_RX_ERROR_COUNTER_EXT_P5.
 *
 */
#define BCM53101_A0_READ_B100X_RX_ERROR_COUNTER_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53101_A0_B100X_RX_ERROR_COUNTER_EXT_P5r,(r._b100x_rx_error_counter_ext_p5),2)
#define BCM53101_A0_WRITE_B100X_RX_ERROR_COUNTER_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53101_A0_B100X_RX_ERROR_COUNTER_EXT_P5r,&(r._b100x_rx_error_counter_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define B100X_RX_ERROR_COUNTER_EXT_P5r BCM53101_A0_B100X_RX_ERROR_COUNTER_EXT_P5r
#define B100X_RX_ERROR_COUNTER_EXT_P5r_SIZE BCM53101_A0_B100X_RX_ERROR_COUNTER_EXT_P5r_SIZE
typedef BCM53101_A0_B100X_RX_ERROR_COUNTER_EXT_P5r_t B100X_RX_ERROR_COUNTER_EXT_P5r_t;
#define B100X_RX_ERROR_COUNTER_EXT_P5r_CLR BCM53101_A0_B100X_RX_ERROR_COUNTER_EXT_P5r_CLR
#define B100X_RX_ERROR_COUNTER_EXT_P5r_SET BCM53101_A0_B100X_RX_ERROR_COUNTER_EXT_P5r_SET
#define B100X_RX_ERROR_COUNTER_EXT_P5r_GET BCM53101_A0_B100X_RX_ERROR_COUNTER_EXT_P5r_GET
#define B100X_RX_ERROR_COUNTER_EXT_P5r_RX_ERROR_COUNTERf_GET BCM53101_A0_B100X_RX_ERROR_COUNTER_EXT_P5r_RX_ERROR_COUNTERf_GET
#define B100X_RX_ERROR_COUNTER_EXT_P5r_RX_ERROR_COUNTERf_SET BCM53101_A0_B100X_RX_ERROR_COUNTER_EXT_P5r_RX_ERROR_COUNTERf_SET
#define READ_B100X_RX_ERROR_COUNTER_EXT_P5r BCM53101_A0_READ_B100X_RX_ERROR_COUNTER_EXT_P5r
#define WRITE_B100X_RX_ERROR_COUNTER_EXT_P5r BCM53101_A0_WRITE_B100X_RX_ERROR_COUNTER_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_B100X_RX_ERROR_COUNTER_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  B10T_AUX_STATUS
 * BLOCKS:   EPIC0
 * DESC:     10BASE-T AUXILIARY ERROR AND GENERAL STATUS REGISTER
 * SIZE:     16
 * FIELDS:
 *     FDX_INDICATION   1 = Full-duplex active.0 = Full-duplex inactive.   
 *     SPEED_INDICATION 1 = 100BASE-X.0 = 10BASE-T.
 *     FORCE100_INDICATION 1 = Speed forced to 100BASE-X. 0 = Speed forced to 10BASE-T.
 *     AN_INDICATION    1 = Auto-negotiation activated.0 = Speed forced manually.  
 *     RESERVED         Reserved
 *     END_OF_FRAME_ERROR 1 = EOF detection error (10BASE-T).
 *     MANCHESTER_CODE_ERROR 1 = Manchester code error (10BASE-T)e.
 *     HP_AUTO_MDIX_DISABLE 0 = Enable HP Auto-MDIX.1 = Disable HP Auto-MDIX.
 *     MDIX_MANUAL_SWAP 0 = MDI or MDIX if MDIX is not disabled.1 = Force MDIX.
 *     MDIX_STATUS      0 = MDI is in use.1 = MDIX is in use.
 *
 ******************************************************************************/
#define BCM53101_A0_B10T_AUX_STATUSr 0x00001038

#define BCM53101_A0_B10T_AUX_STATUSr_SIZE 2

/*
 * This structure should be used to declare and program B10T_AUX_STATUS.
 *
 */
typedef union BCM53101_A0_B10T_AUX_STATUSr_s {
	uint32_t v[1];
	uint32_t b10t_aux_status[1];
	uint32_t _b10t_aux_status;
} BCM53101_A0_B10T_AUX_STATUSr_t;

#define BCM53101_A0_B10T_AUX_STATUSr_CLR(r) (r).b10t_aux_status[0] = 0
#define BCM53101_A0_B10T_AUX_STATUSr_SET(r,d) (r).b10t_aux_status[0] = d
#define BCM53101_A0_B10T_AUX_STATUSr_GET(r) (r).b10t_aux_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_B10T_AUX_STATUSr_FDX_INDICATIONf_GET(r) (((r).b10t_aux_status[0]) & 0x1)
#define BCM53101_A0_B10T_AUX_STATUSr_FDX_INDICATIONf_SET(r,f) (r).b10t_aux_status[0]=(((r).b10t_aux_status[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_B10T_AUX_STATUSr_SPEED_INDICATIONf_GET(r) ((((r).b10t_aux_status[0]) >> 1) & 0x1)
#define BCM53101_A0_B10T_AUX_STATUSr_SPEED_INDICATIONf_SET(r,f) (r).b10t_aux_status[0]=(((r).b10t_aux_status[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_B10T_AUX_STATUSr_FORCE100_INDICATIONf_GET(r) ((((r).b10t_aux_status[0]) >> 2) & 0x1)
#define BCM53101_A0_B10T_AUX_STATUSr_FORCE100_INDICATIONf_SET(r,f) (r).b10t_aux_status[0]=(((r).b10t_aux_status[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_B10T_AUX_STATUSr_AN_INDICATIONf_GET(r) ((((r).b10t_aux_status[0]) >> 3) & 0x1)
#define BCM53101_A0_B10T_AUX_STATUSr_AN_INDICATIONf_SET(r,f) (r).b10t_aux_status[0]=(((r).b10t_aux_status[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_B10T_AUX_STATUSr_RESERVEDf_GET(r) ((((r).b10t_aux_status[0]) >> 4) & 0x1f)
#define BCM53101_A0_B10T_AUX_STATUSr_RESERVEDf_SET(r,f) (r).b10t_aux_status[0]=(((r).b10t_aux_status[0] & ~((uint32_t)0x1f << 4)) | ((((uint32_t)f) & 0x1f) << 4))
#define BCM53101_A0_B10T_AUX_STATUSr_END_OF_FRAME_ERRORf_GET(r) ((((r).b10t_aux_status[0]) >> 9) & 0x1)
#define BCM53101_A0_B10T_AUX_STATUSr_END_OF_FRAME_ERRORf_SET(r,f) (r).b10t_aux_status[0]=(((r).b10t_aux_status[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53101_A0_B10T_AUX_STATUSr_MANCHESTER_CODE_ERRORf_GET(r) ((((r).b10t_aux_status[0]) >> 10) & 0x1)
#define BCM53101_A0_B10T_AUX_STATUSr_MANCHESTER_CODE_ERRORf_SET(r,f) (r).b10t_aux_status[0]=(((r).b10t_aux_status[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53101_A0_B10T_AUX_STATUSr_HP_AUTO_MDIX_DISABLEf_GET(r) ((((r).b10t_aux_status[0]) >> 11) & 0x1)
#define BCM53101_A0_B10T_AUX_STATUSr_HP_AUTO_MDIX_DISABLEf_SET(r,f) (r).b10t_aux_status[0]=(((r).b10t_aux_status[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53101_A0_B10T_AUX_STATUSr_MDIX_MANUAL_SWAPf_GET(r) ((((r).b10t_aux_status[0]) >> 12) & 0x1)
#define BCM53101_A0_B10T_AUX_STATUSr_MDIX_MANUAL_SWAPf_SET(r,f) (r).b10t_aux_status[0]=(((r).b10t_aux_status[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53101_A0_B10T_AUX_STATUSr_MDIX_STATUSf_GET(r) ((((r).b10t_aux_status[0]) >> 13) & 0x1)
#define BCM53101_A0_B10T_AUX_STATUSr_MDIX_STATUSf_SET(r,f) (r).b10t_aux_status[0]=(((r).b10t_aux_status[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))

/*
 * These macros can be used to access B10T_AUX_STATUS.
 *
 */
#define BCM53101_A0_READ_B10T_AUX_STATUSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_B10T_AUX_STATUSr,(r._b10t_aux_status),2)
#define BCM53101_A0_WRITE_B10T_AUX_STATUSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_B10T_AUX_STATUSr,&(r._b10t_aux_status),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define B10T_AUX_STATUSr BCM53101_A0_B10T_AUX_STATUSr
#define B10T_AUX_STATUSr_SIZE BCM53101_A0_B10T_AUX_STATUSr_SIZE
typedef BCM53101_A0_B10T_AUX_STATUSr_t B10T_AUX_STATUSr_t;
#define B10T_AUX_STATUSr_CLR BCM53101_A0_B10T_AUX_STATUSr_CLR
#define B10T_AUX_STATUSr_SET BCM53101_A0_B10T_AUX_STATUSr_SET
#define B10T_AUX_STATUSr_GET BCM53101_A0_B10T_AUX_STATUSr_GET
#define B10T_AUX_STATUSr_FDX_INDICATIONf_GET BCM53101_A0_B10T_AUX_STATUSr_FDX_INDICATIONf_GET
#define B10T_AUX_STATUSr_FDX_INDICATIONf_SET BCM53101_A0_B10T_AUX_STATUSr_FDX_INDICATIONf_SET
#define B10T_AUX_STATUSr_SPEED_INDICATIONf_GET BCM53101_A0_B10T_AUX_STATUSr_SPEED_INDICATIONf_GET
#define B10T_AUX_STATUSr_SPEED_INDICATIONf_SET BCM53101_A0_B10T_AUX_STATUSr_SPEED_INDICATIONf_SET
#define B10T_AUX_STATUSr_FORCE100_INDICATIONf_GET BCM53101_A0_B10T_AUX_STATUSr_FORCE100_INDICATIONf_GET
#define B10T_AUX_STATUSr_FORCE100_INDICATIONf_SET BCM53101_A0_B10T_AUX_STATUSr_FORCE100_INDICATIONf_SET
#define B10T_AUX_STATUSr_AN_INDICATIONf_GET BCM53101_A0_B10T_AUX_STATUSr_AN_INDICATIONf_GET
#define B10T_AUX_STATUSr_AN_INDICATIONf_SET BCM53101_A0_B10T_AUX_STATUSr_AN_INDICATIONf_SET
#define B10T_AUX_STATUSr_RESERVEDf_GET BCM53101_A0_B10T_AUX_STATUSr_RESERVEDf_GET
#define B10T_AUX_STATUSr_RESERVEDf_SET BCM53101_A0_B10T_AUX_STATUSr_RESERVEDf_SET
#define B10T_AUX_STATUSr_END_OF_FRAME_ERRORf_GET BCM53101_A0_B10T_AUX_STATUSr_END_OF_FRAME_ERRORf_GET
#define B10T_AUX_STATUSr_END_OF_FRAME_ERRORf_SET BCM53101_A0_B10T_AUX_STATUSr_END_OF_FRAME_ERRORf_SET
#define B10T_AUX_STATUSr_MANCHESTER_CODE_ERRORf_GET BCM53101_A0_B10T_AUX_STATUSr_MANCHESTER_CODE_ERRORf_GET
#define B10T_AUX_STATUSr_MANCHESTER_CODE_ERRORf_SET BCM53101_A0_B10T_AUX_STATUSr_MANCHESTER_CODE_ERRORf_SET
#define B10T_AUX_STATUSr_HP_AUTO_MDIX_DISABLEf_GET BCM53101_A0_B10T_AUX_STATUSr_HP_AUTO_MDIX_DISABLEf_GET
#define B10T_AUX_STATUSr_HP_AUTO_MDIX_DISABLEf_SET BCM53101_A0_B10T_AUX_STATUSr_HP_AUTO_MDIX_DISABLEf_SET
#define B10T_AUX_STATUSr_MDIX_MANUAL_SWAPf_GET BCM53101_A0_B10T_AUX_STATUSr_MDIX_MANUAL_SWAPf_GET
#define B10T_AUX_STATUSr_MDIX_MANUAL_SWAPf_SET BCM53101_A0_B10T_AUX_STATUSr_MDIX_MANUAL_SWAPf_SET
#define B10T_AUX_STATUSr_MDIX_STATUSf_GET BCM53101_A0_B10T_AUX_STATUSr_MDIX_STATUSf_GET
#define B10T_AUX_STATUSr_MDIX_STATUSf_SET BCM53101_A0_B10T_AUX_STATUSr_MDIX_STATUSf_SET
#define READ_B10T_AUX_STATUSr BCM53101_A0_READ_B10T_AUX_STATUSr
#define WRITE_B10T_AUX_STATUSr BCM53101_A0_WRITE_B10T_AUX_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_B10T_AUX_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  B10T_AUX_STATUS_EXT_P5
 * BLOCKS:   SYS
 * DESC:     10BASE-T AUXILIARY ERROR AND GENERAL STATUS REGISTER
 * SIZE:     16
 * FIELDS:
 *     FDX_INDICATION   1 = Full-duplex active.0 = Full-duplex inactive.   
 *     SPEED_INDICATION 1 = 100BASE-X.0 = 10BASE-T.
 *     FORCE100_INDICATION 1 = Speed forced to 100BASE-X. 0 = Speed forced to 10BASE-T.
 *     AN_INDICATION    1 = Auto-negotiation activated.0 = Speed forced manually.  
 *     RESERVED         Reserved
 *     END_OF_FRAME_ERROR 1 = EOF detection error (10BASE-T).
 *     MANCHESTER_CODE_ERROR 1 = Manchester code error (10BASE-T)e.
 *     HP_AUTO_MDIX_DISABLE 0 = Enable HP Auto-MDIX.1 = Disable HP Auto-MDIX.
 *     MDIX_MANUAL_SWAP 0 = MDI or MDIX if MDIX is not disabled.1 = Force MDIX.
 *     MDIX_STATUS      0 = MDI is in use.1 = MDIX is in use.
 *
 ******************************************************************************/
#define BCM53101_A0_B10T_AUX_STATUS_EXT_P5r 0x00008538

#define BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program B10T_AUX_STATUS_EXT_P5.
 *
 */
typedef union BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_s {
	uint32_t v[1];
	uint32_t b10t_aux_status_ext_p5[1];
	uint32_t _b10t_aux_status_ext_p5;
} BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_t;

#define BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_CLR(r) (r).b10t_aux_status_ext_p5[0] = 0
#define BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_SET(r,d) (r).b10t_aux_status_ext_p5[0] = d
#define BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_GET(r) (r).b10t_aux_status_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_FDX_INDICATIONf_GET(r) (((r).b10t_aux_status_ext_p5[0]) & 0x1)
#define BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_FDX_INDICATIONf_SET(r,f) (r).b10t_aux_status_ext_p5[0]=(((r).b10t_aux_status_ext_p5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_SPEED_INDICATIONf_GET(r) ((((r).b10t_aux_status_ext_p5[0]) >> 1) & 0x1)
#define BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_SPEED_INDICATIONf_SET(r,f) (r).b10t_aux_status_ext_p5[0]=(((r).b10t_aux_status_ext_p5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_FORCE100_INDICATIONf_GET(r) ((((r).b10t_aux_status_ext_p5[0]) >> 2) & 0x1)
#define BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_FORCE100_INDICATIONf_SET(r,f) (r).b10t_aux_status_ext_p5[0]=(((r).b10t_aux_status_ext_p5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_AN_INDICATIONf_GET(r) ((((r).b10t_aux_status_ext_p5[0]) >> 3) & 0x1)
#define BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_AN_INDICATIONf_SET(r,f) (r).b10t_aux_status_ext_p5[0]=(((r).b10t_aux_status_ext_p5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_RESERVEDf_GET(r) ((((r).b10t_aux_status_ext_p5[0]) >> 4) & 0x1f)
#define BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_RESERVEDf_SET(r,f) (r).b10t_aux_status_ext_p5[0]=(((r).b10t_aux_status_ext_p5[0] & ~((uint32_t)0x1f << 4)) | ((((uint32_t)f) & 0x1f) << 4))
#define BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_END_OF_FRAME_ERRORf_GET(r) ((((r).b10t_aux_status_ext_p5[0]) >> 9) & 0x1)
#define BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_END_OF_FRAME_ERRORf_SET(r,f) (r).b10t_aux_status_ext_p5[0]=(((r).b10t_aux_status_ext_p5[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_MANCHESTER_CODE_ERRORf_GET(r) ((((r).b10t_aux_status_ext_p5[0]) >> 10) & 0x1)
#define BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_MANCHESTER_CODE_ERRORf_SET(r,f) (r).b10t_aux_status_ext_p5[0]=(((r).b10t_aux_status_ext_p5[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_HP_AUTO_MDIX_DISABLEf_GET(r) ((((r).b10t_aux_status_ext_p5[0]) >> 11) & 0x1)
#define BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_HP_AUTO_MDIX_DISABLEf_SET(r,f) (r).b10t_aux_status_ext_p5[0]=(((r).b10t_aux_status_ext_p5[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_MDIX_MANUAL_SWAPf_GET(r) ((((r).b10t_aux_status_ext_p5[0]) >> 12) & 0x1)
#define BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_MDIX_MANUAL_SWAPf_SET(r,f) (r).b10t_aux_status_ext_p5[0]=(((r).b10t_aux_status_ext_p5[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_MDIX_STATUSf_GET(r) ((((r).b10t_aux_status_ext_p5[0]) >> 13) & 0x1)
#define BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_MDIX_STATUSf_SET(r,f) (r).b10t_aux_status_ext_p5[0]=(((r).b10t_aux_status_ext_p5[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))

/*
 * These macros can be used to access B10T_AUX_STATUS_EXT_P5.
 *
 */
#define BCM53101_A0_READ_B10T_AUX_STATUS_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53101_A0_B10T_AUX_STATUS_EXT_P5r,(r._b10t_aux_status_ext_p5),2)
#define BCM53101_A0_WRITE_B10T_AUX_STATUS_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53101_A0_B10T_AUX_STATUS_EXT_P5r,&(r._b10t_aux_status_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define B10T_AUX_STATUS_EXT_P5r BCM53101_A0_B10T_AUX_STATUS_EXT_P5r
#define B10T_AUX_STATUS_EXT_P5r_SIZE BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_SIZE
typedef BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_t B10T_AUX_STATUS_EXT_P5r_t;
#define B10T_AUX_STATUS_EXT_P5r_CLR BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_CLR
#define B10T_AUX_STATUS_EXT_P5r_SET BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_SET
#define B10T_AUX_STATUS_EXT_P5r_GET BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_GET
#define B10T_AUX_STATUS_EXT_P5r_FDX_INDICATIONf_GET BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_FDX_INDICATIONf_GET
#define B10T_AUX_STATUS_EXT_P5r_FDX_INDICATIONf_SET BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_FDX_INDICATIONf_SET
#define B10T_AUX_STATUS_EXT_P5r_SPEED_INDICATIONf_GET BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_SPEED_INDICATIONf_GET
#define B10T_AUX_STATUS_EXT_P5r_SPEED_INDICATIONf_SET BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_SPEED_INDICATIONf_SET
#define B10T_AUX_STATUS_EXT_P5r_FORCE100_INDICATIONf_GET BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_FORCE100_INDICATIONf_GET
#define B10T_AUX_STATUS_EXT_P5r_FORCE100_INDICATIONf_SET BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_FORCE100_INDICATIONf_SET
#define B10T_AUX_STATUS_EXT_P5r_AN_INDICATIONf_GET BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_AN_INDICATIONf_GET
#define B10T_AUX_STATUS_EXT_P5r_AN_INDICATIONf_SET BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_AN_INDICATIONf_SET
#define B10T_AUX_STATUS_EXT_P5r_RESERVEDf_GET BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_RESERVEDf_GET
#define B10T_AUX_STATUS_EXT_P5r_RESERVEDf_SET BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_RESERVEDf_SET
#define B10T_AUX_STATUS_EXT_P5r_END_OF_FRAME_ERRORf_GET BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_END_OF_FRAME_ERRORf_GET
#define B10T_AUX_STATUS_EXT_P5r_END_OF_FRAME_ERRORf_SET BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_END_OF_FRAME_ERRORf_SET
#define B10T_AUX_STATUS_EXT_P5r_MANCHESTER_CODE_ERRORf_GET BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_MANCHESTER_CODE_ERRORf_GET
#define B10T_AUX_STATUS_EXT_P5r_MANCHESTER_CODE_ERRORf_SET BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_MANCHESTER_CODE_ERRORf_SET
#define B10T_AUX_STATUS_EXT_P5r_HP_AUTO_MDIX_DISABLEf_GET BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_HP_AUTO_MDIX_DISABLEf_GET
#define B10T_AUX_STATUS_EXT_P5r_HP_AUTO_MDIX_DISABLEf_SET BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_HP_AUTO_MDIX_DISABLEf_SET
#define B10T_AUX_STATUS_EXT_P5r_MDIX_MANUAL_SWAPf_GET BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_MDIX_MANUAL_SWAPf_GET
#define B10T_AUX_STATUS_EXT_P5r_MDIX_MANUAL_SWAPf_SET BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_MDIX_MANUAL_SWAPf_SET
#define B10T_AUX_STATUS_EXT_P5r_MDIX_STATUSf_GET BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_MDIX_STATUSf_GET
#define B10T_AUX_STATUS_EXT_P5r_MDIX_STATUSf_SET BCM53101_A0_B10T_AUX_STATUS_EXT_P5r_MDIX_STATUSf_SET
#define READ_B10T_AUX_STATUS_EXT_P5r BCM53101_A0_READ_B10T_AUX_STATUS_EXT_P5r
#define WRITE_B10T_AUX_STATUS_EXT_P5r BCM53101_A0_WRITE_B10T_AUX_STATUS_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_B10T_AUX_STATUS_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  BC_SUP_PKTDROP_CNT_IMP
 * BLOCKS:   CPIC
 * DESC:     Port 8 Suppressed Packet Drop Counter Register
 * SIZE:     32
 * FIELDS:
 *     PK_DROP_CNT      Packet Dropped Count.Record the Dropped packet count for Suppression Drop Count or Jumbo Filtered Count.Reset after the Register has been read.
 *
 ******************************************************************************/
#define BCM53101_A0_BC_SUP_PKTDROP_CNT_IMPr 0x00004170

#define BCM53101_A0_BC_SUP_PKTDROP_CNT_IMPr_SIZE 4

/*
 * This structure should be used to declare and program BC_SUP_PKTDROP_CNT_IMP.
 *
 */
typedef union BCM53101_A0_BC_SUP_PKTDROP_CNT_IMPr_s {
	uint32_t v[1];
	uint32_t bc_sup_pktdrop_cnt_imp[1];
	uint32_t _bc_sup_pktdrop_cnt_imp;
} BCM53101_A0_BC_SUP_PKTDROP_CNT_IMPr_t;

#define BCM53101_A0_BC_SUP_PKTDROP_CNT_IMPr_CLR(r) (r).bc_sup_pktdrop_cnt_imp[0] = 0
#define BCM53101_A0_BC_SUP_PKTDROP_CNT_IMPr_SET(r,d) (r).bc_sup_pktdrop_cnt_imp[0] = d
#define BCM53101_A0_BC_SUP_PKTDROP_CNT_IMPr_GET(r) (r).bc_sup_pktdrop_cnt_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_BC_SUP_PKTDROP_CNT_IMPr_PK_DROP_CNTf_GET(r) ((r).bc_sup_pktdrop_cnt_imp[0])
#define BCM53101_A0_BC_SUP_PKTDROP_CNT_IMPr_PK_DROP_CNTf_SET(r,f) (r).bc_sup_pktdrop_cnt_imp[0]=((uint32_t)f)

/*
 * These macros can be used to access BC_SUP_PKTDROP_CNT_IMP.
 *
 */
#define BCM53101_A0_READ_BC_SUP_PKTDROP_CNT_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_BC_SUP_PKTDROP_CNT_IMPr,(r._bc_sup_pktdrop_cnt_imp),4)
#define BCM53101_A0_WRITE_BC_SUP_PKTDROP_CNT_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_BC_SUP_PKTDROP_CNT_IMPr,&(r._bc_sup_pktdrop_cnt_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BC_SUP_PKTDROP_CNT_IMPr BCM53101_A0_BC_SUP_PKTDROP_CNT_IMPr
#define BC_SUP_PKTDROP_CNT_IMPr_SIZE BCM53101_A0_BC_SUP_PKTDROP_CNT_IMPr_SIZE
typedef BCM53101_A0_BC_SUP_PKTDROP_CNT_IMPr_t BC_SUP_PKTDROP_CNT_IMPr_t;
#define BC_SUP_PKTDROP_CNT_IMPr_CLR BCM53101_A0_BC_SUP_PKTDROP_CNT_IMPr_CLR
#define BC_SUP_PKTDROP_CNT_IMPr_SET BCM53101_A0_BC_SUP_PKTDROP_CNT_IMPr_SET
#define BC_SUP_PKTDROP_CNT_IMPr_GET BCM53101_A0_BC_SUP_PKTDROP_CNT_IMPr_GET
#define BC_SUP_PKTDROP_CNT_IMPr_PK_DROP_CNTf_GET BCM53101_A0_BC_SUP_PKTDROP_CNT_IMPr_PK_DROP_CNTf_GET
#define BC_SUP_PKTDROP_CNT_IMPr_PK_DROP_CNTf_SET BCM53101_A0_BC_SUP_PKTDROP_CNT_IMPr_PK_DROP_CNTf_SET
#define READ_BC_SUP_PKTDROP_CNT_IMPr BCM53101_A0_READ_BC_SUP_PKTDROP_CNT_IMPr
#define WRITE_BC_SUP_PKTDROP_CNT_IMPr BCM53101_A0_WRITE_BC_SUP_PKTDROP_CNT_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_BC_SUP_PKTDROP_CNT_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  BC_SUP_PKTDROP_CNT_P
 * BLOCKS:   EPIC0
 * DESC:     Port N Suppressed Packet Drop Counter Register
 * SIZE:     32
 * FIELDS:
 *     PK_DROP_CNT      Packet Dropped Count.Record the Dropped packet count for Suppression Drop Count or Jumbo Filtered Count.Reset after the Register has been read.
 *
 ******************************************************************************/
#define BCM53101_A0_BC_SUP_PKTDROP_CNT_Pr 0x00004150

#define BCM53101_A0_BC_SUP_PKTDROP_CNT_Pr_SIZE 4

/*
 * This structure should be used to declare and program BC_SUP_PKTDROP_CNT_P.
 *
 */
typedef union BCM53101_A0_BC_SUP_PKTDROP_CNT_Pr_s {
	uint32_t v[1];
	uint32_t bc_sup_pktdrop_cnt_p[1];
	uint32_t _bc_sup_pktdrop_cnt_p;
} BCM53101_A0_BC_SUP_PKTDROP_CNT_Pr_t;

#define BCM53101_A0_BC_SUP_PKTDROP_CNT_Pr_CLR(r) (r).bc_sup_pktdrop_cnt_p[0] = 0
#define BCM53101_A0_BC_SUP_PKTDROP_CNT_Pr_SET(r,d) (r).bc_sup_pktdrop_cnt_p[0] = d
#define BCM53101_A0_BC_SUP_PKTDROP_CNT_Pr_GET(r) (r).bc_sup_pktdrop_cnt_p[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_BC_SUP_PKTDROP_CNT_Pr_PK_DROP_CNTf_GET(r) ((r).bc_sup_pktdrop_cnt_p[0])
#define BCM53101_A0_BC_SUP_PKTDROP_CNT_Pr_PK_DROP_CNTf_SET(r,f) (r).bc_sup_pktdrop_cnt_p[0]=((uint32_t)f)

/*
 * These macros can be used to access BC_SUP_PKTDROP_CNT_P.
 *
 */
#define BCM53101_A0_READ_BC_SUP_PKTDROP_CNT_Pr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_BC_SUP_PKTDROP_CNT_Pr,(r._bc_sup_pktdrop_cnt_p),4)
#define BCM53101_A0_WRITE_BC_SUP_PKTDROP_CNT_Pr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_BC_SUP_PKTDROP_CNT_Pr,&(r._bc_sup_pktdrop_cnt_p),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BC_SUP_PKTDROP_CNT_Pr BCM53101_A0_BC_SUP_PKTDROP_CNT_Pr
#define BC_SUP_PKTDROP_CNT_Pr_SIZE BCM53101_A0_BC_SUP_PKTDROP_CNT_Pr_SIZE
typedef BCM53101_A0_BC_SUP_PKTDROP_CNT_Pr_t BC_SUP_PKTDROP_CNT_Pr_t;
#define BC_SUP_PKTDROP_CNT_Pr_CLR BCM53101_A0_BC_SUP_PKTDROP_CNT_Pr_CLR
#define BC_SUP_PKTDROP_CNT_Pr_SET BCM53101_A0_BC_SUP_PKTDROP_CNT_Pr_SET
#define BC_SUP_PKTDROP_CNT_Pr_GET BCM53101_A0_BC_SUP_PKTDROP_CNT_Pr_GET
#define BC_SUP_PKTDROP_CNT_Pr_PK_DROP_CNTf_GET BCM53101_A0_BC_SUP_PKTDROP_CNT_Pr_PK_DROP_CNTf_GET
#define BC_SUP_PKTDROP_CNT_Pr_PK_DROP_CNTf_SET BCM53101_A0_BC_SUP_PKTDROP_CNT_Pr_PK_DROP_CNTf_SET
#define READ_BC_SUP_PKTDROP_CNT_Pr BCM53101_A0_READ_BC_SUP_PKTDROP_CNT_Pr
#define WRITE_BC_SUP_PKTDROP_CNT_Pr BCM53101_A0_WRITE_BC_SUP_PKTDROP_CNT_Pr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_BC_SUP_PKTDROP_CNT_Pr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  BC_SUP_RATECTRL_IMP
 * BLOCKS:   CPIC
 * DESC:     Port 8 Recive Rate Control Registers
 * SIZE:     32
 * FIELDS:
 *     BUCKET0_REF_CNT  Refresh Count Define allowing Incoming Packet Bit Rate.For those Packets Defined in Suppressed Packet Type Mask in Suppression Control Register When Bit Rate Mode Selection is 0(Absolute Bit Rate Mode)1~28 :Bit Rate = Refresh Count*8*1024/125, that'sBit Rate is 64Kb ~1.792Mb with Resolution 64Kb29~127:Bit Rate = (Refresh Count-27)*1024, that'sBit Rate is 2Mb~100Mb with Resolution 1Mb128~240:Bit Rate = (Refresh Count - 115)*1024*8, that'sBit Rate is 104Mb~1000Mb with Resolution 8MbWhen Bit Rate Mode Selection is 1(Bit Rate Related to Link Speed Mode)1~125: when 10M speedBit Rate = Refresh Count * 8 * 1024 /100, that'sBit Rate is 0.08Mb~10Mb with Resolution 0.08Mb 1~125: when 100M speedBit Rate = Refresh Count * 8 * 1024/10, that'sBit Rate is 0.8Mb~100Mb with Resolution 0.8Mb 1~125: when 1000M SpeedBit Rate = Refresh Count * 8 * 1024, that'sBit Rate is 8Mb~1000Mb with Resoultion 8Mbdefault by {3'b0,bc_sup,4'b0}.
 *     BUCKET0_SIZE     Bucket Size.Bucket Size will affect the burst traffic.3'b000: 16K Byte(valid 4K bytes),3'b001:20K Byte (valid 8K bytes),3'b010:28K Byte (Valid 16K bytes),3'b011:40K Byte (Valid 28K bytes),3'b100:76K Byte (Valid 64K bytes),others:512K Byte(Valid 500K bytes).
 *     BUCKET1_REF_CNT  Refresh Count.Refresh Count Define allowing Incoming Packet Bit Rate For those Packets Defined in Suppressed Packet Type Mask in Suppression Control RegisterWhen Bit Rate Mode Selection is 0(Absolute Bit Rate Mode)1~28 :Bit Rate = Refresh Count*8*1024/125, that'sBit Rate is 64Kb ~1.792Mb with Resolution 64Kb 29~127:Bit Rate = (Refresh Count-27)*1024, that'sBit Rate is 2Mb~100Mb with Resolution 1Mb 128~240:Bit Rate = (Refresh Count - 115)*1024*8, that'sBit Rate is 104Mb~1000Mb with Resolution 8MbWhen Bit Rate Mode Selection is 1(Bit Rate Related to Link Speed Mode)1~125: when 10M speedBit Rate = Refresh Count * 8 * 1024 /100, that'sBit Rate is 0.08Mb~10Mb with Resolution 0.08Mb 1~125: when 100M speedBit Rate = Refresh Count * 8 * 1024/10, that'sBit Rate is 0.8Mb~100Mb with Resolution 0.8Mb 1~125: when 1000M SpeedBit Rate = Refresh Count * 8 * 1024, that'sBit Rate is 8Mb~1000Mb with Resoultion 8Mb
 *     BUCKET1_SIZE     Bucket Size.Bucket Size will affect the burst traffic.3'b000: 16K Byte(Valid 4K bytes),3'b001:20K Byte(Valid 8K bytes),3'b010:28K Byte(Valid 16K bytes),3'b011:40K Byte(Valid 28K bytes),3'b100:76K Byte(Valid 64K bytes),others:512K Byte(Valid 500K bytes).
 *     EN_BUCKET0       Enable Rate Control of the Ingress Port, Bucket 0.Default by Strap pin bc_supp_en
 *     EN_BUCKET1       Enable Rate Control of the Ingress Port, Bucket 11:Enable,0:Disable.
 *     EN_DLF_SUP       Enable DLF Strom Suppression.1:Enable,0:Disable.
 *     EN_MCAST_SUP     Enable Multicast Strom Suppression.1:Enable,0:Disable.
 *     EN_BCAST_SUP     Enable Broadcast Strom Suppression.1:Enable,0:Disable.
 *     EN_RSV_MLTCST_SUP Enable Reserved Multicast Strom Suppression(RsvMcast:01-80-C2-00-00-00 ~ 01-80-C2-00-00-2F).1:Enable,0:Disable.
 *     EN_STORM_SUP     Enable Strom Suppression(supported by bucket 1).1:Enable,0:Disable.
 *     EN_VLAN_POLICING Enable VLAN-based policing 1: Enable0: DisableWhen enabled, the ingress logic will use the final VID to look up the VLAN table, where two bits in the VLAN table will decide if that specific VLAN entry is target for VLAN policing, and the bucket ID of the policing. Each of the bucket0/1 can police one or more VLAN + storm suppression traffic specified in ingress Rate Control Configuration register(Page: 41h, Address 00d-03d,00h-03h), bit 5:0 for bucket0 and bit 15:9 for bucket 1.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_BC_SUP_RATECTRL_IMPr 0x00004130

#define BCM53101_A0_BC_SUP_RATECTRL_IMPr_SIZE 4

/*
 * This structure should be used to declare and program BC_SUP_RATECTRL_IMP.
 *
 */
typedef union BCM53101_A0_BC_SUP_RATECTRL_IMPr_s {
	uint32_t v[1];
	uint32_t bc_sup_ratectrl_imp[1];
	uint32_t _bc_sup_ratectrl_imp;
} BCM53101_A0_BC_SUP_RATECTRL_IMPr_t;

#define BCM53101_A0_BC_SUP_RATECTRL_IMPr_CLR(r) (r).bc_sup_ratectrl_imp[0] = 0
#define BCM53101_A0_BC_SUP_RATECTRL_IMPr_SET(r,d) (r).bc_sup_ratectrl_imp[0] = d
#define BCM53101_A0_BC_SUP_RATECTRL_IMPr_GET(r) (r).bc_sup_ratectrl_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_BC_SUP_RATECTRL_IMPr_BUCKET0_REF_CNTf_GET(r) (((r).bc_sup_ratectrl_imp[0]) & 0xff)
#define BCM53101_A0_BC_SUP_RATECTRL_IMPr_BUCKET0_REF_CNTf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53101_A0_BC_SUP_RATECTRL_IMPr_BUCKET0_SIZEf_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 8) & 0x7)
#define BCM53101_A0_BC_SUP_RATECTRL_IMPr_BUCKET0_SIZEf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCM53101_A0_BC_SUP_RATECTRL_IMPr_BUCKET1_REF_CNTf_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 11) & 0xff)
#define BCM53101_A0_BC_SUP_RATECTRL_IMPr_BUCKET1_REF_CNTf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0xff << 11)) | ((((uint32_t)f) & 0xff) << 11))
#define BCM53101_A0_BC_SUP_RATECTRL_IMPr_BUCKET1_SIZEf_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 19) & 0x7)
#define BCM53101_A0_BC_SUP_RATECTRL_IMPr_BUCKET1_SIZEf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x7 << 19)) | ((((uint32_t)f) & 0x7) << 19))
#define BCM53101_A0_BC_SUP_RATECTRL_IMPr_EN_BUCKET0f_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 22) & 0x1)
#define BCM53101_A0_BC_SUP_RATECTRL_IMPr_EN_BUCKET0f_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM53101_A0_BC_SUP_RATECTRL_IMPr_EN_BUCKET1f_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 23) & 0x1)
#define BCM53101_A0_BC_SUP_RATECTRL_IMPr_EN_BUCKET1f_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM53101_A0_BC_SUP_RATECTRL_IMPr_EN_DLF_SUPf_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 24) & 0x1)
#define BCM53101_A0_BC_SUP_RATECTRL_IMPr_EN_DLF_SUPf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53101_A0_BC_SUP_RATECTRL_IMPr_EN_MCAST_SUPf_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 25) & 0x1)
#define BCM53101_A0_BC_SUP_RATECTRL_IMPr_EN_MCAST_SUPf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM53101_A0_BC_SUP_RATECTRL_IMPr_EN_BCAST_SUPf_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 26) & 0x1)
#define BCM53101_A0_BC_SUP_RATECTRL_IMPr_EN_BCAST_SUPf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM53101_A0_BC_SUP_RATECTRL_IMPr_EN_RSV_MLTCST_SUPf_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 27) & 0x1)
#define BCM53101_A0_BC_SUP_RATECTRL_IMPr_EN_RSV_MLTCST_SUPf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53101_A0_BC_SUP_RATECTRL_IMPr_EN_STORM_SUPf_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 28) & 0x1)
#define BCM53101_A0_BC_SUP_RATECTRL_IMPr_EN_STORM_SUPf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM53101_A0_BC_SUP_RATECTRL_IMPr_EN_VLAN_POLICINGf_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 29) & 0x1)
#define BCM53101_A0_BC_SUP_RATECTRL_IMPr_EN_VLAN_POLICINGf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM53101_A0_BC_SUP_RATECTRL_IMPr_RESERVEDf_GET(r) ((((r).bc_sup_ratectrl_imp[0]) >> 30) & 0x3)
#define BCM53101_A0_BC_SUP_RATECTRL_IMPr_RESERVEDf_SET(r,f) (r).bc_sup_ratectrl_imp[0]=(((r).bc_sup_ratectrl_imp[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access BC_SUP_RATECTRL_IMP.
 *
 */
#define BCM53101_A0_READ_BC_SUP_RATECTRL_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_BC_SUP_RATECTRL_IMPr,(r._bc_sup_ratectrl_imp),4)
#define BCM53101_A0_WRITE_BC_SUP_RATECTRL_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_BC_SUP_RATECTRL_IMPr,&(r._bc_sup_ratectrl_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BC_SUP_RATECTRL_IMPr BCM53101_A0_BC_SUP_RATECTRL_IMPr
#define BC_SUP_RATECTRL_IMPr_SIZE BCM53101_A0_BC_SUP_RATECTRL_IMPr_SIZE
typedef BCM53101_A0_BC_SUP_RATECTRL_IMPr_t BC_SUP_RATECTRL_IMPr_t;
#define BC_SUP_RATECTRL_IMPr_CLR BCM53101_A0_BC_SUP_RATECTRL_IMPr_CLR
#define BC_SUP_RATECTRL_IMPr_SET BCM53101_A0_BC_SUP_RATECTRL_IMPr_SET
#define BC_SUP_RATECTRL_IMPr_GET BCM53101_A0_BC_SUP_RATECTRL_IMPr_GET
#define BC_SUP_RATECTRL_IMPr_BUCKET0_REF_CNTf_GET BCM53101_A0_BC_SUP_RATECTRL_IMPr_BUCKET0_REF_CNTf_GET
#define BC_SUP_RATECTRL_IMPr_BUCKET0_REF_CNTf_SET BCM53101_A0_BC_SUP_RATECTRL_IMPr_BUCKET0_REF_CNTf_SET
#define BC_SUP_RATECTRL_IMPr_BUCKET0_SIZEf_GET BCM53101_A0_BC_SUP_RATECTRL_IMPr_BUCKET0_SIZEf_GET
#define BC_SUP_RATECTRL_IMPr_BUCKET0_SIZEf_SET BCM53101_A0_BC_SUP_RATECTRL_IMPr_BUCKET0_SIZEf_SET
#define BC_SUP_RATECTRL_IMPr_BUCKET1_REF_CNTf_GET BCM53101_A0_BC_SUP_RATECTRL_IMPr_BUCKET1_REF_CNTf_GET
#define BC_SUP_RATECTRL_IMPr_BUCKET1_REF_CNTf_SET BCM53101_A0_BC_SUP_RATECTRL_IMPr_BUCKET1_REF_CNTf_SET
#define BC_SUP_RATECTRL_IMPr_BUCKET1_SIZEf_GET BCM53101_A0_BC_SUP_RATECTRL_IMPr_BUCKET1_SIZEf_GET
#define BC_SUP_RATECTRL_IMPr_BUCKET1_SIZEf_SET BCM53101_A0_BC_SUP_RATECTRL_IMPr_BUCKET1_SIZEf_SET
#define BC_SUP_RATECTRL_IMPr_EN_BUCKET0f_GET BCM53101_A0_BC_SUP_RATECTRL_IMPr_EN_BUCKET0f_GET
#define BC_SUP_RATECTRL_IMPr_EN_BUCKET0f_SET BCM53101_A0_BC_SUP_RATECTRL_IMPr_EN_BUCKET0f_SET
#define BC_SUP_RATECTRL_IMPr_EN_BUCKET1f_GET BCM53101_A0_BC_SUP_RATECTRL_IMPr_EN_BUCKET1f_GET
#define BC_SUP_RATECTRL_IMPr_EN_BUCKET1f_SET BCM53101_A0_BC_SUP_RATECTRL_IMPr_EN_BUCKET1f_SET
#define BC_SUP_RATECTRL_IMPr_EN_DLF_SUPf_GET BCM53101_A0_BC_SUP_RATECTRL_IMPr_EN_DLF_SUPf_GET
#define BC_SUP_RATECTRL_IMPr_EN_DLF_SUPf_SET BCM53101_A0_BC_SUP_RATECTRL_IMPr_EN_DLF_SUPf_SET
#define BC_SUP_RATECTRL_IMPr_EN_MCAST_SUPf_GET BCM53101_A0_BC_SUP_RATECTRL_IMPr_EN_MCAST_SUPf_GET
#define BC_SUP_RATECTRL_IMPr_EN_MCAST_SUPf_SET BCM53101_A0_BC_SUP_RATECTRL_IMPr_EN_MCAST_SUPf_SET
#define BC_SUP_RATECTRL_IMPr_EN_BCAST_SUPf_GET BCM53101_A0_BC_SUP_RATECTRL_IMPr_EN_BCAST_SUPf_GET
#define BC_SUP_RATECTRL_IMPr_EN_BCAST_SUPf_SET BCM53101_A0_BC_SUP_RATECTRL_IMPr_EN_BCAST_SUPf_SET
#define BC_SUP_RATECTRL_IMPr_EN_RSV_MLTCST_SUPf_GET BCM53101_A0_BC_SUP_RATECTRL_IMPr_EN_RSV_MLTCST_SUPf_GET
#define BC_SUP_RATECTRL_IMPr_EN_RSV_MLTCST_SUPf_SET BCM53101_A0_BC_SUP_RATECTRL_IMPr_EN_RSV_MLTCST_SUPf_SET
#define BC_SUP_RATECTRL_IMPr_EN_STORM_SUPf_GET BCM53101_A0_BC_SUP_RATECTRL_IMPr_EN_STORM_SUPf_GET
#define BC_SUP_RATECTRL_IMPr_EN_STORM_SUPf_SET BCM53101_A0_BC_SUP_RATECTRL_IMPr_EN_STORM_SUPf_SET
#define BC_SUP_RATECTRL_IMPr_EN_VLAN_POLICINGf_GET BCM53101_A0_BC_SUP_RATECTRL_IMPr_EN_VLAN_POLICINGf_GET
#define BC_SUP_RATECTRL_IMPr_EN_VLAN_POLICINGf_SET BCM53101_A0_BC_SUP_RATECTRL_IMPr_EN_VLAN_POLICINGf_SET
#define BC_SUP_RATECTRL_IMPr_RESERVEDf_GET BCM53101_A0_BC_SUP_RATECTRL_IMPr_RESERVEDf_GET
#define BC_SUP_RATECTRL_IMPr_RESERVEDf_SET BCM53101_A0_BC_SUP_RATECTRL_IMPr_RESERVEDf_SET
#define READ_BC_SUP_RATECTRL_IMPr BCM53101_A0_READ_BC_SUP_RATECTRL_IMPr
#define WRITE_BC_SUP_RATECTRL_IMPr BCM53101_A0_WRITE_BC_SUP_RATECTRL_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_BC_SUP_RATECTRL_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  BC_SUP_RATECTRL_P
 * BLOCKS:   CPIC EPIC0
 * DESC:     Port N Recive Rate Control Registers
 * SIZE:     32
 * FIELDS:
 *     BUCKET0_REF_CNT  Refresh Count Define allowing Incoming Packet Bit Rate.For those Packets Defined in Suppressed Packet Type Mask in Suppression Control Register When Bit Rate Mode Selection is 0(Absolute Bit Rate Mode)1~28 :Bit Rate = Refresh Count*8*1024/125, that'sBit Rate is 64Kb ~1.792Mb with Resolution 64Kb29~127:Bit Rate = (Refresh Count-27)*1024, that'sBit Rate is 2Mb~100Mb with Resolution 1Mb128~240:Bit Rate = (Refresh Count - 115)*1024*8, that'sBit Rate is 104Mb~1000Mb with Resolution 8MbWhen Bit Rate Mode Selection is 1(Bit Rate Related to Link Speed Mode)1~125: when 10M speedBit Rate = Refresh Count * 8 * 1024 /100, that'sBit Rate is 0.08Mb~10Mb with Resolution 0.08Mb 1~125: when 100M speedBit Rate = Refresh Count * 8 * 1024/10, that'sBit Rate is 0.8Mb~100Mb with Resolution 0.8Mb 1~125: when 1000M SpeedBit Rate = Refresh Count * 8 * 1024, that'sBit Rate is 8Mb~1000Mb with Resoultion 8Mbdefault by {3'b0,bc_sup,4'b0}.
 *     BUCKET0_SIZE     Bucket Size.Bucket Size will affect the burst traffic.3'b000: 16K Byte(valid 4K bytes),3'b001:20K Byte (valid 8K bytes),3'b010:28K Byte (Valid 16K bytes),3'b011:40K Byte (Valid 28K bytes),3'b100:76K Byte (Valid 64K bytes),others:512K Byte(Valid 500K bytes).
 *     BUCKET1_REF_CNT  Refresh Count.Refresh Count Define allowing Incoming Packet Bit Rate For those Packets Defined in Suppressed Packet Type Mask in Suppression Control RegisterWhen Bit Rate Mode Selection is 0(Absolute Bit Rate Mode)1~28 :Bit Rate = Refresh Count*8*1024/125, that'sBit Rate is 64Kb ~1.792Mb with Resolution 64Kb 29~127:Bit Rate = (Refresh Count-27)*1024, that'sBit Rate is 2Mb~100Mb with Resolution 1Mb 128~240:Bit Rate = (Refresh Count - 115)*1024*8, that'sBit Rate is 104Mb~1000Mb with Resolution 8MbWhen Bit Rate Mode Selection is 1(Bit Rate Related to Link Speed Mode)1~125: when 10M speedBit Rate = Refresh Count * 8 * 1024 /100, that'sBit Rate is 0.08Mb~10Mb with Resolution 0.08Mb 1~125: when 100M speedBit Rate = Refresh Count * 8 * 1024/10, that'sBit Rate is 0.8Mb~100Mb with Resolution 0.8Mb 1~125: when 1000M SpeedBit Rate = Refresh Count * 8 * 1024, that'sBit Rate is 8Mb~1000Mb with Resoultion 8Mb
 *     BUCKET1_SIZE     Bucket Size.Bucket Size will affect the burst traffic.3'b000: 16K Byte(Valid 4K bytes),3'b001:20K Byte(Valid 8K bytes),3'b010:28K Byte(Valid 16K bytes),3'b011:40K Byte(Valid 28K bytes),3'b100:76K Byte(Valid 64K bytes),others:512K Byte(Valid 500K bytes).
 *     EN_BUCKET0       Enable Rate Control of the Ingress Port, Bucket 0.Default by Strap pin bc_supp_en
 *     EN_BUCKET1       Enable Rate Control of the Ingress Port, Bucket 11:Enable,0:Disable.
 *     EN_DLF_SUP       Enable DLF Strom Suppression.1:Enable,0:Disable.
 *     EN_MCAST_SUP     Enable Multicast Strom Suppression.1:Enable,0:Disable.
 *     EN_BCAST_SUP     Enable Broadcast Strom Suppression.1:Enable,0:Disable.
 *     EN_RSV_MLTCST_SUP Enable Reserved Multicast Strom Suppression(RsvMcast:01-80-C2-00-00-00 ~ 01-80-C2-00-00-2F).1:Enable,0:Disable.
 *     EN_STORM_SUP     Enable Strom Suppression(supported by bucket 1).1:Enable,0:Disable.
 *     EN_VLAN_POLICING Enable VLAN-based policing 1: Enable0: DisableWhen enabled, the ingress logic will use the final VID to look up the VLAN table, where two bits in the VLAN table will decide if that specific VLAN entry is target for VLAN policing, and the bucket ID of the policing. Each of the bucket0/1 can police one or more VLAN + storm suppression traffic specified in ingress Rate Control Configuration register(Page: 41h, Address 00d-03d,00h-03h), bit 5:0 for bucket0 and bit 15:9 for bucket 1.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_BC_SUP_RATECTRL_Pr 0x00004110

#define BCM53101_A0_BC_SUP_RATECTRL_Pr_SIZE 4

/*
 * This structure should be used to declare and program BC_SUP_RATECTRL_P.
 *
 */
typedef union BCM53101_A0_BC_SUP_RATECTRL_Pr_s {
	uint32_t v[1];
	uint32_t bc_sup_ratectrl_p[1];
	uint32_t _bc_sup_ratectrl_p;
} BCM53101_A0_BC_SUP_RATECTRL_Pr_t;

#define BCM53101_A0_BC_SUP_RATECTRL_Pr_CLR(r) (r).bc_sup_ratectrl_p[0] = 0
#define BCM53101_A0_BC_SUP_RATECTRL_Pr_SET(r,d) (r).bc_sup_ratectrl_p[0] = d
#define BCM53101_A0_BC_SUP_RATECTRL_Pr_GET(r) (r).bc_sup_ratectrl_p[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_BC_SUP_RATECTRL_Pr_BUCKET0_REF_CNTf_GET(r) (((r).bc_sup_ratectrl_p[0]) & 0xff)
#define BCM53101_A0_BC_SUP_RATECTRL_Pr_BUCKET0_REF_CNTf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53101_A0_BC_SUP_RATECTRL_Pr_BUCKET0_SIZEf_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 8) & 0x7)
#define BCM53101_A0_BC_SUP_RATECTRL_Pr_BUCKET0_SIZEf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCM53101_A0_BC_SUP_RATECTRL_Pr_BUCKET1_REF_CNTf_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 11) & 0xff)
#define BCM53101_A0_BC_SUP_RATECTRL_Pr_BUCKET1_REF_CNTf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0xff << 11)) | ((((uint32_t)f) & 0xff) << 11))
#define BCM53101_A0_BC_SUP_RATECTRL_Pr_BUCKET1_SIZEf_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 19) & 0x7)
#define BCM53101_A0_BC_SUP_RATECTRL_Pr_BUCKET1_SIZEf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x7 << 19)) | ((((uint32_t)f) & 0x7) << 19))
#define BCM53101_A0_BC_SUP_RATECTRL_Pr_EN_BUCKET0f_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 22) & 0x1)
#define BCM53101_A0_BC_SUP_RATECTRL_Pr_EN_BUCKET0f_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM53101_A0_BC_SUP_RATECTRL_Pr_EN_BUCKET1f_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 23) & 0x1)
#define BCM53101_A0_BC_SUP_RATECTRL_Pr_EN_BUCKET1f_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM53101_A0_BC_SUP_RATECTRL_Pr_EN_DLF_SUPf_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 24) & 0x1)
#define BCM53101_A0_BC_SUP_RATECTRL_Pr_EN_DLF_SUPf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53101_A0_BC_SUP_RATECTRL_Pr_EN_MCAST_SUPf_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 25) & 0x1)
#define BCM53101_A0_BC_SUP_RATECTRL_Pr_EN_MCAST_SUPf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x1 << 25)) | ((((uint32_t)f) & 0x1) << 25))
#define BCM53101_A0_BC_SUP_RATECTRL_Pr_EN_BCAST_SUPf_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 26) & 0x1)
#define BCM53101_A0_BC_SUP_RATECTRL_Pr_EN_BCAST_SUPf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM53101_A0_BC_SUP_RATECTRL_Pr_EN_RSV_MLTCST_SUPf_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 27) & 0x1)
#define BCM53101_A0_BC_SUP_RATECTRL_Pr_EN_RSV_MLTCST_SUPf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53101_A0_BC_SUP_RATECTRL_Pr_EN_STORM_SUPf_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 28) & 0x1)
#define BCM53101_A0_BC_SUP_RATECTRL_Pr_EN_STORM_SUPf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM53101_A0_BC_SUP_RATECTRL_Pr_EN_VLAN_POLICINGf_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 29) & 0x1)
#define BCM53101_A0_BC_SUP_RATECTRL_Pr_EN_VLAN_POLICINGf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x1 << 29)) | ((((uint32_t)f) & 0x1) << 29))
#define BCM53101_A0_BC_SUP_RATECTRL_Pr_RESERVEDf_GET(r) ((((r).bc_sup_ratectrl_p[0]) >> 30) & 0x3)
#define BCM53101_A0_BC_SUP_RATECTRL_Pr_RESERVEDf_SET(r,f) (r).bc_sup_ratectrl_p[0]=(((r).bc_sup_ratectrl_p[0] & ~((uint32_t)0x3 << 30)) | ((((uint32_t)f) & 0x3) << 30))

/*
 * These macros can be used to access BC_SUP_RATECTRL_P.
 *
 */
#define BCM53101_A0_READ_BC_SUP_RATECTRL_Pr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_BC_SUP_RATECTRL_Pr,(r._bc_sup_ratectrl_p),4)
#define BCM53101_A0_WRITE_BC_SUP_RATECTRL_Pr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_BC_SUP_RATECTRL_Pr,&(r._bc_sup_ratectrl_p),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BC_SUP_RATECTRL_Pr BCM53101_A0_BC_SUP_RATECTRL_Pr
#define BC_SUP_RATECTRL_Pr_SIZE BCM53101_A0_BC_SUP_RATECTRL_Pr_SIZE
typedef BCM53101_A0_BC_SUP_RATECTRL_Pr_t BC_SUP_RATECTRL_Pr_t;
#define BC_SUP_RATECTRL_Pr_CLR BCM53101_A0_BC_SUP_RATECTRL_Pr_CLR
#define BC_SUP_RATECTRL_Pr_SET BCM53101_A0_BC_SUP_RATECTRL_Pr_SET
#define BC_SUP_RATECTRL_Pr_GET BCM53101_A0_BC_SUP_RATECTRL_Pr_GET
#define BC_SUP_RATECTRL_Pr_BUCKET0_REF_CNTf_GET BCM53101_A0_BC_SUP_RATECTRL_Pr_BUCKET0_REF_CNTf_GET
#define BC_SUP_RATECTRL_Pr_BUCKET0_REF_CNTf_SET BCM53101_A0_BC_SUP_RATECTRL_Pr_BUCKET0_REF_CNTf_SET
#define BC_SUP_RATECTRL_Pr_BUCKET0_SIZEf_GET BCM53101_A0_BC_SUP_RATECTRL_Pr_BUCKET0_SIZEf_GET
#define BC_SUP_RATECTRL_Pr_BUCKET0_SIZEf_SET BCM53101_A0_BC_SUP_RATECTRL_Pr_BUCKET0_SIZEf_SET
#define BC_SUP_RATECTRL_Pr_BUCKET1_REF_CNTf_GET BCM53101_A0_BC_SUP_RATECTRL_Pr_BUCKET1_REF_CNTf_GET
#define BC_SUP_RATECTRL_Pr_BUCKET1_REF_CNTf_SET BCM53101_A0_BC_SUP_RATECTRL_Pr_BUCKET1_REF_CNTf_SET
#define BC_SUP_RATECTRL_Pr_BUCKET1_SIZEf_GET BCM53101_A0_BC_SUP_RATECTRL_Pr_BUCKET1_SIZEf_GET
#define BC_SUP_RATECTRL_Pr_BUCKET1_SIZEf_SET BCM53101_A0_BC_SUP_RATECTRL_Pr_BUCKET1_SIZEf_SET
#define BC_SUP_RATECTRL_Pr_EN_BUCKET0f_GET BCM53101_A0_BC_SUP_RATECTRL_Pr_EN_BUCKET0f_GET
#define BC_SUP_RATECTRL_Pr_EN_BUCKET0f_SET BCM53101_A0_BC_SUP_RATECTRL_Pr_EN_BUCKET0f_SET
#define BC_SUP_RATECTRL_Pr_EN_BUCKET1f_GET BCM53101_A0_BC_SUP_RATECTRL_Pr_EN_BUCKET1f_GET
#define BC_SUP_RATECTRL_Pr_EN_BUCKET1f_SET BCM53101_A0_BC_SUP_RATECTRL_Pr_EN_BUCKET1f_SET
#define BC_SUP_RATECTRL_Pr_EN_DLF_SUPf_GET BCM53101_A0_BC_SUP_RATECTRL_Pr_EN_DLF_SUPf_GET
#define BC_SUP_RATECTRL_Pr_EN_DLF_SUPf_SET BCM53101_A0_BC_SUP_RATECTRL_Pr_EN_DLF_SUPf_SET
#define BC_SUP_RATECTRL_Pr_EN_MCAST_SUPf_GET BCM53101_A0_BC_SUP_RATECTRL_Pr_EN_MCAST_SUPf_GET
#define BC_SUP_RATECTRL_Pr_EN_MCAST_SUPf_SET BCM53101_A0_BC_SUP_RATECTRL_Pr_EN_MCAST_SUPf_SET
#define BC_SUP_RATECTRL_Pr_EN_BCAST_SUPf_GET BCM53101_A0_BC_SUP_RATECTRL_Pr_EN_BCAST_SUPf_GET
#define BC_SUP_RATECTRL_Pr_EN_BCAST_SUPf_SET BCM53101_A0_BC_SUP_RATECTRL_Pr_EN_BCAST_SUPf_SET
#define BC_SUP_RATECTRL_Pr_EN_RSV_MLTCST_SUPf_GET BCM53101_A0_BC_SUP_RATECTRL_Pr_EN_RSV_MLTCST_SUPf_GET
#define BC_SUP_RATECTRL_Pr_EN_RSV_MLTCST_SUPf_SET BCM53101_A0_BC_SUP_RATECTRL_Pr_EN_RSV_MLTCST_SUPf_SET
#define BC_SUP_RATECTRL_Pr_EN_STORM_SUPf_GET BCM53101_A0_BC_SUP_RATECTRL_Pr_EN_STORM_SUPf_GET
#define BC_SUP_RATECTRL_Pr_EN_STORM_SUPf_SET BCM53101_A0_BC_SUP_RATECTRL_Pr_EN_STORM_SUPf_SET
#define BC_SUP_RATECTRL_Pr_EN_VLAN_POLICINGf_GET BCM53101_A0_BC_SUP_RATECTRL_Pr_EN_VLAN_POLICINGf_GET
#define BC_SUP_RATECTRL_Pr_EN_VLAN_POLICINGf_SET BCM53101_A0_BC_SUP_RATECTRL_Pr_EN_VLAN_POLICINGf_SET
#define BC_SUP_RATECTRL_Pr_RESERVEDf_GET BCM53101_A0_BC_SUP_RATECTRL_Pr_RESERVEDf_GET
#define BC_SUP_RATECTRL_Pr_RESERVEDf_SET BCM53101_A0_BC_SUP_RATECTRL_Pr_RESERVEDf_SET
#define READ_BC_SUP_RATECTRL_Pr BCM53101_A0_READ_BC_SUP_RATECTRL_Pr
#define WRITE_BC_SUP_RATECTRL_Pr BCM53101_A0_WRITE_BC_SUP_RATECTRL_Pr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_BC_SUP_RATECTRL_Pr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  BIST_STS0
 * BLOCKS:   SYS
 * DESC:     BIST Status Register 0
 * SIZE:     48
 * FIELDS:
 *     LV_MBIST_STATUS  LV MBIST StatusOnce LV MBIST is enabled, this field is 2'h3, when the MBIST is done(around 4ms), this field contains the status of MBIST, when it is 2'h0, it means the MBIST is all pass.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_BIST_STS0r 0x00000146

#define BCM53101_A0_BIST_STS0r_SIZE 6

/*
 * This structure should be used to declare and program BIST_STS0.
 *
 */
typedef union BCM53101_A0_BIST_STS0r_s {
	uint32_t v[2];
	uint32_t bist_sts0[2];
	uint32_t _bist_sts0;
} BCM53101_A0_BIST_STS0r_t;

#define BCM53101_A0_BIST_STS0r_CLR(r) CDK_MEMSET(&((r)._bist_sts0), 0, sizeof(BCM53101_A0_BIST_STS0r_t))
#define BCM53101_A0_BIST_STS0r_SET(r,i,d) (r).bist_sts0[i] = d
#define BCM53101_A0_BIST_STS0r_GET(r,i) (r).bist_sts0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_BIST_STS0r_LV_MBIST_STATUSf_GET(r) (((r).bist_sts0[0]) & 0x3)
#define BCM53101_A0_BIST_STS0r_LV_MBIST_STATUSf_SET(r,f) (r).bist_sts0[0]=(((r).bist_sts0[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53101_A0_BIST_STS0r_RESERVEDf_GET(r,a) cdk_field_get((r).bist_sts0,2,47,a)
#define BCM53101_A0_BIST_STS0r_RESERVEDf_SET(r,a) cdk_field_set((r).bist_sts0,2,47,a)

/*
 * These macros can be used to access BIST_STS0.
 *
 */
#define BCM53101_A0_READ_BIST_STS0r(u,r) cdk_robo_reg_read(u,BCM53101_A0_BIST_STS0r,(r._bist_sts0),6)
#define BCM53101_A0_WRITE_BIST_STS0r(u,r) cdk_robo_reg_write(u,BCM53101_A0_BIST_STS0r,&(r._bist_sts0),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BIST_STS0r BCM53101_A0_BIST_STS0r
#define BIST_STS0r_SIZE BCM53101_A0_BIST_STS0r_SIZE
typedef BCM53101_A0_BIST_STS0r_t BIST_STS0r_t;
#define BIST_STS0r_CLR BCM53101_A0_BIST_STS0r_CLR
#define BIST_STS0r_SET BCM53101_A0_BIST_STS0r_SET
#define BIST_STS0r_GET BCM53101_A0_BIST_STS0r_GET
#define BIST_STS0r_LV_MBIST_STATUSf_GET BCM53101_A0_BIST_STS0r_LV_MBIST_STATUSf_GET
#define BIST_STS0r_LV_MBIST_STATUSf_SET BCM53101_A0_BIST_STS0r_LV_MBIST_STATUSf_SET
#define BIST_STS0r_RESERVEDf_GET BCM53101_A0_BIST_STS0r_RESERVEDf_GET
#define BIST_STS0r_RESERVEDf_SET BCM53101_A0_BIST_STS0r_RESERVEDf_SET
#define READ_BIST_STS0r BCM53101_A0_READ_BIST_STS0r
#define WRITE_BIST_STS0r BCM53101_A0_WRITE_BIST_STS0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_BIST_STS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  BONDING_PAD_STATUS
 * BLOCKS:   SYS
 * DESC:     Bonding PAD status Registrer(Engineering Use Only)
 * SIZE:     8
 * FIELDS:
 *     BOND_53101_OPTION Bonding options00: 53101E : 1 MII/RvMII + 5 FEPHYs10: 53101P : 1 GMII/MII/RvMII + 5 FEPHYs11: 53101M : 1 RGMII/MII/RvMII/RMII + 1 MII/RvMII/RMII/TMII + 5 FEPHYs
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_BONDING_PAD_STATUSr 0x000000ee

#define BCM53101_A0_BONDING_PAD_STATUSr_SIZE 1

/*
 * This structure should be used to declare and program BONDING_PAD_STATUS.
 *
 */
typedef union BCM53101_A0_BONDING_PAD_STATUSr_s {
	uint32_t v[1];
	uint32_t bonding_pad_status[1];
	uint32_t _bonding_pad_status;
} BCM53101_A0_BONDING_PAD_STATUSr_t;

#define BCM53101_A0_BONDING_PAD_STATUSr_CLR(r) (r).bonding_pad_status[0] = 0
#define BCM53101_A0_BONDING_PAD_STATUSr_SET(r,d) (r).bonding_pad_status[0] = d
#define BCM53101_A0_BONDING_PAD_STATUSr_GET(r) (r).bonding_pad_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_BONDING_PAD_STATUSr_BOND_53101_OPTIONf_GET(r) (((r).bonding_pad_status[0]) & 0x3)
#define BCM53101_A0_BONDING_PAD_STATUSr_BOND_53101_OPTIONf_SET(r,f) (r).bonding_pad_status[0]=(((r).bonding_pad_status[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53101_A0_BONDING_PAD_STATUSr_RESERVEDf_GET(r) ((((r).bonding_pad_status[0]) >> 2) & 0x3f)
#define BCM53101_A0_BONDING_PAD_STATUSr_RESERVEDf_SET(r,f) (r).bonding_pad_status[0]=(((r).bonding_pad_status[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))

/*
 * These macros can be used to access BONDING_PAD_STATUS.
 *
 */
#define BCM53101_A0_READ_BONDING_PAD_STATUSr(u,r) cdk_robo_reg_read(u,BCM53101_A0_BONDING_PAD_STATUSr,(r._bonding_pad_status),1)
#define BCM53101_A0_WRITE_BONDING_PAD_STATUSr(u,r) cdk_robo_reg_write(u,BCM53101_A0_BONDING_PAD_STATUSr,&(r._bonding_pad_status),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BONDING_PAD_STATUSr BCM53101_A0_BONDING_PAD_STATUSr
#define BONDING_PAD_STATUSr_SIZE BCM53101_A0_BONDING_PAD_STATUSr_SIZE
typedef BCM53101_A0_BONDING_PAD_STATUSr_t BONDING_PAD_STATUSr_t;
#define BONDING_PAD_STATUSr_CLR BCM53101_A0_BONDING_PAD_STATUSr_CLR
#define BONDING_PAD_STATUSr_SET BCM53101_A0_BONDING_PAD_STATUSr_SET
#define BONDING_PAD_STATUSr_GET BCM53101_A0_BONDING_PAD_STATUSr_GET
#define BONDING_PAD_STATUSr_BOND_53101_OPTIONf_GET BCM53101_A0_BONDING_PAD_STATUSr_BOND_53101_OPTIONf_GET
#define BONDING_PAD_STATUSr_BOND_53101_OPTIONf_SET BCM53101_A0_BONDING_PAD_STATUSr_BOND_53101_OPTIONf_SET
#define BONDING_PAD_STATUSr_RESERVEDf_GET BCM53101_A0_BONDING_PAD_STATUSr_RESERVEDf_GET
#define BONDING_PAD_STATUSr_RESERVEDf_SET BCM53101_A0_BONDING_PAD_STATUSr_RESERVEDf_SET
#define READ_BONDING_PAD_STATUSr BCM53101_A0_READ_BONDING_PAD_STATUSr
#define WRITE_BONDING_PAD_STATUSr BCM53101_A0_WRITE_BONDING_PAD_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_BONDING_PAD_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  BPDU_MCADDR
 * BLOCKS:   SYS
 * DESC:     BPDU Multicast Address Register
 * SIZE:     48
 * FIELDS:
 *     BPDU_MC_ADDR     BPDU Multicast Address.(not release to customer).Defaults to the 802.1 defined reserved multicast address for the Bridge Group #Address. Programming to an alternate value allows support of proprietary #protocols in place of the normal Spanning Tree Protocol. Frames with a matching #DA to this address will be forwarded only to the designated management port #(IMP).
 *
 ******************************************************************************/
#define BCM53101_A0_BPDU_MCADDRr 0x00000404

#define BCM53101_A0_BPDU_MCADDRr_SIZE 6

/*
 * This structure should be used to declare and program BPDU_MCADDR.
 *
 */
typedef union BCM53101_A0_BPDU_MCADDRr_s {
	uint32_t v[2];
	uint32_t bpdu_mcaddr[2];
	uint32_t _bpdu_mcaddr;
} BCM53101_A0_BPDU_MCADDRr_t;

#define BCM53101_A0_BPDU_MCADDRr_CLR(r) CDK_MEMSET(&((r)._bpdu_mcaddr), 0, sizeof(BCM53101_A0_BPDU_MCADDRr_t))
#define BCM53101_A0_BPDU_MCADDRr_SET(r,i,d) (r).bpdu_mcaddr[i] = d
#define BCM53101_A0_BPDU_MCADDRr_GET(r,i) (r).bpdu_mcaddr[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_BPDU_MCADDRr_BPDU_MC_ADDRf_GET(r,a) cdk_field_get((r).bpdu_mcaddr,0,47,a)
#define BCM53101_A0_BPDU_MCADDRr_BPDU_MC_ADDRf_SET(r,a) cdk_field_set((r).bpdu_mcaddr,0,47,a)

/*
 * These macros can be used to access BPDU_MCADDR.
 *
 */
#define BCM53101_A0_READ_BPDU_MCADDRr(u,r) cdk_robo_reg_read(u,BCM53101_A0_BPDU_MCADDRr,(r._bpdu_mcaddr),6)
#define BCM53101_A0_WRITE_BPDU_MCADDRr(u,r) cdk_robo_reg_write(u,BCM53101_A0_BPDU_MCADDRr,&(r._bpdu_mcaddr),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BPDU_MCADDRr BCM53101_A0_BPDU_MCADDRr
#define BPDU_MCADDRr_SIZE BCM53101_A0_BPDU_MCADDRr_SIZE
typedef BCM53101_A0_BPDU_MCADDRr_t BPDU_MCADDRr_t;
#define BPDU_MCADDRr_CLR BCM53101_A0_BPDU_MCADDRr_CLR
#define BPDU_MCADDRr_SET BCM53101_A0_BPDU_MCADDRr_SET
#define BPDU_MCADDRr_GET BCM53101_A0_BPDU_MCADDRr_GET
#define BPDU_MCADDRr_BPDU_MC_ADDRf_GET BCM53101_A0_BPDU_MCADDRr_BPDU_MC_ADDRf_GET
#define BPDU_MCADDRr_BPDU_MC_ADDRf_SET BCM53101_A0_BPDU_MCADDRr_BPDU_MC_ADDRf_SET
#define READ_BPDU_MCADDRr BCM53101_A0_READ_BPDU_MCADDRr
#define WRITE_BPDU_MCADDRr BCM53101_A0_WRITE_BPDU_MCADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_BPDU_MCADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  BRCM_HDR_CTRL
 * BLOCKS:   SYS
 * DESC:     BRCM Header Control Register
 * SIZE:     8
 * FIELDS:
 *     BRCM_HDR_EN      Broadcom Header enable for IMP portbit 1: enable BRCM header for IMP1(only take effect when IMP1 is enable)bit 0: enable BRCM header for IMP01: Additional header information is inserted into the Original frame, between SA field and Type/Length field. The tag includes the BRCM header field.0: Without additional header information.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_BRCM_HDR_CTRLr 0x00000203

#define BCM53101_A0_BRCM_HDR_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program BRCM_HDR_CTRL.
 *
 */
typedef union BCM53101_A0_BRCM_HDR_CTRLr_s {
	uint32_t v[1];
	uint32_t brcm_hdr_ctrl[1];
	uint32_t _brcm_hdr_ctrl;
} BCM53101_A0_BRCM_HDR_CTRLr_t;

#define BCM53101_A0_BRCM_HDR_CTRLr_CLR(r) (r).brcm_hdr_ctrl[0] = 0
#define BCM53101_A0_BRCM_HDR_CTRLr_SET(r,d) (r).brcm_hdr_ctrl[0] = d
#define BCM53101_A0_BRCM_HDR_CTRLr_GET(r) (r).brcm_hdr_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_BRCM_HDR_CTRLr_BRCM_HDR_ENf_GET(r) (((r).brcm_hdr_ctrl[0]) & 0x3)
#define BCM53101_A0_BRCM_HDR_CTRLr_BRCM_HDR_ENf_SET(r,f) (r).brcm_hdr_ctrl[0]=(((r).brcm_hdr_ctrl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53101_A0_BRCM_HDR_CTRLr_RESERVEDf_GET(r) ((((r).brcm_hdr_ctrl[0]) >> 2) & 0x3f)
#define BCM53101_A0_BRCM_HDR_CTRLr_RESERVEDf_SET(r,f) (r).brcm_hdr_ctrl[0]=(((r).brcm_hdr_ctrl[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))

/*
 * These macros can be used to access BRCM_HDR_CTRL.
 *
 */
#define BCM53101_A0_READ_BRCM_HDR_CTRLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_BRCM_HDR_CTRLr,(r._brcm_hdr_ctrl),1)
#define BCM53101_A0_WRITE_BRCM_HDR_CTRLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_BRCM_HDR_CTRLr,&(r._brcm_hdr_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BRCM_HDR_CTRLr BCM53101_A0_BRCM_HDR_CTRLr
#define BRCM_HDR_CTRLr_SIZE BCM53101_A0_BRCM_HDR_CTRLr_SIZE
typedef BCM53101_A0_BRCM_HDR_CTRLr_t BRCM_HDR_CTRLr_t;
#define BRCM_HDR_CTRLr_CLR BCM53101_A0_BRCM_HDR_CTRLr_CLR
#define BRCM_HDR_CTRLr_SET BCM53101_A0_BRCM_HDR_CTRLr_SET
#define BRCM_HDR_CTRLr_GET BCM53101_A0_BRCM_HDR_CTRLr_GET
#define BRCM_HDR_CTRLr_BRCM_HDR_ENf_GET BCM53101_A0_BRCM_HDR_CTRLr_BRCM_HDR_ENf_GET
#define BRCM_HDR_CTRLr_BRCM_HDR_ENf_SET BCM53101_A0_BRCM_HDR_CTRLr_BRCM_HDR_ENf_SET
#define BRCM_HDR_CTRLr_RESERVEDf_GET BCM53101_A0_BRCM_HDR_CTRLr_RESERVEDf_GET
#define BRCM_HDR_CTRLr_RESERVEDf_SET BCM53101_A0_BRCM_HDR_CTRLr_RESERVEDf_SET
#define READ_BRCM_HDR_CTRLr BCM53101_A0_READ_BRCM_HDR_CTRLr
#define WRITE_BRCM_HDR_CTRLr BCM53101_A0_WRITE_BRCM_HDR_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_BRCM_HDR_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  BROADCOM_TEST
 * BLOCKS:   EPIC0
 * DESC:     BROADCOM TEST
 * SIZE:     16
 * FIELDS:
 *     RESERVED         Reserved
 *     SHADOW2_ENABLE   1 = Enable shadow registers.0 = Disable shadow registers.
 *     SHADOW_ENABLE    1 = Enable shadow registers.0 = Disable shadow registers.
 *
 ******************************************************************************/
#define BCM53101_A0_BROADCOM_TESTr 0x0000103e

#define BCM53101_A0_BROADCOM_TESTr_SIZE 2

/*
 * This structure should be used to declare and program BROADCOM_TEST.
 *
 */
typedef union BCM53101_A0_BROADCOM_TESTr_s {
	uint32_t v[1];
	uint32_t broadcom_test[1];
	uint32_t _broadcom_test;
} BCM53101_A0_BROADCOM_TESTr_t;

#define BCM53101_A0_BROADCOM_TESTr_CLR(r) (r).broadcom_test[0] = 0
#define BCM53101_A0_BROADCOM_TESTr_SET(r,d) (r).broadcom_test[0] = d
#define BCM53101_A0_BROADCOM_TESTr_GET(r) (r).broadcom_test[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_BROADCOM_TESTr_RESERVEDf_GET(r) (((r).broadcom_test[0]) & 0x3)
#define BCM53101_A0_BROADCOM_TESTr_RESERVEDf_SET(r,f) (r).broadcom_test[0]=(((r).broadcom_test[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53101_A0_BROADCOM_TESTr_SHADOW2_ENABLEf_GET(r) ((((r).broadcom_test[0]) >> 2) & 0x1)
#define BCM53101_A0_BROADCOM_TESTr_SHADOW2_ENABLEf_SET(r,f) (r).broadcom_test[0]=(((r).broadcom_test[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_BROADCOM_TESTr_SHADOW_ENABLEf_GET(r) ((((r).broadcom_test[0]) >> 7) & 0x1)
#define BCM53101_A0_BROADCOM_TESTr_SHADOW_ENABLEf_SET(r,f) (r).broadcom_test[0]=(((r).broadcom_test[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access BROADCOM_TEST.
 *
 */
#define BCM53101_A0_READ_BROADCOM_TESTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_BROADCOM_TESTr,(r._broadcom_test),2)
#define BCM53101_A0_WRITE_BROADCOM_TESTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_BROADCOM_TESTr,&(r._broadcom_test),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BROADCOM_TESTr BCM53101_A0_BROADCOM_TESTr
#define BROADCOM_TESTr_SIZE BCM53101_A0_BROADCOM_TESTr_SIZE
typedef BCM53101_A0_BROADCOM_TESTr_t BROADCOM_TESTr_t;
#define BROADCOM_TESTr_CLR BCM53101_A0_BROADCOM_TESTr_CLR
#define BROADCOM_TESTr_SET BCM53101_A0_BROADCOM_TESTr_SET
#define BROADCOM_TESTr_GET BCM53101_A0_BROADCOM_TESTr_GET
#define BROADCOM_TESTr_RESERVEDf_GET BCM53101_A0_BROADCOM_TESTr_RESERVEDf_GET
#define BROADCOM_TESTr_RESERVEDf_SET BCM53101_A0_BROADCOM_TESTr_RESERVEDf_SET
#define BROADCOM_TESTr_SHADOW2_ENABLEf_GET BCM53101_A0_BROADCOM_TESTr_SHADOW2_ENABLEf_GET
#define BROADCOM_TESTr_SHADOW2_ENABLEf_SET BCM53101_A0_BROADCOM_TESTr_SHADOW2_ENABLEf_SET
#define BROADCOM_TESTr_SHADOW_ENABLEf_GET BCM53101_A0_BROADCOM_TESTr_SHADOW_ENABLEf_GET
#define BROADCOM_TESTr_SHADOW_ENABLEf_SET BCM53101_A0_BROADCOM_TESTr_SHADOW_ENABLEf_SET
#define READ_BROADCOM_TESTr BCM53101_A0_READ_BROADCOM_TESTr
#define WRITE_BROADCOM_TESTr BCM53101_A0_WRITE_BROADCOM_TESTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_BROADCOM_TESTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  BROADCOM_TEST_EXT_P5
 * BLOCKS:   SYS
 * DESC:     BROADCOM TEST
 * SIZE:     16
 * FIELDS:
 *     RESERVED         Reserved
 *     SHADOW2_ENABLE   1 = Enable shadow registers.0 = Disable shadow registers.
 *     SHADOW_ENABLE    1 = Enable shadow registers.0 = Disable shadow registers.
 *
 ******************************************************************************/
#define BCM53101_A0_BROADCOM_TEST_EXT_P5r 0x0000853e

#define BCM53101_A0_BROADCOM_TEST_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program BROADCOM_TEST_EXT_P5.
 *
 */
typedef union BCM53101_A0_BROADCOM_TEST_EXT_P5r_s {
	uint32_t v[1];
	uint32_t broadcom_test_ext_p5[1];
	uint32_t _broadcom_test_ext_p5;
} BCM53101_A0_BROADCOM_TEST_EXT_P5r_t;

#define BCM53101_A0_BROADCOM_TEST_EXT_P5r_CLR(r) (r).broadcom_test_ext_p5[0] = 0
#define BCM53101_A0_BROADCOM_TEST_EXT_P5r_SET(r,d) (r).broadcom_test_ext_p5[0] = d
#define BCM53101_A0_BROADCOM_TEST_EXT_P5r_GET(r) (r).broadcom_test_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_BROADCOM_TEST_EXT_P5r_RESERVEDf_GET(r) (((r).broadcom_test_ext_p5[0]) & 0x3)
#define BCM53101_A0_BROADCOM_TEST_EXT_P5r_RESERVEDf_SET(r,f) (r).broadcom_test_ext_p5[0]=(((r).broadcom_test_ext_p5[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53101_A0_BROADCOM_TEST_EXT_P5r_SHADOW2_ENABLEf_GET(r) ((((r).broadcom_test_ext_p5[0]) >> 2) & 0x1)
#define BCM53101_A0_BROADCOM_TEST_EXT_P5r_SHADOW2_ENABLEf_SET(r,f) (r).broadcom_test_ext_p5[0]=(((r).broadcom_test_ext_p5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_BROADCOM_TEST_EXT_P5r_SHADOW_ENABLEf_GET(r) ((((r).broadcom_test_ext_p5[0]) >> 7) & 0x1)
#define BCM53101_A0_BROADCOM_TEST_EXT_P5r_SHADOW_ENABLEf_SET(r,f) (r).broadcom_test_ext_p5[0]=(((r).broadcom_test_ext_p5[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access BROADCOM_TEST_EXT_P5.
 *
 */
#define BCM53101_A0_READ_BROADCOM_TEST_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53101_A0_BROADCOM_TEST_EXT_P5r,(r._broadcom_test_ext_p5),2)
#define BCM53101_A0_WRITE_BROADCOM_TEST_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53101_A0_BROADCOM_TEST_EXT_P5r,&(r._broadcom_test_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BROADCOM_TEST_EXT_P5r BCM53101_A0_BROADCOM_TEST_EXT_P5r
#define BROADCOM_TEST_EXT_P5r_SIZE BCM53101_A0_BROADCOM_TEST_EXT_P5r_SIZE
typedef BCM53101_A0_BROADCOM_TEST_EXT_P5r_t BROADCOM_TEST_EXT_P5r_t;
#define BROADCOM_TEST_EXT_P5r_CLR BCM53101_A0_BROADCOM_TEST_EXT_P5r_CLR
#define BROADCOM_TEST_EXT_P5r_SET BCM53101_A0_BROADCOM_TEST_EXT_P5r_SET
#define BROADCOM_TEST_EXT_P5r_GET BCM53101_A0_BROADCOM_TEST_EXT_P5r_GET
#define BROADCOM_TEST_EXT_P5r_RESERVEDf_GET BCM53101_A0_BROADCOM_TEST_EXT_P5r_RESERVEDf_GET
#define BROADCOM_TEST_EXT_P5r_RESERVEDf_SET BCM53101_A0_BROADCOM_TEST_EXT_P5r_RESERVEDf_SET
#define BROADCOM_TEST_EXT_P5r_SHADOW2_ENABLEf_GET BCM53101_A0_BROADCOM_TEST_EXT_P5r_SHADOW2_ENABLEf_GET
#define BROADCOM_TEST_EXT_P5r_SHADOW2_ENABLEf_SET BCM53101_A0_BROADCOM_TEST_EXT_P5r_SHADOW2_ENABLEf_SET
#define BROADCOM_TEST_EXT_P5r_SHADOW_ENABLEf_GET BCM53101_A0_BROADCOM_TEST_EXT_P5r_SHADOW_ENABLEf_GET
#define BROADCOM_TEST_EXT_P5r_SHADOW_ENABLEf_SET BCM53101_A0_BROADCOM_TEST_EXT_P5r_SHADOW_ENABLEf_SET
#define READ_BROADCOM_TEST_EXT_P5r BCM53101_A0_READ_BROADCOM_TEST_EXT_P5r
#define WRITE_BROADCOM_TEST_EXT_P5r BCM53101_A0_WRITE_BROADCOM_TEST_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_BROADCOM_TEST_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * MEMORY:  BUFCON
 * BLOCKS:   SYS
 * DESC:     Buffer Tag Control Table
 * SIZE:     72
 * FIELDS:
 *     NEXTBUFPTR       nextbufptr[8:0]
 *     UNTAGMAP         untagmap[6:0]
 *     PORTMAP          portmap[6:0]
 *     RXPORT           rxport[3:0]
 *     DSCP             dscp[5:0]
 *     PRESV_1P_TAG     presv_1p_tag
 *     FMLEN            fmlen[13:0]
 *     TC               tc[2:0]
 *     TS               ts
 *     RSN_CD           rsn_cd[5:0]
 *     TSRPT            tsrpt
 *     C_TAG            C_tag
 *     S_TAG            S_tag
 *     CLASS_ID         class_id[7:0]
 *     PRESV_PKT_FORMAT presv_pkt_format
 *     CVID0            cvid0
 *     SVID0            svid0
 *
 ******************************************************************************/
#define BCM53101_A0_BUFCONm 0x00000000

#define BCM53101_A0_BUFCONm_MIN 0
#define BCM53101_A0_BUFCONm_MAX 5119
#define BCM53101_A0_BUFCONm_CMAX(u) 5119
#define BCM53101_A0_BUFCONm_SIZE 9

/*
 * This structure should be used to declare and program BUFCON.
 *
 */
typedef union BCM53101_A0_BUFCONm_s {
	uint32_t v[3];
	uint32_t bufcon[3];
	uint32_t _bufcon;
} BCM53101_A0_BUFCONm_t;

#define BCM53101_A0_BUFCONm_CLR(r) CDK_MEMSET(&((r)._bufcon), 0, sizeof(BCM53101_A0_BUFCONm_t))
#define BCM53101_A0_BUFCONm_SET(r,i,d) (r).bufcon[i] = d
#define BCM53101_A0_BUFCONm_GET(r,i) (r).bufcon[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_BUFCONm_NEXTBUFPTRf_GET(r) (((r).bufcon[0]) & 0x1ff)
#define BCM53101_A0_BUFCONm_NEXTBUFPTRf_SET(r,f) (r).bufcon[0]=(((r).bufcon[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_BUFCONm_UNTAGMAPf_GET(r) ((((r).bufcon[0]) >> 9) & 0x7f)
#define BCM53101_A0_BUFCONm_UNTAGMAPf_SET(r,f) (r).bufcon[0]=(((r).bufcon[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))
#define BCM53101_A0_BUFCONm_PORTMAPf_GET(r) ((((r).bufcon[0]) >> 16) & 0x7f)
#define BCM53101_A0_BUFCONm_PORTMAPf_SET(r,f) (r).bufcon[0]=(((r).bufcon[0] & ~((uint32_t)0x7f << 16)) | ((((uint32_t)f) & 0x7f) << 16))
#define BCM53101_A0_BUFCONm_RXPORTf_GET(r) ((((r).bufcon[0]) >> 23) & 0xf)
#define BCM53101_A0_BUFCONm_RXPORTf_SET(r,f) (r).bufcon[0]=(((r).bufcon[0] & ~((uint32_t)0xf << 23)) | ((((uint32_t)f) & 0xf) << 23))
#define BCM53101_A0_BUFCONm_DSCPf_GET(r) cdk_field32_get((r).bufcon,27,32)
#define BCM53101_A0_BUFCONm_DSCPf_SET(r,f) cdk_field32_set((r).bufcon,27,32,f)
#define BCM53101_A0_BUFCONm_PRESV_1P_TAGf_GET(r) ((((r).bufcon[1]) >> 1) & 0x1)
#define BCM53101_A0_BUFCONm_PRESV_1P_TAGf_SET(r,f) (r).bufcon[1]=(((r).bufcon[1] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_BUFCONm_FMLENf_GET(r) ((((r).bufcon[1]) >> 2) & 0x3fff)
#define BCM53101_A0_BUFCONm_FMLENf_SET(r,f) (r).bufcon[1]=(((r).bufcon[1] & ~((uint32_t)0x3fff << 2)) | ((((uint32_t)f) & 0x3fff) << 2))
#define BCM53101_A0_BUFCONm_TCf_GET(r) ((((r).bufcon[1]) >> 16) & 0x7)
#define BCM53101_A0_BUFCONm_TCf_SET(r,f) (r).bufcon[1]=(((r).bufcon[1] & ~((uint32_t)0x7 << 16)) | ((((uint32_t)f) & 0x7) << 16))
#define BCM53101_A0_BUFCONm_TSf_GET(r) ((((r).bufcon[1]) >> 19) & 0x1)
#define BCM53101_A0_BUFCONm_TSf_SET(r,f) (r).bufcon[1]=(((r).bufcon[1] & ~((uint32_t)0x1 << 19)) | ((((uint32_t)f) & 0x1) << 19))
#define BCM53101_A0_BUFCONm_RSN_CDf_GET(r) ((((r).bufcon[1]) >> 20) & 0x3f)
#define BCM53101_A0_BUFCONm_RSN_CDf_SET(r,f) (r).bufcon[1]=(((r).bufcon[1] & ~((uint32_t)0x3f << 20)) | ((((uint32_t)f) & 0x3f) << 20))
#define BCM53101_A0_BUFCONm_TSRPTf_GET(r) ((((r).bufcon[1]) >> 26) & 0x1)
#define BCM53101_A0_BUFCONm_TSRPTf_SET(r,f) (r).bufcon[1]=(((r).bufcon[1] & ~((uint32_t)0x1 << 26)) | ((((uint32_t)f) & 0x1) << 26))
#define BCM53101_A0_BUFCONm_C_TAGf_GET(r) ((((r).bufcon[1]) >> 27) & 0x1)
#define BCM53101_A0_BUFCONm_C_TAGf_SET(r,f) (r).bufcon[1]=(((r).bufcon[1] & ~((uint32_t)0x1 << 27)) | ((((uint32_t)f) & 0x1) << 27))
#define BCM53101_A0_BUFCONm_S_TAGf_GET(r) ((((r).bufcon[1]) >> 28) & 0x1)
#define BCM53101_A0_BUFCONm_S_TAGf_SET(r,f) (r).bufcon[1]=(((r).bufcon[1] & ~((uint32_t)0x1 << 28)) | ((((uint32_t)f) & 0x1) << 28))
#define BCM53101_A0_BUFCONm_CLASS_IDf_GET(r) cdk_field32_get((r).bufcon,61,68)
#define BCM53101_A0_BUFCONm_CLASS_IDf_SET(r,f) cdk_field32_set((r).bufcon,61,68,f)
#define BCM53101_A0_BUFCONm_PRESV_PKT_FORMATf_GET(r) ((((r).bufcon[2]) >> 5) & 0x1)
#define BCM53101_A0_BUFCONm_PRESV_PKT_FORMATf_SET(r,f) (r).bufcon[2]=(((r).bufcon[2] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_BUFCONm_CVID0f_GET(r) ((((r).bufcon[2]) >> 6) & 0x1)
#define BCM53101_A0_BUFCONm_CVID0f_SET(r,f) (r).bufcon[2]=(((r).bufcon[2] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_BUFCONm_SVID0f_GET(r) ((((r).bufcon[2]) >> 7) & 0x1)
#define BCM53101_A0_BUFCONm_SVID0f_SET(r,f) (r).bufcon[2]=(((r).bufcon[2] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access BUFCON.
 *
 */
#define BCM53101_A0_READ_BUFCONm(u,i,m) cdk_robo_mem_read(u,BCM53101_A0_BUFCONm,i,(m),9)
#define BCM53101_A0_WRITE_BUFCONm(u,i,m) cdk_robo_mem_write(u,BCM53101_A0_BUFCONm,i,&(m),9)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define BUFCONm BCM53101_A0_BUFCONm
#define BUFCONm_MIN BCM53101_A0_BUFCONm_MIN
#define BUFCONm_MAX BCM53101_A0_BUFCONm_MAX
#define BUFCONm_CMAX(u) BCM53101_A0_BUFCONm_CMAX(u)
#define BUFCONm_SIZE BCM53101_A0_BUFCONm_SIZE
typedef BCM53101_A0_BUFCONm_t BUFCONm_t;
#define BUFCONm_CLR BCM53101_A0_BUFCONm_CLR
#define BUFCONm_SET BCM53101_A0_BUFCONm_SET
#define BUFCONm_GET BCM53101_A0_BUFCONm_GET
#define BUFCONm_NEXTBUFPTRf_GET BCM53101_A0_BUFCONm_NEXTBUFPTRf_GET
#define BUFCONm_NEXTBUFPTRf_SET BCM53101_A0_BUFCONm_NEXTBUFPTRf_SET
#define BUFCONm_UNTAGMAPf_GET BCM53101_A0_BUFCONm_UNTAGMAPf_GET
#define BUFCONm_UNTAGMAPf_SET BCM53101_A0_BUFCONm_UNTAGMAPf_SET
#define BUFCONm_PORTMAPf_GET BCM53101_A0_BUFCONm_PORTMAPf_GET
#define BUFCONm_PORTMAPf_SET BCM53101_A0_BUFCONm_PORTMAPf_SET
#define BUFCONm_RXPORTf_GET BCM53101_A0_BUFCONm_RXPORTf_GET
#define BUFCONm_RXPORTf_SET BCM53101_A0_BUFCONm_RXPORTf_SET
#define BUFCONm_DSCPf_GET BCM53101_A0_BUFCONm_DSCPf_GET
#define BUFCONm_DSCPf_SET BCM53101_A0_BUFCONm_DSCPf_SET
#define BUFCONm_PRESV_1P_TAGf_GET BCM53101_A0_BUFCONm_PRESV_1P_TAGf_GET
#define BUFCONm_PRESV_1P_TAGf_SET BCM53101_A0_BUFCONm_PRESV_1P_TAGf_SET
#define BUFCONm_FMLENf_GET BCM53101_A0_BUFCONm_FMLENf_GET
#define BUFCONm_FMLENf_SET BCM53101_A0_BUFCONm_FMLENf_SET
#define BUFCONm_TCf_GET BCM53101_A0_BUFCONm_TCf_GET
#define BUFCONm_TCf_SET BCM53101_A0_BUFCONm_TCf_SET
#define BUFCONm_TSf_GET BCM53101_A0_BUFCONm_TSf_GET
#define BUFCONm_TSf_SET BCM53101_A0_BUFCONm_TSf_SET
#define BUFCONm_RSN_CDf_GET BCM53101_A0_BUFCONm_RSN_CDf_GET
#define BUFCONm_RSN_CDf_SET BCM53101_A0_BUFCONm_RSN_CDf_SET
#define BUFCONm_TSRPTf_GET BCM53101_A0_BUFCONm_TSRPTf_GET
#define BUFCONm_TSRPTf_SET BCM53101_A0_BUFCONm_TSRPTf_SET
#define BUFCONm_C_TAGf_GET BCM53101_A0_BUFCONm_C_TAGf_GET
#define BUFCONm_C_TAGf_SET BCM53101_A0_BUFCONm_C_TAGf_SET
#define BUFCONm_S_TAGf_GET BCM53101_A0_BUFCONm_S_TAGf_GET
#define BUFCONm_S_TAGf_SET BCM53101_A0_BUFCONm_S_TAGf_SET
#define BUFCONm_CLASS_IDf_GET BCM53101_A0_BUFCONm_CLASS_IDf_GET
#define BUFCONm_CLASS_IDf_SET BCM53101_A0_BUFCONm_CLASS_IDf_SET
#define BUFCONm_PRESV_PKT_FORMATf_GET BCM53101_A0_BUFCONm_PRESV_PKT_FORMATf_GET
#define BUFCONm_PRESV_PKT_FORMATf_SET BCM53101_A0_BUFCONm_PRESV_PKT_FORMATf_SET
#define BUFCONm_CVID0f_GET BCM53101_A0_BUFCONm_CVID0f_GET
#define BUFCONm_CVID0f_SET BCM53101_A0_BUFCONm_CVID0f_SET
#define BUFCONm_SVID0f_GET BCM53101_A0_BUFCONm_SVID0f_GET
#define BUFCONm_SVID0f_SET BCM53101_A0_BUFCONm_SVID0f_SET
#define READ_BUFCONm BCM53101_A0_READ_BUFCONm
#define WRITE_BUFCONm BCM53101_A0_WRITE_BUFCONm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_BUFCONm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  C4_WEIGHT
 * BLOCKS:   SYS
 * DESC:     Class4 Service Weight Register
 * SIZE:     16
 * FIELDS:
 *     C4_WEIGHT        C4 Service WeightThis field defines the service weight between Class 4 traffic and the Best Effort Q3-Q0. When this field is N, it means Class-4:Best-Effort = N:1 When in weighted round robin mode, it is meaningless to set this field as zero.
 *     C4_STRCT         C4 Strict PriorityWhen this field is set to '1', the C4 service weight is don't care and Class 4 is in strict priority over the best effort queues (Q3-Q0).
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_C4_WEIGHTr 0x00003085

#define BCM53101_A0_C4_WEIGHTr_SIZE 2

/*
 * This structure should be used to declare and program C4_WEIGHT.
 *
 */
typedef union BCM53101_A0_C4_WEIGHTr_s {
	uint32_t v[1];
	uint32_t c4_weight[1];
	uint32_t _c4_weight;
} BCM53101_A0_C4_WEIGHTr_t;

#define BCM53101_A0_C4_WEIGHTr_CLR(r) (r).c4_weight[0] = 0
#define BCM53101_A0_C4_WEIGHTr_SET(r,d) (r).c4_weight[0] = d
#define BCM53101_A0_C4_WEIGHTr_GET(r) (r).c4_weight[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_C4_WEIGHTr_C4_WEIGHTf_GET(r) (((r).c4_weight[0]) & 0xff)
#define BCM53101_A0_C4_WEIGHTr_C4_WEIGHTf_SET(r,f) (r).c4_weight[0]=(((r).c4_weight[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53101_A0_C4_WEIGHTr_C4_STRCTf_GET(r) ((((r).c4_weight[0]) >> 8) & 0x1)
#define BCM53101_A0_C4_WEIGHTr_C4_STRCTf_SET(r,f) (r).c4_weight[0]=(((r).c4_weight[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53101_A0_C4_WEIGHTr_RESERVEDf_GET(r) ((((r).c4_weight[0]) >> 9) & 0x7f)
#define BCM53101_A0_C4_WEIGHTr_RESERVEDf_SET(r,f) (r).c4_weight[0]=(((r).c4_weight[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access C4_WEIGHT.
 *
 */
#define BCM53101_A0_READ_C4_WEIGHTr(u,r) cdk_robo_reg_read(u,BCM53101_A0_C4_WEIGHTr,(r._c4_weight),2)
#define BCM53101_A0_WRITE_C4_WEIGHTr(u,r) cdk_robo_reg_write(u,BCM53101_A0_C4_WEIGHTr,&(r._c4_weight),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define C4_WEIGHTr BCM53101_A0_C4_WEIGHTr
#define C4_WEIGHTr_SIZE BCM53101_A0_C4_WEIGHTr_SIZE
typedef BCM53101_A0_C4_WEIGHTr_t C4_WEIGHTr_t;
#define C4_WEIGHTr_CLR BCM53101_A0_C4_WEIGHTr_CLR
#define C4_WEIGHTr_SET BCM53101_A0_C4_WEIGHTr_SET
#define C4_WEIGHTr_GET BCM53101_A0_C4_WEIGHTr_GET
#define C4_WEIGHTr_C4_WEIGHTf_GET BCM53101_A0_C4_WEIGHTr_C4_WEIGHTf_GET
#define C4_WEIGHTr_C4_WEIGHTf_SET BCM53101_A0_C4_WEIGHTr_C4_WEIGHTf_SET
#define C4_WEIGHTr_C4_STRCTf_GET BCM53101_A0_C4_WEIGHTr_C4_STRCTf_GET
#define C4_WEIGHTr_C4_STRCTf_SET BCM53101_A0_C4_WEIGHTr_C4_STRCTf_SET
#define C4_WEIGHTr_RESERVEDf_GET BCM53101_A0_C4_WEIGHTr_RESERVEDf_GET
#define C4_WEIGHTr_RESERVEDf_SET BCM53101_A0_C4_WEIGHTr_RESERVEDf_SET
#define READ_C4_WEIGHTr BCM53101_A0_READ_C4_WEIGHTr
#define WRITE_C4_WEIGHTr BCM53101_A0_WRITE_C4_WEIGHTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_C4_WEIGHTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  CHIP_REVID
 * BLOCKS:   SYS
 * DESC:     Chip Version ID Register
 * SIZE:     8
 * FIELDS:
 *     REVID            Chip Version ID.
 *
 ******************************************************************************/
#define BCM53101_A0_CHIP_REVIDr 0x00000240

#define BCM53101_A0_CHIP_REVIDr_SIZE 1

/*
 * This structure should be used to declare and program CHIP_REVID.
 *
 */
typedef union BCM53101_A0_CHIP_REVIDr_s {
	uint32_t v[1];
	uint32_t chip_revid[1];
	uint32_t _chip_revid;
} BCM53101_A0_CHIP_REVIDr_t;

#define BCM53101_A0_CHIP_REVIDr_CLR(r) (r).chip_revid[0] = 0
#define BCM53101_A0_CHIP_REVIDr_SET(r,d) (r).chip_revid[0] = d
#define BCM53101_A0_CHIP_REVIDr_GET(r) (r).chip_revid[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_CHIP_REVIDr_REVIDf_GET(r) (((r).chip_revid[0]) & 0xff)
#define BCM53101_A0_CHIP_REVIDr_REVIDf_SET(r,f) (r).chip_revid[0]=(((r).chip_revid[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access CHIP_REVID.
 *
 */
#define BCM53101_A0_READ_CHIP_REVIDr(u,r) cdk_robo_reg_read(u,BCM53101_A0_CHIP_REVIDr,(r._chip_revid),1)
#define BCM53101_A0_WRITE_CHIP_REVIDr(u,r) cdk_robo_reg_write(u,BCM53101_A0_CHIP_REVIDr,&(r._chip_revid),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CHIP_REVIDr BCM53101_A0_CHIP_REVIDr
#define CHIP_REVIDr_SIZE BCM53101_A0_CHIP_REVIDr_SIZE
typedef BCM53101_A0_CHIP_REVIDr_t CHIP_REVIDr_t;
#define CHIP_REVIDr_CLR BCM53101_A0_CHIP_REVIDr_CLR
#define CHIP_REVIDr_SET BCM53101_A0_CHIP_REVIDr_SET
#define CHIP_REVIDr_GET BCM53101_A0_CHIP_REVIDr_GET
#define CHIP_REVIDr_REVIDf_GET BCM53101_A0_CHIP_REVIDr_REVIDf_GET
#define CHIP_REVIDr_REVIDf_SET BCM53101_A0_CHIP_REVIDr_REVIDf_SET
#define READ_CHIP_REVIDr BCM53101_A0_READ_CHIP_REVIDr
#define WRITE_CHIP_REVIDr BCM53101_A0_WRITE_CHIP_REVIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_CHIP_REVIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  CLKSET
 * BLOCKS:   SYS
 * DESC:     Clock Period Setting Registers
 * SIZE:     32
 * FIELDS:
 *     RESERVED         Clock Control Register
 *
 ******************************************************************************/
#define BCM53101_A0_CLKSETr 0x0000fffa

#define BCM53101_A0_CLKSETr_SIZE 4

/*
 * This structure should be used to declare and program CLKSET.
 *
 */
typedef union BCM53101_A0_CLKSETr_s {
	uint32_t v[1];
	uint32_t clkset[1];
	uint32_t _clkset;
} BCM53101_A0_CLKSETr_t;

#define BCM53101_A0_CLKSETr_CLR(r) (r).clkset[0] = 0
#define BCM53101_A0_CLKSETr_SET(r,d) (r).clkset[0] = d
#define BCM53101_A0_CLKSETr_GET(r) (r).clkset[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_CLKSETr_RESERVEDf_GET(r) ((r).clkset[0])
#define BCM53101_A0_CLKSETr_RESERVEDf_SET(r,f) (r).clkset[0]=((uint32_t)f)

/*
 * These macros can be used to access CLKSET.
 *
 */
#define BCM53101_A0_READ_CLKSETr(u,r) cdk_robo_reg_read(u,BCM53101_A0_CLKSETr,(r._clkset),4)
#define BCM53101_A0_WRITE_CLKSETr(u,r) cdk_robo_reg_write(u,BCM53101_A0_CLKSETr,&(r._clkset),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CLKSETr BCM53101_A0_CLKSETr
#define CLKSETr_SIZE BCM53101_A0_CLKSETr_SIZE
typedef BCM53101_A0_CLKSETr_t CLKSETr_t;
#define CLKSETr_CLR BCM53101_A0_CLKSETr_CLR
#define CLKSETr_SET BCM53101_A0_CLKSETr_SET
#define CLKSETr_GET BCM53101_A0_CLKSETr_GET
#define CLKSETr_RESERVEDf_GET BCM53101_A0_CLKSETr_RESERVEDf_GET
#define CLKSETr_RESERVEDf_SET BCM53101_A0_CLKSETr_RESERVEDf_SET
#define READ_CLKSETr BCM53101_A0_READ_CLKSETr
#define WRITE_CLKSETr BCM53101_A0_WRITE_CLKSETr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_CLKSETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  COMM_IRC_CON
 * BLOCKS:   SYS
 * DESC:     Common Ingress rate Control Configuration Registers
 * SIZE:     32
 * FIELDS:
 *     PKT_MSK0         Packet Mask for Bucket 0Bit 0: Unicast lookup hitBit 1: Multicast lookup hitBit 2: Reserved Mac Address Frame(01-80-C2-0-00-2F)Bit 3: BroadcastBit 4: Multicats lookup failBit 5: Unicast lookup fail
 *     XLENEN_EG        Bit Rate Mode Selection for Egress Control0:TX Rate Exclude IPG1:TX Rate Include IPG(and preamble + SFD)
 *     DROP_EN0         suppression Drop Mode Enabled.1:The incoming packet will be dropped if the allowed bandwidth for those packets defined in Packet Type Mask is up.0:The Pause Frame/Jamming Frame will be transmitted depend on Full/HalfDuplex Mode if the allowed bandwidth for those packets defined in Packet Type Mask is up.
 *     RATE_TYPE0       Bit Rate Mode selection.0: E3556 ModeIncoming Bit Rate is Defined in Refresh Count in per Ingress Port Rate Control Register with Absolute amout and Nothing about Link Speed.1:Bit Rate Related to Link Speed ModeIncoming Bit Rate is Define in Refresh Count in Per Ingress Port Rate Control Register with Related Amount to Link Speed
 *     PKT_MSK1         Packet Mask for Bucket 1Suppressed Packet Type in Bucket 1Bit 0: Unicast lookup hitBit 1: Multicast lookup hitBit 2: Reserved Mac Address Frame(01-80-C2-0-00-2F)Bit 3: BroadcastBit 4: Multicats lookup failBit 5: Unicast lookup failBit 6: Reserved
 *     DROP_EN1         suppression Drop Mode Enabled1:The incoming packet will be dropped if the allowed bandwidth for those packets defined in Packet Type Mask is up.0:The Pause Frame/Jamming Frame will be transmitted depend on Full/HalfDuplex Mode if the allowed bandwidth for those packets defined in Packet Type Mask is up.
 *     RATE_TYPE1       Bit Rate Mode selection.0:Absolute Bit Rate ModeIncoming Bit Rate is Defined in Refresh Count in per Ingress Port Rate Control Register with Absolute amout and Nothing about Link Speed.1:Bit Rate Related to Link Speed ModeIncoming Bit Rate is Define in Refresh Count in Per Ingress Port Rate Control Register with Related Amount to Link Speed
 *     XLEN_EN          bit rate Mode  Selection.0 : Rx rate exclude IGP,1 : Rx rate include IGP,
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_COMM_IRC_CONr 0x00004100

#define BCM53101_A0_COMM_IRC_CONr_SIZE 4

/*
 * This structure should be used to declare and program COMM_IRC_CON.
 *
 */
typedef union BCM53101_A0_COMM_IRC_CONr_s {
	uint32_t v[1];
	uint32_t comm_irc_con[1];
	uint32_t _comm_irc_con;
} BCM53101_A0_COMM_IRC_CONr_t;

#define BCM53101_A0_COMM_IRC_CONr_CLR(r) (r).comm_irc_con[0] = 0
#define BCM53101_A0_COMM_IRC_CONr_SET(r,d) (r).comm_irc_con[0] = d
#define BCM53101_A0_COMM_IRC_CONr_GET(r) (r).comm_irc_con[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_COMM_IRC_CONr_PKT_MSK0f_GET(r) (((r).comm_irc_con[0]) & 0x3f)
#define BCM53101_A0_COMM_IRC_CONr_PKT_MSK0f_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53101_A0_COMM_IRC_CONr_XLENEN_EGf_GET(r) ((((r).comm_irc_con[0]) >> 6) & 0x1)
#define BCM53101_A0_COMM_IRC_CONr_XLENEN_EGf_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_COMM_IRC_CONr_DROP_EN0f_GET(r) ((((r).comm_irc_con[0]) >> 7) & 0x1)
#define BCM53101_A0_COMM_IRC_CONr_DROP_EN0f_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53101_A0_COMM_IRC_CONr_RATE_TYPE0f_GET(r) ((((r).comm_irc_con[0]) >> 8) & 0x1)
#define BCM53101_A0_COMM_IRC_CONr_RATE_TYPE0f_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53101_A0_COMM_IRC_CONr_PKT_MSK1f_GET(r) ((((r).comm_irc_con[0]) >> 9) & 0x7f)
#define BCM53101_A0_COMM_IRC_CONr_PKT_MSK1f_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))
#define BCM53101_A0_COMM_IRC_CONr_DROP_EN1f_GET(r) ((((r).comm_irc_con[0]) >> 16) & 0x1)
#define BCM53101_A0_COMM_IRC_CONr_DROP_EN1f_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53101_A0_COMM_IRC_CONr_RATE_TYPE1f_GET(r) ((((r).comm_irc_con[0]) >> 17) & 0x1)
#define BCM53101_A0_COMM_IRC_CONr_RATE_TYPE1f_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53101_A0_COMM_IRC_CONr_XLEN_ENf_GET(r) ((((r).comm_irc_con[0]) >> 18) & 0x1)
#define BCM53101_A0_COMM_IRC_CONr_XLEN_ENf_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM53101_A0_COMM_IRC_CONr_RESERVEDf_GET(r) ((((r).comm_irc_con[0]) >> 19) & 0x1fff)
#define BCM53101_A0_COMM_IRC_CONr_RESERVEDf_SET(r,f) (r).comm_irc_con[0]=(((r).comm_irc_con[0] & ~((uint32_t)0x1fff << 19)) | ((((uint32_t)f) & 0x1fff) << 19))

/*
 * These macros can be used to access COMM_IRC_CON.
 *
 */
#define BCM53101_A0_READ_COMM_IRC_CONr(u,r) cdk_robo_reg_read(u,BCM53101_A0_COMM_IRC_CONr,(r._comm_irc_con),4)
#define BCM53101_A0_WRITE_COMM_IRC_CONr(u,r) cdk_robo_reg_write(u,BCM53101_A0_COMM_IRC_CONr,&(r._comm_irc_con),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define COMM_IRC_CONr BCM53101_A0_COMM_IRC_CONr
#define COMM_IRC_CONr_SIZE BCM53101_A0_COMM_IRC_CONr_SIZE
typedef BCM53101_A0_COMM_IRC_CONr_t COMM_IRC_CONr_t;
#define COMM_IRC_CONr_CLR BCM53101_A0_COMM_IRC_CONr_CLR
#define COMM_IRC_CONr_SET BCM53101_A0_COMM_IRC_CONr_SET
#define COMM_IRC_CONr_GET BCM53101_A0_COMM_IRC_CONr_GET
#define COMM_IRC_CONr_PKT_MSK0f_GET BCM53101_A0_COMM_IRC_CONr_PKT_MSK0f_GET
#define COMM_IRC_CONr_PKT_MSK0f_SET BCM53101_A0_COMM_IRC_CONr_PKT_MSK0f_SET
#define COMM_IRC_CONr_XLENEN_EGf_GET BCM53101_A0_COMM_IRC_CONr_XLENEN_EGf_GET
#define COMM_IRC_CONr_XLENEN_EGf_SET BCM53101_A0_COMM_IRC_CONr_XLENEN_EGf_SET
#define COMM_IRC_CONr_DROP_EN0f_GET BCM53101_A0_COMM_IRC_CONr_DROP_EN0f_GET
#define COMM_IRC_CONr_DROP_EN0f_SET BCM53101_A0_COMM_IRC_CONr_DROP_EN0f_SET
#define COMM_IRC_CONr_RATE_TYPE0f_GET BCM53101_A0_COMM_IRC_CONr_RATE_TYPE0f_GET
#define COMM_IRC_CONr_RATE_TYPE0f_SET BCM53101_A0_COMM_IRC_CONr_RATE_TYPE0f_SET
#define COMM_IRC_CONr_PKT_MSK1f_GET BCM53101_A0_COMM_IRC_CONr_PKT_MSK1f_GET
#define COMM_IRC_CONr_PKT_MSK1f_SET BCM53101_A0_COMM_IRC_CONr_PKT_MSK1f_SET
#define COMM_IRC_CONr_DROP_EN1f_GET BCM53101_A0_COMM_IRC_CONr_DROP_EN1f_GET
#define COMM_IRC_CONr_DROP_EN1f_SET BCM53101_A0_COMM_IRC_CONr_DROP_EN1f_SET
#define COMM_IRC_CONr_RATE_TYPE1f_GET BCM53101_A0_COMM_IRC_CONr_RATE_TYPE1f_GET
#define COMM_IRC_CONr_RATE_TYPE1f_SET BCM53101_A0_COMM_IRC_CONr_RATE_TYPE1f_SET
#define COMM_IRC_CONr_XLEN_ENf_GET BCM53101_A0_COMM_IRC_CONr_XLEN_ENf_GET
#define COMM_IRC_CONr_XLEN_ENf_SET BCM53101_A0_COMM_IRC_CONr_XLEN_ENf_SET
#define COMM_IRC_CONr_RESERVEDf_GET BCM53101_A0_COMM_IRC_CONr_RESERVEDf_GET
#define COMM_IRC_CONr_RESERVEDf_SET BCM53101_A0_COMM_IRC_CONr_RESERVEDf_SET
#define READ_COMM_IRC_CONr BCM53101_A0_READ_COMM_IRC_CONr
#define WRITE_COMM_IRC_CONr BCM53101_A0_WRITE_COMM_IRC_CONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_COMM_IRC_CONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  CPU2COS_MAP
 * BLOCKS:   SYS
 * DESC:     CPU to COS Mapping Register
 * SIZE:     32
 * FIELDS:
 *     MIRROR           The packet forwarded to the CPU for mirroring reason. The COS selection is based on the highest COS valuses among all the resons for the packet.
 *     SA_LRN           The packet forwarded to the CPU for SA Learning reason .The COS selection is based on the highest COS valuses among all the resons for the packet..
 *     SW_FLD           The packet forwarded to the CPU for Switching/Flooding reason. The COS selection is based on the highest COS valuses among all the resons for the packet.
 *     PRTC_TRMNT       The packet forwarded to the CPU for Protocol Termination reason. The COS selection is based on the highest COS valuses among all the resons for the packet.
 *     PRTC_SNOOP       The packet forwarded to the CPU for Protocol Snooping reason. The COS selection is based on the highest COS valuses among all the resons for the packet.
 *     EXCPT_PRCS       The packet forwarded to the CPU for Exception Processing reason. The COS selection is based on the highest COS valuses among all the resons for the packet.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_CPU2COS_MAPr 0x00003064

#define BCM53101_A0_CPU2COS_MAPr_SIZE 4

/*
 * This structure should be used to declare and program CPU2COS_MAP.
 *
 */
typedef union BCM53101_A0_CPU2COS_MAPr_s {
	uint32_t v[1];
	uint32_t cpu2cos_map[1];
	uint32_t _cpu2cos_map;
} BCM53101_A0_CPU2COS_MAPr_t;

#define BCM53101_A0_CPU2COS_MAPr_CLR(r) (r).cpu2cos_map[0] = 0
#define BCM53101_A0_CPU2COS_MAPr_SET(r,d) (r).cpu2cos_map[0] = d
#define BCM53101_A0_CPU2COS_MAPr_GET(r) (r).cpu2cos_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_CPU2COS_MAPr_MIRRORf_GET(r) (((r).cpu2cos_map[0]) & 0x7)
#define BCM53101_A0_CPU2COS_MAPr_MIRRORf_SET(r,f) (r).cpu2cos_map[0]=(((r).cpu2cos_map[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53101_A0_CPU2COS_MAPr_SA_LRNf_GET(r) ((((r).cpu2cos_map[0]) >> 3) & 0x7)
#define BCM53101_A0_CPU2COS_MAPr_SA_LRNf_SET(r,f) (r).cpu2cos_map[0]=(((r).cpu2cos_map[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM53101_A0_CPU2COS_MAPr_SW_FLDf_GET(r) ((((r).cpu2cos_map[0]) >> 6) & 0x7)
#define BCM53101_A0_CPU2COS_MAPr_SW_FLDf_SET(r,f) (r).cpu2cos_map[0]=(((r).cpu2cos_map[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM53101_A0_CPU2COS_MAPr_PRTC_TRMNTf_GET(r) ((((r).cpu2cos_map[0]) >> 9) & 0x7)
#define BCM53101_A0_CPU2COS_MAPr_PRTC_TRMNTf_SET(r,f) (r).cpu2cos_map[0]=(((r).cpu2cos_map[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM53101_A0_CPU2COS_MAPr_PRTC_SNOOPf_GET(r) ((((r).cpu2cos_map[0]) >> 12) & 0x7)
#define BCM53101_A0_CPU2COS_MAPr_PRTC_SNOOPf_SET(r,f) (r).cpu2cos_map[0]=(((r).cpu2cos_map[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53101_A0_CPU2COS_MAPr_EXCPT_PRCSf_GET(r) ((((r).cpu2cos_map[0]) >> 15) & 0x7)
#define BCM53101_A0_CPU2COS_MAPr_EXCPT_PRCSf_SET(r,f) (r).cpu2cos_map[0]=(((r).cpu2cos_map[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM53101_A0_CPU2COS_MAPr_RESERVEDf_GET(r) ((((r).cpu2cos_map[0]) >> 18) & 0x3fff)
#define BCM53101_A0_CPU2COS_MAPr_RESERVEDf_SET(r,f) (r).cpu2cos_map[0]=(((r).cpu2cos_map[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access CPU2COS_MAP.
 *
 */
#define BCM53101_A0_READ_CPU2COS_MAPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_CPU2COS_MAPr,(r._cpu2cos_map),4)
#define BCM53101_A0_WRITE_CPU2COS_MAPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_CPU2COS_MAPr,&(r._cpu2cos_map),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CPU2COS_MAPr BCM53101_A0_CPU2COS_MAPr
#define CPU2COS_MAPr_SIZE BCM53101_A0_CPU2COS_MAPr_SIZE
typedef BCM53101_A0_CPU2COS_MAPr_t CPU2COS_MAPr_t;
#define CPU2COS_MAPr_CLR BCM53101_A0_CPU2COS_MAPr_CLR
#define CPU2COS_MAPr_SET BCM53101_A0_CPU2COS_MAPr_SET
#define CPU2COS_MAPr_GET BCM53101_A0_CPU2COS_MAPr_GET
#define CPU2COS_MAPr_MIRRORf_GET BCM53101_A0_CPU2COS_MAPr_MIRRORf_GET
#define CPU2COS_MAPr_MIRRORf_SET BCM53101_A0_CPU2COS_MAPr_MIRRORf_SET
#define CPU2COS_MAPr_SA_LRNf_GET BCM53101_A0_CPU2COS_MAPr_SA_LRNf_GET
#define CPU2COS_MAPr_SA_LRNf_SET BCM53101_A0_CPU2COS_MAPr_SA_LRNf_SET
#define CPU2COS_MAPr_SW_FLDf_GET BCM53101_A0_CPU2COS_MAPr_SW_FLDf_GET
#define CPU2COS_MAPr_SW_FLDf_SET BCM53101_A0_CPU2COS_MAPr_SW_FLDf_SET
#define CPU2COS_MAPr_PRTC_TRMNTf_GET BCM53101_A0_CPU2COS_MAPr_PRTC_TRMNTf_GET
#define CPU2COS_MAPr_PRTC_TRMNTf_SET BCM53101_A0_CPU2COS_MAPr_PRTC_TRMNTf_SET
#define CPU2COS_MAPr_PRTC_SNOOPf_GET BCM53101_A0_CPU2COS_MAPr_PRTC_SNOOPf_GET
#define CPU2COS_MAPr_PRTC_SNOOPf_SET BCM53101_A0_CPU2COS_MAPr_PRTC_SNOOPf_SET
#define CPU2COS_MAPr_EXCPT_PRCSf_GET BCM53101_A0_CPU2COS_MAPr_EXCPT_PRCSf_GET
#define CPU2COS_MAPr_EXCPT_PRCSf_SET BCM53101_A0_CPU2COS_MAPr_EXCPT_PRCSf_SET
#define CPU2COS_MAPr_RESERVEDf_GET BCM53101_A0_CPU2COS_MAPr_RESERVEDf_GET
#define CPU2COS_MAPr_RESERVEDf_SET BCM53101_A0_CPU2COS_MAPr_RESERVEDf_SET
#define READ_CPU2COS_MAPr BCM53101_A0_READ_CPU2COS_MAPr
#define WRITE_CPU2COS_MAPr BCM53101_A0_WRITE_CPU2COS_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_CPU2COS_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  CTRL_REG
 * BLOCKS:   SYS
 * DESC:     Control Register
 * SIZE:     8
 * FIELDS:
 *     EN_DEBUG         1 : Enable debugging bus
 *     DEBUG_SEL        Debug bus select.
 *     MDC_TIMING_ENH   1'b0 : glitch-free MDC design.1'b1 : MDC design which might have glitch(Falcon implementation)(Not2Release)
 *
 ******************************************************************************/
#define BCM53101_A0_CTRL_REGr 0x0000001e

#define BCM53101_A0_CTRL_REGr_SIZE 1

/*
 * This structure should be used to declare and program CTRL_REG.
 *
 */
typedef union BCM53101_A0_CTRL_REGr_s {
	uint32_t v[1];
	uint32_t ctrl_reg[1];
	uint32_t _ctrl_reg;
} BCM53101_A0_CTRL_REGr_t;

#define BCM53101_A0_CTRL_REGr_CLR(r) (r).ctrl_reg[0] = 0
#define BCM53101_A0_CTRL_REGr_SET(r,d) (r).ctrl_reg[0] = d
#define BCM53101_A0_CTRL_REGr_GET(r) (r).ctrl_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_CTRL_REGr_EN_DEBUGf_GET(r) (((r).ctrl_reg[0]) & 0x1)
#define BCM53101_A0_CTRL_REGr_EN_DEBUGf_SET(r,f) (r).ctrl_reg[0]=(((r).ctrl_reg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_CTRL_REGr_DEBUG_SELf_GET(r) ((((r).ctrl_reg[0]) >> 1) & 0x3f)
#define BCM53101_A0_CTRL_REGr_DEBUG_SELf_SET(r,f) (r).ctrl_reg[0]=(((r).ctrl_reg[0] & ~((uint32_t)0x3f << 1)) | ((((uint32_t)f) & 0x3f) << 1))
#define BCM53101_A0_CTRL_REGr_MDC_TIMING_ENHf_GET(r) ((((r).ctrl_reg[0]) >> 7) & 0x1)
#define BCM53101_A0_CTRL_REGr_MDC_TIMING_ENHf_SET(r,f) (r).ctrl_reg[0]=(((r).ctrl_reg[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access CTRL_REG.
 *
 */
#define BCM53101_A0_READ_CTRL_REGr(u,r) cdk_robo_reg_read(u,BCM53101_A0_CTRL_REGr,(r._ctrl_reg),1)
#define BCM53101_A0_WRITE_CTRL_REGr(u,r) cdk_robo_reg_write(u,BCM53101_A0_CTRL_REGr,&(r._ctrl_reg),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define CTRL_REGr BCM53101_A0_CTRL_REGr
#define CTRL_REGr_SIZE BCM53101_A0_CTRL_REGr_SIZE
typedef BCM53101_A0_CTRL_REGr_t CTRL_REGr_t;
#define CTRL_REGr_CLR BCM53101_A0_CTRL_REGr_CLR
#define CTRL_REGr_SET BCM53101_A0_CTRL_REGr_SET
#define CTRL_REGr_GET BCM53101_A0_CTRL_REGr_GET
#define CTRL_REGr_EN_DEBUGf_GET BCM53101_A0_CTRL_REGr_EN_DEBUGf_GET
#define CTRL_REGr_EN_DEBUGf_SET BCM53101_A0_CTRL_REGr_EN_DEBUGf_SET
#define CTRL_REGr_DEBUG_SELf_GET BCM53101_A0_CTRL_REGr_DEBUG_SELf_GET
#define CTRL_REGr_DEBUG_SELf_SET BCM53101_A0_CTRL_REGr_DEBUG_SELf_SET
#define CTRL_REGr_MDC_TIMING_ENHf_GET BCM53101_A0_CTRL_REGr_MDC_TIMING_ENHf_GET
#define CTRL_REGr_MDC_TIMING_ENHf_SET BCM53101_A0_CTRL_REGr_MDC_TIMING_ENHf_SET
#define READ_CTRL_REGr BCM53101_A0_READ_CTRL_REGr
#define WRITE_CTRL_REGr BCM53101_A0_WRITE_CTRL_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_CTRL_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  DEFAULT_1Q_TAG
 * BLOCKS:   CPIC EPIC0
 * DESC:     802.1Q Default Port Tag Registers
 * SIZE:     16
 * FIELDS:
 *     VID              Default VLAN ID('h0 and 'hfff are illegal setting).When incoming packet is non-1Q tagged frame or priority tagged frame, Default VLAN ID will be used as the VID for the port if VLAN_1Q enabled.
 *     CFI              Canonical Form Indicator (Lotus don't care this bit).
 *     PRI              Default Priority Bit.When incoming packet is non-priority tagged frame or non-1Q  frame, Default Priority Bit will be used as the Priority bit for the port if VLAN_1Q enabled.When Port-Based QOS enabled, the bits will be the default priority for the ingress port.
 *
 ******************************************************************************/
#define BCM53101_A0_DEFAULT_1Q_TAGr 0x00003410

#define BCM53101_A0_DEFAULT_1Q_TAGr_SIZE 2

/*
 * This structure should be used to declare and program DEFAULT_1Q_TAG.
 *
 */
typedef union BCM53101_A0_DEFAULT_1Q_TAGr_s {
	uint32_t v[1];
	uint32_t default_1q_tag[1];
	uint32_t _default_1q_tag;
} BCM53101_A0_DEFAULT_1Q_TAGr_t;

#define BCM53101_A0_DEFAULT_1Q_TAGr_CLR(r) (r).default_1q_tag[0] = 0
#define BCM53101_A0_DEFAULT_1Q_TAGr_SET(r,d) (r).default_1q_tag[0] = d
#define BCM53101_A0_DEFAULT_1Q_TAGr_GET(r) (r).default_1q_tag[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_DEFAULT_1Q_TAGr_VIDf_GET(r) (((r).default_1q_tag[0]) & 0xfff)
#define BCM53101_A0_DEFAULT_1Q_TAGr_VIDf_SET(r,f) (r).default_1q_tag[0]=(((r).default_1q_tag[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53101_A0_DEFAULT_1Q_TAGr_CFIf_GET(r) ((((r).default_1q_tag[0]) >> 12) & 0x1)
#define BCM53101_A0_DEFAULT_1Q_TAGr_CFIf_SET(r,f) (r).default_1q_tag[0]=(((r).default_1q_tag[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53101_A0_DEFAULT_1Q_TAGr_PRIf_GET(r) ((((r).default_1q_tag[0]) >> 13) & 0x7)
#define BCM53101_A0_DEFAULT_1Q_TAGr_PRIf_SET(r,f) (r).default_1q_tag[0]=(((r).default_1q_tag[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access DEFAULT_1Q_TAG.
 *
 */
#define BCM53101_A0_READ_DEFAULT_1Q_TAGr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_DEFAULT_1Q_TAGr,(r._default_1q_tag),2)
#define BCM53101_A0_WRITE_DEFAULT_1Q_TAGr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_DEFAULT_1Q_TAGr,&(r._default_1q_tag),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DEFAULT_1Q_TAGr BCM53101_A0_DEFAULT_1Q_TAGr
#define DEFAULT_1Q_TAGr_SIZE BCM53101_A0_DEFAULT_1Q_TAGr_SIZE
typedef BCM53101_A0_DEFAULT_1Q_TAGr_t DEFAULT_1Q_TAGr_t;
#define DEFAULT_1Q_TAGr_CLR BCM53101_A0_DEFAULT_1Q_TAGr_CLR
#define DEFAULT_1Q_TAGr_SET BCM53101_A0_DEFAULT_1Q_TAGr_SET
#define DEFAULT_1Q_TAGr_GET BCM53101_A0_DEFAULT_1Q_TAGr_GET
#define DEFAULT_1Q_TAGr_VIDf_GET BCM53101_A0_DEFAULT_1Q_TAGr_VIDf_GET
#define DEFAULT_1Q_TAGr_VIDf_SET BCM53101_A0_DEFAULT_1Q_TAGr_VIDf_SET
#define DEFAULT_1Q_TAGr_CFIf_GET BCM53101_A0_DEFAULT_1Q_TAGr_CFIf_GET
#define DEFAULT_1Q_TAGr_CFIf_SET BCM53101_A0_DEFAULT_1Q_TAGr_CFIf_SET
#define DEFAULT_1Q_TAGr_PRIf_GET BCM53101_A0_DEFAULT_1Q_TAGr_PRIf_GET
#define DEFAULT_1Q_TAGr_PRIf_SET BCM53101_A0_DEFAULT_1Q_TAGr_PRIf_SET
#define READ_DEFAULT_1Q_TAGr BCM53101_A0_READ_DEFAULT_1Q_TAGr
#define WRITE_DEFAULT_1Q_TAGr BCM53101_A0_WRITE_DEFAULT_1Q_TAGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_DEFAULT_1Q_TAGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  DEFAULT_1Q_TAG_IMP
 * BLOCKS:   CPIC
 * DESC:     802.1Q Default Port 8 Tag Registers
 * SIZE:     16
 * FIELDS:
 *     VID              Default VLAN ID.When incoming packet is non-1Q tagged frame or priority tagged frame, Default VLAN ID will be used as the VID for the port if VLAN_1Q enabled.
 *     CFI              Canonical Form Indicator (Lotus don't care this bit).
 *     PRI              Default Priority Bit.When incoming packet is non-priority tagged frame or non-1Q  frame, Default Priority Bit will be used as the Priority bit for the port if VLAN_1Q enabled.When Port-Based QOS enabled, the bits will be the default priority for the ingress port.
 *
 ******************************************************************************/
#define BCM53101_A0_DEFAULT_1Q_TAG_IMPr 0x00003420

#define BCM53101_A0_DEFAULT_1Q_TAG_IMPr_SIZE 2

/*
 * This structure should be used to declare and program DEFAULT_1Q_TAG_IMP.
 *
 */
typedef union BCM53101_A0_DEFAULT_1Q_TAG_IMPr_s {
	uint32_t v[1];
	uint32_t default_1q_tag_imp[1];
	uint32_t _default_1q_tag_imp;
} BCM53101_A0_DEFAULT_1Q_TAG_IMPr_t;

#define BCM53101_A0_DEFAULT_1Q_TAG_IMPr_CLR(r) (r).default_1q_tag_imp[0] = 0
#define BCM53101_A0_DEFAULT_1Q_TAG_IMPr_SET(r,d) (r).default_1q_tag_imp[0] = d
#define BCM53101_A0_DEFAULT_1Q_TAG_IMPr_GET(r) (r).default_1q_tag_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_DEFAULT_1Q_TAG_IMPr_VIDf_GET(r) (((r).default_1q_tag_imp[0]) & 0xfff)
#define BCM53101_A0_DEFAULT_1Q_TAG_IMPr_VIDf_SET(r,f) (r).default_1q_tag_imp[0]=(((r).default_1q_tag_imp[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53101_A0_DEFAULT_1Q_TAG_IMPr_CFIf_GET(r) ((((r).default_1q_tag_imp[0]) >> 12) & 0x1)
#define BCM53101_A0_DEFAULT_1Q_TAG_IMPr_CFIf_SET(r,f) (r).default_1q_tag_imp[0]=(((r).default_1q_tag_imp[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53101_A0_DEFAULT_1Q_TAG_IMPr_PRIf_GET(r) ((((r).default_1q_tag_imp[0]) >> 13) & 0x7)
#define BCM53101_A0_DEFAULT_1Q_TAG_IMPr_PRIf_SET(r,f) (r).default_1q_tag_imp[0]=(((r).default_1q_tag_imp[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access DEFAULT_1Q_TAG_IMP.
 *
 */
#define BCM53101_A0_READ_DEFAULT_1Q_TAG_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_DEFAULT_1Q_TAG_IMPr,(r._default_1q_tag_imp),2)
#define BCM53101_A0_WRITE_DEFAULT_1Q_TAG_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_DEFAULT_1Q_TAG_IMPr,&(r._default_1q_tag_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DEFAULT_1Q_TAG_IMPr BCM53101_A0_DEFAULT_1Q_TAG_IMPr
#define DEFAULT_1Q_TAG_IMPr_SIZE BCM53101_A0_DEFAULT_1Q_TAG_IMPr_SIZE
typedef BCM53101_A0_DEFAULT_1Q_TAG_IMPr_t DEFAULT_1Q_TAG_IMPr_t;
#define DEFAULT_1Q_TAG_IMPr_CLR BCM53101_A0_DEFAULT_1Q_TAG_IMPr_CLR
#define DEFAULT_1Q_TAG_IMPr_SET BCM53101_A0_DEFAULT_1Q_TAG_IMPr_SET
#define DEFAULT_1Q_TAG_IMPr_GET BCM53101_A0_DEFAULT_1Q_TAG_IMPr_GET
#define DEFAULT_1Q_TAG_IMPr_VIDf_GET BCM53101_A0_DEFAULT_1Q_TAG_IMPr_VIDf_GET
#define DEFAULT_1Q_TAG_IMPr_VIDf_SET BCM53101_A0_DEFAULT_1Q_TAG_IMPr_VIDf_SET
#define DEFAULT_1Q_TAG_IMPr_CFIf_GET BCM53101_A0_DEFAULT_1Q_TAG_IMPr_CFIf_GET
#define DEFAULT_1Q_TAG_IMPr_CFIf_SET BCM53101_A0_DEFAULT_1Q_TAG_IMPr_CFIf_SET
#define DEFAULT_1Q_TAG_IMPr_PRIf_GET BCM53101_A0_DEFAULT_1Q_TAG_IMPr_PRIf_GET
#define DEFAULT_1Q_TAG_IMPr_PRIf_SET BCM53101_A0_DEFAULT_1Q_TAG_IMPr_PRIf_SET
#define READ_DEFAULT_1Q_TAG_IMPr BCM53101_A0_READ_DEFAULT_1Q_TAG_IMPr
#define WRITE_DEFAULT_1Q_TAG_IMPr BCM53101_A0_WRITE_DEFAULT_1Q_TAG_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_DEFAULT_1Q_TAG_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  DIRECT_CTRL_PIN
 * BLOCKS:   SYS
 * DESC:     Direct input control value register
 * SIZE:     32
 * FIELDS:
 *     PUP_LED1B        pup_led1b
 *     PUP_LED0C        pup_led0c
 *     PUP_LED1C        pup_led1c
 *     PUP_LED2C        pup_led2c
 *     PUP_LED3C        pup_led3c
 *     PUP_LED4C        pup_led4c
 *     PUP_LEDDATA      pu[_leddata
 *     PUP_LEDCLK       pup_ledclk
 *     PUP_MII1_MODE0   pup_mii1_mode0
 *     PUP_MII1_MODE1   pup_mii1_mode1
 *     PUP_MII1_MODE2   pup_mii1_mode2
 *     PUP_MII2_MODE0   pup_mii2_mode0
 *     PUP_MII2_MODE1   pup_mii2_mode1
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_DIRECT_CTRL_PINr 0x00000180

#define BCM53101_A0_DIRECT_CTRL_PINr_SIZE 4

/*
 * This structure should be used to declare and program DIRECT_CTRL_PIN.
 *
 */
typedef union BCM53101_A0_DIRECT_CTRL_PINr_s {
	uint32_t v[1];
	uint32_t direct_ctrl_pin[1];
	uint32_t _direct_ctrl_pin;
} BCM53101_A0_DIRECT_CTRL_PINr_t;

#define BCM53101_A0_DIRECT_CTRL_PINr_CLR(r) (r).direct_ctrl_pin[0] = 0
#define BCM53101_A0_DIRECT_CTRL_PINr_SET(r,d) (r).direct_ctrl_pin[0] = d
#define BCM53101_A0_DIRECT_CTRL_PINr_GET(r) (r).direct_ctrl_pin[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_DIRECT_CTRL_PINr_PUP_LED1Bf_GET(r) (((r).direct_ctrl_pin[0]) & 0x1)
#define BCM53101_A0_DIRECT_CTRL_PINr_PUP_LED1Bf_SET(r,f) (r).direct_ctrl_pin[0]=(((r).direct_ctrl_pin[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_DIRECT_CTRL_PINr_PUP_LED0Cf_GET(r) ((((r).direct_ctrl_pin[0]) >> 1) & 0x1)
#define BCM53101_A0_DIRECT_CTRL_PINr_PUP_LED0Cf_SET(r,f) (r).direct_ctrl_pin[0]=(((r).direct_ctrl_pin[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_DIRECT_CTRL_PINr_PUP_LED1Cf_GET(r) ((((r).direct_ctrl_pin[0]) >> 2) & 0x1)
#define BCM53101_A0_DIRECT_CTRL_PINr_PUP_LED1Cf_SET(r,f) (r).direct_ctrl_pin[0]=(((r).direct_ctrl_pin[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_DIRECT_CTRL_PINr_PUP_LED2Cf_GET(r) ((((r).direct_ctrl_pin[0]) >> 3) & 0x1)
#define BCM53101_A0_DIRECT_CTRL_PINr_PUP_LED2Cf_SET(r,f) (r).direct_ctrl_pin[0]=(((r).direct_ctrl_pin[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_DIRECT_CTRL_PINr_PUP_LED3Cf_GET(r) ((((r).direct_ctrl_pin[0]) >> 4) & 0x1)
#define BCM53101_A0_DIRECT_CTRL_PINr_PUP_LED3Cf_SET(r,f) (r).direct_ctrl_pin[0]=(((r).direct_ctrl_pin[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_DIRECT_CTRL_PINr_PUP_LED4Cf_GET(r) ((((r).direct_ctrl_pin[0]) >> 5) & 0x1)
#define BCM53101_A0_DIRECT_CTRL_PINr_PUP_LED4Cf_SET(r,f) (r).direct_ctrl_pin[0]=(((r).direct_ctrl_pin[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_DIRECT_CTRL_PINr_PUP_LEDDATAf_GET(r) ((((r).direct_ctrl_pin[0]) >> 6) & 0x1)
#define BCM53101_A0_DIRECT_CTRL_PINr_PUP_LEDDATAf_SET(r,f) (r).direct_ctrl_pin[0]=(((r).direct_ctrl_pin[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_DIRECT_CTRL_PINr_PUP_LEDCLKf_GET(r) ((((r).direct_ctrl_pin[0]) >> 7) & 0x1)
#define BCM53101_A0_DIRECT_CTRL_PINr_PUP_LEDCLKf_SET(r,f) (r).direct_ctrl_pin[0]=(((r).direct_ctrl_pin[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53101_A0_DIRECT_CTRL_PINr_PUP_MII1_MODE0f_GET(r) ((((r).direct_ctrl_pin[0]) >> 8) & 0x1)
#define BCM53101_A0_DIRECT_CTRL_PINr_PUP_MII1_MODE0f_SET(r,f) (r).direct_ctrl_pin[0]=(((r).direct_ctrl_pin[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53101_A0_DIRECT_CTRL_PINr_PUP_MII1_MODE1f_GET(r) ((((r).direct_ctrl_pin[0]) >> 9) & 0x1)
#define BCM53101_A0_DIRECT_CTRL_PINr_PUP_MII1_MODE1f_SET(r,f) (r).direct_ctrl_pin[0]=(((r).direct_ctrl_pin[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53101_A0_DIRECT_CTRL_PINr_PUP_MII1_MODE2f_GET(r) ((((r).direct_ctrl_pin[0]) >> 10) & 0x1)
#define BCM53101_A0_DIRECT_CTRL_PINr_PUP_MII1_MODE2f_SET(r,f) (r).direct_ctrl_pin[0]=(((r).direct_ctrl_pin[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53101_A0_DIRECT_CTRL_PINr_PUP_MII2_MODE0f_GET(r) ((((r).direct_ctrl_pin[0]) >> 11) & 0x1)
#define BCM53101_A0_DIRECT_CTRL_PINr_PUP_MII2_MODE0f_SET(r,f) (r).direct_ctrl_pin[0]=(((r).direct_ctrl_pin[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53101_A0_DIRECT_CTRL_PINr_PUP_MII2_MODE1f_GET(r) ((((r).direct_ctrl_pin[0]) >> 12) & 0x1)
#define BCM53101_A0_DIRECT_CTRL_PINr_PUP_MII2_MODE1f_SET(r,f) (r).direct_ctrl_pin[0]=(((r).direct_ctrl_pin[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53101_A0_DIRECT_CTRL_PINr_RESERVEDf_GET(r) ((((r).direct_ctrl_pin[0]) >> 13) & 0x7ffff)
#define BCM53101_A0_DIRECT_CTRL_PINr_RESERVEDf_SET(r,f) (r).direct_ctrl_pin[0]=(((r).direct_ctrl_pin[0] & ~((uint32_t)0x7ffff << 13)) | ((((uint32_t)f) & 0x7ffff) << 13))

/*
 * These macros can be used to access DIRECT_CTRL_PIN.
 *
 */
#define BCM53101_A0_READ_DIRECT_CTRL_PINr(u,r) cdk_robo_reg_read(u,BCM53101_A0_DIRECT_CTRL_PINr,(r._direct_ctrl_pin),4)
#define BCM53101_A0_WRITE_DIRECT_CTRL_PINr(u,r) cdk_robo_reg_write(u,BCM53101_A0_DIRECT_CTRL_PINr,&(r._direct_ctrl_pin),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DIRECT_CTRL_PINr BCM53101_A0_DIRECT_CTRL_PINr
#define DIRECT_CTRL_PINr_SIZE BCM53101_A0_DIRECT_CTRL_PINr_SIZE
typedef BCM53101_A0_DIRECT_CTRL_PINr_t DIRECT_CTRL_PINr_t;
#define DIRECT_CTRL_PINr_CLR BCM53101_A0_DIRECT_CTRL_PINr_CLR
#define DIRECT_CTRL_PINr_SET BCM53101_A0_DIRECT_CTRL_PINr_SET
#define DIRECT_CTRL_PINr_GET BCM53101_A0_DIRECT_CTRL_PINr_GET
#define DIRECT_CTRL_PINr_PUP_LED1Bf_GET BCM53101_A0_DIRECT_CTRL_PINr_PUP_LED1Bf_GET
#define DIRECT_CTRL_PINr_PUP_LED1Bf_SET BCM53101_A0_DIRECT_CTRL_PINr_PUP_LED1Bf_SET
#define DIRECT_CTRL_PINr_PUP_LED0Cf_GET BCM53101_A0_DIRECT_CTRL_PINr_PUP_LED0Cf_GET
#define DIRECT_CTRL_PINr_PUP_LED0Cf_SET BCM53101_A0_DIRECT_CTRL_PINr_PUP_LED0Cf_SET
#define DIRECT_CTRL_PINr_PUP_LED1Cf_GET BCM53101_A0_DIRECT_CTRL_PINr_PUP_LED1Cf_GET
#define DIRECT_CTRL_PINr_PUP_LED1Cf_SET BCM53101_A0_DIRECT_CTRL_PINr_PUP_LED1Cf_SET
#define DIRECT_CTRL_PINr_PUP_LED2Cf_GET BCM53101_A0_DIRECT_CTRL_PINr_PUP_LED2Cf_GET
#define DIRECT_CTRL_PINr_PUP_LED2Cf_SET BCM53101_A0_DIRECT_CTRL_PINr_PUP_LED2Cf_SET
#define DIRECT_CTRL_PINr_PUP_LED3Cf_GET BCM53101_A0_DIRECT_CTRL_PINr_PUP_LED3Cf_GET
#define DIRECT_CTRL_PINr_PUP_LED3Cf_SET BCM53101_A0_DIRECT_CTRL_PINr_PUP_LED3Cf_SET
#define DIRECT_CTRL_PINr_PUP_LED4Cf_GET BCM53101_A0_DIRECT_CTRL_PINr_PUP_LED4Cf_GET
#define DIRECT_CTRL_PINr_PUP_LED4Cf_SET BCM53101_A0_DIRECT_CTRL_PINr_PUP_LED4Cf_SET
#define DIRECT_CTRL_PINr_PUP_LEDDATAf_GET BCM53101_A0_DIRECT_CTRL_PINr_PUP_LEDDATAf_GET
#define DIRECT_CTRL_PINr_PUP_LEDDATAf_SET BCM53101_A0_DIRECT_CTRL_PINr_PUP_LEDDATAf_SET
#define DIRECT_CTRL_PINr_PUP_LEDCLKf_GET BCM53101_A0_DIRECT_CTRL_PINr_PUP_LEDCLKf_GET
#define DIRECT_CTRL_PINr_PUP_LEDCLKf_SET BCM53101_A0_DIRECT_CTRL_PINr_PUP_LEDCLKf_SET
#define DIRECT_CTRL_PINr_PUP_MII1_MODE0f_GET BCM53101_A0_DIRECT_CTRL_PINr_PUP_MII1_MODE0f_GET
#define DIRECT_CTRL_PINr_PUP_MII1_MODE0f_SET BCM53101_A0_DIRECT_CTRL_PINr_PUP_MII1_MODE0f_SET
#define DIRECT_CTRL_PINr_PUP_MII1_MODE1f_GET BCM53101_A0_DIRECT_CTRL_PINr_PUP_MII1_MODE1f_GET
#define DIRECT_CTRL_PINr_PUP_MII1_MODE1f_SET BCM53101_A0_DIRECT_CTRL_PINr_PUP_MII1_MODE1f_SET
#define DIRECT_CTRL_PINr_PUP_MII1_MODE2f_GET BCM53101_A0_DIRECT_CTRL_PINr_PUP_MII1_MODE2f_GET
#define DIRECT_CTRL_PINr_PUP_MII1_MODE2f_SET BCM53101_A0_DIRECT_CTRL_PINr_PUP_MII1_MODE2f_SET
#define DIRECT_CTRL_PINr_PUP_MII2_MODE0f_GET BCM53101_A0_DIRECT_CTRL_PINr_PUP_MII2_MODE0f_GET
#define DIRECT_CTRL_PINr_PUP_MII2_MODE0f_SET BCM53101_A0_DIRECT_CTRL_PINr_PUP_MII2_MODE0f_SET
#define DIRECT_CTRL_PINr_PUP_MII2_MODE1f_GET BCM53101_A0_DIRECT_CTRL_PINr_PUP_MII2_MODE1f_GET
#define DIRECT_CTRL_PINr_PUP_MII2_MODE1f_SET BCM53101_A0_DIRECT_CTRL_PINr_PUP_MII2_MODE1f_SET
#define DIRECT_CTRL_PINr_RESERVEDf_GET BCM53101_A0_DIRECT_CTRL_PINr_RESERVEDf_GET
#define DIRECT_CTRL_PINr_RESERVEDf_SET BCM53101_A0_DIRECT_CTRL_PINr_RESERVEDf_SET
#define READ_DIRECT_CTRL_PINr BCM53101_A0_READ_DIRECT_CTRL_PINr
#define WRITE_DIRECT_CTRL_PINr BCM53101_A0_WRITE_DIRECT_CTRL_PINr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_DIRECT_CTRL_PINr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  DIS_LEARN
 * BLOCKS:   SYS
 * DESC:     Disable Learning Registrer
 * SIZE:     16
 * FIELDS:
 *     DIS_LEARN        bit[8] : Port 8.bit[5:0] : Port 5-01 : Disable learning, when disable, the hardware won't do the following items:	a. learn entries to ARL.	b. refresh entries to ARL.	c. support software learning.0 : Enable Learning.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_DIS_LEARNr 0x0000003c

#define BCM53101_A0_DIS_LEARNr_SIZE 2

/*
 * This structure should be used to declare and program DIS_LEARN.
 *
 */
typedef union BCM53101_A0_DIS_LEARNr_s {
	uint32_t v[1];
	uint32_t dis_learn[1];
	uint32_t _dis_learn;
} BCM53101_A0_DIS_LEARNr_t;

#define BCM53101_A0_DIS_LEARNr_CLR(r) (r).dis_learn[0] = 0
#define BCM53101_A0_DIS_LEARNr_SET(r,d) (r).dis_learn[0] = d
#define BCM53101_A0_DIS_LEARNr_GET(r) (r).dis_learn[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_DIS_LEARNr_DIS_LEARNf_GET(r) (((r).dis_learn[0]) & 0x1ff)
#define BCM53101_A0_DIS_LEARNr_DIS_LEARNf_SET(r,f) (r).dis_learn[0]=(((r).dis_learn[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_DIS_LEARNr_RESERVEDf_GET(r) ((((r).dis_learn[0]) >> 9) & 0x7f)
#define BCM53101_A0_DIS_LEARNr_RESERVEDf_SET(r,f) (r).dis_learn[0]=(((r).dis_learn[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access DIS_LEARN.
 *
 */
#define BCM53101_A0_READ_DIS_LEARNr(u,r) cdk_robo_reg_read(u,BCM53101_A0_DIS_LEARNr,(r._dis_learn),2)
#define BCM53101_A0_WRITE_DIS_LEARNr(u,r) cdk_robo_reg_write(u,BCM53101_A0_DIS_LEARNr,&(r._dis_learn),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DIS_LEARNr BCM53101_A0_DIS_LEARNr
#define DIS_LEARNr_SIZE BCM53101_A0_DIS_LEARNr_SIZE
typedef BCM53101_A0_DIS_LEARNr_t DIS_LEARNr_t;
#define DIS_LEARNr_CLR BCM53101_A0_DIS_LEARNr_CLR
#define DIS_LEARNr_SET BCM53101_A0_DIS_LEARNr_SET
#define DIS_LEARNr_GET BCM53101_A0_DIS_LEARNr_GET
#define DIS_LEARNr_DIS_LEARNf_GET BCM53101_A0_DIS_LEARNr_DIS_LEARNf_GET
#define DIS_LEARNr_DIS_LEARNf_SET BCM53101_A0_DIS_LEARNr_DIS_LEARNf_SET
#define DIS_LEARNr_RESERVEDf_GET BCM53101_A0_DIS_LEARNr_RESERVEDf_GET
#define DIS_LEARNr_RESERVEDf_SET BCM53101_A0_DIS_LEARNr_RESERVEDf_SET
#define READ_DIS_LEARNr BCM53101_A0_READ_DIS_LEARNr
#define WRITE_DIS_LEARNr BCM53101_A0_WRITE_DIS_LEARNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_DIS_LEARNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  DOS_CTRL
 * BLOCKS:   SYS
 * DESC:     DoS Control RegisterRegister
 * SIZE:     32
 * FIELDS:
 *     RESERVED         
 *     IP_LAND_DROP_EN  IP_LAND:IPDA=IPSA in an IP(v4/v6) datagram.1= Drop the specified packet0= Do not drop
 *     TCP_BLAT_DROP_EN TCP_BLAT:DPort=SPort in a TCP header carried in an unfragmented IP datagram or in the first fragment of a fragmented IP datagram.1= Drop the specified packet0= Do not drop
 *     UDP_BLAT_DROP_EN UDP_BLAT:DPport=SPort in a UDP header carried in an unfragmented IP datagram or in the first fragment of a fragmented IP datagram. 1= Drop the specified packet0= Do not drop
 *     TCP_NULL_SCAN_DROP_EN TCP_NULLScan:Seq_Num=0 & All TCP_FLAGs=0, in a TCP header carried in an unfragmented IP datagram or in the first fragment of a fragmented IP datagram.1= Drop the specified packet0= Do not drop
 *     TCP_XMASS_SCAN_DROP_EN TCP_XMASScan:Seq_Num=0 & FIN=1 & URG=1 & PSH=1 in a TCP header carried in an unfragmented IP datagram or in the first fragment of a fragmented IP datagram.1= Drop the specified packet0= Do not drop
 *     TCP_SYNFIN_SCAN_DROP_EN TCP_SYNFINScan:SYN=1 & FIN=1 in a TCP header carried in an unfragmented IP datagram or in the first fragment of a fragmented IP datagram.  1= Drop the specified packet0= Do not drop
 *     TCP_SYN_ERR_DROP_EN TCP_SYNError:SYN=1 & ACK=0 & SRC_Port<1024 in a TCP header carried in an unfragmented IP datagram or in the first fragment of a fragmented IP datagram.1= Drop the specified packet0= Do not drop
 *     TCP_SHORT_HDR_DROP_EN TCP_ShortHDR:The length of a TCP header carried in an unfragmented IP datagram or the first fragment of a fragmented IP datagram is less than MIN_TCP_Header_Size.1= Drop the specified packet0= Do not drop
 *     TCP_FRAG_ERR_DROP_EN TCP_FragError:The Fragment_Offset=1 in any fragment of a fragmented IP datagram carring part of TCP data.1= Drop the specified packet0= Do not drop
 *     ICMPV4_FRAGMENT_DROP_EN ICMPv4_Fragment:The ICMPv4 protocol data unit carrier in a fragmented IPv4 datagram.1= Drop the specified packet0= Do not drop
 *     ICMPV6_FRAGMENT_DROP_EN ICMPv6_Fragment:The ICMPv6 protocol data unit carrier in a fragmented IPv6 datagram.1= Drop the specified packet 0= Do not drop
 *     ICMPV4_LONG_PING_DROP_EN ICMPv4_LongPing:The ICMPv4 Ping(Echo Request) protocol data unit carried in an unfragmented IPv4 datagram with its Payload Length indicating a value greater than the MAX_ICMPv4_Size + size of IPv4 heater.1= Drop the specified packet0= Do not drop
 *     ICMPV6_LONG_PING_DROP_EN ICMPv6_LongPing:The ICMPv6 Ping(Echo Request) protocol data unit carried in an unfragmented IPv6 datagram with its Payload Length indicating a value greater than the MAX_ICMPv6_Size.1= Drop the specified packet0= Do not drop
 *
 ******************************************************************************/
#define BCM53101_A0_DOS_CTRLr 0x00003600

#define BCM53101_A0_DOS_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program DOS_CTRL.
 *
 */
typedef union BCM53101_A0_DOS_CTRLr_s {
	uint32_t v[1];
	uint32_t dos_ctrl[1];
	uint32_t _dos_ctrl;
} BCM53101_A0_DOS_CTRLr_t;

#define BCM53101_A0_DOS_CTRLr_CLR(r) (r).dos_ctrl[0] = 0
#define BCM53101_A0_DOS_CTRLr_SET(r,d) (r).dos_ctrl[0] = d
#define BCM53101_A0_DOS_CTRLr_GET(r) (r).dos_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_DOS_CTRLr_RESERVEDf_GET(r) (((r).dos_ctrl[0]) & 0x1)
#define BCM53101_A0_DOS_CTRLr_RESERVEDf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_DOS_CTRLr_IP_LAND_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 1) & 0x1)
#define BCM53101_A0_DOS_CTRLr_IP_LAND_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_DOS_CTRLr_TCP_BLAT_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 2) & 0x1)
#define BCM53101_A0_DOS_CTRLr_TCP_BLAT_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_DOS_CTRLr_UDP_BLAT_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 3) & 0x1)
#define BCM53101_A0_DOS_CTRLr_UDP_BLAT_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_DOS_CTRLr_TCP_NULL_SCAN_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 4) & 0x1)
#define BCM53101_A0_DOS_CTRLr_TCP_NULL_SCAN_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_DOS_CTRLr_TCP_XMASS_SCAN_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 5) & 0x1)
#define BCM53101_A0_DOS_CTRLr_TCP_XMASS_SCAN_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_DOS_CTRLr_TCP_SYNFIN_SCAN_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 6) & 0x1)
#define BCM53101_A0_DOS_CTRLr_TCP_SYNFIN_SCAN_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_DOS_CTRLr_TCP_SYN_ERR_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 7) & 0x1)
#define BCM53101_A0_DOS_CTRLr_TCP_SYN_ERR_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53101_A0_DOS_CTRLr_TCP_SHORT_HDR_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 8) & 0x1)
#define BCM53101_A0_DOS_CTRLr_TCP_SHORT_HDR_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53101_A0_DOS_CTRLr_TCP_FRAG_ERR_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 9) & 0x1)
#define BCM53101_A0_DOS_CTRLr_TCP_FRAG_ERR_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53101_A0_DOS_CTRLr_ICMPV4_FRAGMENT_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 10) & 0x1)
#define BCM53101_A0_DOS_CTRLr_ICMPV4_FRAGMENT_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53101_A0_DOS_CTRLr_ICMPV6_FRAGMENT_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 11) & 0x1)
#define BCM53101_A0_DOS_CTRLr_ICMPV6_FRAGMENT_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53101_A0_DOS_CTRLr_ICMPV4_LONG_PING_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 12) & 0x1)
#define BCM53101_A0_DOS_CTRLr_ICMPV4_LONG_PING_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53101_A0_DOS_CTRLr_ICMPV6_LONG_PING_DROP_ENf_GET(r) ((((r).dos_ctrl[0]) >> 13) & 0x1)
#define BCM53101_A0_DOS_CTRLr_ICMPV6_LONG_PING_DROP_ENf_SET(r,f) (r).dos_ctrl[0]=(((r).dos_ctrl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))

/*
 * These macros can be used to access DOS_CTRL.
 *
 */
#define BCM53101_A0_READ_DOS_CTRLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_DOS_CTRLr,(r._dos_ctrl),4)
#define BCM53101_A0_WRITE_DOS_CTRLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_DOS_CTRLr,&(r._dos_ctrl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DOS_CTRLr BCM53101_A0_DOS_CTRLr
#define DOS_CTRLr_SIZE BCM53101_A0_DOS_CTRLr_SIZE
typedef BCM53101_A0_DOS_CTRLr_t DOS_CTRLr_t;
#define DOS_CTRLr_CLR BCM53101_A0_DOS_CTRLr_CLR
#define DOS_CTRLr_SET BCM53101_A0_DOS_CTRLr_SET
#define DOS_CTRLr_GET BCM53101_A0_DOS_CTRLr_GET
#define DOS_CTRLr_RESERVEDf_GET BCM53101_A0_DOS_CTRLr_RESERVEDf_GET
#define DOS_CTRLr_RESERVEDf_SET BCM53101_A0_DOS_CTRLr_RESERVEDf_SET
#define DOS_CTRLr_IP_LAND_DROP_ENf_GET BCM53101_A0_DOS_CTRLr_IP_LAND_DROP_ENf_GET
#define DOS_CTRLr_IP_LAND_DROP_ENf_SET BCM53101_A0_DOS_CTRLr_IP_LAND_DROP_ENf_SET
#define DOS_CTRLr_TCP_BLAT_DROP_ENf_GET BCM53101_A0_DOS_CTRLr_TCP_BLAT_DROP_ENf_GET
#define DOS_CTRLr_TCP_BLAT_DROP_ENf_SET BCM53101_A0_DOS_CTRLr_TCP_BLAT_DROP_ENf_SET
#define DOS_CTRLr_UDP_BLAT_DROP_ENf_GET BCM53101_A0_DOS_CTRLr_UDP_BLAT_DROP_ENf_GET
#define DOS_CTRLr_UDP_BLAT_DROP_ENf_SET BCM53101_A0_DOS_CTRLr_UDP_BLAT_DROP_ENf_SET
#define DOS_CTRLr_TCP_NULL_SCAN_DROP_ENf_GET BCM53101_A0_DOS_CTRLr_TCP_NULL_SCAN_DROP_ENf_GET
#define DOS_CTRLr_TCP_NULL_SCAN_DROP_ENf_SET BCM53101_A0_DOS_CTRLr_TCP_NULL_SCAN_DROP_ENf_SET
#define DOS_CTRLr_TCP_XMASS_SCAN_DROP_ENf_GET BCM53101_A0_DOS_CTRLr_TCP_XMASS_SCAN_DROP_ENf_GET
#define DOS_CTRLr_TCP_XMASS_SCAN_DROP_ENf_SET BCM53101_A0_DOS_CTRLr_TCP_XMASS_SCAN_DROP_ENf_SET
#define DOS_CTRLr_TCP_SYNFIN_SCAN_DROP_ENf_GET BCM53101_A0_DOS_CTRLr_TCP_SYNFIN_SCAN_DROP_ENf_GET
#define DOS_CTRLr_TCP_SYNFIN_SCAN_DROP_ENf_SET BCM53101_A0_DOS_CTRLr_TCP_SYNFIN_SCAN_DROP_ENf_SET
#define DOS_CTRLr_TCP_SYN_ERR_DROP_ENf_GET BCM53101_A0_DOS_CTRLr_TCP_SYN_ERR_DROP_ENf_GET
#define DOS_CTRLr_TCP_SYN_ERR_DROP_ENf_SET BCM53101_A0_DOS_CTRLr_TCP_SYN_ERR_DROP_ENf_SET
#define DOS_CTRLr_TCP_SHORT_HDR_DROP_ENf_GET BCM53101_A0_DOS_CTRLr_TCP_SHORT_HDR_DROP_ENf_GET
#define DOS_CTRLr_TCP_SHORT_HDR_DROP_ENf_SET BCM53101_A0_DOS_CTRLr_TCP_SHORT_HDR_DROP_ENf_SET
#define DOS_CTRLr_TCP_FRAG_ERR_DROP_ENf_GET BCM53101_A0_DOS_CTRLr_TCP_FRAG_ERR_DROP_ENf_GET
#define DOS_CTRLr_TCP_FRAG_ERR_DROP_ENf_SET BCM53101_A0_DOS_CTRLr_TCP_FRAG_ERR_DROP_ENf_SET
#define DOS_CTRLr_ICMPV4_FRAGMENT_DROP_ENf_GET BCM53101_A0_DOS_CTRLr_ICMPV4_FRAGMENT_DROP_ENf_GET
#define DOS_CTRLr_ICMPV4_FRAGMENT_DROP_ENf_SET BCM53101_A0_DOS_CTRLr_ICMPV4_FRAGMENT_DROP_ENf_SET
#define DOS_CTRLr_ICMPV6_FRAGMENT_DROP_ENf_GET BCM53101_A0_DOS_CTRLr_ICMPV6_FRAGMENT_DROP_ENf_GET
#define DOS_CTRLr_ICMPV6_FRAGMENT_DROP_ENf_SET BCM53101_A0_DOS_CTRLr_ICMPV6_FRAGMENT_DROP_ENf_SET
#define DOS_CTRLr_ICMPV4_LONG_PING_DROP_ENf_GET BCM53101_A0_DOS_CTRLr_ICMPV4_LONG_PING_DROP_ENf_GET
#define DOS_CTRLr_ICMPV4_LONG_PING_DROP_ENf_SET BCM53101_A0_DOS_CTRLr_ICMPV4_LONG_PING_DROP_ENf_SET
#define DOS_CTRLr_ICMPV6_LONG_PING_DROP_ENf_GET BCM53101_A0_DOS_CTRLr_ICMPV6_LONG_PING_DROP_ENf_GET
#define DOS_CTRLr_ICMPV6_LONG_PING_DROP_ENf_SET BCM53101_A0_DOS_CTRLr_ICMPV6_LONG_PING_DROP_ENf_SET
#define READ_DOS_CTRLr BCM53101_A0_READ_DOS_CTRLr
#define WRITE_DOS_CTRLr BCM53101_A0_WRITE_DOS_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_DOS_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  DOS_DIS_LRN_REG
 * BLOCKS:   SYS
 * DESC:     DoS Disable Learn Register
 * SIZE:     8
 * FIELDS:
 *     DOS_DIS_LRN      When this bit is enabled, all frames drop by dos prevent module will NOT be learned.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_DOS_DIS_LRN_REGr 0x00003610

#define BCM53101_A0_DOS_DIS_LRN_REGr_SIZE 1

/*
 * This structure should be used to declare and program DOS_DIS_LRN_REG.
 *
 */
typedef union BCM53101_A0_DOS_DIS_LRN_REGr_s {
	uint32_t v[1];
	uint32_t dos_dis_lrn_reg[1];
	uint32_t _dos_dis_lrn_reg;
} BCM53101_A0_DOS_DIS_LRN_REGr_t;

#define BCM53101_A0_DOS_DIS_LRN_REGr_CLR(r) (r).dos_dis_lrn_reg[0] = 0
#define BCM53101_A0_DOS_DIS_LRN_REGr_SET(r,d) (r).dos_dis_lrn_reg[0] = d
#define BCM53101_A0_DOS_DIS_LRN_REGr_GET(r) (r).dos_dis_lrn_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_DOS_DIS_LRN_REGr_DOS_DIS_LRNf_GET(r) (((r).dos_dis_lrn_reg[0]) & 0x1)
#define BCM53101_A0_DOS_DIS_LRN_REGr_DOS_DIS_LRNf_SET(r,f) (r).dos_dis_lrn_reg[0]=(((r).dos_dis_lrn_reg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_DOS_DIS_LRN_REGr_RESERVEDf_GET(r) ((((r).dos_dis_lrn_reg[0]) >> 1) & 0x7f)
#define BCM53101_A0_DOS_DIS_LRN_REGr_RESERVEDf_SET(r,f) (r).dos_dis_lrn_reg[0]=(((r).dos_dis_lrn_reg[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access DOS_DIS_LRN_REG.
 *
 */
#define BCM53101_A0_READ_DOS_DIS_LRN_REGr(u,r) cdk_robo_reg_read(u,BCM53101_A0_DOS_DIS_LRN_REGr,(r._dos_dis_lrn_reg),1)
#define BCM53101_A0_WRITE_DOS_DIS_LRN_REGr(u,r) cdk_robo_reg_write(u,BCM53101_A0_DOS_DIS_LRN_REGr,&(r._dos_dis_lrn_reg),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DOS_DIS_LRN_REGr BCM53101_A0_DOS_DIS_LRN_REGr
#define DOS_DIS_LRN_REGr_SIZE BCM53101_A0_DOS_DIS_LRN_REGr_SIZE
typedef BCM53101_A0_DOS_DIS_LRN_REGr_t DOS_DIS_LRN_REGr_t;
#define DOS_DIS_LRN_REGr_CLR BCM53101_A0_DOS_DIS_LRN_REGr_CLR
#define DOS_DIS_LRN_REGr_SET BCM53101_A0_DOS_DIS_LRN_REGr_SET
#define DOS_DIS_LRN_REGr_GET BCM53101_A0_DOS_DIS_LRN_REGr_GET
#define DOS_DIS_LRN_REGr_DOS_DIS_LRNf_GET BCM53101_A0_DOS_DIS_LRN_REGr_DOS_DIS_LRNf_GET
#define DOS_DIS_LRN_REGr_DOS_DIS_LRNf_SET BCM53101_A0_DOS_DIS_LRN_REGr_DOS_DIS_LRNf_SET
#define DOS_DIS_LRN_REGr_RESERVEDf_GET BCM53101_A0_DOS_DIS_LRN_REGr_RESERVEDf_GET
#define DOS_DIS_LRN_REGr_RESERVEDf_SET BCM53101_A0_DOS_DIS_LRN_REGr_RESERVEDf_SET
#define READ_DOS_DIS_LRN_REGr BCM53101_A0_READ_DOS_DIS_LRN_REGr
#define WRITE_DOS_DIS_LRN_REGr BCM53101_A0_WRITE_DOS_DIS_LRN_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_DOS_DIS_LRN_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  DTAG_TPID
 * BLOCKS:   SYS
 * DESC:     Double Tagging TPID Registers
 * SIZE:     16
 * FIELDS:
 *     ISP_TPID         TPID used to identify double tagged frame or not.
 *
 ******************************************************************************/
#define BCM53101_A0_DTAG_TPIDr 0x00003430

#define BCM53101_A0_DTAG_TPIDr_SIZE 2

/*
 * This structure should be used to declare and program DTAG_TPID.
 *
 */
typedef union BCM53101_A0_DTAG_TPIDr_s {
	uint32_t v[1];
	uint32_t dtag_tpid[1];
	uint32_t _dtag_tpid;
} BCM53101_A0_DTAG_TPIDr_t;

#define BCM53101_A0_DTAG_TPIDr_CLR(r) (r).dtag_tpid[0] = 0
#define BCM53101_A0_DTAG_TPIDr_SET(r,d) (r).dtag_tpid[0] = d
#define BCM53101_A0_DTAG_TPIDr_GET(r) (r).dtag_tpid[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_DTAG_TPIDr_ISP_TPIDf_GET(r) (((r).dtag_tpid[0]) & 0xffff)
#define BCM53101_A0_DTAG_TPIDr_ISP_TPIDf_SET(r,f) (r).dtag_tpid[0]=(((r).dtag_tpid[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access DTAG_TPID.
 *
 */
#define BCM53101_A0_READ_DTAG_TPIDr(u,r) cdk_robo_reg_read(u,BCM53101_A0_DTAG_TPIDr,(r._dtag_tpid),2)
#define BCM53101_A0_WRITE_DTAG_TPIDr(u,r) cdk_robo_reg_write(u,BCM53101_A0_DTAG_TPIDr,&(r._dtag_tpid),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DTAG_TPIDr BCM53101_A0_DTAG_TPIDr
#define DTAG_TPIDr_SIZE BCM53101_A0_DTAG_TPIDr_SIZE
typedef BCM53101_A0_DTAG_TPIDr_t DTAG_TPIDr_t;
#define DTAG_TPIDr_CLR BCM53101_A0_DTAG_TPIDr_CLR
#define DTAG_TPIDr_SET BCM53101_A0_DTAG_TPIDr_SET
#define DTAG_TPIDr_GET BCM53101_A0_DTAG_TPIDr_GET
#define DTAG_TPIDr_ISP_TPIDf_GET BCM53101_A0_DTAG_TPIDr_ISP_TPIDf_GET
#define DTAG_TPIDr_ISP_TPIDf_SET BCM53101_A0_DTAG_TPIDr_ISP_TPIDf_SET
#define READ_DTAG_TPIDr BCM53101_A0_READ_DTAG_TPIDr
#define WRITE_DTAG_TPIDr BCM53101_A0_WRITE_DTAG_TPIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_DTAG_TPIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  DUPSTS
 * BLOCKS:   SYS
 * DESC:     Duplex status Summary Register
 * SIZE:     16
 * FIELDS:
 *     DUP_STS          Duplex State.9 bit field indicating the half/full duplex state for each 10/100/1000BASE-T port.bit 8 = IMP Port(bits 0-5 = 10/100/1000BASE-T ports).0 = Half Duplex.1 = Full Duplex.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_DUPSTSr 0x00000108

#define BCM53101_A0_DUPSTSr_SIZE 2

/*
 * This structure should be used to declare and program DUPSTS.
 *
 */
typedef union BCM53101_A0_DUPSTSr_s {
	uint32_t v[1];
	uint32_t dupsts[1];
	uint32_t _dupsts;
} BCM53101_A0_DUPSTSr_t;

#define BCM53101_A0_DUPSTSr_CLR(r) (r).dupsts[0] = 0
#define BCM53101_A0_DUPSTSr_SET(r,d) (r).dupsts[0] = d
#define BCM53101_A0_DUPSTSr_GET(r) (r).dupsts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_DUPSTSr_DUP_STSf_GET(r) (((r).dupsts[0]) & 0x1ff)
#define BCM53101_A0_DUPSTSr_DUP_STSf_SET(r,f) (r).dupsts[0]=(((r).dupsts[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_DUPSTSr_RESERVEDf_GET(r) ((((r).dupsts[0]) >> 9) & 0x7f)
#define BCM53101_A0_DUPSTSr_RESERVEDf_SET(r,f) (r).dupsts[0]=(((r).dupsts[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access DUPSTS.
 *
 */
#define BCM53101_A0_READ_DUPSTSr(u,r) cdk_robo_reg_read(u,BCM53101_A0_DUPSTSr,(r._dupsts),2)
#define BCM53101_A0_WRITE_DUPSTSr(u,r) cdk_robo_reg_write(u,BCM53101_A0_DUPSTSr,&(r._dupsts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define DUPSTSr BCM53101_A0_DUPSTSr
#define DUPSTSr_SIZE BCM53101_A0_DUPSTSr_SIZE
typedef BCM53101_A0_DUPSTSr_t DUPSTSr_t;
#define DUPSTSr_CLR BCM53101_A0_DUPSTSr_CLR
#define DUPSTSr_SET BCM53101_A0_DUPSTSr_SET
#define DUPSTSr_GET BCM53101_A0_DUPSTSr_GET
#define DUPSTSr_DUP_STSf_GET BCM53101_A0_DUPSTSr_DUP_STSf_GET
#define DUPSTSr_DUP_STSf_SET BCM53101_A0_DUPSTSr_DUP_STSf_SET
#define DUPSTSr_RESERVEDf_GET BCM53101_A0_DUPSTSr_RESERVEDf_GET
#define DUPSTSr_RESERVEDf_SET BCM53101_A0_DUPSTSr_RESERVEDf_SET
#define READ_DUPSTSr BCM53101_A0_READ_DUPSTSr
#define WRITE_DUPSTSr BCM53101_A0_WRITE_DUPSTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_DUPSTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  EAP_DIP
 * BLOCKS:   SYS
 * DESC:     EAP Destination IP Registers
 * SIZE:     64
 * FIELDS:
 *     DIP_MASK_REG     EAP destination IP mask register N
 *     DIP_SUB_REG      EAP destination IP subnet register N 
 *
 ******************************************************************************/
#define BCM53101_A0_EAP_DIPr 0x00004202

#define BCM53101_A0_EAP_DIPr_SIZE 8

/*
 * This structure should be used to declare and program EAP_DIP.
 *
 */
typedef union BCM53101_A0_EAP_DIPr_s {
	uint32_t v[2];
	uint32_t eap_dip[2];
	uint32_t _eap_dip;
} BCM53101_A0_EAP_DIPr_t;

#define BCM53101_A0_EAP_DIPr_CLR(r) CDK_MEMSET(&((r)._eap_dip), 0, sizeof(BCM53101_A0_EAP_DIPr_t))
#define BCM53101_A0_EAP_DIPr_SET(r,i,d) (r).eap_dip[i] = d
#define BCM53101_A0_EAP_DIPr_GET(r,i) (r).eap_dip[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_EAP_DIPr_DIP_MASK_REGf_GET(r) ((r).eap_dip[0])
#define BCM53101_A0_EAP_DIPr_DIP_MASK_REGf_SET(r,f) (r).eap_dip[0]=((uint32_t)f)
#define BCM53101_A0_EAP_DIPr_DIP_SUB_REGf_GET(r) ((r).eap_dip[1])
#define BCM53101_A0_EAP_DIPr_DIP_SUB_REGf_SET(r,f) (r).eap_dip[1]=((uint32_t)f)

/*
 * These macros can be used to access EAP_DIP.
 *
 */
#define BCM53101_A0_READ_EAP_DIPr(u,i,r) cdk_robo_reg_read(u,BCM53101_A0_EAP_DIPr+(8*(i)),(r._eap_dip),8)
#define BCM53101_A0_WRITE_EAP_DIPr(u,i,r) cdk_robo_reg_write(u,BCM53101_A0_EAP_DIPr+(8*(i)),&(r._eap_dip),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EAP_DIPr BCM53101_A0_EAP_DIPr
#define EAP_DIPr_SIZE BCM53101_A0_EAP_DIPr_SIZE
typedef BCM53101_A0_EAP_DIPr_t EAP_DIPr_t;
#define EAP_DIPr_CLR BCM53101_A0_EAP_DIPr_CLR
#define EAP_DIPr_SET BCM53101_A0_EAP_DIPr_SET
#define EAP_DIPr_GET BCM53101_A0_EAP_DIPr_GET
#define EAP_DIPr_DIP_MASK_REGf_GET BCM53101_A0_EAP_DIPr_DIP_MASK_REGf_GET
#define EAP_DIPr_DIP_MASK_REGf_SET BCM53101_A0_EAP_DIPr_DIP_MASK_REGf_SET
#define EAP_DIPr_DIP_SUB_REGf_GET BCM53101_A0_EAP_DIPr_DIP_SUB_REGf_GET
#define EAP_DIPr_DIP_SUB_REGf_SET BCM53101_A0_EAP_DIPr_DIP_SUB_REGf_SET
#define READ_EAP_DIPr BCM53101_A0_READ_EAP_DIPr
#define WRITE_EAP_DIPr BCM53101_A0_WRITE_EAP_DIPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_EAP_DIPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  EAP_GLO_CON
 * BLOCKS:   SYS
 * DESC:     EAP Global Configuration Registers
 * SIZE:     8
 * FIELDS:
 *     RESERVED         Reserved
 *     EN_2_DIP         1'b1 : 2 subnet destination IP defined in EAP_DIP0_MASK & EAP_DIP1_MASK are allowed to pass1'b0 : drop 
 *     EN_ARP           1'b1 : allow ARP to pass1'b0 : drop ARP
 *     EN_DHCP          1'b1 : allow DHCP to pass1'b0 : drop DHCP 
 *     EN_RMC           When EAP_BLK_MODE is set,1'b1 : allow DA = 01-80-C2-00-00-02, 04-0F to pass1'b0 : drop DA = 01-80-C2-00-00-02, 04-0F
 *     EN_BPDU          When EAP_BLK_MODE is set,1'b1 : allow BPDU to pass1'b0 : drop BPDU
 *     EN_RARP          1'b1: allow RARP to pass1'b0: drop RARP
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_EAP_GLO_CONr 0x00004200

#define BCM53101_A0_EAP_GLO_CONr_SIZE 1

/*
 * This structure should be used to declare and program EAP_GLO_CON.
 *
 */
typedef union BCM53101_A0_EAP_GLO_CONr_s {
	uint32_t v[1];
	uint32_t eap_glo_con[1];
	uint32_t _eap_glo_con;
} BCM53101_A0_EAP_GLO_CONr_t;

#define BCM53101_A0_EAP_GLO_CONr_CLR(r) (r).eap_glo_con[0] = 0
#define BCM53101_A0_EAP_GLO_CONr_SET(r,d) (r).eap_glo_con[0] = d
#define BCM53101_A0_EAP_GLO_CONr_GET(r) (r).eap_glo_con[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_EAP_GLO_CONr_RESERVEDf_GET(r) (((r).eap_glo_con[0]) & 0x1)
#define BCM53101_A0_EAP_GLO_CONr_RESERVEDf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_EAP_GLO_CONr_EN_2_DIPf_GET(r) ((((r).eap_glo_con[0]) >> 1) & 0x1)
#define BCM53101_A0_EAP_GLO_CONr_EN_2_DIPf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_EAP_GLO_CONr_EN_ARPf_GET(r) ((((r).eap_glo_con[0]) >> 2) & 0x1)
#define BCM53101_A0_EAP_GLO_CONr_EN_ARPf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_EAP_GLO_CONr_EN_DHCPf_GET(r) ((((r).eap_glo_con[0]) >> 3) & 0x1)
#define BCM53101_A0_EAP_GLO_CONr_EN_DHCPf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_EAP_GLO_CONr_EN_RMCf_GET(r) ((((r).eap_glo_con[0]) >> 4) & 0x1)
#define BCM53101_A0_EAP_GLO_CONr_EN_RMCf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_EAP_GLO_CONr_EN_BPDUf_GET(r) ((((r).eap_glo_con[0]) >> 5) & 0x1)
#define BCM53101_A0_EAP_GLO_CONr_EN_BPDUf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_EAP_GLO_CONr_EN_RARPf_GET(r) ((((r).eap_glo_con[0]) >> 6) & 0x1)
#define BCM53101_A0_EAP_GLO_CONr_EN_RARPf_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_EAP_GLO_CONr_RESERVED_0f_GET(r) ((((r).eap_glo_con[0]) >> 7) & 0x1)
#define BCM53101_A0_EAP_GLO_CONr_RESERVED_0f_SET(r,f) (r).eap_glo_con[0]=(((r).eap_glo_con[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access EAP_GLO_CON.
 *
 */
#define BCM53101_A0_READ_EAP_GLO_CONr(u,r) cdk_robo_reg_read(u,BCM53101_A0_EAP_GLO_CONr,(r._eap_glo_con),1)
#define BCM53101_A0_WRITE_EAP_GLO_CONr(u,r) cdk_robo_reg_write(u,BCM53101_A0_EAP_GLO_CONr,&(r._eap_glo_con),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EAP_GLO_CONr BCM53101_A0_EAP_GLO_CONr
#define EAP_GLO_CONr_SIZE BCM53101_A0_EAP_GLO_CONr_SIZE
typedef BCM53101_A0_EAP_GLO_CONr_t EAP_GLO_CONr_t;
#define EAP_GLO_CONr_CLR BCM53101_A0_EAP_GLO_CONr_CLR
#define EAP_GLO_CONr_SET BCM53101_A0_EAP_GLO_CONr_SET
#define EAP_GLO_CONr_GET BCM53101_A0_EAP_GLO_CONr_GET
#define EAP_GLO_CONr_RESERVEDf_GET BCM53101_A0_EAP_GLO_CONr_RESERVEDf_GET
#define EAP_GLO_CONr_RESERVEDf_SET BCM53101_A0_EAP_GLO_CONr_RESERVEDf_SET
#define EAP_GLO_CONr_EN_2_DIPf_GET BCM53101_A0_EAP_GLO_CONr_EN_2_DIPf_GET
#define EAP_GLO_CONr_EN_2_DIPf_SET BCM53101_A0_EAP_GLO_CONr_EN_2_DIPf_SET
#define EAP_GLO_CONr_EN_ARPf_GET BCM53101_A0_EAP_GLO_CONr_EN_ARPf_GET
#define EAP_GLO_CONr_EN_ARPf_SET BCM53101_A0_EAP_GLO_CONr_EN_ARPf_SET
#define EAP_GLO_CONr_EN_DHCPf_GET BCM53101_A0_EAP_GLO_CONr_EN_DHCPf_GET
#define EAP_GLO_CONr_EN_DHCPf_SET BCM53101_A0_EAP_GLO_CONr_EN_DHCPf_SET
#define EAP_GLO_CONr_EN_RMCf_GET BCM53101_A0_EAP_GLO_CONr_EN_RMCf_GET
#define EAP_GLO_CONr_EN_RMCf_SET BCM53101_A0_EAP_GLO_CONr_EN_RMCf_SET
#define EAP_GLO_CONr_EN_BPDUf_GET BCM53101_A0_EAP_GLO_CONr_EN_BPDUf_GET
#define EAP_GLO_CONr_EN_BPDUf_SET BCM53101_A0_EAP_GLO_CONr_EN_BPDUf_SET
#define EAP_GLO_CONr_EN_RARPf_GET BCM53101_A0_EAP_GLO_CONr_EN_RARPf_GET
#define EAP_GLO_CONr_EN_RARPf_SET BCM53101_A0_EAP_GLO_CONr_EN_RARPf_SET
#define EAP_GLO_CONr_RESERVED_0f_GET BCM53101_A0_EAP_GLO_CONr_RESERVED_0f_GET
#define EAP_GLO_CONr_RESERVED_0f_SET BCM53101_A0_EAP_GLO_CONr_RESERVED_0f_SET
#define READ_EAP_GLO_CONr BCM53101_A0_READ_EAP_GLO_CONr
#define WRITE_EAP_GLO_CONr BCM53101_A0_WRITE_EAP_GLO_CONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_EAP_GLO_CONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  EAP_MULTI_ADDR_CTRL
 * BLOCKS:   SYS
 * DESC:     EAP Multiport Address Control Register
 * SIZE:     8
 * FIELDS:
 *     EN_MPORT0        1'b1: allow multiport address define at Page/Offset=04/10h  to pass1'b0: drop
 *     EN_MPORT1        1'b1: allow multiport address define at Page/Offset=04/20h  to pass1'b0: drop
 *     EN_MPORT2        1'b1: allow multiport address define at Page/Offset=04/30h  to pass1'b0: drop
 *     EN_MPORT3        1'b1: allow multiport address define at Page/Offset=04/40h  to pass1'b0: drop
 *     EN_MPORT4        1'b1: allow multiport address define at Page/Offset=04/50h  to pass1'b0: drop
 *     EN_MPORT5        1'b1: allow multiport address define at Page/Offset=04/60h  to pass1'b0: drop
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_EAP_MULTI_ADDR_CTRLr 0x00004201

#define BCM53101_A0_EAP_MULTI_ADDR_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program EAP_MULTI_ADDR_CTRL.
 *
 */
typedef union BCM53101_A0_EAP_MULTI_ADDR_CTRLr_s {
	uint32_t v[1];
	uint32_t eap_multi_addr_ctrl[1];
	uint32_t _eap_multi_addr_ctrl;
} BCM53101_A0_EAP_MULTI_ADDR_CTRLr_t;

#define BCM53101_A0_EAP_MULTI_ADDR_CTRLr_CLR(r) (r).eap_multi_addr_ctrl[0] = 0
#define BCM53101_A0_EAP_MULTI_ADDR_CTRLr_SET(r,d) (r).eap_multi_addr_ctrl[0] = d
#define BCM53101_A0_EAP_MULTI_ADDR_CTRLr_GET(r) (r).eap_multi_addr_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT0f_GET(r) (((r).eap_multi_addr_ctrl[0]) & 0x1)
#define BCM53101_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT0f_SET(r,f) (r).eap_multi_addr_ctrl[0]=(((r).eap_multi_addr_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT1f_GET(r) ((((r).eap_multi_addr_ctrl[0]) >> 1) & 0x1)
#define BCM53101_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT1f_SET(r,f) (r).eap_multi_addr_ctrl[0]=(((r).eap_multi_addr_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT2f_GET(r) ((((r).eap_multi_addr_ctrl[0]) >> 2) & 0x1)
#define BCM53101_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT2f_SET(r,f) (r).eap_multi_addr_ctrl[0]=(((r).eap_multi_addr_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT3f_GET(r) ((((r).eap_multi_addr_ctrl[0]) >> 3) & 0x1)
#define BCM53101_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT3f_SET(r,f) (r).eap_multi_addr_ctrl[0]=(((r).eap_multi_addr_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT4f_GET(r) ((((r).eap_multi_addr_ctrl[0]) >> 4) & 0x1)
#define BCM53101_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT4f_SET(r,f) (r).eap_multi_addr_ctrl[0]=(((r).eap_multi_addr_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT5f_GET(r) ((((r).eap_multi_addr_ctrl[0]) >> 5) & 0x1)
#define BCM53101_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT5f_SET(r,f) (r).eap_multi_addr_ctrl[0]=(((r).eap_multi_addr_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_EAP_MULTI_ADDR_CTRLr_RESERVEDf_GET(r) ((((r).eap_multi_addr_ctrl[0]) >> 6) & 0x3)
#define BCM53101_A0_EAP_MULTI_ADDR_CTRLr_RESERVEDf_SET(r,f) (r).eap_multi_addr_ctrl[0]=(((r).eap_multi_addr_ctrl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access EAP_MULTI_ADDR_CTRL.
 *
 */
#define BCM53101_A0_READ_EAP_MULTI_ADDR_CTRLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_EAP_MULTI_ADDR_CTRLr,(r._eap_multi_addr_ctrl),1)
#define BCM53101_A0_WRITE_EAP_MULTI_ADDR_CTRLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_EAP_MULTI_ADDR_CTRLr,&(r._eap_multi_addr_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EAP_MULTI_ADDR_CTRLr BCM53101_A0_EAP_MULTI_ADDR_CTRLr
#define EAP_MULTI_ADDR_CTRLr_SIZE BCM53101_A0_EAP_MULTI_ADDR_CTRLr_SIZE
typedef BCM53101_A0_EAP_MULTI_ADDR_CTRLr_t EAP_MULTI_ADDR_CTRLr_t;
#define EAP_MULTI_ADDR_CTRLr_CLR BCM53101_A0_EAP_MULTI_ADDR_CTRLr_CLR
#define EAP_MULTI_ADDR_CTRLr_SET BCM53101_A0_EAP_MULTI_ADDR_CTRLr_SET
#define EAP_MULTI_ADDR_CTRLr_GET BCM53101_A0_EAP_MULTI_ADDR_CTRLr_GET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT0f_GET BCM53101_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT0f_GET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT0f_SET BCM53101_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT0f_SET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT1f_GET BCM53101_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT1f_GET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT1f_SET BCM53101_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT1f_SET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT2f_GET BCM53101_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT2f_GET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT2f_SET BCM53101_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT2f_SET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT3f_GET BCM53101_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT3f_GET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT3f_SET BCM53101_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT3f_SET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT4f_GET BCM53101_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT4f_GET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT4f_SET BCM53101_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT4f_SET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT5f_GET BCM53101_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT5f_GET
#define EAP_MULTI_ADDR_CTRLr_EN_MPORT5f_SET BCM53101_A0_EAP_MULTI_ADDR_CTRLr_EN_MPORT5f_SET
#define EAP_MULTI_ADDR_CTRLr_RESERVEDf_GET BCM53101_A0_EAP_MULTI_ADDR_CTRLr_RESERVEDf_GET
#define EAP_MULTI_ADDR_CTRLr_RESERVEDf_SET BCM53101_A0_EAP_MULTI_ADDR_CTRLr_RESERVEDf_SET
#define READ_EAP_MULTI_ADDR_CTRLr BCM53101_A0_READ_EAP_MULTI_ADDR_CTRLr
#define WRITE_EAP_MULTI_ADDR_CTRLr BCM53101_A0_WRITE_EAP_MULTI_ADDR_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_EAP_MULTI_ADDR_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  EAV_LNK_STATUS
 * BLOCKS:   SYS
 * DESC:     ResE Port EAV Link Status Register
 * SIZE:     16
 * FIELDS:
 *     PT_EAV_LNK_STATUS When software write the port EAV link status and select bit 14 in LED function.The EAV link status is shown on the LED.**Note port 5 status can be output on serial LED but not Parallel LED.bits[5:0] : for port5~port0
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_EAV_LNK_STATUSr 0x000090b0

#define BCM53101_A0_EAV_LNK_STATUSr_SIZE 2

/*
 * This structure should be used to declare and program EAV_LNK_STATUS.
 *
 */
typedef union BCM53101_A0_EAV_LNK_STATUSr_s {
	uint32_t v[1];
	uint32_t eav_lnk_status[1];
	uint32_t _eav_lnk_status;
} BCM53101_A0_EAV_LNK_STATUSr_t;

#define BCM53101_A0_EAV_LNK_STATUSr_CLR(r) (r).eav_lnk_status[0] = 0
#define BCM53101_A0_EAV_LNK_STATUSr_SET(r,d) (r).eav_lnk_status[0] = d
#define BCM53101_A0_EAV_LNK_STATUSr_GET(r) (r).eav_lnk_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_EAV_LNK_STATUSr_PT_EAV_LNK_STATUSf_GET(r) (((r).eav_lnk_status[0]) & 0x3f)
#define BCM53101_A0_EAV_LNK_STATUSr_PT_EAV_LNK_STATUSf_SET(r,f) (r).eav_lnk_status[0]=(((r).eav_lnk_status[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53101_A0_EAV_LNK_STATUSr_RESERVEDf_GET(r) ((((r).eav_lnk_status[0]) >> 6) & 0x3ff)
#define BCM53101_A0_EAV_LNK_STATUSr_RESERVEDf_SET(r,f) (r).eav_lnk_status[0]=(((r).eav_lnk_status[0] & ~((uint32_t)0x3ff << 6)) | ((((uint32_t)f) & 0x3ff) << 6))

/*
 * These macros can be used to access EAV_LNK_STATUS.
 *
 */
#define BCM53101_A0_READ_EAV_LNK_STATUSr(u,r) cdk_robo_reg_read(u,BCM53101_A0_EAV_LNK_STATUSr,(r._eav_lnk_status),2)
#define BCM53101_A0_WRITE_EAV_LNK_STATUSr(u,r) cdk_robo_reg_write(u,BCM53101_A0_EAV_LNK_STATUSr,&(r._eav_lnk_status),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EAV_LNK_STATUSr BCM53101_A0_EAV_LNK_STATUSr
#define EAV_LNK_STATUSr_SIZE BCM53101_A0_EAV_LNK_STATUSr_SIZE
typedef BCM53101_A0_EAV_LNK_STATUSr_t EAV_LNK_STATUSr_t;
#define EAV_LNK_STATUSr_CLR BCM53101_A0_EAV_LNK_STATUSr_CLR
#define EAV_LNK_STATUSr_SET BCM53101_A0_EAV_LNK_STATUSr_SET
#define EAV_LNK_STATUSr_GET BCM53101_A0_EAV_LNK_STATUSr_GET
#define EAV_LNK_STATUSr_PT_EAV_LNK_STATUSf_GET BCM53101_A0_EAV_LNK_STATUSr_PT_EAV_LNK_STATUSf_GET
#define EAV_LNK_STATUSr_PT_EAV_LNK_STATUSf_SET BCM53101_A0_EAV_LNK_STATUSr_PT_EAV_LNK_STATUSf_SET
#define EAV_LNK_STATUSr_RESERVEDf_GET BCM53101_A0_EAV_LNK_STATUSr_RESERVEDf_GET
#define EAV_LNK_STATUSr_RESERVEDf_SET BCM53101_A0_EAV_LNK_STATUSr_RESERVEDf_SET
#define READ_EAV_LNK_STATUSr BCM53101_A0_READ_EAV_LNK_STATUSr
#define WRITE_EAV_LNK_STATUSr BCM53101_A0_WRITE_EAV_LNK_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_EAV_LNK_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  EGMIRCTL
 * BLOCKS:   SYS
 * DESC:     Egress Mirror Control Register
 * SIZE:     16
 * FIELDS:
 *     OUT_MIR_MSK      Egress Mirror Port Mask.9 bit mask which selectively allows any port with its corresponding bit set, to be mirrored to the port identified by the MIRROR_CAPTURE_PORT value. Note that while multiple bits in a device may be set, severe congestion and/or frame loss may occur if excessive bandwidth from the mirrored port(s) is directed to the MIRROR_CAPTURE_PORT.Bits 0-5 = Port0-5Bit 8= IMP Port.
 *     RESERVED         Reserved
 *     OUT_DIV_EN       Egress Divider Enable.Mirror every nth transmitted frame (n=OUT_MIRROR_DIV + 1) that has passed through the OUT_MIRROR_FILTER.
 *     OUT_MIR_FLTR     Egress Mirror Filter.Defines the conditions under which frames transmitted on a port that has been selected in the OUT_MRROR_MASK[10:0], will be compared in order to determine if they should be forwarded to the MIRROR_CAPTURE_PORT.00: Mirror all egress frames.01: Mirror all transmitted frames with DA = OUT_MIROR_MAC.10: Mirror all transmitted frames with SA = OUT_MIRROR_MAC.11: Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_EGMIRCTLr 0x0000021c

#define BCM53101_A0_EGMIRCTLr_SIZE 2

/*
 * This structure should be used to declare and program EGMIRCTL.
 *
 */
typedef union BCM53101_A0_EGMIRCTLr_s {
	uint32_t v[1];
	uint32_t egmirctl[1];
	uint32_t _egmirctl;
} BCM53101_A0_EGMIRCTLr_t;

#define BCM53101_A0_EGMIRCTLr_CLR(r) (r).egmirctl[0] = 0
#define BCM53101_A0_EGMIRCTLr_SET(r,d) (r).egmirctl[0] = d
#define BCM53101_A0_EGMIRCTLr_GET(r) (r).egmirctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_EGMIRCTLr_OUT_MIR_MSKf_GET(r) (((r).egmirctl[0]) & 0x1ff)
#define BCM53101_A0_EGMIRCTLr_OUT_MIR_MSKf_SET(r,f) (r).egmirctl[0]=(((r).egmirctl[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_EGMIRCTLr_RESERVEDf_GET(r) ((((r).egmirctl[0]) >> 9) & 0xf)
#define BCM53101_A0_EGMIRCTLr_RESERVEDf_SET(r,f) (r).egmirctl[0]=(((r).egmirctl[0] & ~((uint32_t)0xf << 9)) | ((((uint32_t)f) & 0xf) << 9))
#define BCM53101_A0_EGMIRCTLr_OUT_DIV_ENf_GET(r) ((((r).egmirctl[0]) >> 13) & 0x1)
#define BCM53101_A0_EGMIRCTLr_OUT_DIV_ENf_SET(r,f) (r).egmirctl[0]=(((r).egmirctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53101_A0_EGMIRCTLr_OUT_MIR_FLTRf_GET(r) ((((r).egmirctl[0]) >> 14) & 0x3)
#define BCM53101_A0_EGMIRCTLr_OUT_MIR_FLTRf_SET(r,f) (r).egmirctl[0]=(((r).egmirctl[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access EGMIRCTL.
 *
 */
#define BCM53101_A0_READ_EGMIRCTLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_EGMIRCTLr,(r._egmirctl),2)
#define BCM53101_A0_WRITE_EGMIRCTLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_EGMIRCTLr,&(r._egmirctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGMIRCTLr BCM53101_A0_EGMIRCTLr
#define EGMIRCTLr_SIZE BCM53101_A0_EGMIRCTLr_SIZE
typedef BCM53101_A0_EGMIRCTLr_t EGMIRCTLr_t;
#define EGMIRCTLr_CLR BCM53101_A0_EGMIRCTLr_CLR
#define EGMIRCTLr_SET BCM53101_A0_EGMIRCTLr_SET
#define EGMIRCTLr_GET BCM53101_A0_EGMIRCTLr_GET
#define EGMIRCTLr_OUT_MIR_MSKf_GET BCM53101_A0_EGMIRCTLr_OUT_MIR_MSKf_GET
#define EGMIRCTLr_OUT_MIR_MSKf_SET BCM53101_A0_EGMIRCTLr_OUT_MIR_MSKf_SET
#define EGMIRCTLr_RESERVEDf_GET BCM53101_A0_EGMIRCTLr_RESERVEDf_GET
#define EGMIRCTLr_RESERVEDf_SET BCM53101_A0_EGMIRCTLr_RESERVEDf_SET
#define EGMIRCTLr_OUT_DIV_ENf_GET BCM53101_A0_EGMIRCTLr_OUT_DIV_ENf_GET
#define EGMIRCTLr_OUT_DIV_ENf_SET BCM53101_A0_EGMIRCTLr_OUT_DIV_ENf_SET
#define EGMIRCTLr_OUT_MIR_FLTRf_GET BCM53101_A0_EGMIRCTLr_OUT_MIR_FLTRf_GET
#define EGMIRCTLr_OUT_MIR_FLTRf_SET BCM53101_A0_EGMIRCTLr_OUT_MIR_FLTRf_SET
#define READ_EGMIRCTLr BCM53101_A0_READ_EGMIRCTLr
#define WRITE_EGMIRCTLr BCM53101_A0_WRITE_EGMIRCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_EGMIRCTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  EGMIRDIV
 * BLOCKS:   SYS
 * DESC:     Egress Mirror Divider Register
 * SIZE:     16
 * FIELDS:
 *     OUT_MIR_DIV      Egress Mirror Divider.Transmit frames that have passed the OUT_MIRROR_FILTER rule can further be pruned to reduce the overall number of frames returned to the MIRROR_CAPTURE_PORT. When the OUT_DIV_EN bit in the Egress Mirror Control register is set, frames that pass the OUT_MIRROR_FILTER rule are further divided by the value loaded into this register, so that only cp reg_profile.dat reg_profile.dat.julia6one in n frames (where n = OUT_MIRROR_DIV + 1) will be mirrored.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_EGMIRDIVr 0x0000021e

#define BCM53101_A0_EGMIRDIVr_SIZE 2

/*
 * This structure should be used to declare and program EGMIRDIV.
 *
 */
typedef union BCM53101_A0_EGMIRDIVr_s {
	uint32_t v[1];
	uint32_t egmirdiv[1];
	uint32_t _egmirdiv;
} BCM53101_A0_EGMIRDIVr_t;

#define BCM53101_A0_EGMIRDIVr_CLR(r) (r).egmirdiv[0] = 0
#define BCM53101_A0_EGMIRDIVr_SET(r,d) (r).egmirdiv[0] = d
#define BCM53101_A0_EGMIRDIVr_GET(r) (r).egmirdiv[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_EGMIRDIVr_OUT_MIR_DIVf_GET(r) (((r).egmirdiv[0]) & 0x3ff)
#define BCM53101_A0_EGMIRDIVr_OUT_MIR_DIVf_SET(r,f) (r).egmirdiv[0]=(((r).egmirdiv[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53101_A0_EGMIRDIVr_RESERVEDf_GET(r) ((((r).egmirdiv[0]) >> 10) & 0x3f)
#define BCM53101_A0_EGMIRDIVr_RESERVEDf_SET(r,f) (r).egmirdiv[0]=(((r).egmirdiv[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access EGMIRDIV.
 *
 */
#define BCM53101_A0_READ_EGMIRDIVr(u,r) cdk_robo_reg_read(u,BCM53101_A0_EGMIRDIVr,(r._egmirdiv),2)
#define BCM53101_A0_WRITE_EGMIRDIVr(u,r) cdk_robo_reg_write(u,BCM53101_A0_EGMIRDIVr,&(r._egmirdiv),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGMIRDIVr BCM53101_A0_EGMIRDIVr
#define EGMIRDIVr_SIZE BCM53101_A0_EGMIRDIVr_SIZE
typedef BCM53101_A0_EGMIRDIVr_t EGMIRDIVr_t;
#define EGMIRDIVr_CLR BCM53101_A0_EGMIRDIVr_CLR
#define EGMIRDIVr_SET BCM53101_A0_EGMIRDIVr_SET
#define EGMIRDIVr_GET BCM53101_A0_EGMIRDIVr_GET
#define EGMIRDIVr_OUT_MIR_DIVf_GET BCM53101_A0_EGMIRDIVr_OUT_MIR_DIVf_GET
#define EGMIRDIVr_OUT_MIR_DIVf_SET BCM53101_A0_EGMIRDIVr_OUT_MIR_DIVf_SET
#define EGMIRDIVr_RESERVEDf_GET BCM53101_A0_EGMIRDIVr_RESERVEDf_GET
#define EGMIRDIVr_RESERVEDf_SET BCM53101_A0_EGMIRDIVr_RESERVEDf_SET
#define READ_EGMIRDIVr BCM53101_A0_READ_EGMIRDIVr
#define WRITE_EGMIRDIVr BCM53101_A0_WRITE_EGMIRDIVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_EGMIRDIVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  EGMIRMAC
 * BLOCKS:   SYS
 * DESC:     Egress Mirror MAC Address Register
 * SIZE:     48
 * FIELDS:
 *     OUT_MIR_MAC      Egress Mirror MAC Address.MAC address that will be compared against engress frames in accordance with the OUT_MIRROR_FILTER rules.
 *
 ******************************************************************************/
#define BCM53101_A0_EGMIRMACr 0x00000220

#define BCM53101_A0_EGMIRMACr_SIZE 6

/*
 * This structure should be used to declare and program EGMIRMAC.
 *
 */
typedef union BCM53101_A0_EGMIRMACr_s {
	uint32_t v[2];
	uint32_t egmirmac[2];
	uint32_t _egmirmac;
} BCM53101_A0_EGMIRMACr_t;

#define BCM53101_A0_EGMIRMACr_CLR(r) CDK_MEMSET(&((r)._egmirmac), 0, sizeof(BCM53101_A0_EGMIRMACr_t))
#define BCM53101_A0_EGMIRMACr_SET(r,i,d) (r).egmirmac[i] = d
#define BCM53101_A0_EGMIRMACr_GET(r,i) (r).egmirmac[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_EGMIRMACr_OUT_MIR_MACf_GET(r,a) cdk_field_get((r).egmirmac,0,47,a)
#define BCM53101_A0_EGMIRMACr_OUT_MIR_MACf_SET(r,a) cdk_field_set((r).egmirmac,0,47,a)

/*
 * These macros can be used to access EGMIRMAC.
 *
 */
#define BCM53101_A0_READ_EGMIRMACr(u,r) cdk_robo_reg_read(u,BCM53101_A0_EGMIRMACr,(r._egmirmac),6)
#define BCM53101_A0_WRITE_EGMIRMACr(u,r) cdk_robo_reg_write(u,BCM53101_A0_EGMIRMACr,&(r._egmirmac),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGMIRMACr BCM53101_A0_EGMIRMACr
#define EGMIRMACr_SIZE BCM53101_A0_EGMIRMACr_SIZE
typedef BCM53101_A0_EGMIRMACr_t EGMIRMACr_t;
#define EGMIRMACr_CLR BCM53101_A0_EGMIRMACr_CLR
#define EGMIRMACr_SET BCM53101_A0_EGMIRMACr_SET
#define EGMIRMACr_GET BCM53101_A0_EGMIRMACr_GET
#define EGMIRMACr_OUT_MIR_MACf_GET BCM53101_A0_EGMIRMACr_OUT_MIR_MACf_GET
#define EGMIRMACr_OUT_MIR_MACf_SET BCM53101_A0_EGMIRMACr_OUT_MIR_MACf_SET
#define READ_EGMIRMACr BCM53101_A0_READ_EGMIRMACr
#define WRITE_EGMIRMACr BCM53101_A0_WRITE_EGMIRMACr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_EGMIRMACr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  EGRESS_NRESE_PKT_TC2PCP_MAP
 * BLOCKS:   CPIC EPIC0
 * DESC:     Egress Non-ResE Packet TC to PCP mapping Register
 * SIZE:     64
 * FIELDS:
 *     PCP_FOR_RV0_TC0  PCP for RV0_TC0
 *     PCP_FOR_RV0_TC1  PCP for RV0_TC1
 *     PCP_FOR_RV0_TC2  PCP for RV0_TC2
 *     PCP_FOR_RV0_TC3  PCP for RV0_TC3
 *     PCP_FOR_RV0_TC4  PCP for RV0_TC4
 *     PCP_FOR_RV0_TC5  PCP for RV0_TC5
 *     PCP_FOR_RV0_TC6  PCP for RV0_TC6
 *     PCP_FOR_RV0_TC7  PCP for RV0_TC7
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr 0x00009110

#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_SIZE 8

/*
 * This structure should be used to declare and program EGRESS_NRESE_PKT_TC2PCP_MAP.
 *
 */
typedef union BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_s {
	uint32_t v[2];
	uint32_t egress_nrese_pkt_tc2pcp_map[2];
	uint32_t _egress_nrese_pkt_tc2pcp_map;
} BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_t;

#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_CLR(r) CDK_MEMSET(&((r)._egress_nrese_pkt_tc2pcp_map), 0, sizeof(BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_t))
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_SET(r,i,d) (r).egress_nrese_pkt_tc2pcp_map[i] = d
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_GET(r,i) (r).egress_nrese_pkt_tc2pcp_map[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC0f_GET(r) (((r).egress_nrese_pkt_tc2pcp_map[0]) & 0xf)
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC0f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map[0]=(((r).egress_nrese_pkt_tc2pcp_map[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC1f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map[0]) >> 4) & 0xf)
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC1f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map[0]=(((r).egress_nrese_pkt_tc2pcp_map[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC2f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map[0]) >> 8) & 0xf)
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC2f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map[0]=(((r).egress_nrese_pkt_tc2pcp_map[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC3f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map[0]) >> 12) & 0xf)
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC3f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map[0]=(((r).egress_nrese_pkt_tc2pcp_map[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC4f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map[0]) >> 16) & 0xf)
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC4f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map[0]=(((r).egress_nrese_pkt_tc2pcp_map[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC5f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map[0]) >> 20) & 0xf)
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC5f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map[0]=(((r).egress_nrese_pkt_tc2pcp_map[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC6f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map[0]) >> 24) & 0xf)
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC6f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map[0]=(((r).egress_nrese_pkt_tc2pcp_map[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC7f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map[0]) >> 28) & 0xf)
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC7f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map[0]=(((r).egress_nrese_pkt_tc2pcp_map[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_RESERVED_1f_GET(r) ((r).egress_nrese_pkt_tc2pcp_map[1])
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_RESERVED_1f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map[1]=((uint32_t)f)

/*
 * These macros can be used to access EGRESS_NRESE_PKT_TC2PCP_MAP.
 *
 */
#define BCM53101_A0_READ_EGRESS_NRESE_PKT_TC2PCP_MAPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr,(r._egress_nrese_pkt_tc2pcp_map),8)
#define BCM53101_A0_WRITE_EGRESS_NRESE_PKT_TC2PCP_MAPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr,&(r._egress_nrese_pkt_tc2pcp_map),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRESS_NRESE_PKT_TC2PCP_MAPr BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_SIZE BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_SIZE
typedef BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_t EGRESS_NRESE_PKT_TC2PCP_MAPr_t;
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_CLR BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_CLR
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_SET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_GET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC0f_GET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC0f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC0f_SET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC0f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC1f_GET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC1f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC1f_SET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC1f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC2f_GET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC2f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC2f_SET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC2f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC3f_GET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC3f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC3f_SET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC3f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC4f_GET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC4f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC4f_SET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC4f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC5f_GET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC5f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC5f_SET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC5f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC6f_GET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC6f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC6f_SET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC6f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC7f_GET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC7f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC7f_SET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_PCP_FOR_RV0_TC7f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_RESERVED_1f_GET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_RESERVED_1f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAPr_RESERVED_1f_SET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr_RESERVED_1f_SET
#define READ_EGRESS_NRESE_PKT_TC2PCP_MAPr BCM53101_A0_READ_EGRESS_NRESE_PKT_TC2PCP_MAPr
#define WRITE_EGRESS_NRESE_PKT_TC2PCP_MAPr BCM53101_A0_WRITE_EGRESS_NRESE_PKT_TC2PCP_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  EGRESS_NRESE_PKT_TC2PCP_MAP_IMP
 * BLOCKS:   SYS
 * DESC:     Egress Non-ResE Packet TC to PCP mapping Register for port8
 * SIZE:     64
 * FIELDS:
 *     PCP_FOR_RV0_TC0  PCP for RV0_TC0
 *     PCP_FOR_RV0_TC1  PCP for RV0_TC1
 *     PCP_FOR_RV0_TC2  PCP for RV0_TC2
 *     PCP_FOR_RV0_TC3  PCP for RV0_TC3
 *     PCP_FOR_RV0_TC4  PCP for RV0_TC4
 *     PCP_FOR_RV0_TC5  PCP for RV0_TC5
 *     PCP_FOR_RV0_TC6  PCP for RV0_TC6
 *     PCP_FOR_RV0_TC7  PCP for RV0_TC7
 *     RESERVED_1       
 *
 ******************************************************************************/
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr 0x00009150

#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_SIZE 8

/*
 * This structure should be used to declare and program EGRESS_NRESE_PKT_TC2PCP_MAP_IMP.
 *
 */
typedef union BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_s {
	uint32_t v[2];
	uint32_t egress_nrese_pkt_tc2pcp_map_imp[2];
	uint32_t _egress_nrese_pkt_tc2pcp_map_imp;
} BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_t;

#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_CLR(r) CDK_MEMSET(&((r)._egress_nrese_pkt_tc2pcp_map_imp), 0, sizeof(BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_t))
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_SET(r,i,d) (r).egress_nrese_pkt_tc2pcp_map_imp[i] = d
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_GET(r,i) (r).egress_nrese_pkt_tc2pcp_map_imp[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC0f_GET(r) (((r).egress_nrese_pkt_tc2pcp_map_imp[0]) & 0xf)
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC0f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map_imp[0]=(((r).egress_nrese_pkt_tc2pcp_map_imp[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC1f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map_imp[0]) >> 4) & 0xf)
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC1f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map_imp[0]=(((r).egress_nrese_pkt_tc2pcp_map_imp[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC2f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map_imp[0]) >> 8) & 0xf)
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC2f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map_imp[0]=(((r).egress_nrese_pkt_tc2pcp_map_imp[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC3f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map_imp[0]) >> 12) & 0xf)
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC3f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map_imp[0]=(((r).egress_nrese_pkt_tc2pcp_map_imp[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC4f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map_imp[0]) >> 16) & 0xf)
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC4f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map_imp[0]=(((r).egress_nrese_pkt_tc2pcp_map_imp[0] & ~((uint32_t)0xf << 16)) | ((((uint32_t)f) & 0xf) << 16))
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC5f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map_imp[0]) >> 20) & 0xf)
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC5f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map_imp[0]=(((r).egress_nrese_pkt_tc2pcp_map_imp[0] & ~((uint32_t)0xf << 20)) | ((((uint32_t)f) & 0xf) << 20))
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC6f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map_imp[0]) >> 24) & 0xf)
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC6f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map_imp[0]=(((r).egress_nrese_pkt_tc2pcp_map_imp[0] & ~((uint32_t)0xf << 24)) | ((((uint32_t)f) & 0xf) << 24))
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC7f_GET(r) ((((r).egress_nrese_pkt_tc2pcp_map_imp[0]) >> 28) & 0xf)
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC7f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map_imp[0]=(((r).egress_nrese_pkt_tc2pcp_map_imp[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_RESERVED_1f_GET(r) ((r).egress_nrese_pkt_tc2pcp_map_imp[1])
#define BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_RESERVED_1f_SET(r,f) (r).egress_nrese_pkt_tc2pcp_map_imp[1]=((uint32_t)f)

/*
 * These macros can be used to access EGRESS_NRESE_PKT_TC2PCP_MAP_IMP.
 *
 */
#define BCM53101_A0_READ_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr,(r._egress_nrese_pkt_tc2pcp_map_imp),8)
#define BCM53101_A0_WRITE_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr,&(r._egress_nrese_pkt_tc2pcp_map_imp),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_SIZE BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_SIZE
typedef BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_t EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_t;
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_CLR BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_CLR
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_SET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_GET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC0f_GET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC0f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC0f_SET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC0f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC1f_GET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC1f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC1f_SET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC1f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC2f_GET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC2f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC2f_SET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC2f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC3f_GET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC3f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC3f_SET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC3f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC4f_GET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC4f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC4f_SET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC4f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC5f_GET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC5f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC5f_SET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC5f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC6f_GET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC6f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC6f_SET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC6f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC7f_GET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC7f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC7f_SET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_PCP_FOR_RV0_TC7f_SET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_RESERVED_1f_GET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_RESERVED_1f_GET
#define EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_RESERVED_1f_SET BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr_RESERVED_1f_SET
#define READ_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr BCM53101_A0_READ_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr
#define WRITE_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr BCM53101_A0_WRITE_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_EGRESS_NRESE_PKT_TC2PCP_MAP_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FAST_AGE_CTRL
 * BLOCKS:   SYS
 * DESC:     Fast Ageing Control Registrer
 * SIZE:     8
 * FIELDS:
 *     EN_FAST_AGE_STATIC Set 1'b1 to Age out Static Entry.
 *     EN_AGE_DYNAMIC   Set 1'b1 to Age out Dymanic Entry.
 *     EN_AGE_PORT      Set 1'b1 to Check Port ID
 *     EN_AGE_VLAN      Set 1'b1 to Check Vlan ID.
 *     EN_AGE_SPT       Set 1'b1 to check spanning Tree ID(refer to EN_802_1S/MSPT_AGE_MAP at page/address=43h/00h,02-05h)
 *     EN_AGE_MCAST     Enable Aging Multicast entry1: Aging multicast entries in ARL table0: Disable aging multicast entries in ARL table*** Note that the EN_AGE_MCAST and the EN_AGE_PORT can't enable(set to 1'b1) at same time.
 *     RESERVED         Reserved
 *     FAST_AGE_STR_DONE Set 1'b1 to trigger fast ageing process.When Fast aging process is done, this bit is cleared to 1'b0.
 *
 ******************************************************************************/
#define BCM53101_A0_FAST_AGE_CTRLr 0x00000088

#define BCM53101_A0_FAST_AGE_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program FAST_AGE_CTRL.
 *
 */
typedef union BCM53101_A0_FAST_AGE_CTRLr_s {
	uint32_t v[1];
	uint32_t fast_age_ctrl[1];
	uint32_t _fast_age_ctrl;
} BCM53101_A0_FAST_AGE_CTRLr_t;

#define BCM53101_A0_FAST_AGE_CTRLr_CLR(r) (r).fast_age_ctrl[0] = 0
#define BCM53101_A0_FAST_AGE_CTRLr_SET(r,d) (r).fast_age_ctrl[0] = d
#define BCM53101_A0_FAST_AGE_CTRLr_GET(r) (r).fast_age_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FAST_AGE_CTRLr_EN_FAST_AGE_STATICf_GET(r) (((r).fast_age_ctrl[0]) & 0x1)
#define BCM53101_A0_FAST_AGE_CTRLr_EN_FAST_AGE_STATICf_SET(r,f) (r).fast_age_ctrl[0]=(((r).fast_age_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_FAST_AGE_CTRLr_EN_AGE_DYNAMICf_GET(r) ((((r).fast_age_ctrl[0]) >> 1) & 0x1)
#define BCM53101_A0_FAST_AGE_CTRLr_EN_AGE_DYNAMICf_SET(r,f) (r).fast_age_ctrl[0]=(((r).fast_age_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_FAST_AGE_CTRLr_EN_AGE_PORTf_GET(r) ((((r).fast_age_ctrl[0]) >> 2) & 0x1)
#define BCM53101_A0_FAST_AGE_CTRLr_EN_AGE_PORTf_SET(r,f) (r).fast_age_ctrl[0]=(((r).fast_age_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_FAST_AGE_CTRLr_EN_AGE_VLANf_GET(r) ((((r).fast_age_ctrl[0]) >> 3) & 0x1)
#define BCM53101_A0_FAST_AGE_CTRLr_EN_AGE_VLANf_SET(r,f) (r).fast_age_ctrl[0]=(((r).fast_age_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_FAST_AGE_CTRLr_EN_AGE_SPTf_GET(r) ((((r).fast_age_ctrl[0]) >> 4) & 0x1)
#define BCM53101_A0_FAST_AGE_CTRLr_EN_AGE_SPTf_SET(r,f) (r).fast_age_ctrl[0]=(((r).fast_age_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_FAST_AGE_CTRLr_EN_AGE_MCASTf_GET(r) ((((r).fast_age_ctrl[0]) >> 5) & 0x1)
#define BCM53101_A0_FAST_AGE_CTRLr_EN_AGE_MCASTf_SET(r,f) (r).fast_age_ctrl[0]=(((r).fast_age_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_FAST_AGE_CTRLr_RESERVEDf_GET(r) ((((r).fast_age_ctrl[0]) >> 6) & 0x1)
#define BCM53101_A0_FAST_AGE_CTRLr_RESERVEDf_SET(r,f) (r).fast_age_ctrl[0]=(((r).fast_age_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_FAST_AGE_CTRLr_FAST_AGE_STR_DONEf_GET(r) ((((r).fast_age_ctrl[0]) >> 7) & 0x1)
#define BCM53101_A0_FAST_AGE_CTRLr_FAST_AGE_STR_DONEf_SET(r,f) (r).fast_age_ctrl[0]=(((r).fast_age_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access FAST_AGE_CTRL.
 *
 */
#define BCM53101_A0_READ_FAST_AGE_CTRLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_FAST_AGE_CTRLr,(r._fast_age_ctrl),1)
#define BCM53101_A0_WRITE_FAST_AGE_CTRLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_FAST_AGE_CTRLr,&(r._fast_age_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FAST_AGE_CTRLr BCM53101_A0_FAST_AGE_CTRLr
#define FAST_AGE_CTRLr_SIZE BCM53101_A0_FAST_AGE_CTRLr_SIZE
typedef BCM53101_A0_FAST_AGE_CTRLr_t FAST_AGE_CTRLr_t;
#define FAST_AGE_CTRLr_CLR BCM53101_A0_FAST_AGE_CTRLr_CLR
#define FAST_AGE_CTRLr_SET BCM53101_A0_FAST_AGE_CTRLr_SET
#define FAST_AGE_CTRLr_GET BCM53101_A0_FAST_AGE_CTRLr_GET
#define FAST_AGE_CTRLr_EN_FAST_AGE_STATICf_GET BCM53101_A0_FAST_AGE_CTRLr_EN_FAST_AGE_STATICf_GET
#define FAST_AGE_CTRLr_EN_FAST_AGE_STATICf_SET BCM53101_A0_FAST_AGE_CTRLr_EN_FAST_AGE_STATICf_SET
#define FAST_AGE_CTRLr_EN_AGE_DYNAMICf_GET BCM53101_A0_FAST_AGE_CTRLr_EN_AGE_DYNAMICf_GET
#define FAST_AGE_CTRLr_EN_AGE_DYNAMICf_SET BCM53101_A0_FAST_AGE_CTRLr_EN_AGE_DYNAMICf_SET
#define FAST_AGE_CTRLr_EN_AGE_PORTf_GET BCM53101_A0_FAST_AGE_CTRLr_EN_AGE_PORTf_GET
#define FAST_AGE_CTRLr_EN_AGE_PORTf_SET BCM53101_A0_FAST_AGE_CTRLr_EN_AGE_PORTf_SET
#define FAST_AGE_CTRLr_EN_AGE_VLANf_GET BCM53101_A0_FAST_AGE_CTRLr_EN_AGE_VLANf_GET
#define FAST_AGE_CTRLr_EN_AGE_VLANf_SET BCM53101_A0_FAST_AGE_CTRLr_EN_AGE_VLANf_SET
#define FAST_AGE_CTRLr_EN_AGE_SPTf_GET BCM53101_A0_FAST_AGE_CTRLr_EN_AGE_SPTf_GET
#define FAST_AGE_CTRLr_EN_AGE_SPTf_SET BCM53101_A0_FAST_AGE_CTRLr_EN_AGE_SPTf_SET
#define FAST_AGE_CTRLr_EN_AGE_MCASTf_GET BCM53101_A0_FAST_AGE_CTRLr_EN_AGE_MCASTf_GET
#define FAST_AGE_CTRLr_EN_AGE_MCASTf_SET BCM53101_A0_FAST_AGE_CTRLr_EN_AGE_MCASTf_SET
#define FAST_AGE_CTRLr_RESERVEDf_GET BCM53101_A0_FAST_AGE_CTRLr_RESERVEDf_GET
#define FAST_AGE_CTRLr_RESERVEDf_SET BCM53101_A0_FAST_AGE_CTRLr_RESERVEDf_SET
#define FAST_AGE_CTRLr_FAST_AGE_STR_DONEf_GET BCM53101_A0_FAST_AGE_CTRLr_FAST_AGE_STR_DONEf_GET
#define FAST_AGE_CTRLr_FAST_AGE_STR_DONEf_SET BCM53101_A0_FAST_AGE_CTRLr_FAST_AGE_STR_DONEf_SET
#define READ_FAST_AGE_CTRLr BCM53101_A0_READ_FAST_AGE_CTRLr
#define WRITE_FAST_AGE_CTRLr BCM53101_A0_WRITE_FAST_AGE_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FAST_AGE_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FAST_AGE_PORT
 * BLOCKS:   SYS
 * DESC:     Fast Ageing Port Control Registrer
 * SIZE:     8
 * FIELDS:
 *     AGE_PORT         Select Fast Ageing Source Port.Select a specified Port ID to be aged-out.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_FAST_AGE_PORTr 0x00000089

#define BCM53101_A0_FAST_AGE_PORTr_SIZE 1

/*
 * This structure should be used to declare and program FAST_AGE_PORT.
 *
 */
typedef union BCM53101_A0_FAST_AGE_PORTr_s {
	uint32_t v[1];
	uint32_t fast_age_port[1];
	uint32_t _fast_age_port;
} BCM53101_A0_FAST_AGE_PORTr_t;

#define BCM53101_A0_FAST_AGE_PORTr_CLR(r) (r).fast_age_port[0] = 0
#define BCM53101_A0_FAST_AGE_PORTr_SET(r,d) (r).fast_age_port[0] = d
#define BCM53101_A0_FAST_AGE_PORTr_GET(r) (r).fast_age_port[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FAST_AGE_PORTr_AGE_PORTf_GET(r) (((r).fast_age_port[0]) & 0xf)
#define BCM53101_A0_FAST_AGE_PORTr_AGE_PORTf_SET(r,f) (r).fast_age_port[0]=(((r).fast_age_port[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53101_A0_FAST_AGE_PORTr_RESERVEDf_GET(r) ((((r).fast_age_port[0]) >> 4) & 0xf)
#define BCM53101_A0_FAST_AGE_PORTr_RESERVEDf_SET(r,f) (r).fast_age_port[0]=(((r).fast_age_port[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access FAST_AGE_PORT.
 *
 */
#define BCM53101_A0_READ_FAST_AGE_PORTr(u,r) cdk_robo_reg_read(u,BCM53101_A0_FAST_AGE_PORTr,(r._fast_age_port),1)
#define BCM53101_A0_WRITE_FAST_AGE_PORTr(u,r) cdk_robo_reg_write(u,BCM53101_A0_FAST_AGE_PORTr,&(r._fast_age_port),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FAST_AGE_PORTr BCM53101_A0_FAST_AGE_PORTr
#define FAST_AGE_PORTr_SIZE BCM53101_A0_FAST_AGE_PORTr_SIZE
typedef BCM53101_A0_FAST_AGE_PORTr_t FAST_AGE_PORTr_t;
#define FAST_AGE_PORTr_CLR BCM53101_A0_FAST_AGE_PORTr_CLR
#define FAST_AGE_PORTr_SET BCM53101_A0_FAST_AGE_PORTr_SET
#define FAST_AGE_PORTr_GET BCM53101_A0_FAST_AGE_PORTr_GET
#define FAST_AGE_PORTr_AGE_PORTf_GET BCM53101_A0_FAST_AGE_PORTr_AGE_PORTf_GET
#define FAST_AGE_PORTr_AGE_PORTf_SET BCM53101_A0_FAST_AGE_PORTr_AGE_PORTf_SET
#define FAST_AGE_PORTr_RESERVEDf_GET BCM53101_A0_FAST_AGE_PORTr_RESERVEDf_GET
#define FAST_AGE_PORTr_RESERVEDf_SET BCM53101_A0_FAST_AGE_PORTr_RESERVEDf_SET
#define READ_FAST_AGE_PORTr BCM53101_A0_READ_FAST_AGE_PORTr
#define WRITE_FAST_AGE_PORTr BCM53101_A0_WRITE_FAST_AGE_PORTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FAST_AGE_PORTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FAST_AGE_VID
 * BLOCKS:   SYS
 * DESC:     Fast Ageing VID Control Registrer
 * SIZE:     16
 * FIELDS:
 *     AGE_VID          Select Fast Ageing VLAN IDSelect a specified VLAN ID to be aged-out.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_FAST_AGE_VIDr 0x0000008a

#define BCM53101_A0_FAST_AGE_VIDr_SIZE 2

/*
 * This structure should be used to declare and program FAST_AGE_VID.
 *
 */
typedef union BCM53101_A0_FAST_AGE_VIDr_s {
	uint32_t v[1];
	uint32_t fast_age_vid[1];
	uint32_t _fast_age_vid;
} BCM53101_A0_FAST_AGE_VIDr_t;

#define BCM53101_A0_FAST_AGE_VIDr_CLR(r) (r).fast_age_vid[0] = 0
#define BCM53101_A0_FAST_AGE_VIDr_SET(r,d) (r).fast_age_vid[0] = d
#define BCM53101_A0_FAST_AGE_VIDr_GET(r) (r).fast_age_vid[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FAST_AGE_VIDr_AGE_VIDf_GET(r) (((r).fast_age_vid[0]) & 0xfff)
#define BCM53101_A0_FAST_AGE_VIDr_AGE_VIDf_SET(r,f) (r).fast_age_vid[0]=(((r).fast_age_vid[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53101_A0_FAST_AGE_VIDr_RESERVEDf_GET(r) ((((r).fast_age_vid[0]) >> 12) & 0xf)
#define BCM53101_A0_FAST_AGE_VIDr_RESERVEDf_SET(r,f) (r).fast_age_vid[0]=(((r).fast_age_vid[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access FAST_AGE_VID.
 *
 */
#define BCM53101_A0_READ_FAST_AGE_VIDr(u,r) cdk_robo_reg_read(u,BCM53101_A0_FAST_AGE_VIDr,(r._fast_age_vid),2)
#define BCM53101_A0_WRITE_FAST_AGE_VIDr(u,r) cdk_robo_reg_write(u,BCM53101_A0_FAST_AGE_VIDr,&(r._fast_age_vid),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FAST_AGE_VIDr BCM53101_A0_FAST_AGE_VIDr
#define FAST_AGE_VIDr_SIZE BCM53101_A0_FAST_AGE_VIDr_SIZE
typedef BCM53101_A0_FAST_AGE_VIDr_t FAST_AGE_VIDr_t;
#define FAST_AGE_VIDr_CLR BCM53101_A0_FAST_AGE_VIDr_CLR
#define FAST_AGE_VIDr_SET BCM53101_A0_FAST_AGE_VIDr_SET
#define FAST_AGE_VIDr_GET BCM53101_A0_FAST_AGE_VIDr_GET
#define FAST_AGE_VIDr_AGE_VIDf_GET BCM53101_A0_FAST_AGE_VIDr_AGE_VIDf_GET
#define FAST_AGE_VIDr_AGE_VIDf_SET BCM53101_A0_FAST_AGE_VIDr_AGE_VIDf_SET
#define FAST_AGE_VIDr_RESERVEDf_GET BCM53101_A0_FAST_AGE_VIDr_RESERVEDf_GET
#define FAST_AGE_VIDr_RESERVEDf_SET BCM53101_A0_FAST_AGE_VIDr_RESERVEDf_SET
#define READ_FAST_AGE_VIDr BCM53101_A0_READ_FAST_AGE_VIDr
#define WRITE_FAST_AGE_VIDr BCM53101_A0_WRITE_FAST_AGE_VIDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FAST_AGE_VIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_CHIP_INFO
 * BLOCKS:   SYS
 * DESC:     Chip Info For FC Register
 * SIZE:     16
 * FIELDS:
 *     PRT_LINK         
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_FC_CHIP_INFOr 0x00000a9a

#define BCM53101_A0_FC_CHIP_INFOr_SIZE 2

/*
 * This structure should be used to declare and program FC_CHIP_INFO.
 *
 */
typedef union BCM53101_A0_FC_CHIP_INFOr_s {
	uint32_t v[1];
	uint32_t fc_chip_info[1];
	uint32_t _fc_chip_info;
} BCM53101_A0_FC_CHIP_INFOr_t;

#define BCM53101_A0_FC_CHIP_INFOr_CLR(r) (r).fc_chip_info[0] = 0
#define BCM53101_A0_FC_CHIP_INFOr_SET(r,d) (r).fc_chip_info[0] = d
#define BCM53101_A0_FC_CHIP_INFOr_GET(r) (r).fc_chip_info[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_CHIP_INFOr_PRT_LINKf_GET(r) (((r).fc_chip_info[0]) & 0x1ff)
#define BCM53101_A0_FC_CHIP_INFOr_PRT_LINKf_SET(r,f) (r).fc_chip_info[0]=(((r).fc_chip_info[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_FC_CHIP_INFOr_RESERVEDf_GET(r) ((((r).fc_chip_info[0]) >> 9) & 0x7f)
#define BCM53101_A0_FC_CHIP_INFOr_RESERVEDf_SET(r,f) (r).fc_chip_info[0]=(((r).fc_chip_info[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access FC_CHIP_INFO.
 *
 */
#define BCM53101_A0_READ_FC_CHIP_INFOr(u,r) cdk_robo_reg_read(u,BCM53101_A0_FC_CHIP_INFOr,(r._fc_chip_info),2)
#define BCM53101_A0_WRITE_FC_CHIP_INFOr(u,r) cdk_robo_reg_write(u,BCM53101_A0_FC_CHIP_INFOr,&(r._fc_chip_info),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_CHIP_INFOr BCM53101_A0_FC_CHIP_INFOr
#define FC_CHIP_INFOr_SIZE BCM53101_A0_FC_CHIP_INFOr_SIZE
typedef BCM53101_A0_FC_CHIP_INFOr_t FC_CHIP_INFOr_t;
#define FC_CHIP_INFOr_CLR BCM53101_A0_FC_CHIP_INFOr_CLR
#define FC_CHIP_INFOr_SET BCM53101_A0_FC_CHIP_INFOr_SET
#define FC_CHIP_INFOr_GET BCM53101_A0_FC_CHIP_INFOr_GET
#define FC_CHIP_INFOr_PRT_LINKf_GET BCM53101_A0_FC_CHIP_INFOr_PRT_LINKf_GET
#define FC_CHIP_INFOr_PRT_LINKf_SET BCM53101_A0_FC_CHIP_INFOr_PRT_LINKf_SET
#define FC_CHIP_INFOr_RESERVEDf_GET BCM53101_A0_FC_CHIP_INFOr_RESERVEDf_GET
#define FC_CHIP_INFOr_RESERVEDf_SET BCM53101_A0_FC_CHIP_INFOr_RESERVEDf_SET
#define READ_FC_CHIP_INFOr BCM53101_A0_READ_FC_CHIP_INFOr
#define WRITE_FC_CHIP_INFOr BCM53101_A0_WRITE_FC_CHIP_INFOr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_CHIP_INFOr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_CONG_BUF_ERR_HIS
 * BLOCKS:   SYS
 * DESC:     Congested Bus Error Register
 * SIZE:     16
 * FIELDS:
 *     CONG_BUF_ERR_HIS 
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_FC_CONG_BUF_ERR_HISr 0x00000aaa

#define BCM53101_A0_FC_CONG_BUF_ERR_HISr_SIZE 2

/*
 * This structure should be used to declare and program FC_CONG_BUF_ERR_HIS.
 *
 */
typedef union BCM53101_A0_FC_CONG_BUF_ERR_HISr_s {
	uint32_t v[1];
	uint32_t fc_cong_buf_err_his[1];
	uint32_t _fc_cong_buf_err_his;
} BCM53101_A0_FC_CONG_BUF_ERR_HISr_t;

#define BCM53101_A0_FC_CONG_BUF_ERR_HISr_CLR(r) (r).fc_cong_buf_err_his[0] = 0
#define BCM53101_A0_FC_CONG_BUF_ERR_HISr_SET(r,d) (r).fc_cong_buf_err_his[0] = d
#define BCM53101_A0_FC_CONG_BUF_ERR_HISr_GET(r) (r).fc_cong_buf_err_his[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_CONG_BUF_ERR_HISr_CONG_BUF_ERR_HISf_GET(r) (((r).fc_cong_buf_err_his[0]) & 0x1)
#define BCM53101_A0_FC_CONG_BUF_ERR_HISr_CONG_BUF_ERR_HISf_SET(r,f) (r).fc_cong_buf_err_his[0]=(((r).fc_cong_buf_err_his[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_FC_CONG_BUF_ERR_HISr_RESERVEDf_GET(r) ((((r).fc_cong_buf_err_his[0]) >> 1) & 0x7fff)
#define BCM53101_A0_FC_CONG_BUF_ERR_HISr_RESERVEDf_SET(r,f) (r).fc_cong_buf_err_his[0]=(((r).fc_cong_buf_err_his[0] & ~((uint32_t)0x7fff << 1)) | ((((uint32_t)f) & 0x7fff) << 1))

/*
 * These macros can be used to access FC_CONG_BUF_ERR_HIS.
 *
 */
#define BCM53101_A0_READ_FC_CONG_BUF_ERR_HISr(u,r) cdk_robo_reg_read(u,BCM53101_A0_FC_CONG_BUF_ERR_HISr,(r._fc_cong_buf_err_his),2)
#define BCM53101_A0_WRITE_FC_CONG_BUF_ERR_HISr(u,r) cdk_robo_reg_write(u,BCM53101_A0_FC_CONG_BUF_ERR_HISr,&(r._fc_cong_buf_err_his),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_CONG_BUF_ERR_HISr BCM53101_A0_FC_CONG_BUF_ERR_HISr
#define FC_CONG_BUF_ERR_HISr_SIZE BCM53101_A0_FC_CONG_BUF_ERR_HISr_SIZE
typedef BCM53101_A0_FC_CONG_BUF_ERR_HISr_t FC_CONG_BUF_ERR_HISr_t;
#define FC_CONG_BUF_ERR_HISr_CLR BCM53101_A0_FC_CONG_BUF_ERR_HISr_CLR
#define FC_CONG_BUF_ERR_HISr_SET BCM53101_A0_FC_CONG_BUF_ERR_HISr_SET
#define FC_CONG_BUF_ERR_HISr_GET BCM53101_A0_FC_CONG_BUF_ERR_HISr_GET
#define FC_CONG_BUF_ERR_HISr_CONG_BUF_ERR_HISf_GET BCM53101_A0_FC_CONG_BUF_ERR_HISr_CONG_BUF_ERR_HISf_GET
#define FC_CONG_BUF_ERR_HISr_CONG_BUF_ERR_HISf_SET BCM53101_A0_FC_CONG_BUF_ERR_HISr_CONG_BUF_ERR_HISf_SET
#define FC_CONG_BUF_ERR_HISr_RESERVEDf_GET BCM53101_A0_FC_CONG_BUF_ERR_HISr_RESERVEDf_GET
#define FC_CONG_BUF_ERR_HISr_RESERVEDf_SET BCM53101_A0_FC_CONG_BUF_ERR_HISr_RESERVEDf_SET
#define READ_FC_CONG_BUF_ERR_HISr BCM53101_A0_READ_FC_CONG_BUF_ERR_HISr
#define WRITE_FC_CONG_BUF_ERR_HISr BCM53101_A0_WRITE_FC_CONG_BUF_ERR_HISr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_CONG_BUF_ERR_HISr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_CONG_PORTMAP01
 * BLOCKS:   SYS
 * DESC:     Congested PortMap Port01 Register
 * SIZE:     16
 * FIELDS:
 *     CONG_PORTMAP0    Port 0 congest status for all Queuesbit[7:6] = congest status for Q3bit[5:4] = congest status for Q2bit[3:2] = congest status for Q1bit[1:0] = congest status for Q0
 *     CONG_PORTMAP1    Port 1 congest status for all Queuesbit[15:14] = congest status for Q3bit[13:12] = congest status for Q2bit[11:10] = congest status for Q1bit[9:8] = congest status for Q0
 *
 ******************************************************************************/
#define BCM53101_A0_FC_CONG_PORTMAP01r 0x00000a90

#define BCM53101_A0_FC_CONG_PORTMAP01r_SIZE 2

/*
 * This structure should be used to declare and program FC_CONG_PORTMAP01.
 *
 */
typedef union BCM53101_A0_FC_CONG_PORTMAP01r_s {
	uint32_t v[1];
	uint32_t fc_cong_portmap01[1];
	uint32_t _fc_cong_portmap01;
} BCM53101_A0_FC_CONG_PORTMAP01r_t;

#define BCM53101_A0_FC_CONG_PORTMAP01r_CLR(r) (r).fc_cong_portmap01[0] = 0
#define BCM53101_A0_FC_CONG_PORTMAP01r_SET(r,d) (r).fc_cong_portmap01[0] = d
#define BCM53101_A0_FC_CONG_PORTMAP01r_GET(r) (r).fc_cong_portmap01[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP0f_GET(r) (((r).fc_cong_portmap01[0]) & 0xff)
#define BCM53101_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP0f_SET(r,f) (r).fc_cong_portmap01[0]=(((r).fc_cong_portmap01[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53101_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP1f_GET(r) ((((r).fc_cong_portmap01[0]) >> 8) & 0xff)
#define BCM53101_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP1f_SET(r,f) (r).fc_cong_portmap01[0]=(((r).fc_cong_portmap01[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_CONG_PORTMAP01.
 *
 */
#define BCM53101_A0_READ_FC_CONG_PORTMAP01r(u,r) cdk_robo_reg_read(u,BCM53101_A0_FC_CONG_PORTMAP01r,(r._fc_cong_portmap01),2)
#define BCM53101_A0_WRITE_FC_CONG_PORTMAP01r(u,r) cdk_robo_reg_write(u,BCM53101_A0_FC_CONG_PORTMAP01r,&(r._fc_cong_portmap01),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_CONG_PORTMAP01r BCM53101_A0_FC_CONG_PORTMAP01r
#define FC_CONG_PORTMAP01r_SIZE BCM53101_A0_FC_CONG_PORTMAP01r_SIZE
typedef BCM53101_A0_FC_CONG_PORTMAP01r_t FC_CONG_PORTMAP01r_t;
#define FC_CONG_PORTMAP01r_CLR BCM53101_A0_FC_CONG_PORTMAP01r_CLR
#define FC_CONG_PORTMAP01r_SET BCM53101_A0_FC_CONG_PORTMAP01r_SET
#define FC_CONG_PORTMAP01r_GET BCM53101_A0_FC_CONG_PORTMAP01r_GET
#define FC_CONG_PORTMAP01r_CONG_PORTMAP0f_GET BCM53101_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP0f_GET
#define FC_CONG_PORTMAP01r_CONG_PORTMAP0f_SET BCM53101_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP0f_SET
#define FC_CONG_PORTMAP01r_CONG_PORTMAP1f_GET BCM53101_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP1f_GET
#define FC_CONG_PORTMAP01r_CONG_PORTMAP1f_SET BCM53101_A0_FC_CONG_PORTMAP01r_CONG_PORTMAP1f_SET
#define READ_FC_CONG_PORTMAP01r BCM53101_A0_READ_FC_CONG_PORTMAP01r
#define WRITE_FC_CONG_PORTMAP01r BCM53101_A0_WRITE_FC_CONG_PORTMAP01r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_CONG_PORTMAP01r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_CONG_PORTMAP23
 * BLOCKS:   SYS
 * DESC:     Congested PortMap Port23 Register
 * SIZE:     16
 * FIELDS:
 *     CONG_PORTMAP2    Port 2 congest status for all Queuesbit[7:6] = congest status for Q3bit[5:4] = congest status for Q2bit[3:2] = congest status for Q1bit[1:0] = congest status for Q0
 *     CONG_PORTMAP3    Port 3 congest status for all Queuesbit[15:14] = congest status for Q3bit[13:12] = congest status for Q2bit[11:10] = congest status for Q1bit[9:8] = congest status for Q0
 *
 ******************************************************************************/
#define BCM53101_A0_FC_CONG_PORTMAP23r 0x00000a92

#define BCM53101_A0_FC_CONG_PORTMAP23r_SIZE 2

/*
 * This structure should be used to declare and program FC_CONG_PORTMAP23.
 *
 */
typedef union BCM53101_A0_FC_CONG_PORTMAP23r_s {
	uint32_t v[1];
	uint32_t fc_cong_portmap23[1];
	uint32_t _fc_cong_portmap23;
} BCM53101_A0_FC_CONG_PORTMAP23r_t;

#define BCM53101_A0_FC_CONG_PORTMAP23r_CLR(r) (r).fc_cong_portmap23[0] = 0
#define BCM53101_A0_FC_CONG_PORTMAP23r_SET(r,d) (r).fc_cong_portmap23[0] = d
#define BCM53101_A0_FC_CONG_PORTMAP23r_GET(r) (r).fc_cong_portmap23[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP2f_GET(r) (((r).fc_cong_portmap23[0]) & 0xff)
#define BCM53101_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP2f_SET(r,f) (r).fc_cong_portmap23[0]=(((r).fc_cong_portmap23[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53101_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP3f_GET(r) ((((r).fc_cong_portmap23[0]) >> 8) & 0xff)
#define BCM53101_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP3f_SET(r,f) (r).fc_cong_portmap23[0]=(((r).fc_cong_portmap23[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_CONG_PORTMAP23.
 *
 */
#define BCM53101_A0_READ_FC_CONG_PORTMAP23r(u,r) cdk_robo_reg_read(u,BCM53101_A0_FC_CONG_PORTMAP23r,(r._fc_cong_portmap23),2)
#define BCM53101_A0_WRITE_FC_CONG_PORTMAP23r(u,r) cdk_robo_reg_write(u,BCM53101_A0_FC_CONG_PORTMAP23r,&(r._fc_cong_portmap23),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_CONG_PORTMAP23r BCM53101_A0_FC_CONG_PORTMAP23r
#define FC_CONG_PORTMAP23r_SIZE BCM53101_A0_FC_CONG_PORTMAP23r_SIZE
typedef BCM53101_A0_FC_CONG_PORTMAP23r_t FC_CONG_PORTMAP23r_t;
#define FC_CONG_PORTMAP23r_CLR BCM53101_A0_FC_CONG_PORTMAP23r_CLR
#define FC_CONG_PORTMAP23r_SET BCM53101_A0_FC_CONG_PORTMAP23r_SET
#define FC_CONG_PORTMAP23r_GET BCM53101_A0_FC_CONG_PORTMAP23r_GET
#define FC_CONG_PORTMAP23r_CONG_PORTMAP2f_GET BCM53101_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP2f_GET
#define FC_CONG_PORTMAP23r_CONG_PORTMAP2f_SET BCM53101_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP2f_SET
#define FC_CONG_PORTMAP23r_CONG_PORTMAP3f_GET BCM53101_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP3f_GET
#define FC_CONG_PORTMAP23r_CONG_PORTMAP3f_SET BCM53101_A0_FC_CONG_PORTMAP23r_CONG_PORTMAP3f_SET
#define READ_FC_CONG_PORTMAP23r BCM53101_A0_READ_FC_CONG_PORTMAP23r
#define WRITE_FC_CONG_PORTMAP23r BCM53101_A0_WRITE_FC_CONG_PORTMAP23r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_CONG_PORTMAP23r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_CONG_PORTMAP45
 * BLOCKS:   SYS
 * DESC:     Congested PortMap Port45 Register
 * SIZE:     16
 * FIELDS:
 *     CONG_PORTMAP4    Port 4 congest status for all Queuesbit[7:6] = congest status for Q3bit[5:4] = congest status for Q2bit[3:2] = congest status for Q1bit[1:0] = congest status for Q0
 *     CONG_PORTMAP5    Port 5 congest status for all Queuesbit[15:14] = congest status for Q3bit[13:12] = congest status for Q2bit[11:10] = congest status for Q1bit[9:8] = congest status for Q0
 *
 ******************************************************************************/
#define BCM53101_A0_FC_CONG_PORTMAP45r 0x00000a94

#define BCM53101_A0_FC_CONG_PORTMAP45r_SIZE 2

/*
 * This structure should be used to declare and program FC_CONG_PORTMAP45.
 *
 */
typedef union BCM53101_A0_FC_CONG_PORTMAP45r_s {
	uint32_t v[1];
	uint32_t fc_cong_portmap45[1];
	uint32_t _fc_cong_portmap45;
} BCM53101_A0_FC_CONG_PORTMAP45r_t;

#define BCM53101_A0_FC_CONG_PORTMAP45r_CLR(r) (r).fc_cong_portmap45[0] = 0
#define BCM53101_A0_FC_CONG_PORTMAP45r_SET(r,d) (r).fc_cong_portmap45[0] = d
#define BCM53101_A0_FC_CONG_PORTMAP45r_GET(r) (r).fc_cong_portmap45[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP4f_GET(r) (((r).fc_cong_portmap45[0]) & 0xff)
#define BCM53101_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP4f_SET(r,f) (r).fc_cong_portmap45[0]=(((r).fc_cong_portmap45[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53101_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP5f_GET(r) ((((r).fc_cong_portmap45[0]) >> 8) & 0xff)
#define BCM53101_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP5f_SET(r,f) (r).fc_cong_portmap45[0]=(((r).fc_cong_portmap45[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_CONG_PORTMAP45.
 *
 */
#define BCM53101_A0_READ_FC_CONG_PORTMAP45r(u,r) cdk_robo_reg_read(u,BCM53101_A0_FC_CONG_PORTMAP45r,(r._fc_cong_portmap45),2)
#define BCM53101_A0_WRITE_FC_CONG_PORTMAP45r(u,r) cdk_robo_reg_write(u,BCM53101_A0_FC_CONG_PORTMAP45r,&(r._fc_cong_portmap45),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_CONG_PORTMAP45r BCM53101_A0_FC_CONG_PORTMAP45r
#define FC_CONG_PORTMAP45r_SIZE BCM53101_A0_FC_CONG_PORTMAP45r_SIZE
typedef BCM53101_A0_FC_CONG_PORTMAP45r_t FC_CONG_PORTMAP45r_t;
#define FC_CONG_PORTMAP45r_CLR BCM53101_A0_FC_CONG_PORTMAP45r_CLR
#define FC_CONG_PORTMAP45r_SET BCM53101_A0_FC_CONG_PORTMAP45r_SET
#define FC_CONG_PORTMAP45r_GET BCM53101_A0_FC_CONG_PORTMAP45r_GET
#define FC_CONG_PORTMAP45r_CONG_PORTMAP4f_GET BCM53101_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP4f_GET
#define FC_CONG_PORTMAP45r_CONG_PORTMAP4f_SET BCM53101_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP4f_SET
#define FC_CONG_PORTMAP45r_CONG_PORTMAP5f_GET BCM53101_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP5f_GET
#define FC_CONG_PORTMAP45r_CONG_PORTMAP5f_SET BCM53101_A0_FC_CONG_PORTMAP45r_CONG_PORTMAP5f_SET
#define READ_FC_CONG_PORTMAP45r BCM53101_A0_READ_FC_CONG_PORTMAP45r
#define WRITE_FC_CONG_PORTMAP45r BCM53101_A0_WRITE_FC_CONG_PORTMAP45r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_CONG_PORTMAP45r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_CONG_PORTMAP67
 * BLOCKS:   SYS
 * DESC:     Congested PortMap Port67 Register
 * SIZE:     16
 * FIELDS:
 *     CONG_PORTMAP6    Port 6 congest status for all Queuesbit[7:6] = congest status for Q3bit[5:4] = congest status for Q2bit[3:2] = congest status for Q1bit[1:0] = congest status for Q0
 *     CONG_PORTMAP7    Port 7 congest status for all Queuesbit[15:14] = congest status for Q3bit[13:12] = congest status for Q2bit[11:10] = congest status for Q1bit[9:8] = congest status for Q0
 *
 ******************************************************************************/
#define BCM53101_A0_FC_CONG_PORTMAP67r 0x00000a96

#define BCM53101_A0_FC_CONG_PORTMAP67r_SIZE 2

/*
 * This structure should be used to declare and program FC_CONG_PORTMAP67.
 *
 */
typedef union BCM53101_A0_FC_CONG_PORTMAP67r_s {
	uint32_t v[1];
	uint32_t fc_cong_portmap67[1];
	uint32_t _fc_cong_portmap67;
} BCM53101_A0_FC_CONG_PORTMAP67r_t;

#define BCM53101_A0_FC_CONG_PORTMAP67r_CLR(r) (r).fc_cong_portmap67[0] = 0
#define BCM53101_A0_FC_CONG_PORTMAP67r_SET(r,d) (r).fc_cong_portmap67[0] = d
#define BCM53101_A0_FC_CONG_PORTMAP67r_GET(r) (r).fc_cong_portmap67[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP6f_GET(r) (((r).fc_cong_portmap67[0]) & 0xff)
#define BCM53101_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP6f_SET(r,f) (r).fc_cong_portmap67[0]=(((r).fc_cong_portmap67[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53101_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP7f_GET(r) ((((r).fc_cong_portmap67[0]) >> 8) & 0xff)
#define BCM53101_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP7f_SET(r,f) (r).fc_cong_portmap67[0]=(((r).fc_cong_portmap67[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_CONG_PORTMAP67.
 *
 */
#define BCM53101_A0_READ_FC_CONG_PORTMAP67r(u,r) cdk_robo_reg_read(u,BCM53101_A0_FC_CONG_PORTMAP67r,(r._fc_cong_portmap67),2)
#define BCM53101_A0_WRITE_FC_CONG_PORTMAP67r(u,r) cdk_robo_reg_write(u,BCM53101_A0_FC_CONG_PORTMAP67r,&(r._fc_cong_portmap67),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_CONG_PORTMAP67r BCM53101_A0_FC_CONG_PORTMAP67r
#define FC_CONG_PORTMAP67r_SIZE BCM53101_A0_FC_CONG_PORTMAP67r_SIZE
typedef BCM53101_A0_FC_CONG_PORTMAP67r_t FC_CONG_PORTMAP67r_t;
#define FC_CONG_PORTMAP67r_CLR BCM53101_A0_FC_CONG_PORTMAP67r_CLR
#define FC_CONG_PORTMAP67r_SET BCM53101_A0_FC_CONG_PORTMAP67r_SET
#define FC_CONG_PORTMAP67r_GET BCM53101_A0_FC_CONG_PORTMAP67r_GET
#define FC_CONG_PORTMAP67r_CONG_PORTMAP6f_GET BCM53101_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP6f_GET
#define FC_CONG_PORTMAP67r_CONG_PORTMAP6f_SET BCM53101_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP6f_SET
#define FC_CONG_PORTMAP67r_CONG_PORTMAP7f_GET BCM53101_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP7f_GET
#define FC_CONG_PORTMAP67r_CONG_PORTMAP7f_SET BCM53101_A0_FC_CONG_PORTMAP67r_CONG_PORTMAP7f_SET
#define READ_FC_CONG_PORTMAP67r BCM53101_A0_READ_FC_CONG_PORTMAP67r
#define WRITE_FC_CONG_PORTMAP67r BCM53101_A0_WRITE_FC_CONG_PORTMAP67r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_CONG_PORTMAP67r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_CONG_PORTMAP8
 * BLOCKS:   SYS
 * DESC:     Congested PortMap Port8 Register
 * SIZE:     16
 * FIELDS:
 *     CONG_PORTMAP8    Port 8 congest status for all Queuesbit[7:6] = congest status for Q3bit[5:4] = congest status for Q2bit[3:2] = congest status for Q1bit[1:0] = congest status for Q0
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_FC_CONG_PORTMAP8r 0x00000a98

#define BCM53101_A0_FC_CONG_PORTMAP8r_SIZE 2

/*
 * This structure should be used to declare and program FC_CONG_PORTMAP8.
 *
 */
typedef union BCM53101_A0_FC_CONG_PORTMAP8r_s {
	uint32_t v[1];
	uint32_t fc_cong_portmap8[1];
	uint32_t _fc_cong_portmap8;
} BCM53101_A0_FC_CONG_PORTMAP8r_t;

#define BCM53101_A0_FC_CONG_PORTMAP8r_CLR(r) (r).fc_cong_portmap8[0] = 0
#define BCM53101_A0_FC_CONG_PORTMAP8r_SET(r,d) (r).fc_cong_portmap8[0] = d
#define BCM53101_A0_FC_CONG_PORTMAP8r_GET(r) (r).fc_cong_portmap8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_CONG_PORTMAP8r_CONG_PORTMAP8f_GET(r) (((r).fc_cong_portmap8[0]) & 0xff)
#define BCM53101_A0_FC_CONG_PORTMAP8r_CONG_PORTMAP8f_SET(r,f) (r).fc_cong_portmap8[0]=(((r).fc_cong_portmap8[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53101_A0_FC_CONG_PORTMAP8r_RESERVEDf_GET(r) ((((r).fc_cong_portmap8[0]) >> 8) & 0xff)
#define BCM53101_A0_FC_CONG_PORTMAP8r_RESERVEDf_SET(r,f) (r).fc_cong_portmap8[0]=(((r).fc_cong_portmap8[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_CONG_PORTMAP8.
 *
 */
#define BCM53101_A0_READ_FC_CONG_PORTMAP8r(u,r) cdk_robo_reg_read(u,BCM53101_A0_FC_CONG_PORTMAP8r,(r._fc_cong_portmap8),2)
#define BCM53101_A0_WRITE_FC_CONG_PORTMAP8r(u,r) cdk_robo_reg_write(u,BCM53101_A0_FC_CONG_PORTMAP8r,&(r._fc_cong_portmap8),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_CONG_PORTMAP8r BCM53101_A0_FC_CONG_PORTMAP8r
#define FC_CONG_PORTMAP8r_SIZE BCM53101_A0_FC_CONG_PORTMAP8r_SIZE
typedef BCM53101_A0_FC_CONG_PORTMAP8r_t FC_CONG_PORTMAP8r_t;
#define FC_CONG_PORTMAP8r_CLR BCM53101_A0_FC_CONG_PORTMAP8r_CLR
#define FC_CONG_PORTMAP8r_SET BCM53101_A0_FC_CONG_PORTMAP8r_SET
#define FC_CONG_PORTMAP8r_GET BCM53101_A0_FC_CONG_PORTMAP8r_GET
#define FC_CONG_PORTMAP8r_CONG_PORTMAP8f_GET BCM53101_A0_FC_CONG_PORTMAP8r_CONG_PORTMAP8f_GET
#define FC_CONG_PORTMAP8r_CONG_PORTMAP8f_SET BCM53101_A0_FC_CONG_PORTMAP8r_CONG_PORTMAP8f_SET
#define FC_CONG_PORTMAP8r_RESERVEDf_GET BCM53101_A0_FC_CONG_PORTMAP8r_RESERVEDf_GET
#define FC_CONG_PORTMAP8r_RESERVEDf_SET BCM53101_A0_FC_CONG_PORTMAP8r_RESERVEDf_SET
#define READ_FC_CONG_PORTMAP8r BCM53101_A0_READ_FC_CONG_PORTMAP8r
#define WRITE_FC_CONG_PORTMAP8r BCM53101_A0_WRITE_FC_CONG_PORTMAP8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_CONG_PORTMAP8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_DIAG_CTRL
 * BLOCKS:   SYS
 * DESC:     Flowcon Diagnosis Control Register
 * SIZE:     16
 * FIELDS:
 *     DIG_FLOWCON_PROT Diagnosis only: Select which port to be monitored.4'd0 : port 0; 4'd1: port1;  4'd 7: port 7
 *     RESERVED_1       Reserved.
 *     RESERVED_2       Reserved.
 *     RESERVED_3       Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_FC_DIAG_CTRLr 0x00000a00

#define BCM53101_A0_FC_DIAG_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program FC_DIAG_CTRL.
 *
 */
typedef union BCM53101_A0_FC_DIAG_CTRLr_s {
	uint32_t v[1];
	uint32_t fc_diag_ctrl[1];
	uint32_t _fc_diag_ctrl;
} BCM53101_A0_FC_DIAG_CTRLr_t;

#define BCM53101_A0_FC_DIAG_CTRLr_CLR(r) (r).fc_diag_ctrl[0] = 0
#define BCM53101_A0_FC_DIAG_CTRLr_SET(r,d) (r).fc_diag_ctrl[0] = d
#define BCM53101_A0_FC_DIAG_CTRLr_GET(r) (r).fc_diag_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_DIAG_CTRLr_DIG_FLOWCON_PROTf_GET(r) (((r).fc_diag_ctrl[0]) & 0xf)
#define BCM53101_A0_FC_DIAG_CTRLr_DIG_FLOWCON_PROTf_SET(r,f) (r).fc_diag_ctrl[0]=(((r).fc_diag_ctrl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53101_A0_FC_DIAG_CTRLr_RESERVED_1f_GET(r) ((((r).fc_diag_ctrl[0]) >> 4) & 0x3)
#define BCM53101_A0_FC_DIAG_CTRLr_RESERVED_1f_SET(r,f) (r).fc_diag_ctrl[0]=(((r).fc_diag_ctrl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53101_A0_FC_DIAG_CTRLr_RESERVED_2f_GET(r) ((((r).fc_diag_ctrl[0]) >> 6) & 0x3)
#define BCM53101_A0_FC_DIAG_CTRLr_RESERVED_2f_SET(r,f) (r).fc_diag_ctrl[0]=(((r).fc_diag_ctrl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53101_A0_FC_DIAG_CTRLr_RESERVED_3f_GET(r) ((((r).fc_diag_ctrl[0]) >> 8) & 0xff)
#define BCM53101_A0_FC_DIAG_CTRLr_RESERVED_3f_SET(r,f) (r).fc_diag_ctrl[0]=(((r).fc_diag_ctrl[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_DIAG_CTRL.
 *
 */
#define BCM53101_A0_READ_FC_DIAG_CTRLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_FC_DIAG_CTRLr,(r._fc_diag_ctrl),2)
#define BCM53101_A0_WRITE_FC_DIAG_CTRLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_FC_DIAG_CTRLr,&(r._fc_diag_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_DIAG_CTRLr BCM53101_A0_FC_DIAG_CTRLr
#define FC_DIAG_CTRLr_SIZE BCM53101_A0_FC_DIAG_CTRLr_SIZE
typedef BCM53101_A0_FC_DIAG_CTRLr_t FC_DIAG_CTRLr_t;
#define FC_DIAG_CTRLr_CLR BCM53101_A0_FC_DIAG_CTRLr_CLR
#define FC_DIAG_CTRLr_SET BCM53101_A0_FC_DIAG_CTRLr_SET
#define FC_DIAG_CTRLr_GET BCM53101_A0_FC_DIAG_CTRLr_GET
#define FC_DIAG_CTRLr_DIG_FLOWCON_PROTf_GET BCM53101_A0_FC_DIAG_CTRLr_DIG_FLOWCON_PROTf_GET
#define FC_DIAG_CTRLr_DIG_FLOWCON_PROTf_SET BCM53101_A0_FC_DIAG_CTRLr_DIG_FLOWCON_PROTf_SET
#define FC_DIAG_CTRLr_RESERVED_1f_GET BCM53101_A0_FC_DIAG_CTRLr_RESERVED_1f_GET
#define FC_DIAG_CTRLr_RESERVED_1f_SET BCM53101_A0_FC_DIAG_CTRLr_RESERVED_1f_SET
#define FC_DIAG_CTRLr_RESERVED_2f_GET BCM53101_A0_FC_DIAG_CTRLr_RESERVED_2f_GET
#define FC_DIAG_CTRLr_RESERVED_2f_SET BCM53101_A0_FC_DIAG_CTRLr_RESERVED_2f_SET
#define FC_DIAG_CTRLr_RESERVED_3f_GET BCM53101_A0_FC_DIAG_CTRLr_RESERVED_3f_GET
#define FC_DIAG_CTRLr_RESERVED_3f_SET BCM53101_A0_FC_DIAG_CTRLr_RESERVED_3f_SET
#define READ_FC_DIAG_CTRLr BCM53101_A0_READ_FC_DIAG_CTRLr
#define WRITE_FC_DIAG_CTRLr BCM53101_A0_WRITE_FC_DIAG_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_DIAG_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_GIGA_INFO
 * BLOCKS:   SYS
 * DESC:     Giga Speed Info For FC Register
 * SIZE:     16
 * FIELDS:
 *     GIGA_PORTMAP     
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_FC_GIGA_INFOr 0x00000a9c

#define BCM53101_A0_FC_GIGA_INFOr_SIZE 2

/*
 * This structure should be used to declare and program FC_GIGA_INFO.
 *
 */
typedef union BCM53101_A0_FC_GIGA_INFOr_s {
	uint32_t v[1];
	uint32_t fc_giga_info[1];
	uint32_t _fc_giga_info;
} BCM53101_A0_FC_GIGA_INFOr_t;

#define BCM53101_A0_FC_GIGA_INFOr_CLR(r) (r).fc_giga_info[0] = 0
#define BCM53101_A0_FC_GIGA_INFOr_SET(r,d) (r).fc_giga_info[0] = d
#define BCM53101_A0_FC_GIGA_INFOr_GET(r) (r).fc_giga_info[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_GIGA_INFOr_GIGA_PORTMAPf_GET(r) (((r).fc_giga_info[0]) & 0x1ff)
#define BCM53101_A0_FC_GIGA_INFOr_GIGA_PORTMAPf_SET(r,f) (r).fc_giga_info[0]=(((r).fc_giga_info[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_FC_GIGA_INFOr_RESERVEDf_GET(r) ((((r).fc_giga_info[0]) >> 9) & 0x7f)
#define BCM53101_A0_FC_GIGA_INFOr_RESERVEDf_SET(r,f) (r).fc_giga_info[0]=(((r).fc_giga_info[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access FC_GIGA_INFO.
 *
 */
#define BCM53101_A0_READ_FC_GIGA_INFOr(u,r) cdk_robo_reg_read(u,BCM53101_A0_FC_GIGA_INFOr,(r._fc_giga_info),2)
#define BCM53101_A0_WRITE_FC_GIGA_INFOr(u,r) cdk_robo_reg_write(u,BCM53101_A0_FC_GIGA_INFOr,&(r._fc_giga_info),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_GIGA_INFOr BCM53101_A0_FC_GIGA_INFOr
#define FC_GIGA_INFOr_SIZE BCM53101_A0_FC_GIGA_INFOr_SIZE
typedef BCM53101_A0_FC_GIGA_INFOr_t FC_GIGA_INFOr_t;
#define FC_GIGA_INFOr_CLR BCM53101_A0_FC_GIGA_INFOr_CLR
#define FC_GIGA_INFOr_SET BCM53101_A0_FC_GIGA_INFOr_SET
#define FC_GIGA_INFOr_GET BCM53101_A0_FC_GIGA_INFOr_GET
#define FC_GIGA_INFOr_GIGA_PORTMAPf_GET BCM53101_A0_FC_GIGA_INFOr_GIGA_PORTMAPf_GET
#define FC_GIGA_INFOr_GIGA_PORTMAPf_SET BCM53101_A0_FC_GIGA_INFOr_GIGA_PORTMAPf_SET
#define FC_GIGA_INFOr_RESERVEDf_GET BCM53101_A0_FC_GIGA_INFOr_RESERVEDf_GET
#define FC_GIGA_INFOr_RESERVEDf_SET BCM53101_A0_FC_GIGA_INFOr_RESERVEDf_SET
#define READ_FC_GIGA_INFOr BCM53101_A0_READ_FC_GIGA_INFOr
#define WRITE_FC_GIGA_INFOr BCM53101_A0_WRITE_FC_GIGA_INFOr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_GIGA_INFOr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_MCAST_DROP_CTRL
 * BLOCKS:   SYS
 * DESC:     Multicast Drop Control Register
 * SIZE:     16
 * FIELDS:
 *     PAR_DROP_EN      Multicast Partial Drop Enalbed.Bit 8 = IMP port,Bit 5:0 = Port 5 ~ Port 0,1: Multicast Frame can forward to uncongested Destination Port, and will not forward to congested Destination Port0: Multicast Frame can forward only if all destination ports are not congested.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_FC_MCAST_DROP_CTRLr 0x00000a0c

#define BCM53101_A0_FC_MCAST_DROP_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program FC_MCAST_DROP_CTRL.
 *
 */
typedef union BCM53101_A0_FC_MCAST_DROP_CTRLr_s {
	uint32_t v[1];
	uint32_t fc_mcast_drop_ctrl[1];
	uint32_t _fc_mcast_drop_ctrl;
} BCM53101_A0_FC_MCAST_DROP_CTRLr_t;

#define BCM53101_A0_FC_MCAST_DROP_CTRLr_CLR(r) (r).fc_mcast_drop_ctrl[0] = 0
#define BCM53101_A0_FC_MCAST_DROP_CTRLr_SET(r,d) (r).fc_mcast_drop_ctrl[0] = d
#define BCM53101_A0_FC_MCAST_DROP_CTRLr_GET(r) (r).fc_mcast_drop_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_MCAST_DROP_CTRLr_PAR_DROP_ENf_GET(r) (((r).fc_mcast_drop_ctrl[0]) & 0x1ff)
#define BCM53101_A0_FC_MCAST_DROP_CTRLr_PAR_DROP_ENf_SET(r,f) (r).fc_mcast_drop_ctrl[0]=(((r).fc_mcast_drop_ctrl[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_FC_MCAST_DROP_CTRLr_RESERVEDf_GET(r) ((((r).fc_mcast_drop_ctrl[0]) >> 9) & 0x7f)
#define BCM53101_A0_FC_MCAST_DROP_CTRLr_RESERVEDf_SET(r,f) (r).fc_mcast_drop_ctrl[0]=(((r).fc_mcast_drop_ctrl[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access FC_MCAST_DROP_CTRL.
 *
 */
#define BCM53101_A0_READ_FC_MCAST_DROP_CTRLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_FC_MCAST_DROP_CTRLr,(r._fc_mcast_drop_ctrl),2)
#define BCM53101_A0_WRITE_FC_MCAST_DROP_CTRLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_FC_MCAST_DROP_CTRLr,&(r._fc_mcast_drop_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_MCAST_DROP_CTRLr BCM53101_A0_FC_MCAST_DROP_CTRLr
#define FC_MCAST_DROP_CTRLr_SIZE BCM53101_A0_FC_MCAST_DROP_CTRLr_SIZE
typedef BCM53101_A0_FC_MCAST_DROP_CTRLr_t FC_MCAST_DROP_CTRLr_t;
#define FC_MCAST_DROP_CTRLr_CLR BCM53101_A0_FC_MCAST_DROP_CTRLr_CLR
#define FC_MCAST_DROP_CTRLr_SET BCM53101_A0_FC_MCAST_DROP_CTRLr_SET
#define FC_MCAST_DROP_CTRLr_GET BCM53101_A0_FC_MCAST_DROP_CTRLr_GET
#define FC_MCAST_DROP_CTRLr_PAR_DROP_ENf_GET BCM53101_A0_FC_MCAST_DROP_CTRLr_PAR_DROP_ENf_GET
#define FC_MCAST_DROP_CTRLr_PAR_DROP_ENf_SET BCM53101_A0_FC_MCAST_DROP_CTRLr_PAR_DROP_ENf_SET
#define FC_MCAST_DROP_CTRLr_RESERVEDf_GET BCM53101_A0_FC_MCAST_DROP_CTRLr_RESERVEDf_GET
#define FC_MCAST_DROP_CTRLr_RESERVEDf_SET BCM53101_A0_FC_MCAST_DROP_CTRLr_RESERVEDf_SET
#define READ_FC_MCAST_DROP_CTRLr BCM53101_A0_READ_FC_MCAST_DROP_CTRLr
#define WRITE_FC_MCAST_DROP_CTRLr BCM53101_A0_WRITE_FC_MCAST_DROP_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_MCAST_DROP_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_MON_TXQ
 * BLOCKS:   SYS
 * DESC:     Monitored TxQ N (0~5) Register
 * SIZE:     16
 * FIELDS:
 *     MONITORED_TXQ_CNT Monitor TxQ 0~5 countTxQ 4/% indicate Class4/% trafficThe diag_port setting in Diag register(Page 0A, Offset 00) can be selected for different Ports.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_FC_MON_TXQr 0x00000a60

#define BCM53101_A0_FC_MON_TXQr_SIZE 2

/*
 * This structure should be used to declare and program FC_MON_TXQ.
 *
 */
typedef union BCM53101_A0_FC_MON_TXQr_s {
	uint32_t v[1];
	uint32_t fc_mon_txq[1];
	uint32_t _fc_mon_txq;
} BCM53101_A0_FC_MON_TXQr_t;

#define BCM53101_A0_FC_MON_TXQr_CLR(r) (r).fc_mon_txq[0] = 0
#define BCM53101_A0_FC_MON_TXQr_SET(r,d) (r).fc_mon_txq[0] = d
#define BCM53101_A0_FC_MON_TXQr_GET(r) (r).fc_mon_txq[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_MON_TXQr_MONITORED_TXQ_CNTf_GET(r) (((r).fc_mon_txq[0]) & 0x7ff)
#define BCM53101_A0_FC_MON_TXQr_MONITORED_TXQ_CNTf_SET(r,f) (r).fc_mon_txq[0]=(((r).fc_mon_txq[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53101_A0_FC_MON_TXQr_RESERVEDf_GET(r) ((((r).fc_mon_txq[0]) >> 11) & 0x1f)
#define BCM53101_A0_FC_MON_TXQr_RESERVEDf_SET(r,f) (r).fc_mon_txq[0]=(((r).fc_mon_txq[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_MON_TXQ.
 *
 */
#define BCM53101_A0_READ_FC_MON_TXQr(u,i,r) cdk_robo_reg_read(u,BCM53101_A0_FC_MON_TXQr+(2*(i)),(r._fc_mon_txq),2)
#define BCM53101_A0_WRITE_FC_MON_TXQr(u,i,r) cdk_robo_reg_write(u,BCM53101_A0_FC_MON_TXQr+(2*(i)),&(r._fc_mon_txq),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_MON_TXQr BCM53101_A0_FC_MON_TXQr
#define FC_MON_TXQr_SIZE BCM53101_A0_FC_MON_TXQr_SIZE
typedef BCM53101_A0_FC_MON_TXQr_t FC_MON_TXQr_t;
#define FC_MON_TXQr_CLR BCM53101_A0_FC_MON_TXQr_CLR
#define FC_MON_TXQr_SET BCM53101_A0_FC_MON_TXQr_SET
#define FC_MON_TXQr_GET BCM53101_A0_FC_MON_TXQr_GET
#define FC_MON_TXQr_MONITORED_TXQ_CNTf_GET BCM53101_A0_FC_MON_TXQr_MONITORED_TXQ_CNTf_GET
#define FC_MON_TXQr_MONITORED_TXQ_CNTf_SET BCM53101_A0_FC_MON_TXQr_MONITORED_TXQ_CNTf_SET
#define FC_MON_TXQr_RESERVEDf_GET BCM53101_A0_FC_MON_TXQr_RESERVEDf_GET
#define FC_MON_TXQr_RESERVEDf_SET BCM53101_A0_FC_MON_TXQr_RESERVEDf_SET
#define READ_FC_MON_TXQr BCM53101_A0_READ_FC_MON_TXQr
#define WRITE_FC_MON_TXQr BCM53101_A0_WRITE_FC_MON_TXQr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_MON_TXQr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_PAUSE_DROP_CTRL
 * BLOCKS:   SYS
 * DESC:     Pause/Drop Control Register
 * SIZE:     16
 * FIELDS:
 *     EN_TX_PAUSE      To enable txq pause machinism on Ethernet port
 *     EN_TX_DROP       
 *     EN_TOTAL_PAUSE   To enable total pause machinism on Ethernet port
 *     EN_TOTAL_DROP    
 *     EN_TX_LEGACY_PAUSE 
 *     RESERVED         Reserved.
 *     EN_RX_PAUSE      
 *     EN_RX_DROP       
 *     RESERVED_0       Reserved.
 *     EN_IMP1_TXQ_PAUSE To enable txq pause machinism on IMP1
 *     EN_IMP1_TOTAL_PAUSE To enable total pause machinism on IMP1
 *     EN_IMP_TXQ_PAUSE To enable txq pause machinism on IMP/IMP0
 *     EN_IMP_TOTAL_PAUSE To enable total pause machinism on IMP/IMP0
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_FC_PAUSE_DROP_CTRLr 0x00000a0e

#define BCM53101_A0_FC_PAUSE_DROP_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program FC_PAUSE_DROP_CTRL.
 *
 */
typedef union BCM53101_A0_FC_PAUSE_DROP_CTRLr_s {
	uint32_t v[1];
	uint32_t fc_pause_drop_ctrl[1];
	uint32_t _fc_pause_drop_ctrl;
} BCM53101_A0_FC_PAUSE_DROP_CTRLr_t;

#define BCM53101_A0_FC_PAUSE_DROP_CTRLr_CLR(r) (r).fc_pause_drop_ctrl[0] = 0
#define BCM53101_A0_FC_PAUSE_DROP_CTRLr_SET(r,d) (r).fc_pause_drop_ctrl[0] = d
#define BCM53101_A0_FC_PAUSE_DROP_CTRLr_GET(r) (r).fc_pause_drop_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_TX_PAUSEf_GET(r) (((r).fc_pause_drop_ctrl[0]) & 0x1)
#define BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_TX_PAUSEf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_TX_DROPf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 1) & 0x1)
#define BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_TX_DROPf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_PAUSEf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 2) & 0x1)
#define BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_PAUSEf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_DROPf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 3) & 0x1)
#define BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_DROPf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_TX_LEGACY_PAUSEf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 4) & 0x1)
#define BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_TX_LEGACY_PAUSEf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_FC_PAUSE_DROP_CTRLr_RESERVEDf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 5) & 0x1)
#define BCM53101_A0_FC_PAUSE_DROP_CTRLr_RESERVEDf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_RX_PAUSEf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 6) & 0x1)
#define BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_RX_PAUSEf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_RX_DROPf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 7) & 0x1)
#define BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_RX_DROPf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53101_A0_FC_PAUSE_DROP_CTRLr_RESERVED_0f_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 8) & 0x1)
#define BCM53101_A0_FC_PAUSE_DROP_CTRLr_RESERVED_0f_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_IMP1_TXQ_PAUSEf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 9) & 0x1)
#define BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_IMP1_TXQ_PAUSEf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_IMP1_TOTAL_PAUSEf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 10) & 0x1)
#define BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_IMP1_TOTAL_PAUSEf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_IMP_TXQ_PAUSEf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 11) & 0x1)
#define BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_IMP_TXQ_PAUSEf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_IMP_TOTAL_PAUSEf_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 12) & 0x1)
#define BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_IMP_TOTAL_PAUSEf_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53101_A0_FC_PAUSE_DROP_CTRLr_RESERVED_1f_GET(r) ((((r).fc_pause_drop_ctrl[0]) >> 13) & 0x7)
#define BCM53101_A0_FC_PAUSE_DROP_CTRLr_RESERVED_1f_SET(r,f) (r).fc_pause_drop_ctrl[0]=(((r).fc_pause_drop_ctrl[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access FC_PAUSE_DROP_CTRL.
 *
 */
#define BCM53101_A0_READ_FC_PAUSE_DROP_CTRLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_FC_PAUSE_DROP_CTRLr,(r._fc_pause_drop_ctrl),2)
#define BCM53101_A0_WRITE_FC_PAUSE_DROP_CTRLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_FC_PAUSE_DROP_CTRLr,&(r._fc_pause_drop_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_PAUSE_DROP_CTRLr BCM53101_A0_FC_PAUSE_DROP_CTRLr
#define FC_PAUSE_DROP_CTRLr_SIZE BCM53101_A0_FC_PAUSE_DROP_CTRLr_SIZE
typedef BCM53101_A0_FC_PAUSE_DROP_CTRLr_t FC_PAUSE_DROP_CTRLr_t;
#define FC_PAUSE_DROP_CTRLr_CLR BCM53101_A0_FC_PAUSE_DROP_CTRLr_CLR
#define FC_PAUSE_DROP_CTRLr_SET BCM53101_A0_FC_PAUSE_DROP_CTRLr_SET
#define FC_PAUSE_DROP_CTRLr_GET BCM53101_A0_FC_PAUSE_DROP_CTRLr_GET
#define FC_PAUSE_DROP_CTRLr_EN_TX_PAUSEf_GET BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_TX_PAUSEf_GET
#define FC_PAUSE_DROP_CTRLr_EN_TX_PAUSEf_SET BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_TX_PAUSEf_SET
#define FC_PAUSE_DROP_CTRLr_EN_TX_DROPf_GET BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_TX_DROPf_GET
#define FC_PAUSE_DROP_CTRLr_EN_TX_DROPf_SET BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_TX_DROPf_SET
#define FC_PAUSE_DROP_CTRLr_EN_TOTAL_PAUSEf_GET BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_PAUSEf_GET
#define FC_PAUSE_DROP_CTRLr_EN_TOTAL_PAUSEf_SET BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_PAUSEf_SET
#define FC_PAUSE_DROP_CTRLr_EN_TOTAL_DROPf_GET BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_DROPf_GET
#define FC_PAUSE_DROP_CTRLr_EN_TOTAL_DROPf_SET BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_TOTAL_DROPf_SET
#define FC_PAUSE_DROP_CTRLr_EN_TX_LEGACY_PAUSEf_GET BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_TX_LEGACY_PAUSEf_GET
#define FC_PAUSE_DROP_CTRLr_EN_TX_LEGACY_PAUSEf_SET BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_TX_LEGACY_PAUSEf_SET
#define FC_PAUSE_DROP_CTRLr_RESERVEDf_GET BCM53101_A0_FC_PAUSE_DROP_CTRLr_RESERVEDf_GET
#define FC_PAUSE_DROP_CTRLr_RESERVEDf_SET BCM53101_A0_FC_PAUSE_DROP_CTRLr_RESERVEDf_SET
#define FC_PAUSE_DROP_CTRLr_EN_RX_PAUSEf_GET BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_RX_PAUSEf_GET
#define FC_PAUSE_DROP_CTRLr_EN_RX_PAUSEf_SET BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_RX_PAUSEf_SET
#define FC_PAUSE_DROP_CTRLr_EN_RX_DROPf_GET BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_RX_DROPf_GET
#define FC_PAUSE_DROP_CTRLr_EN_RX_DROPf_SET BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_RX_DROPf_SET
#define FC_PAUSE_DROP_CTRLr_RESERVED_0f_GET BCM53101_A0_FC_PAUSE_DROP_CTRLr_RESERVED_0f_GET
#define FC_PAUSE_DROP_CTRLr_RESERVED_0f_SET BCM53101_A0_FC_PAUSE_DROP_CTRLr_RESERVED_0f_SET
#define FC_PAUSE_DROP_CTRLr_EN_IMP1_TXQ_PAUSEf_GET BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_IMP1_TXQ_PAUSEf_GET
#define FC_PAUSE_DROP_CTRLr_EN_IMP1_TXQ_PAUSEf_SET BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_IMP1_TXQ_PAUSEf_SET
#define FC_PAUSE_DROP_CTRLr_EN_IMP1_TOTAL_PAUSEf_GET BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_IMP1_TOTAL_PAUSEf_GET
#define FC_PAUSE_DROP_CTRLr_EN_IMP1_TOTAL_PAUSEf_SET BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_IMP1_TOTAL_PAUSEf_SET
#define FC_PAUSE_DROP_CTRLr_EN_IMP_TXQ_PAUSEf_GET BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_IMP_TXQ_PAUSEf_GET
#define FC_PAUSE_DROP_CTRLr_EN_IMP_TXQ_PAUSEf_SET BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_IMP_TXQ_PAUSEf_SET
#define FC_PAUSE_DROP_CTRLr_EN_IMP_TOTAL_PAUSEf_GET BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_IMP_TOTAL_PAUSEf_GET
#define FC_PAUSE_DROP_CTRLr_EN_IMP_TOTAL_PAUSEf_SET BCM53101_A0_FC_PAUSE_DROP_CTRLr_EN_IMP_TOTAL_PAUSEf_SET
#define FC_PAUSE_DROP_CTRLr_RESERVED_1f_GET BCM53101_A0_FC_PAUSE_DROP_CTRLr_RESERVED_1f_GET
#define FC_PAUSE_DROP_CTRLr_RESERVED_1f_SET BCM53101_A0_FC_PAUSE_DROP_CTRLr_RESERVED_1f_SET
#define READ_FC_PAUSE_DROP_CTRLr BCM53101_A0_READ_FC_PAUSE_DROP_CTRLr
#define WRITE_FC_PAUSE_DROP_CTRLr BCM53101_A0_WRITE_FC_PAUSE_DROP_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_PAUSE_DROP_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_PAUSE_HIS
 * BLOCKS:   SYS
 * DESC:     Pause History Register
 * SIZE:     16
 * FIELDS:
 *     PAUSE_HIS        
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_FC_PAUSE_HISr 0x00000aa0

#define BCM53101_A0_FC_PAUSE_HISr_SIZE 2

/*
 * This structure should be used to declare and program FC_PAUSE_HIS.
 *
 */
typedef union BCM53101_A0_FC_PAUSE_HISr_s {
	uint32_t v[1];
	uint32_t fc_pause_his[1];
	uint32_t _fc_pause_his;
} BCM53101_A0_FC_PAUSE_HISr_t;

#define BCM53101_A0_FC_PAUSE_HISr_CLR(r) (r).fc_pause_his[0] = 0
#define BCM53101_A0_FC_PAUSE_HISr_SET(r,d) (r).fc_pause_his[0] = d
#define BCM53101_A0_FC_PAUSE_HISr_GET(r) (r).fc_pause_his[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_PAUSE_HISr_PAUSE_HISf_GET(r) (((r).fc_pause_his[0]) & 0x7ff)
#define BCM53101_A0_FC_PAUSE_HISr_PAUSE_HISf_SET(r,f) (r).fc_pause_his[0]=(((r).fc_pause_his[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53101_A0_FC_PAUSE_HISr_RESERVEDf_GET(r) ((((r).fc_pause_his[0]) >> 11) & 0x1f)
#define BCM53101_A0_FC_PAUSE_HISr_RESERVEDf_SET(r,f) (r).fc_pause_his[0]=(((r).fc_pause_his[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_PAUSE_HIS.
 *
 */
#define BCM53101_A0_READ_FC_PAUSE_HISr(u,r) cdk_robo_reg_read(u,BCM53101_A0_FC_PAUSE_HISr,(r._fc_pause_his),2)
#define BCM53101_A0_WRITE_FC_PAUSE_HISr(u,r) cdk_robo_reg_write(u,BCM53101_A0_FC_PAUSE_HISr,&(r._fc_pause_his),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_PAUSE_HISr BCM53101_A0_FC_PAUSE_HISr
#define FC_PAUSE_HISr_SIZE BCM53101_A0_FC_PAUSE_HISr_SIZE
typedef BCM53101_A0_FC_PAUSE_HISr_t FC_PAUSE_HISr_t;
#define FC_PAUSE_HISr_CLR BCM53101_A0_FC_PAUSE_HISr_CLR
#define FC_PAUSE_HISr_SET BCM53101_A0_FC_PAUSE_HISr_SET
#define FC_PAUSE_HISr_GET BCM53101_A0_FC_PAUSE_HISr_GET
#define FC_PAUSE_HISr_PAUSE_HISf_GET BCM53101_A0_FC_PAUSE_HISr_PAUSE_HISf_GET
#define FC_PAUSE_HISr_PAUSE_HISf_SET BCM53101_A0_FC_PAUSE_HISr_PAUSE_HISf_SET
#define FC_PAUSE_HISr_RESERVEDf_GET BCM53101_A0_FC_PAUSE_HISr_RESERVEDf_GET
#define FC_PAUSE_HISr_RESERVEDf_SET BCM53101_A0_FC_PAUSE_HISr_RESERVEDf_SET
#define READ_FC_PAUSE_HISr BCM53101_A0_READ_FC_PAUSE_HISr
#define WRITE_FC_PAUSE_HISr BCM53101_A0_WRITE_FC_PAUSE_HISr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_PAUSE_HISr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_PEAK_RXBYTE
 * BLOCKS:   SYS
 * DESC:     Peak Rx Buffer Count Register
 * SIZE:     16
 * FIELDS:
 *     PEAK_RXBUFFER_CNT Peak Rx Byte count.The diag_port setting in Diag register (Page 0A, Offset 00) can be selected for different Ports.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_FC_PEAK_RXBYTEr 0x00000a78

#define BCM53101_A0_FC_PEAK_RXBYTEr_SIZE 2

/*
 * This structure should be used to declare and program FC_PEAK_RXBYTE.
 *
 */
typedef union BCM53101_A0_FC_PEAK_RXBYTEr_s {
	uint32_t v[1];
	uint32_t fc_peak_rxbyte[1];
	uint32_t _fc_peak_rxbyte;
} BCM53101_A0_FC_PEAK_RXBYTEr_t;

#define BCM53101_A0_FC_PEAK_RXBYTEr_CLR(r) (r).fc_peak_rxbyte[0] = 0
#define BCM53101_A0_FC_PEAK_RXBYTEr_SET(r,d) (r).fc_peak_rxbyte[0] = d
#define BCM53101_A0_FC_PEAK_RXBYTEr_GET(r) (r).fc_peak_rxbyte[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_PEAK_RXBYTEr_PEAK_RXBUFFER_CNTf_GET(r) (((r).fc_peak_rxbyte[0]) & 0x7ff)
#define BCM53101_A0_FC_PEAK_RXBYTEr_PEAK_RXBUFFER_CNTf_SET(r,f) (r).fc_peak_rxbyte[0]=(((r).fc_peak_rxbyte[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53101_A0_FC_PEAK_RXBYTEr_RESERVEDf_GET(r) ((((r).fc_peak_rxbyte[0]) >> 11) & 0x1f)
#define BCM53101_A0_FC_PEAK_RXBYTEr_RESERVEDf_SET(r,f) (r).fc_peak_rxbyte[0]=(((r).fc_peak_rxbyte[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_PEAK_RXBYTE.
 *
 */
#define BCM53101_A0_READ_FC_PEAK_RXBYTEr(u,r) cdk_robo_reg_read(u,BCM53101_A0_FC_PEAK_RXBYTEr,(r._fc_peak_rxbyte),2)
#define BCM53101_A0_WRITE_FC_PEAK_RXBYTEr(u,r) cdk_robo_reg_write(u,BCM53101_A0_FC_PEAK_RXBYTEr,&(r._fc_peak_rxbyte),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_PEAK_RXBYTEr BCM53101_A0_FC_PEAK_RXBYTEr
#define FC_PEAK_RXBYTEr_SIZE BCM53101_A0_FC_PEAK_RXBYTEr_SIZE
typedef BCM53101_A0_FC_PEAK_RXBYTEr_t FC_PEAK_RXBYTEr_t;
#define FC_PEAK_RXBYTEr_CLR BCM53101_A0_FC_PEAK_RXBYTEr_CLR
#define FC_PEAK_RXBYTEr_SET BCM53101_A0_FC_PEAK_RXBYTEr_SET
#define FC_PEAK_RXBYTEr_GET BCM53101_A0_FC_PEAK_RXBYTEr_GET
#define FC_PEAK_RXBYTEr_PEAK_RXBUFFER_CNTf_GET BCM53101_A0_FC_PEAK_RXBYTEr_PEAK_RXBUFFER_CNTf_GET
#define FC_PEAK_RXBYTEr_PEAK_RXBUFFER_CNTf_SET BCM53101_A0_FC_PEAK_RXBYTEr_PEAK_RXBUFFER_CNTf_SET
#define FC_PEAK_RXBYTEr_RESERVEDf_GET BCM53101_A0_FC_PEAK_RXBYTEr_RESERVEDf_GET
#define FC_PEAK_RXBYTEr_RESERVEDf_SET BCM53101_A0_FC_PEAK_RXBYTEr_RESERVEDf_SET
#define READ_FC_PEAK_RXBYTEr BCM53101_A0_READ_FC_PEAK_RXBYTEr
#define WRITE_FC_PEAK_RXBYTEr BCM53101_A0_WRITE_FC_PEAK_RXBYTEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_PEAK_RXBYTEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_PEAK_TOTAL_USED
 * BLOCKS:   SYS
 * DESC:     Peak Total Used Count Register
 * SIZE:     16
 * FIELDS:
 *     PEAK_TOTAL_USE   Peak Total Used count.This register lock the peak value of total used count.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_FC_PEAK_TOTAL_USEDr 0x00000a80

#define BCM53101_A0_FC_PEAK_TOTAL_USEDr_SIZE 2

/*
 * This structure should be used to declare and program FC_PEAK_TOTAL_USED.
 *
 */
typedef union BCM53101_A0_FC_PEAK_TOTAL_USEDr_s {
	uint32_t v[1];
	uint32_t fc_peak_total_used[1];
	uint32_t _fc_peak_total_used;
} BCM53101_A0_FC_PEAK_TOTAL_USEDr_t;

#define BCM53101_A0_FC_PEAK_TOTAL_USEDr_CLR(r) (r).fc_peak_total_used[0] = 0
#define BCM53101_A0_FC_PEAK_TOTAL_USEDr_SET(r,d) (r).fc_peak_total_used[0] = d
#define BCM53101_A0_FC_PEAK_TOTAL_USEDr_GET(r) (r).fc_peak_total_used[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_PEAK_TOTAL_USEDr_PEAK_TOTAL_USEf_GET(r) (((r).fc_peak_total_used[0]) & 0x7ff)
#define BCM53101_A0_FC_PEAK_TOTAL_USEDr_PEAK_TOTAL_USEf_SET(r,f) (r).fc_peak_total_used[0]=(((r).fc_peak_total_used[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53101_A0_FC_PEAK_TOTAL_USEDr_RESERVEDf_GET(r) ((((r).fc_peak_total_used[0]) >> 11) & 0x1f)
#define BCM53101_A0_FC_PEAK_TOTAL_USEDr_RESERVEDf_SET(r,f) (r).fc_peak_total_used[0]=(((r).fc_peak_total_used[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_PEAK_TOTAL_USED.
 *
 */
#define BCM53101_A0_READ_FC_PEAK_TOTAL_USEDr(u,r) cdk_robo_reg_read(u,BCM53101_A0_FC_PEAK_TOTAL_USEDr,(r._fc_peak_total_used),2)
#define BCM53101_A0_WRITE_FC_PEAK_TOTAL_USEDr(u,r) cdk_robo_reg_write(u,BCM53101_A0_FC_PEAK_TOTAL_USEDr,&(r._fc_peak_total_used),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_PEAK_TOTAL_USEDr BCM53101_A0_FC_PEAK_TOTAL_USEDr
#define FC_PEAK_TOTAL_USEDr_SIZE BCM53101_A0_FC_PEAK_TOTAL_USEDr_SIZE
typedef BCM53101_A0_FC_PEAK_TOTAL_USEDr_t FC_PEAK_TOTAL_USEDr_t;
#define FC_PEAK_TOTAL_USEDr_CLR BCM53101_A0_FC_PEAK_TOTAL_USEDr_CLR
#define FC_PEAK_TOTAL_USEDr_SET BCM53101_A0_FC_PEAK_TOTAL_USEDr_SET
#define FC_PEAK_TOTAL_USEDr_GET BCM53101_A0_FC_PEAK_TOTAL_USEDr_GET
#define FC_PEAK_TOTAL_USEDr_PEAK_TOTAL_USEf_GET BCM53101_A0_FC_PEAK_TOTAL_USEDr_PEAK_TOTAL_USEf_GET
#define FC_PEAK_TOTAL_USEDr_PEAK_TOTAL_USEf_SET BCM53101_A0_FC_PEAK_TOTAL_USEDr_PEAK_TOTAL_USEf_SET
#define FC_PEAK_TOTAL_USEDr_RESERVEDf_GET BCM53101_A0_FC_PEAK_TOTAL_USEDr_RESERVEDf_GET
#define FC_PEAK_TOTAL_USEDr_RESERVEDf_SET BCM53101_A0_FC_PEAK_TOTAL_USEDr_RESERVEDf_SET
#define READ_FC_PEAK_TOTAL_USEDr BCM53101_A0_READ_FC_PEAK_TOTAL_USEDr
#define WRITE_FC_PEAK_TOTAL_USEDr BCM53101_A0_WRITE_FC_PEAK_TOTAL_USEDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_PEAK_TOTAL_USEDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_PEAK_TXQ
 * BLOCKS:   SYS
 * DESC:     Peak TxQ N (0~3) Counter Register
 * SIZE:     16
 * FIELDS:
 *     PEAK_TXBCNT      Peak TxQ 0~3 counr.The diag_port setting in Diag register (Page 0Ah, Offset 00h)can selected for different Ports.Diagnosis only: read on clear.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_FC_PEAK_TXQr 0x00000a70

#define BCM53101_A0_FC_PEAK_TXQr_SIZE 2

/*
 * This structure should be used to declare and program FC_PEAK_TXQ.
 *
 */
typedef union BCM53101_A0_FC_PEAK_TXQr_s {
	uint32_t v[1];
	uint32_t fc_peak_txq[1];
	uint32_t _fc_peak_txq;
} BCM53101_A0_FC_PEAK_TXQr_t;

#define BCM53101_A0_FC_PEAK_TXQr_CLR(r) (r).fc_peak_txq[0] = 0
#define BCM53101_A0_FC_PEAK_TXQr_SET(r,d) (r).fc_peak_txq[0] = d
#define BCM53101_A0_FC_PEAK_TXQr_GET(r) (r).fc_peak_txq[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_PEAK_TXQr_PEAK_TXBCNTf_GET(r) (((r).fc_peak_txq[0]) & 0x7ff)
#define BCM53101_A0_FC_PEAK_TXQr_PEAK_TXBCNTf_SET(r,f) (r).fc_peak_txq[0]=(((r).fc_peak_txq[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53101_A0_FC_PEAK_TXQr_RESERVEDf_GET(r) ((((r).fc_peak_txq[0]) >> 10) & 0x3f)
#define BCM53101_A0_FC_PEAK_TXQr_RESERVEDf_SET(r,f) (r).fc_peak_txq[0]=(((r).fc_peak_txq[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_PEAK_TXQ.
 *
 */
#define BCM53101_A0_READ_FC_PEAK_TXQr(u,i,r) cdk_robo_reg_read(u,BCM53101_A0_FC_PEAK_TXQr+(2*(i)),(r._fc_peak_txq),2)
#define BCM53101_A0_WRITE_FC_PEAK_TXQr(u,i,r) cdk_robo_reg_write(u,BCM53101_A0_FC_PEAK_TXQr+(2*(i)),&(r._fc_peak_txq),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_PEAK_TXQr BCM53101_A0_FC_PEAK_TXQr
#define FC_PEAK_TXQr_SIZE BCM53101_A0_FC_PEAK_TXQr_SIZE
typedef BCM53101_A0_FC_PEAK_TXQr_t FC_PEAK_TXQr_t;
#define FC_PEAK_TXQr_CLR BCM53101_A0_FC_PEAK_TXQr_CLR
#define FC_PEAK_TXQr_SET BCM53101_A0_FC_PEAK_TXQr_SET
#define FC_PEAK_TXQr_GET BCM53101_A0_FC_PEAK_TXQr_GET
#define FC_PEAK_TXQr_PEAK_TXBCNTf_GET BCM53101_A0_FC_PEAK_TXQr_PEAK_TXBCNTf_GET
#define FC_PEAK_TXQr_PEAK_TXBCNTf_SET BCM53101_A0_FC_PEAK_TXQr_PEAK_TXBCNTf_SET
#define FC_PEAK_TXQr_RESERVEDf_GET BCM53101_A0_FC_PEAK_TXQr_RESERVEDf_GET
#define FC_PEAK_TXQr_RESERVEDf_SET BCM53101_A0_FC_PEAK_TXQr_RESERVEDf_SET
#define READ_FC_PEAK_TXQr BCM53101_A0_READ_FC_PEAK_TXQr
#define WRITE_FC_PEAK_TXQr BCM53101_A0_WRITE_FC_PEAK_TXQr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_PEAK_TXQr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_PEAK_TXQ_45
 * BLOCKS:   SYS
 * DESC:     Peak TxQ N (4~5) Counter Register
 * SIZE:     16
 * FIELDS:
 *     PEAK_TXBCNT      Peak TxQ 4~5 counr.The diag_port setting in Diag register (Page 0Ah, Offset 00h)can selected for different Ports.Diagnosis only: read on clear.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_FC_PEAK_TXQ_45r 0x00000a88

#define BCM53101_A0_FC_PEAK_TXQ_45r_SIZE 2

/*
 * This structure should be used to declare and program FC_PEAK_TXQ_45.
 *
 */
typedef union BCM53101_A0_FC_PEAK_TXQ_45r_s {
	uint32_t v[1];
	uint32_t fc_peak_txq_45[1];
	uint32_t _fc_peak_txq_45;
} BCM53101_A0_FC_PEAK_TXQ_45r_t;

#define BCM53101_A0_FC_PEAK_TXQ_45r_CLR(r) (r).fc_peak_txq_45[0] = 0
#define BCM53101_A0_FC_PEAK_TXQ_45r_SET(r,d) (r).fc_peak_txq_45[0] = d
#define BCM53101_A0_FC_PEAK_TXQ_45r_GET(r) (r).fc_peak_txq_45[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_PEAK_TXQ_45r_PEAK_TXBCNTf_GET(r) (((r).fc_peak_txq_45[0]) & 0x7ff)
#define BCM53101_A0_FC_PEAK_TXQ_45r_PEAK_TXBCNTf_SET(r,f) (r).fc_peak_txq_45[0]=(((r).fc_peak_txq_45[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53101_A0_FC_PEAK_TXQ_45r_RESERVEDf_GET(r) ((((r).fc_peak_txq_45[0]) >> 10) & 0x3f)
#define BCM53101_A0_FC_PEAK_TXQ_45r_RESERVEDf_SET(r,f) (r).fc_peak_txq_45[0]=(((r).fc_peak_txq_45[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_PEAK_TXQ_45.
 *
 */
#define BCM53101_A0_READ_FC_PEAK_TXQ_45r(u,i,r) cdk_robo_reg_read(u,BCM53101_A0_FC_PEAK_TXQ_45r+(2*(i)),(r._fc_peak_txq_45),2)
#define BCM53101_A0_WRITE_FC_PEAK_TXQ_45r(u,i,r) cdk_robo_reg_write(u,BCM53101_A0_FC_PEAK_TXQ_45r+(2*(i)),&(r._fc_peak_txq_45),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_PEAK_TXQ_45r BCM53101_A0_FC_PEAK_TXQ_45r
#define FC_PEAK_TXQ_45r_SIZE BCM53101_A0_FC_PEAK_TXQ_45r_SIZE
typedef BCM53101_A0_FC_PEAK_TXQ_45r_t FC_PEAK_TXQ_45r_t;
#define FC_PEAK_TXQ_45r_CLR BCM53101_A0_FC_PEAK_TXQ_45r_CLR
#define FC_PEAK_TXQ_45r_SET BCM53101_A0_FC_PEAK_TXQ_45r_SET
#define FC_PEAK_TXQ_45r_GET BCM53101_A0_FC_PEAK_TXQ_45r_GET
#define FC_PEAK_TXQ_45r_PEAK_TXBCNTf_GET BCM53101_A0_FC_PEAK_TXQ_45r_PEAK_TXBCNTf_GET
#define FC_PEAK_TXQ_45r_PEAK_TXBCNTf_SET BCM53101_A0_FC_PEAK_TXQ_45r_PEAK_TXBCNTf_SET
#define FC_PEAK_TXQ_45r_RESERVEDf_GET BCM53101_A0_FC_PEAK_TXQ_45r_RESERVEDf_GET
#define FC_PEAK_TXQ_45r_RESERVEDf_SET BCM53101_A0_FC_PEAK_TXQ_45r_RESERVEDf_SET
#define READ_FC_PEAK_TXQ_45r BCM53101_A0_READ_FC_PEAK_TXQ_45r
#define WRITE_FC_PEAK_TXQ_45r BCM53101_A0_WRITE_FC_PEAK_TXQ_45r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_PEAK_TXQ_45r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_Q45_CONG_PORTMAP_0123
 * BLOCKS:   SYS
 * DESC:     Q45 Congested PortMap Port 0,1,2,3 Register
 * SIZE:     16
 * FIELDS:
 *     CONG_PORTMAP01   Port 1 congest status for Queue 4/5bit[7:6] = congest status for Q5bit[5:4] = congest status for Q4Port 1 congest status for Queue 4/5bit[3:2] = congest status for Q5bit[1:0] = congest status for Q4
 *     CONG_PORTMAP23   Port 3 congest status for Queue 4/5bit[15:14] = congest status for Q5bit[13:12] = congest status for Q4Port 2 congest status for Queue 4/5bit[11:10] = congest status for Q5bit[9:8] = congest status for Q4
 *
 ******************************************************************************/
#define BCM53101_A0_FC_Q45_CONG_PORTMAP_0123r 0x00000ad0

#define BCM53101_A0_FC_Q45_CONG_PORTMAP_0123r_SIZE 2

/*
 * This structure should be used to declare and program FC_Q45_CONG_PORTMAP_0123.
 *
 */
typedef union BCM53101_A0_FC_Q45_CONG_PORTMAP_0123r_s {
	uint32_t v[1];
	uint32_t fc_q45_cong_portmap_0123[1];
	uint32_t _fc_q45_cong_portmap_0123;
} BCM53101_A0_FC_Q45_CONG_PORTMAP_0123r_t;

#define BCM53101_A0_FC_Q45_CONG_PORTMAP_0123r_CLR(r) (r).fc_q45_cong_portmap_0123[0] = 0
#define BCM53101_A0_FC_Q45_CONG_PORTMAP_0123r_SET(r,d) (r).fc_q45_cong_portmap_0123[0] = d
#define BCM53101_A0_FC_Q45_CONG_PORTMAP_0123r_GET(r) (r).fc_q45_cong_portmap_0123[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP01f_GET(r) (((r).fc_q45_cong_portmap_0123[0]) & 0xff)
#define BCM53101_A0_FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP01f_SET(r,f) (r).fc_q45_cong_portmap_0123[0]=(((r).fc_q45_cong_portmap_0123[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53101_A0_FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP23f_GET(r) ((((r).fc_q45_cong_portmap_0123[0]) >> 8) & 0xff)
#define BCM53101_A0_FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP23f_SET(r,f) (r).fc_q45_cong_portmap_0123[0]=(((r).fc_q45_cong_portmap_0123[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_Q45_CONG_PORTMAP_0123.
 *
 */
#define BCM53101_A0_READ_FC_Q45_CONG_PORTMAP_0123r(u,r) cdk_robo_reg_read(u,BCM53101_A0_FC_Q45_CONG_PORTMAP_0123r,(r._fc_q45_cong_portmap_0123),2)
#define BCM53101_A0_WRITE_FC_Q45_CONG_PORTMAP_0123r(u,r) cdk_robo_reg_write(u,BCM53101_A0_FC_Q45_CONG_PORTMAP_0123r,&(r._fc_q45_cong_portmap_0123),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_Q45_CONG_PORTMAP_0123r BCM53101_A0_FC_Q45_CONG_PORTMAP_0123r
#define FC_Q45_CONG_PORTMAP_0123r_SIZE BCM53101_A0_FC_Q45_CONG_PORTMAP_0123r_SIZE
typedef BCM53101_A0_FC_Q45_CONG_PORTMAP_0123r_t FC_Q45_CONG_PORTMAP_0123r_t;
#define FC_Q45_CONG_PORTMAP_0123r_CLR BCM53101_A0_FC_Q45_CONG_PORTMAP_0123r_CLR
#define FC_Q45_CONG_PORTMAP_0123r_SET BCM53101_A0_FC_Q45_CONG_PORTMAP_0123r_SET
#define FC_Q45_CONG_PORTMAP_0123r_GET BCM53101_A0_FC_Q45_CONG_PORTMAP_0123r_GET
#define FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP01f_GET BCM53101_A0_FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP01f_GET
#define FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP01f_SET BCM53101_A0_FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP01f_SET
#define FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP23f_GET BCM53101_A0_FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP23f_GET
#define FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP23f_SET BCM53101_A0_FC_Q45_CONG_PORTMAP_0123r_CONG_PORTMAP23f_SET
#define READ_FC_Q45_CONG_PORTMAP_0123r BCM53101_A0_READ_FC_Q45_CONG_PORTMAP_0123r
#define WRITE_FC_Q45_CONG_PORTMAP_0123r BCM53101_A0_WRITE_FC_Q45_CONG_PORTMAP_0123r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_Q45_CONG_PORTMAP_0123r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_Q45_CONG_PORTMAP_4567
 * BLOCKS:   SYS
 * DESC:     Q45 Congested PortMap Port 4,5,6,7 Register
 * SIZE:     16
 * FIELDS:
 *     CONG_PORTMAP45   Port 5 congest status for Queue 4/5bit[7:6] = congest status for Q5bit[5:4] = congest status for Q4Port 4 congest status for Queue 4/5bit[3:2] = congest status for Q5bit[1:0] = congest status for Q4
 *     CONG_PORTMAP67   Port 7 congest status for Queue 4/5bit[15:14] = congest status for Q5bit[13:12] = congest status for Q4Port 6 congest status for Queue 4/5bit[11:10] = congest status for Q5bit[9:8] = congest status for Q4
 *
 ******************************************************************************/
#define BCM53101_A0_FC_Q45_CONG_PORTMAP_4567r 0x00000ad2

#define BCM53101_A0_FC_Q45_CONG_PORTMAP_4567r_SIZE 2

/*
 * This structure should be used to declare and program FC_Q45_CONG_PORTMAP_4567.
 *
 */
typedef union BCM53101_A0_FC_Q45_CONG_PORTMAP_4567r_s {
	uint32_t v[1];
	uint32_t fc_q45_cong_portmap_4567[1];
	uint32_t _fc_q45_cong_portmap_4567;
} BCM53101_A0_FC_Q45_CONG_PORTMAP_4567r_t;

#define BCM53101_A0_FC_Q45_CONG_PORTMAP_4567r_CLR(r) (r).fc_q45_cong_portmap_4567[0] = 0
#define BCM53101_A0_FC_Q45_CONG_PORTMAP_4567r_SET(r,d) (r).fc_q45_cong_portmap_4567[0] = d
#define BCM53101_A0_FC_Q45_CONG_PORTMAP_4567r_GET(r) (r).fc_q45_cong_portmap_4567[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP45f_GET(r) (((r).fc_q45_cong_portmap_4567[0]) & 0xff)
#define BCM53101_A0_FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP45f_SET(r,f) (r).fc_q45_cong_portmap_4567[0]=(((r).fc_q45_cong_portmap_4567[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53101_A0_FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP67f_GET(r) ((((r).fc_q45_cong_portmap_4567[0]) >> 8) & 0xff)
#define BCM53101_A0_FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP67f_SET(r,f) (r).fc_q45_cong_portmap_4567[0]=(((r).fc_q45_cong_portmap_4567[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_Q45_CONG_PORTMAP_4567.
 *
 */
#define BCM53101_A0_READ_FC_Q45_CONG_PORTMAP_4567r(u,r) cdk_robo_reg_read(u,BCM53101_A0_FC_Q45_CONG_PORTMAP_4567r,(r._fc_q45_cong_portmap_4567),2)
#define BCM53101_A0_WRITE_FC_Q45_CONG_PORTMAP_4567r(u,r) cdk_robo_reg_write(u,BCM53101_A0_FC_Q45_CONG_PORTMAP_4567r,&(r._fc_q45_cong_portmap_4567),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_Q45_CONG_PORTMAP_4567r BCM53101_A0_FC_Q45_CONG_PORTMAP_4567r
#define FC_Q45_CONG_PORTMAP_4567r_SIZE BCM53101_A0_FC_Q45_CONG_PORTMAP_4567r_SIZE
typedef BCM53101_A0_FC_Q45_CONG_PORTMAP_4567r_t FC_Q45_CONG_PORTMAP_4567r_t;
#define FC_Q45_CONG_PORTMAP_4567r_CLR BCM53101_A0_FC_Q45_CONG_PORTMAP_4567r_CLR
#define FC_Q45_CONG_PORTMAP_4567r_SET BCM53101_A0_FC_Q45_CONG_PORTMAP_4567r_SET
#define FC_Q45_CONG_PORTMAP_4567r_GET BCM53101_A0_FC_Q45_CONG_PORTMAP_4567r_GET
#define FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP45f_GET BCM53101_A0_FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP45f_GET
#define FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP45f_SET BCM53101_A0_FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP45f_SET
#define FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP67f_GET BCM53101_A0_FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP67f_GET
#define FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP67f_SET BCM53101_A0_FC_Q45_CONG_PORTMAP_4567r_CONG_PORTMAP67f_SET
#define READ_FC_Q45_CONG_PORTMAP_4567r BCM53101_A0_READ_FC_Q45_CONG_PORTMAP_4567r
#define WRITE_FC_Q45_CONG_PORTMAP_4567r BCM53101_A0_WRITE_FC_Q45_CONG_PORTMAP_4567r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_Q45_CONG_PORTMAP_4567r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_Q45_CONG_PORTMAP_8
 * BLOCKS:   SYS
 * DESC:     Q45 Congested PortMap Port 8 Register
 * SIZE:     16
 * FIELDS:
 *     CONG_PORTMAP8    Port 8 congest status for Queue 4/5bit[3:2] = congest status for Q5bit[1:0] = congest status for Q4
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_FC_Q45_CONG_PORTMAP_8r 0x00000ad4

#define BCM53101_A0_FC_Q45_CONG_PORTMAP_8r_SIZE 2

/*
 * This structure should be used to declare and program FC_Q45_CONG_PORTMAP_8.
 *
 */
typedef union BCM53101_A0_FC_Q45_CONG_PORTMAP_8r_s {
	uint32_t v[1];
	uint32_t fc_q45_cong_portmap_8[1];
	uint32_t _fc_q45_cong_portmap_8;
} BCM53101_A0_FC_Q45_CONG_PORTMAP_8r_t;

#define BCM53101_A0_FC_Q45_CONG_PORTMAP_8r_CLR(r) (r).fc_q45_cong_portmap_8[0] = 0
#define BCM53101_A0_FC_Q45_CONG_PORTMAP_8r_SET(r,d) (r).fc_q45_cong_portmap_8[0] = d
#define BCM53101_A0_FC_Q45_CONG_PORTMAP_8r_GET(r) (r).fc_q45_cong_portmap_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_Q45_CONG_PORTMAP_8r_CONG_PORTMAP8f_GET(r) (((r).fc_q45_cong_portmap_8[0]) & 0xf)
#define BCM53101_A0_FC_Q45_CONG_PORTMAP_8r_CONG_PORTMAP8f_SET(r,f) (r).fc_q45_cong_portmap_8[0]=(((r).fc_q45_cong_portmap_8[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53101_A0_FC_Q45_CONG_PORTMAP_8r_RESERVEDf_GET(r) ((((r).fc_q45_cong_portmap_8[0]) >> 4) & 0xfff)
#define BCM53101_A0_FC_Q45_CONG_PORTMAP_8r_RESERVEDf_SET(r,f) (r).fc_q45_cong_portmap_8[0]=(((r).fc_q45_cong_portmap_8[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4))

/*
 * These macros can be used to access FC_Q45_CONG_PORTMAP_8.
 *
 */
#define BCM53101_A0_READ_FC_Q45_CONG_PORTMAP_8r(u,r) cdk_robo_reg_read(u,BCM53101_A0_FC_Q45_CONG_PORTMAP_8r,(r._fc_q45_cong_portmap_8),2)
#define BCM53101_A0_WRITE_FC_Q45_CONG_PORTMAP_8r(u,r) cdk_robo_reg_write(u,BCM53101_A0_FC_Q45_CONG_PORTMAP_8r,&(r._fc_q45_cong_portmap_8),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_Q45_CONG_PORTMAP_8r BCM53101_A0_FC_Q45_CONG_PORTMAP_8r
#define FC_Q45_CONG_PORTMAP_8r_SIZE BCM53101_A0_FC_Q45_CONG_PORTMAP_8r_SIZE
typedef BCM53101_A0_FC_Q45_CONG_PORTMAP_8r_t FC_Q45_CONG_PORTMAP_8r_t;
#define FC_Q45_CONG_PORTMAP_8r_CLR BCM53101_A0_FC_Q45_CONG_PORTMAP_8r_CLR
#define FC_Q45_CONG_PORTMAP_8r_SET BCM53101_A0_FC_Q45_CONG_PORTMAP_8r_SET
#define FC_Q45_CONG_PORTMAP_8r_GET BCM53101_A0_FC_Q45_CONG_PORTMAP_8r_GET
#define FC_Q45_CONG_PORTMAP_8r_CONG_PORTMAP8f_GET BCM53101_A0_FC_Q45_CONG_PORTMAP_8r_CONG_PORTMAP8f_GET
#define FC_Q45_CONG_PORTMAP_8r_CONG_PORTMAP8f_SET BCM53101_A0_FC_Q45_CONG_PORTMAP_8r_CONG_PORTMAP8f_SET
#define FC_Q45_CONG_PORTMAP_8r_RESERVEDf_GET BCM53101_A0_FC_Q45_CONG_PORTMAP_8r_RESERVEDf_GET
#define FC_Q45_CONG_PORTMAP_8r_RESERVEDf_SET BCM53101_A0_FC_Q45_CONG_PORTMAP_8r_RESERVEDf_SET
#define READ_FC_Q45_CONG_PORTMAP_8r BCM53101_A0_READ_FC_Q45_CONG_PORTMAP_8r
#define WRITE_FC_Q45_CONG_PORTMAP_8r BCM53101_A0_WRITE_FC_Q45_CONG_PORTMAP_8r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_Q45_CONG_PORTMAP_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_RXBUF_ERR_HIS
 * BLOCKS:   SYS
 * DESC:     Rx Buffer Error History Register
 * SIZE:     16
 * FIELDS:
 *     RXBUF_ERR_HIS    
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_FC_RXBUF_ERR_HISr 0x00000aa8

#define BCM53101_A0_FC_RXBUF_ERR_HISr_SIZE 2

/*
 * This structure should be used to declare and program FC_RXBUF_ERR_HIS.
 *
 */
typedef union BCM53101_A0_FC_RXBUF_ERR_HISr_s {
	uint32_t v[1];
	uint32_t fc_rxbuf_err_his[1];
	uint32_t _fc_rxbuf_err_his;
} BCM53101_A0_FC_RXBUF_ERR_HISr_t;

#define BCM53101_A0_FC_RXBUF_ERR_HISr_CLR(r) (r).fc_rxbuf_err_his[0] = 0
#define BCM53101_A0_FC_RXBUF_ERR_HISr_SET(r,d) (r).fc_rxbuf_err_his[0] = d
#define BCM53101_A0_FC_RXBUF_ERR_HISr_GET(r) (r).fc_rxbuf_err_his[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_RXBUF_ERR_HISr_RXBUF_ERR_HISf_GET(r) (((r).fc_rxbuf_err_his[0]) & 0x7ff)
#define BCM53101_A0_FC_RXBUF_ERR_HISr_RXBUF_ERR_HISf_SET(r,f) (r).fc_rxbuf_err_his[0]=(((r).fc_rxbuf_err_his[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53101_A0_FC_RXBUF_ERR_HISr_RESERVEDf_GET(r) ((((r).fc_rxbuf_err_his[0]) >> 11) & 0x1f)
#define BCM53101_A0_FC_RXBUF_ERR_HISr_RESERVEDf_SET(r,f) (r).fc_rxbuf_err_his[0]=(((r).fc_rxbuf_err_his[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_RXBUF_ERR_HIS.
 *
 */
#define BCM53101_A0_READ_FC_RXBUF_ERR_HISr(u,r) cdk_robo_reg_read(u,BCM53101_A0_FC_RXBUF_ERR_HISr,(r._fc_rxbuf_err_his),2)
#define BCM53101_A0_WRITE_FC_RXBUF_ERR_HISr(u,r) cdk_robo_reg_write(u,BCM53101_A0_FC_RXBUF_ERR_HISr,&(r._fc_rxbuf_err_his),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_RXBUF_ERR_HISr BCM53101_A0_FC_RXBUF_ERR_HISr
#define FC_RXBUF_ERR_HISr_SIZE BCM53101_A0_FC_RXBUF_ERR_HISr_SIZE
typedef BCM53101_A0_FC_RXBUF_ERR_HISr_t FC_RXBUF_ERR_HISr_t;
#define FC_RXBUF_ERR_HISr_CLR BCM53101_A0_FC_RXBUF_ERR_HISr_CLR
#define FC_RXBUF_ERR_HISr_SET BCM53101_A0_FC_RXBUF_ERR_HISr_SET
#define FC_RXBUF_ERR_HISr_GET BCM53101_A0_FC_RXBUF_ERR_HISr_GET
#define FC_RXBUF_ERR_HISr_RXBUF_ERR_HISf_GET BCM53101_A0_FC_RXBUF_ERR_HISr_RXBUF_ERR_HISf_GET
#define FC_RXBUF_ERR_HISr_RXBUF_ERR_HISf_SET BCM53101_A0_FC_RXBUF_ERR_HISr_RXBUF_ERR_HISf_SET
#define FC_RXBUF_ERR_HISr_RESERVEDf_GET BCM53101_A0_FC_RXBUF_ERR_HISr_RESERVEDf_GET
#define FC_RXBUF_ERR_HISr_RESERVEDf_SET BCM53101_A0_FC_RXBUF_ERR_HISr_RESERVEDf_SET
#define READ_FC_RXBUF_ERR_HISr BCM53101_A0_READ_FC_RXBUF_ERR_HISr
#define WRITE_FC_RXBUF_ERR_HISr BCM53101_A0_WRITE_FC_RXBUF_ERR_HISr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_RXBUF_ERR_HISr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_RXPAUSE_HIS
 * BLOCKS:   SYS
 * DESC:     RX Pause History Register
 * SIZE:     16
 * FIELDS:
 *     RXPAUSE_HIS      
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_FC_RXPAUSE_HISr 0x00000aa4

#define BCM53101_A0_FC_RXPAUSE_HISr_SIZE 2

/*
 * This structure should be used to declare and program FC_RXPAUSE_HIS.
 *
 */
typedef union BCM53101_A0_FC_RXPAUSE_HISr_s {
	uint32_t v[1];
	uint32_t fc_rxpause_his[1];
	uint32_t _fc_rxpause_his;
} BCM53101_A0_FC_RXPAUSE_HISr_t;

#define BCM53101_A0_FC_RXPAUSE_HISr_CLR(r) (r).fc_rxpause_his[0] = 0
#define BCM53101_A0_FC_RXPAUSE_HISr_SET(r,d) (r).fc_rxpause_his[0] = d
#define BCM53101_A0_FC_RXPAUSE_HISr_GET(r) (r).fc_rxpause_his[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_RXPAUSE_HISr_RXPAUSE_HISf_GET(r) (((r).fc_rxpause_his[0]) & 0x7ff)
#define BCM53101_A0_FC_RXPAUSE_HISr_RXPAUSE_HISf_SET(r,f) (r).fc_rxpause_his[0]=(((r).fc_rxpause_his[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53101_A0_FC_RXPAUSE_HISr_RESERVEDf_GET(r) ((((r).fc_rxpause_his[0]) >> 11) & 0x1f)
#define BCM53101_A0_FC_RXPAUSE_HISr_RESERVEDf_SET(r,f) (r).fc_rxpause_his[0]=(((r).fc_rxpause_his[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_RXPAUSE_HIS.
 *
 */
#define BCM53101_A0_READ_FC_RXPAUSE_HISr(u,r) cdk_robo_reg_read(u,BCM53101_A0_FC_RXPAUSE_HISr,(r._fc_rxpause_his),2)
#define BCM53101_A0_WRITE_FC_RXPAUSE_HISr(u,r) cdk_robo_reg_write(u,BCM53101_A0_FC_RXPAUSE_HISr,&(r._fc_rxpause_his),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_RXPAUSE_HISr BCM53101_A0_FC_RXPAUSE_HISr
#define FC_RXPAUSE_HISr_SIZE BCM53101_A0_FC_RXPAUSE_HISr_SIZE
typedef BCM53101_A0_FC_RXPAUSE_HISr_t FC_RXPAUSE_HISr_t;
#define FC_RXPAUSE_HISr_CLR BCM53101_A0_FC_RXPAUSE_HISr_CLR
#define FC_RXPAUSE_HISr_SET BCM53101_A0_FC_RXPAUSE_HISr_SET
#define FC_RXPAUSE_HISr_GET BCM53101_A0_FC_RXPAUSE_HISr_GET
#define FC_RXPAUSE_HISr_RXPAUSE_HISf_GET BCM53101_A0_FC_RXPAUSE_HISr_RXPAUSE_HISf_GET
#define FC_RXPAUSE_HISr_RXPAUSE_HISf_SET BCM53101_A0_FC_RXPAUSE_HISr_RXPAUSE_HISf_SET
#define FC_RXPAUSE_HISr_RESERVEDf_GET BCM53101_A0_FC_RXPAUSE_HISr_RESERVEDf_GET
#define FC_RXPAUSE_HISr_RESERVEDf_SET BCM53101_A0_FC_RXPAUSE_HISr_RESERVEDf_SET
#define READ_FC_RXPAUSE_HISr BCM53101_A0_READ_FC_RXPAUSE_HISr
#define WRITE_FC_RXPAUSE_HISr BCM53101_A0_WRITE_FC_RXPAUSE_HISr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_RXPAUSE_HISr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_RX_HYST
 * BLOCKS:   SYS
 * DESC:     Rx-Base Hysteresis Register
 * SIZE:     16
 * FIELDS:
 *     RX_HYST_THRS     
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_FC_RX_HYSTr 0x00000a54

#define BCM53101_A0_FC_RX_HYSTr_SIZE 2

/*
 * This structure should be used to declare and program FC_RX_HYST.
 *
 */
typedef union BCM53101_A0_FC_RX_HYSTr_s {
	uint32_t v[1];
	uint32_t fc_rx_hyst[1];
	uint32_t _fc_rx_hyst;
} BCM53101_A0_FC_RX_HYSTr_t;

#define BCM53101_A0_FC_RX_HYSTr_CLR(r) (r).fc_rx_hyst[0] = 0
#define BCM53101_A0_FC_RX_HYSTr_SET(r,d) (r).fc_rx_hyst[0] = d
#define BCM53101_A0_FC_RX_HYSTr_GET(r) (r).fc_rx_hyst[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_RX_HYSTr_RX_HYST_THRSf_GET(r) (((r).fc_rx_hyst[0]) & 0xff)
#define BCM53101_A0_FC_RX_HYSTr_RX_HYST_THRSf_SET(r,f) (r).fc_rx_hyst[0]=(((r).fc_rx_hyst[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53101_A0_FC_RX_HYSTr_RESERVEDf_GET(r) ((((r).fc_rx_hyst[0]) >> 8) & 0xff)
#define BCM53101_A0_FC_RX_HYSTr_RESERVEDf_SET(r,f) (r).fc_rx_hyst[0]=(((r).fc_rx_hyst[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_RX_HYST.
 *
 */
#define BCM53101_A0_READ_FC_RX_HYSTr(u,r) cdk_robo_reg_read(u,BCM53101_A0_FC_RX_HYSTr,(r._fc_rx_hyst),2)
#define BCM53101_A0_WRITE_FC_RX_HYSTr(u,r) cdk_robo_reg_write(u,BCM53101_A0_FC_RX_HYSTr,&(r._fc_rx_hyst),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_RX_HYSTr BCM53101_A0_FC_RX_HYSTr
#define FC_RX_HYSTr_SIZE BCM53101_A0_FC_RX_HYSTr_SIZE
typedef BCM53101_A0_FC_RX_HYSTr_t FC_RX_HYSTr_t;
#define FC_RX_HYSTr_CLR BCM53101_A0_FC_RX_HYSTr_CLR
#define FC_RX_HYSTr_SET BCM53101_A0_FC_RX_HYSTr_SET
#define FC_RX_HYSTr_GET BCM53101_A0_FC_RX_HYSTr_GET
#define FC_RX_HYSTr_RX_HYST_THRSf_GET BCM53101_A0_FC_RX_HYSTr_RX_HYST_THRSf_GET
#define FC_RX_HYSTr_RX_HYST_THRSf_SET BCM53101_A0_FC_RX_HYSTr_RX_HYST_THRSf_SET
#define FC_RX_HYSTr_RESERVEDf_GET BCM53101_A0_FC_RX_HYSTr_RESERVEDf_GET
#define FC_RX_HYSTr_RESERVEDf_SET BCM53101_A0_FC_RX_HYSTr_RESERVEDf_SET
#define READ_FC_RX_HYSTr BCM53101_A0_READ_FC_RX_HYSTr
#define WRITE_FC_RX_HYSTr BCM53101_A0_WRITE_FC_RX_HYSTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_RX_HYSTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_RX_MAX_PTR
 * BLOCKS:   SYS
 * DESC:     Rx-Base Max-Buffer Remap Register
 * SIZE:     16
 * FIELDS:
 *     MAXBUF_REMAP     Max_Buffer_ReMap Value.
 *     RESERVED         Reserved.
 *     EN_REMAP         Enable remap.
 *
 ******************************************************************************/
#define BCM53101_A0_FC_RX_MAX_PTRr 0x00000a56

#define BCM53101_A0_FC_RX_MAX_PTRr_SIZE 2

/*
 * This structure should be used to declare and program FC_RX_MAX_PTR.
 *
 */
typedef union BCM53101_A0_FC_RX_MAX_PTRr_s {
	uint32_t v[1];
	uint32_t fc_rx_max_ptr[1];
	uint32_t _fc_rx_max_ptr;
} BCM53101_A0_FC_RX_MAX_PTRr_t;

#define BCM53101_A0_FC_RX_MAX_PTRr_CLR(r) (r).fc_rx_max_ptr[0] = 0
#define BCM53101_A0_FC_RX_MAX_PTRr_SET(r,d) (r).fc_rx_max_ptr[0] = d
#define BCM53101_A0_FC_RX_MAX_PTRr_GET(r) (r).fc_rx_max_ptr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_RX_MAX_PTRr_MAXBUF_REMAPf_GET(r) (((r).fc_rx_max_ptr[0]) & 0x7ff)
#define BCM53101_A0_FC_RX_MAX_PTRr_MAXBUF_REMAPf_SET(r,f) (r).fc_rx_max_ptr[0]=(((r).fc_rx_max_ptr[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53101_A0_FC_RX_MAX_PTRr_RESERVEDf_GET(r) ((((r).fc_rx_max_ptr[0]) >> 11) & 0xf)
#define BCM53101_A0_FC_RX_MAX_PTRr_RESERVEDf_SET(r,f) (r).fc_rx_max_ptr[0]=(((r).fc_rx_max_ptr[0] & ~((uint32_t)0xf << 11)) | ((((uint32_t)f) & 0xf) << 11))
#define BCM53101_A0_FC_RX_MAX_PTRr_EN_REMAPf_GET(r) ((((r).fc_rx_max_ptr[0]) >> 15) & 0x1)
#define BCM53101_A0_FC_RX_MAX_PTRr_EN_REMAPf_SET(r,f) (r).fc_rx_max_ptr[0]=(((r).fc_rx_max_ptr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access FC_RX_MAX_PTR.
 *
 */
#define BCM53101_A0_READ_FC_RX_MAX_PTRr(u,r) cdk_robo_reg_read(u,BCM53101_A0_FC_RX_MAX_PTRr,(r._fc_rx_max_ptr),2)
#define BCM53101_A0_WRITE_FC_RX_MAX_PTRr(u,r) cdk_robo_reg_write(u,BCM53101_A0_FC_RX_MAX_PTRr,&(r._fc_rx_max_ptr),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_RX_MAX_PTRr BCM53101_A0_FC_RX_MAX_PTRr
#define FC_RX_MAX_PTRr_SIZE BCM53101_A0_FC_RX_MAX_PTRr_SIZE
typedef BCM53101_A0_FC_RX_MAX_PTRr_t FC_RX_MAX_PTRr_t;
#define FC_RX_MAX_PTRr_CLR BCM53101_A0_FC_RX_MAX_PTRr_CLR
#define FC_RX_MAX_PTRr_SET BCM53101_A0_FC_RX_MAX_PTRr_SET
#define FC_RX_MAX_PTRr_GET BCM53101_A0_FC_RX_MAX_PTRr_GET
#define FC_RX_MAX_PTRr_MAXBUF_REMAPf_GET BCM53101_A0_FC_RX_MAX_PTRr_MAXBUF_REMAPf_GET
#define FC_RX_MAX_PTRr_MAXBUF_REMAPf_SET BCM53101_A0_FC_RX_MAX_PTRr_MAXBUF_REMAPf_SET
#define FC_RX_MAX_PTRr_RESERVEDf_GET BCM53101_A0_FC_RX_MAX_PTRr_RESERVEDf_GET
#define FC_RX_MAX_PTRr_RESERVEDf_SET BCM53101_A0_FC_RX_MAX_PTRr_RESERVEDf_SET
#define FC_RX_MAX_PTRr_EN_REMAPf_GET BCM53101_A0_FC_RX_MAX_PTRr_EN_REMAPf_GET
#define FC_RX_MAX_PTRr_EN_REMAPf_SET BCM53101_A0_FC_RX_MAX_PTRr_EN_REMAPf_SET
#define READ_FC_RX_MAX_PTRr BCM53101_A0_READ_FC_RX_MAX_PTRr
#define WRITE_FC_RX_MAX_PTRr BCM53101_A0_WRITE_FC_RX_MAX_PTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_RX_MAX_PTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_RX_RSRV
 * BLOCKS:   SYS
 * DESC:     Rx-Base Reserved Register
 * SIZE:     16
 * FIELDS:
 *     RESV_CTRL        
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_FC_RX_RSRVr 0x00000a52

#define BCM53101_A0_FC_RX_RSRVr_SIZE 2

/*
 * This structure should be used to declare and program FC_RX_RSRV.
 *
 */
typedef union BCM53101_A0_FC_RX_RSRVr_s {
	uint32_t v[1];
	uint32_t fc_rx_rsrv[1];
	uint32_t _fc_rx_rsrv;
} BCM53101_A0_FC_RX_RSRVr_t;

#define BCM53101_A0_FC_RX_RSRVr_CLR(r) (r).fc_rx_rsrv[0] = 0
#define BCM53101_A0_FC_RX_RSRVr_SET(r,d) (r).fc_rx_rsrv[0] = d
#define BCM53101_A0_FC_RX_RSRVr_GET(r) (r).fc_rx_rsrv[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_RX_RSRVr_RESV_CTRLf_GET(r) (((r).fc_rx_rsrv[0]) & 0xff)
#define BCM53101_A0_FC_RX_RSRVr_RESV_CTRLf_SET(r,f) (r).fc_rx_rsrv[0]=(((r).fc_rx_rsrv[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53101_A0_FC_RX_RSRVr_RESERVEDf_GET(r) ((((r).fc_rx_rsrv[0]) >> 8) & 0xff)
#define BCM53101_A0_FC_RX_RSRVr_RESERVEDf_SET(r,f) (r).fc_rx_rsrv[0]=(((r).fc_rx_rsrv[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_RX_RSRV.
 *
 */
#define BCM53101_A0_READ_FC_RX_RSRVr(u,r) cdk_robo_reg_read(u,BCM53101_A0_FC_RX_RSRVr,(r._fc_rx_rsrv),2)
#define BCM53101_A0_WRITE_FC_RX_RSRVr(u,r) cdk_robo_reg_write(u,BCM53101_A0_FC_RX_RSRVr,&(r._fc_rx_rsrv),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_RX_RSRVr BCM53101_A0_FC_RX_RSRVr
#define FC_RX_RSRVr_SIZE BCM53101_A0_FC_RX_RSRVr_SIZE
typedef BCM53101_A0_FC_RX_RSRVr_t FC_RX_RSRVr_t;
#define FC_RX_RSRVr_CLR BCM53101_A0_FC_RX_RSRVr_CLR
#define FC_RX_RSRVr_SET BCM53101_A0_FC_RX_RSRVr_SET
#define FC_RX_RSRVr_GET BCM53101_A0_FC_RX_RSRVr_GET
#define FC_RX_RSRVr_RESV_CTRLf_GET BCM53101_A0_FC_RX_RSRVr_RESV_CTRLf_GET
#define FC_RX_RSRVr_RESV_CTRLf_SET BCM53101_A0_FC_RX_RSRVr_RESV_CTRLf_SET
#define FC_RX_RSRVr_RESERVEDf_GET BCM53101_A0_FC_RX_RSRVr_RESERVEDf_GET
#define FC_RX_RSRVr_RESERVEDf_SET BCM53101_A0_FC_RX_RSRVr_RESERVEDf_SET
#define READ_FC_RX_RSRVr BCM53101_A0_READ_FC_RX_RSRVr
#define WRITE_FC_RX_RSRVr BCM53101_A0_WRITE_FC_RX_RSRVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_RX_RSRVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_RX_RUNOFF
 * BLOCKS:   SYS
 * DESC:     Rx-Base Run-Off Register
 * SIZE:     16
 * FIELDS:
 *     RUN_OFF          
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_FC_RX_RUNOFFr 0x00000a50

#define BCM53101_A0_FC_RX_RUNOFFr_SIZE 2

/*
 * This structure should be used to declare and program FC_RX_RUNOFF.
 *
 */
typedef union BCM53101_A0_FC_RX_RUNOFFr_s {
	uint32_t v[1];
	uint32_t fc_rx_runoff[1];
	uint32_t _fc_rx_runoff;
} BCM53101_A0_FC_RX_RUNOFFr_t;

#define BCM53101_A0_FC_RX_RUNOFFr_CLR(r) (r).fc_rx_runoff[0] = 0
#define BCM53101_A0_FC_RX_RUNOFFr_SET(r,d) (r).fc_rx_runoff[0] = d
#define BCM53101_A0_FC_RX_RUNOFFr_GET(r) (r).fc_rx_runoff[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_RX_RUNOFFr_RUN_OFFf_GET(r) (((r).fc_rx_runoff[0]) & 0xff)
#define BCM53101_A0_FC_RX_RUNOFFr_RUN_OFFf_SET(r,f) (r).fc_rx_runoff[0]=(((r).fc_rx_runoff[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53101_A0_FC_RX_RUNOFFr_RESERVEDf_GET(r) ((((r).fc_rx_runoff[0]) >> 8) & 0xff)
#define BCM53101_A0_FC_RX_RUNOFFr_RESERVEDf_SET(r,f) (r).fc_rx_runoff[0]=(((r).fc_rx_runoff[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access FC_RX_RUNOFF.
 *
 */
#define BCM53101_A0_READ_FC_RX_RUNOFFr(u,r) cdk_robo_reg_read(u,BCM53101_A0_FC_RX_RUNOFFr,(r._fc_rx_runoff),2)
#define BCM53101_A0_WRITE_FC_RX_RUNOFFr(u,r) cdk_robo_reg_write(u,BCM53101_A0_FC_RX_RUNOFFr,&(r._fc_rx_runoff),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_RX_RUNOFFr BCM53101_A0_FC_RX_RUNOFFr
#define FC_RX_RUNOFFr_SIZE BCM53101_A0_FC_RX_RUNOFFr_SIZE
typedef BCM53101_A0_FC_RX_RUNOFFr_t FC_RX_RUNOFFr_t;
#define FC_RX_RUNOFFr_CLR BCM53101_A0_FC_RX_RUNOFFr_CLR
#define FC_RX_RUNOFFr_SET BCM53101_A0_FC_RX_RUNOFFr_SET
#define FC_RX_RUNOFFr_GET BCM53101_A0_FC_RX_RUNOFFr_GET
#define FC_RX_RUNOFFr_RUN_OFFf_GET BCM53101_A0_FC_RX_RUNOFFr_RUN_OFFf_GET
#define FC_RX_RUNOFFr_RUN_OFFf_SET BCM53101_A0_FC_RX_RUNOFFr_RUN_OFFf_SET
#define FC_RX_RUNOFFr_RESERVEDf_GET BCM53101_A0_FC_RX_RUNOFFr_RESERVEDf_GET
#define FC_RX_RUNOFFr_RESERVEDf_SET BCM53101_A0_FC_RX_RUNOFFr_RESERVEDf_SET
#define READ_FC_RX_RUNOFFr BCM53101_A0_READ_FC_RX_RUNOFFr
#define WRITE_FC_RX_RUNOFFr BCM53101_A0_WRITE_FC_RX_RUNOFFr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_RX_RUNOFFr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_SPARE_REG
 * BLOCKS:   SYS
 * DESC:     Spare Registers
 * SIZE:     16
 * FIELDS:
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_FC_SPARE_REGr 0x00000a58

#define BCM53101_A0_FC_SPARE_REGr_SIZE 2

/*
 * This structure should be used to declare and program FC_SPARE_REG.
 *
 */
typedef union BCM53101_A0_FC_SPARE_REGr_s {
	uint32_t v[1];
	uint32_t fc_spare_reg[1];
	uint32_t _fc_spare_reg;
} BCM53101_A0_FC_SPARE_REGr_t;

#define BCM53101_A0_FC_SPARE_REGr_CLR(r) (r).fc_spare_reg[0] = 0
#define BCM53101_A0_FC_SPARE_REGr_SET(r,d) (r).fc_spare_reg[0] = d
#define BCM53101_A0_FC_SPARE_REGr_GET(r) (r).fc_spare_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_SPARE_REGr_RESERVEDf_GET(r) (((r).fc_spare_reg[0]) & 0xffff)
#define BCM53101_A0_FC_SPARE_REGr_RESERVEDf_SET(r,f) (r).fc_spare_reg[0]=(((r).fc_spare_reg[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access FC_SPARE_REG.
 *
 */
#define BCM53101_A0_READ_FC_SPARE_REGr(u,i,r) cdk_robo_reg_read(u,BCM53101_A0_FC_SPARE_REGr+(2*(i)),(r._fc_spare_reg),2)
#define BCM53101_A0_WRITE_FC_SPARE_REGr(u,i,r) cdk_robo_reg_write(u,BCM53101_A0_FC_SPARE_REGr+(2*(i)),&(r._fc_spare_reg),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_SPARE_REGr BCM53101_A0_FC_SPARE_REGr
#define FC_SPARE_REGr_SIZE BCM53101_A0_FC_SPARE_REGr_SIZE
typedef BCM53101_A0_FC_SPARE_REGr_t FC_SPARE_REGr_t;
#define FC_SPARE_REGr_CLR BCM53101_A0_FC_SPARE_REGr_CLR
#define FC_SPARE_REGr_SET BCM53101_A0_FC_SPARE_REGr_SET
#define FC_SPARE_REGr_GET BCM53101_A0_FC_SPARE_REGr_GET
#define FC_SPARE_REGr_RESERVEDf_GET BCM53101_A0_FC_SPARE_REGr_RESERVEDf_GET
#define FC_SPARE_REGr_RESERVEDf_SET BCM53101_A0_FC_SPARE_REGr_RESERVEDf_SET
#define READ_FC_SPARE_REGr BCM53101_A0_READ_FC_SPARE_REGr
#define WRITE_FC_SPARE_REGr BCM53101_A0_WRITE_FC_SPARE_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_SPARE_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_TOTAL_TH_DROP_Q
 * BLOCKS:   SYS
 * DESC:     Total Drop Threshold For Queue N Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_DROP_THRS if QOS is off, default is 512.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_FC_TOTAL_TH_DROP_Qr 0x00000a38

#define BCM53101_A0_FC_TOTAL_TH_DROP_Qr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_DROP_Q.
 *
 */
typedef union BCM53101_A0_FC_TOTAL_TH_DROP_Qr_s {
	uint32_t v[1];
	uint32_t fc_total_th_drop_q[1];
	uint32_t _fc_total_th_drop_q;
} BCM53101_A0_FC_TOTAL_TH_DROP_Qr_t;

#define BCM53101_A0_FC_TOTAL_TH_DROP_Qr_CLR(r) (r).fc_total_th_drop_q[0] = 0
#define BCM53101_A0_FC_TOTAL_TH_DROP_Qr_SET(r,d) (r).fc_total_th_drop_q[0] = d
#define BCM53101_A0_FC_TOTAL_TH_DROP_Qr_GET(r) (r).fc_total_th_drop_q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_TOTAL_TH_DROP_Qr_TXQ_TOTAL_DROP_THRSf_GET(r) (((r).fc_total_th_drop_q[0]) & 0x7ff)
#define BCM53101_A0_FC_TOTAL_TH_DROP_Qr_TXQ_TOTAL_DROP_THRSf_SET(r,f) (r).fc_total_th_drop_q[0]=(((r).fc_total_th_drop_q[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53101_A0_FC_TOTAL_TH_DROP_Qr_RESERVEDf_GET(r) ((((r).fc_total_th_drop_q[0]) >> 11) & 0x1f)
#define BCM53101_A0_FC_TOTAL_TH_DROP_Qr_RESERVEDf_SET(r,f) (r).fc_total_th_drop_q[0]=(((r).fc_total_th_drop_q[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_TOTAL_TH_DROP_Q.
 *
 */
#define BCM53101_A0_READ_FC_TOTAL_TH_DROP_Qr(u,i,r) cdk_robo_reg_read(u,BCM53101_A0_FC_TOTAL_TH_DROP_Qr+(2*(i)),(r._fc_total_th_drop_q),2)
#define BCM53101_A0_WRITE_FC_TOTAL_TH_DROP_Qr(u,i,r) cdk_robo_reg_write(u,BCM53101_A0_FC_TOTAL_TH_DROP_Qr+(2*(i)),&(r._fc_total_th_drop_q),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_DROP_Qr BCM53101_A0_FC_TOTAL_TH_DROP_Qr
#define FC_TOTAL_TH_DROP_Qr_SIZE BCM53101_A0_FC_TOTAL_TH_DROP_Qr_SIZE
typedef BCM53101_A0_FC_TOTAL_TH_DROP_Qr_t FC_TOTAL_TH_DROP_Qr_t;
#define FC_TOTAL_TH_DROP_Qr_CLR BCM53101_A0_FC_TOTAL_TH_DROP_Qr_CLR
#define FC_TOTAL_TH_DROP_Qr_SET BCM53101_A0_FC_TOTAL_TH_DROP_Qr_SET
#define FC_TOTAL_TH_DROP_Qr_GET BCM53101_A0_FC_TOTAL_TH_DROP_Qr_GET
#define FC_TOTAL_TH_DROP_Qr_TXQ_TOTAL_DROP_THRSf_GET BCM53101_A0_FC_TOTAL_TH_DROP_Qr_TXQ_TOTAL_DROP_THRSf_GET
#define FC_TOTAL_TH_DROP_Qr_TXQ_TOTAL_DROP_THRSf_SET BCM53101_A0_FC_TOTAL_TH_DROP_Qr_TXQ_TOTAL_DROP_THRSf_SET
#define FC_TOTAL_TH_DROP_Qr_RESERVEDf_GET BCM53101_A0_FC_TOTAL_TH_DROP_Qr_RESERVEDf_GET
#define FC_TOTAL_TH_DROP_Qr_RESERVEDf_SET BCM53101_A0_FC_TOTAL_TH_DROP_Qr_RESERVEDf_SET
#define READ_FC_TOTAL_TH_DROP_Qr BCM53101_A0_READ_FC_TOTAL_TH_DROP_Qr
#define WRITE_FC_TOTAL_TH_DROP_Qr BCM53101_A0_WRITE_FC_TOTAL_TH_DROP_Qr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_TOTAL_TH_DROP_Qr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_TOTAL_TH_DROP_Q45
 * BLOCKS:   SYS
 * DESC:     Total Drop Threshold For Queue N(4~5) Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_DROP_THRS if QOS is off, default is 512.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_FC_TOTAL_TH_DROP_Q45r 0x00000ac4

#define BCM53101_A0_FC_TOTAL_TH_DROP_Q45r_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_DROP_Q45.
 *
 */
typedef union BCM53101_A0_FC_TOTAL_TH_DROP_Q45r_s {
	uint32_t v[1];
	uint32_t fc_total_th_drop_q45[1];
	uint32_t _fc_total_th_drop_q45;
} BCM53101_A0_FC_TOTAL_TH_DROP_Q45r_t;

#define BCM53101_A0_FC_TOTAL_TH_DROP_Q45r_CLR(r) (r).fc_total_th_drop_q45[0] = 0
#define BCM53101_A0_FC_TOTAL_TH_DROP_Q45r_SET(r,d) (r).fc_total_th_drop_q45[0] = d
#define BCM53101_A0_FC_TOTAL_TH_DROP_Q45r_GET(r) (r).fc_total_th_drop_q45[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_TOTAL_TH_DROP_Q45r_TXQ_TOTAL_DROP_THRSf_GET(r) (((r).fc_total_th_drop_q45[0]) & 0x7ff)
#define BCM53101_A0_FC_TOTAL_TH_DROP_Q45r_TXQ_TOTAL_DROP_THRSf_SET(r,f) (r).fc_total_th_drop_q45[0]=(((r).fc_total_th_drop_q45[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53101_A0_FC_TOTAL_TH_DROP_Q45r_RESERVEDf_GET(r) ((((r).fc_total_th_drop_q45[0]) >> 11) & 0x1f)
#define BCM53101_A0_FC_TOTAL_TH_DROP_Q45r_RESERVEDf_SET(r,f) (r).fc_total_th_drop_q45[0]=(((r).fc_total_th_drop_q45[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_TOTAL_TH_DROP_Q45.
 *
 */
#define BCM53101_A0_READ_FC_TOTAL_TH_DROP_Q45r(u,i,r) cdk_robo_reg_read(u,BCM53101_A0_FC_TOTAL_TH_DROP_Q45r+(2*(i)),(r._fc_total_th_drop_q45),2)
#define BCM53101_A0_WRITE_FC_TOTAL_TH_DROP_Q45r(u,i,r) cdk_robo_reg_write(u,BCM53101_A0_FC_TOTAL_TH_DROP_Q45r+(2*(i)),&(r._fc_total_th_drop_q45),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_DROP_Q45r BCM53101_A0_FC_TOTAL_TH_DROP_Q45r
#define FC_TOTAL_TH_DROP_Q45r_SIZE BCM53101_A0_FC_TOTAL_TH_DROP_Q45r_SIZE
typedef BCM53101_A0_FC_TOTAL_TH_DROP_Q45r_t FC_TOTAL_TH_DROP_Q45r_t;
#define FC_TOTAL_TH_DROP_Q45r_CLR BCM53101_A0_FC_TOTAL_TH_DROP_Q45r_CLR
#define FC_TOTAL_TH_DROP_Q45r_SET BCM53101_A0_FC_TOTAL_TH_DROP_Q45r_SET
#define FC_TOTAL_TH_DROP_Q45r_GET BCM53101_A0_FC_TOTAL_TH_DROP_Q45r_GET
#define FC_TOTAL_TH_DROP_Q45r_TXQ_TOTAL_DROP_THRSf_GET BCM53101_A0_FC_TOTAL_TH_DROP_Q45r_TXQ_TOTAL_DROP_THRSf_GET
#define FC_TOTAL_TH_DROP_Q45r_TXQ_TOTAL_DROP_THRSf_SET BCM53101_A0_FC_TOTAL_TH_DROP_Q45r_TXQ_TOTAL_DROP_THRSf_SET
#define FC_TOTAL_TH_DROP_Q45r_RESERVEDf_GET BCM53101_A0_FC_TOTAL_TH_DROP_Q45r_RESERVEDf_GET
#define FC_TOTAL_TH_DROP_Q45r_RESERVEDf_SET BCM53101_A0_FC_TOTAL_TH_DROP_Q45r_RESERVEDf_SET
#define READ_FC_TOTAL_TH_DROP_Q45r BCM53101_A0_READ_FC_TOTAL_TH_DROP_Q45r
#define WRITE_FC_TOTAL_TH_DROP_Q45r BCM53101_A0_WRITE_FC_TOTAL_TH_DROP_Q45r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_TOTAL_TH_DROP_Q45r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_TOTAL_TH_DROP_Q_IMP
 * BLOCKS:   SYS
 * DESC:     Total Drop Threshold For Queue N Register for IMP
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_DROP_THRS if QOS is off, default is 512.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_FC_TOTAL_TH_DROP_Q_IMPr 0x00000d38

#define BCM53101_A0_FC_TOTAL_TH_DROP_Q_IMPr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_DROP_Q_IMP.
 *
 */
typedef union BCM53101_A0_FC_TOTAL_TH_DROP_Q_IMPr_s {
	uint32_t v[1];
	uint32_t fc_total_th_drop_q_imp[1];
	uint32_t _fc_total_th_drop_q_imp;
} BCM53101_A0_FC_TOTAL_TH_DROP_Q_IMPr_t;

#define BCM53101_A0_FC_TOTAL_TH_DROP_Q_IMPr_CLR(r) (r).fc_total_th_drop_q_imp[0] = 0
#define BCM53101_A0_FC_TOTAL_TH_DROP_Q_IMPr_SET(r,d) (r).fc_total_th_drop_q_imp[0] = d
#define BCM53101_A0_FC_TOTAL_TH_DROP_Q_IMPr_GET(r) (r).fc_total_th_drop_q_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_TOTAL_TH_DROP_Q_IMPr_TXQ_TOTAL_DROP_THRSf_GET(r) (((r).fc_total_th_drop_q_imp[0]) & 0x7ff)
#define BCM53101_A0_FC_TOTAL_TH_DROP_Q_IMPr_TXQ_TOTAL_DROP_THRSf_SET(r,f) (r).fc_total_th_drop_q_imp[0]=(((r).fc_total_th_drop_q_imp[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53101_A0_FC_TOTAL_TH_DROP_Q_IMPr_RESERVEDf_GET(r) ((((r).fc_total_th_drop_q_imp[0]) >> 11) & 0x1f)
#define BCM53101_A0_FC_TOTAL_TH_DROP_Q_IMPr_RESERVEDf_SET(r,f) (r).fc_total_th_drop_q_imp[0]=(((r).fc_total_th_drop_q_imp[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_TOTAL_TH_DROP_Q_IMP.
 *
 */
#define BCM53101_A0_READ_FC_TOTAL_TH_DROP_Q_IMPr(u,i,r) cdk_robo_reg_read(u,BCM53101_A0_FC_TOTAL_TH_DROP_Q_IMPr+(2*(i)),(r._fc_total_th_drop_q_imp),2)
#define BCM53101_A0_WRITE_FC_TOTAL_TH_DROP_Q_IMPr(u,i,r) cdk_robo_reg_write(u,BCM53101_A0_FC_TOTAL_TH_DROP_Q_IMPr+(2*(i)),&(r._fc_total_th_drop_q_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_DROP_Q_IMPr BCM53101_A0_FC_TOTAL_TH_DROP_Q_IMPr
#define FC_TOTAL_TH_DROP_Q_IMPr_SIZE BCM53101_A0_FC_TOTAL_TH_DROP_Q_IMPr_SIZE
typedef BCM53101_A0_FC_TOTAL_TH_DROP_Q_IMPr_t FC_TOTAL_TH_DROP_Q_IMPr_t;
#define FC_TOTAL_TH_DROP_Q_IMPr_CLR BCM53101_A0_FC_TOTAL_TH_DROP_Q_IMPr_CLR
#define FC_TOTAL_TH_DROP_Q_IMPr_SET BCM53101_A0_FC_TOTAL_TH_DROP_Q_IMPr_SET
#define FC_TOTAL_TH_DROP_Q_IMPr_GET BCM53101_A0_FC_TOTAL_TH_DROP_Q_IMPr_GET
#define FC_TOTAL_TH_DROP_Q_IMPr_TXQ_TOTAL_DROP_THRSf_GET BCM53101_A0_FC_TOTAL_TH_DROP_Q_IMPr_TXQ_TOTAL_DROP_THRSf_GET
#define FC_TOTAL_TH_DROP_Q_IMPr_TXQ_TOTAL_DROP_THRSf_SET BCM53101_A0_FC_TOTAL_TH_DROP_Q_IMPr_TXQ_TOTAL_DROP_THRSf_SET
#define FC_TOTAL_TH_DROP_Q_IMPr_RESERVEDf_GET BCM53101_A0_FC_TOTAL_TH_DROP_Q_IMPr_RESERVEDf_GET
#define FC_TOTAL_TH_DROP_Q_IMPr_RESERVEDf_SET BCM53101_A0_FC_TOTAL_TH_DROP_Q_IMPr_RESERVEDf_SET
#define READ_FC_TOTAL_TH_DROP_Q_IMPr BCM53101_A0_READ_FC_TOTAL_TH_DROP_Q_IMPr
#define WRITE_FC_TOTAL_TH_DROP_Q_IMPr BCM53101_A0_WRITE_FC_TOTAL_TH_DROP_Q_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_TOTAL_TH_DROP_Q_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_TOTAL_TH_DROP_Q_WAN
 * BLOCKS:   SYS
 * DESC:     Total Drop Threshold For Queue N Register for WAN
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_DROP_THRS 
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_FC_TOTAL_TH_DROP_Q_WANr 0x00000e38

#define BCM53101_A0_FC_TOTAL_TH_DROP_Q_WANr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_DROP_Q_WAN.
 *
 */
typedef union BCM53101_A0_FC_TOTAL_TH_DROP_Q_WANr_s {
	uint32_t v[1];
	uint32_t fc_total_th_drop_q_wan[1];
	uint32_t _fc_total_th_drop_q_wan;
} BCM53101_A0_FC_TOTAL_TH_DROP_Q_WANr_t;

#define BCM53101_A0_FC_TOTAL_TH_DROP_Q_WANr_CLR(r) (r).fc_total_th_drop_q_wan[0] = 0
#define BCM53101_A0_FC_TOTAL_TH_DROP_Q_WANr_SET(r,d) (r).fc_total_th_drop_q_wan[0] = d
#define BCM53101_A0_FC_TOTAL_TH_DROP_Q_WANr_GET(r) (r).fc_total_th_drop_q_wan[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_TOTAL_TH_DROP_Q_WANr_TXQ_TOTAL_DROP_THRSf_GET(r) (((r).fc_total_th_drop_q_wan[0]) & 0x7ff)
#define BCM53101_A0_FC_TOTAL_TH_DROP_Q_WANr_TXQ_TOTAL_DROP_THRSf_SET(r,f) (r).fc_total_th_drop_q_wan[0]=(((r).fc_total_th_drop_q_wan[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53101_A0_FC_TOTAL_TH_DROP_Q_WANr_RESERVEDf_GET(r) ((((r).fc_total_th_drop_q_wan[0]) >> 11) & 0x1f)
#define BCM53101_A0_FC_TOTAL_TH_DROP_Q_WANr_RESERVEDf_SET(r,f) (r).fc_total_th_drop_q_wan[0]=(((r).fc_total_th_drop_q_wan[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_TOTAL_TH_DROP_Q_WAN.
 *
 */
#define BCM53101_A0_READ_FC_TOTAL_TH_DROP_Q_WANr(u,i,r) cdk_robo_reg_read(u,BCM53101_A0_FC_TOTAL_TH_DROP_Q_WANr+(2*(i)),(r._fc_total_th_drop_q_wan),2)
#define BCM53101_A0_WRITE_FC_TOTAL_TH_DROP_Q_WANr(u,i,r) cdk_robo_reg_write(u,BCM53101_A0_FC_TOTAL_TH_DROP_Q_WANr+(2*(i)),&(r._fc_total_th_drop_q_wan),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_DROP_Q_WANr BCM53101_A0_FC_TOTAL_TH_DROP_Q_WANr
#define FC_TOTAL_TH_DROP_Q_WANr_SIZE BCM53101_A0_FC_TOTAL_TH_DROP_Q_WANr_SIZE
typedef BCM53101_A0_FC_TOTAL_TH_DROP_Q_WANr_t FC_TOTAL_TH_DROP_Q_WANr_t;
#define FC_TOTAL_TH_DROP_Q_WANr_CLR BCM53101_A0_FC_TOTAL_TH_DROP_Q_WANr_CLR
#define FC_TOTAL_TH_DROP_Q_WANr_SET BCM53101_A0_FC_TOTAL_TH_DROP_Q_WANr_SET
#define FC_TOTAL_TH_DROP_Q_WANr_GET BCM53101_A0_FC_TOTAL_TH_DROP_Q_WANr_GET
#define FC_TOTAL_TH_DROP_Q_WANr_TXQ_TOTAL_DROP_THRSf_GET BCM53101_A0_FC_TOTAL_TH_DROP_Q_WANr_TXQ_TOTAL_DROP_THRSf_GET
#define FC_TOTAL_TH_DROP_Q_WANr_TXQ_TOTAL_DROP_THRSf_SET BCM53101_A0_FC_TOTAL_TH_DROP_Q_WANr_TXQ_TOTAL_DROP_THRSf_SET
#define FC_TOTAL_TH_DROP_Q_WANr_RESERVEDf_GET BCM53101_A0_FC_TOTAL_TH_DROP_Q_WANr_RESERVEDf_GET
#define FC_TOTAL_TH_DROP_Q_WANr_RESERVEDf_SET BCM53101_A0_FC_TOTAL_TH_DROP_Q_WANr_RESERVEDf_SET
#define READ_FC_TOTAL_TH_DROP_Q_WANr BCM53101_A0_READ_FC_TOTAL_TH_DROP_Q_WANr
#define WRITE_FC_TOTAL_TH_DROP_Q_WANr BCM53101_A0_WRITE_FC_TOTAL_TH_DROP_Q_WANr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_TOTAL_TH_DROP_Q_WANr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_TOTAL_TH_HYST_Q
 * BLOCKS:   SYS
 * DESC:     Total Hysteresis Threshold For Queue N Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_HYST_THRS 
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_FC_TOTAL_TH_HYST_Qr 0x00000a28

#define BCM53101_A0_FC_TOTAL_TH_HYST_Qr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_HYST_Q.
 *
 */
typedef union BCM53101_A0_FC_TOTAL_TH_HYST_Qr_s {
	uint32_t v[1];
	uint32_t fc_total_th_hyst_q[1];
	uint32_t _fc_total_th_hyst_q;
} BCM53101_A0_FC_TOTAL_TH_HYST_Qr_t;

#define BCM53101_A0_FC_TOTAL_TH_HYST_Qr_CLR(r) (r).fc_total_th_hyst_q[0] = 0
#define BCM53101_A0_FC_TOTAL_TH_HYST_Qr_SET(r,d) (r).fc_total_th_hyst_q[0] = d
#define BCM53101_A0_FC_TOTAL_TH_HYST_Qr_GET(r) (r).fc_total_th_hyst_q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_TOTAL_TH_HYST_Qr_TXQ_TOTAL_HYST_THRSf_GET(r) (((r).fc_total_th_hyst_q[0]) & 0x3ff)
#define BCM53101_A0_FC_TOTAL_TH_HYST_Qr_TXQ_TOTAL_HYST_THRSf_SET(r,f) (r).fc_total_th_hyst_q[0]=(((r).fc_total_th_hyst_q[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53101_A0_FC_TOTAL_TH_HYST_Qr_RESERVEDf_GET(r) ((((r).fc_total_th_hyst_q[0]) >> 10) & 0x3f)
#define BCM53101_A0_FC_TOTAL_TH_HYST_Qr_RESERVEDf_SET(r,f) (r).fc_total_th_hyst_q[0]=(((r).fc_total_th_hyst_q[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TOTAL_TH_HYST_Q.
 *
 */
#define BCM53101_A0_READ_FC_TOTAL_TH_HYST_Qr(u,i,r) cdk_robo_reg_read(u,BCM53101_A0_FC_TOTAL_TH_HYST_Qr+(2*(i)),(r._fc_total_th_hyst_q),2)
#define BCM53101_A0_WRITE_FC_TOTAL_TH_HYST_Qr(u,i,r) cdk_robo_reg_write(u,BCM53101_A0_FC_TOTAL_TH_HYST_Qr+(2*(i)),&(r._fc_total_th_hyst_q),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_HYST_Qr BCM53101_A0_FC_TOTAL_TH_HYST_Qr
#define FC_TOTAL_TH_HYST_Qr_SIZE BCM53101_A0_FC_TOTAL_TH_HYST_Qr_SIZE
typedef BCM53101_A0_FC_TOTAL_TH_HYST_Qr_t FC_TOTAL_TH_HYST_Qr_t;
#define FC_TOTAL_TH_HYST_Qr_CLR BCM53101_A0_FC_TOTAL_TH_HYST_Qr_CLR
#define FC_TOTAL_TH_HYST_Qr_SET BCM53101_A0_FC_TOTAL_TH_HYST_Qr_SET
#define FC_TOTAL_TH_HYST_Qr_GET BCM53101_A0_FC_TOTAL_TH_HYST_Qr_GET
#define FC_TOTAL_TH_HYST_Qr_TXQ_TOTAL_HYST_THRSf_GET BCM53101_A0_FC_TOTAL_TH_HYST_Qr_TXQ_TOTAL_HYST_THRSf_GET
#define FC_TOTAL_TH_HYST_Qr_TXQ_TOTAL_HYST_THRSf_SET BCM53101_A0_FC_TOTAL_TH_HYST_Qr_TXQ_TOTAL_HYST_THRSf_SET
#define FC_TOTAL_TH_HYST_Qr_RESERVEDf_GET BCM53101_A0_FC_TOTAL_TH_HYST_Qr_RESERVEDf_GET
#define FC_TOTAL_TH_HYST_Qr_RESERVEDf_SET BCM53101_A0_FC_TOTAL_TH_HYST_Qr_RESERVEDf_SET
#define READ_FC_TOTAL_TH_HYST_Qr BCM53101_A0_READ_FC_TOTAL_TH_HYST_Qr
#define WRITE_FC_TOTAL_TH_HYST_Qr BCM53101_A0_WRITE_FC_TOTAL_TH_HYST_Qr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_TOTAL_TH_HYST_Qr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_TOTAL_TH_HYST_Q45
 * BLOCKS:   SYS
 * DESC:     Total Hysteresis Threshold For Queue N(4~5) Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_HYST_THRS 
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_FC_TOTAL_TH_HYST_Q45r 0x00000abc

#define BCM53101_A0_FC_TOTAL_TH_HYST_Q45r_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_HYST_Q45.
 *
 */
typedef union BCM53101_A0_FC_TOTAL_TH_HYST_Q45r_s {
	uint32_t v[1];
	uint32_t fc_total_th_hyst_q45[1];
	uint32_t _fc_total_th_hyst_q45;
} BCM53101_A0_FC_TOTAL_TH_HYST_Q45r_t;

#define BCM53101_A0_FC_TOTAL_TH_HYST_Q45r_CLR(r) (r).fc_total_th_hyst_q45[0] = 0
#define BCM53101_A0_FC_TOTAL_TH_HYST_Q45r_SET(r,d) (r).fc_total_th_hyst_q45[0] = d
#define BCM53101_A0_FC_TOTAL_TH_HYST_Q45r_GET(r) (r).fc_total_th_hyst_q45[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_TOTAL_TH_HYST_Q45r_TXQ_TOTAL_HYST_THRSf_GET(r) (((r).fc_total_th_hyst_q45[0]) & 0x3ff)
#define BCM53101_A0_FC_TOTAL_TH_HYST_Q45r_TXQ_TOTAL_HYST_THRSf_SET(r,f) (r).fc_total_th_hyst_q45[0]=(((r).fc_total_th_hyst_q45[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53101_A0_FC_TOTAL_TH_HYST_Q45r_RESERVEDf_GET(r) ((((r).fc_total_th_hyst_q45[0]) >> 10) & 0x3f)
#define BCM53101_A0_FC_TOTAL_TH_HYST_Q45r_RESERVEDf_SET(r,f) (r).fc_total_th_hyst_q45[0]=(((r).fc_total_th_hyst_q45[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TOTAL_TH_HYST_Q45.
 *
 */
#define BCM53101_A0_READ_FC_TOTAL_TH_HYST_Q45r(u,i,r) cdk_robo_reg_read(u,BCM53101_A0_FC_TOTAL_TH_HYST_Q45r+(2*(i)),(r._fc_total_th_hyst_q45),2)
#define BCM53101_A0_WRITE_FC_TOTAL_TH_HYST_Q45r(u,i,r) cdk_robo_reg_write(u,BCM53101_A0_FC_TOTAL_TH_HYST_Q45r+(2*(i)),&(r._fc_total_th_hyst_q45),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_HYST_Q45r BCM53101_A0_FC_TOTAL_TH_HYST_Q45r
#define FC_TOTAL_TH_HYST_Q45r_SIZE BCM53101_A0_FC_TOTAL_TH_HYST_Q45r_SIZE
typedef BCM53101_A0_FC_TOTAL_TH_HYST_Q45r_t FC_TOTAL_TH_HYST_Q45r_t;
#define FC_TOTAL_TH_HYST_Q45r_CLR BCM53101_A0_FC_TOTAL_TH_HYST_Q45r_CLR
#define FC_TOTAL_TH_HYST_Q45r_SET BCM53101_A0_FC_TOTAL_TH_HYST_Q45r_SET
#define FC_TOTAL_TH_HYST_Q45r_GET BCM53101_A0_FC_TOTAL_TH_HYST_Q45r_GET
#define FC_TOTAL_TH_HYST_Q45r_TXQ_TOTAL_HYST_THRSf_GET BCM53101_A0_FC_TOTAL_TH_HYST_Q45r_TXQ_TOTAL_HYST_THRSf_GET
#define FC_TOTAL_TH_HYST_Q45r_TXQ_TOTAL_HYST_THRSf_SET BCM53101_A0_FC_TOTAL_TH_HYST_Q45r_TXQ_TOTAL_HYST_THRSf_SET
#define FC_TOTAL_TH_HYST_Q45r_RESERVEDf_GET BCM53101_A0_FC_TOTAL_TH_HYST_Q45r_RESERVEDf_GET
#define FC_TOTAL_TH_HYST_Q45r_RESERVEDf_SET BCM53101_A0_FC_TOTAL_TH_HYST_Q45r_RESERVEDf_SET
#define READ_FC_TOTAL_TH_HYST_Q45r BCM53101_A0_READ_FC_TOTAL_TH_HYST_Q45r
#define WRITE_FC_TOTAL_TH_HYST_Q45r BCM53101_A0_WRITE_FC_TOTAL_TH_HYST_Q45r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_TOTAL_TH_HYST_Q45r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_TOTAL_TH_HYST_Q_IMP
 * BLOCKS:   SYS
 * DESC:     Total Hysteresis Threshold For Queue N Register for IMP
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_HYST_THRS 
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_FC_TOTAL_TH_HYST_Q_IMPr 0x00000d28

#define BCM53101_A0_FC_TOTAL_TH_HYST_Q_IMPr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_HYST_Q_IMP.
 *
 */
typedef union BCM53101_A0_FC_TOTAL_TH_HYST_Q_IMPr_s {
	uint32_t v[1];
	uint32_t fc_total_th_hyst_q_imp[1];
	uint32_t _fc_total_th_hyst_q_imp;
} BCM53101_A0_FC_TOTAL_TH_HYST_Q_IMPr_t;

#define BCM53101_A0_FC_TOTAL_TH_HYST_Q_IMPr_CLR(r) (r).fc_total_th_hyst_q_imp[0] = 0
#define BCM53101_A0_FC_TOTAL_TH_HYST_Q_IMPr_SET(r,d) (r).fc_total_th_hyst_q_imp[0] = d
#define BCM53101_A0_FC_TOTAL_TH_HYST_Q_IMPr_GET(r) (r).fc_total_th_hyst_q_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_TOTAL_TH_HYST_Q_IMPr_TXQ_TOTAL_HYST_THRSf_GET(r) (((r).fc_total_th_hyst_q_imp[0]) & 0x3ff)
#define BCM53101_A0_FC_TOTAL_TH_HYST_Q_IMPr_TXQ_TOTAL_HYST_THRSf_SET(r,f) (r).fc_total_th_hyst_q_imp[0]=(((r).fc_total_th_hyst_q_imp[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53101_A0_FC_TOTAL_TH_HYST_Q_IMPr_RESERVEDf_GET(r) ((((r).fc_total_th_hyst_q_imp[0]) >> 10) & 0x3f)
#define BCM53101_A0_FC_TOTAL_TH_HYST_Q_IMPr_RESERVEDf_SET(r,f) (r).fc_total_th_hyst_q_imp[0]=(((r).fc_total_th_hyst_q_imp[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TOTAL_TH_HYST_Q_IMP.
 *
 */
#define BCM53101_A0_READ_FC_TOTAL_TH_HYST_Q_IMPr(u,i,r) cdk_robo_reg_read(u,BCM53101_A0_FC_TOTAL_TH_HYST_Q_IMPr+(2*(i)),(r._fc_total_th_hyst_q_imp),2)
#define BCM53101_A0_WRITE_FC_TOTAL_TH_HYST_Q_IMPr(u,i,r) cdk_robo_reg_write(u,BCM53101_A0_FC_TOTAL_TH_HYST_Q_IMPr+(2*(i)),&(r._fc_total_th_hyst_q_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_HYST_Q_IMPr BCM53101_A0_FC_TOTAL_TH_HYST_Q_IMPr
#define FC_TOTAL_TH_HYST_Q_IMPr_SIZE BCM53101_A0_FC_TOTAL_TH_HYST_Q_IMPr_SIZE
typedef BCM53101_A0_FC_TOTAL_TH_HYST_Q_IMPr_t FC_TOTAL_TH_HYST_Q_IMPr_t;
#define FC_TOTAL_TH_HYST_Q_IMPr_CLR BCM53101_A0_FC_TOTAL_TH_HYST_Q_IMPr_CLR
#define FC_TOTAL_TH_HYST_Q_IMPr_SET BCM53101_A0_FC_TOTAL_TH_HYST_Q_IMPr_SET
#define FC_TOTAL_TH_HYST_Q_IMPr_GET BCM53101_A0_FC_TOTAL_TH_HYST_Q_IMPr_GET
#define FC_TOTAL_TH_HYST_Q_IMPr_TXQ_TOTAL_HYST_THRSf_GET BCM53101_A0_FC_TOTAL_TH_HYST_Q_IMPr_TXQ_TOTAL_HYST_THRSf_GET
#define FC_TOTAL_TH_HYST_Q_IMPr_TXQ_TOTAL_HYST_THRSf_SET BCM53101_A0_FC_TOTAL_TH_HYST_Q_IMPr_TXQ_TOTAL_HYST_THRSf_SET
#define FC_TOTAL_TH_HYST_Q_IMPr_RESERVEDf_GET BCM53101_A0_FC_TOTAL_TH_HYST_Q_IMPr_RESERVEDf_GET
#define FC_TOTAL_TH_HYST_Q_IMPr_RESERVEDf_SET BCM53101_A0_FC_TOTAL_TH_HYST_Q_IMPr_RESERVEDf_SET
#define READ_FC_TOTAL_TH_HYST_Q_IMPr BCM53101_A0_READ_FC_TOTAL_TH_HYST_Q_IMPr
#define WRITE_FC_TOTAL_TH_HYST_Q_IMPr BCM53101_A0_WRITE_FC_TOTAL_TH_HYST_Q_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_TOTAL_TH_HYST_Q_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_TOTAL_TH_HYST_Q_WAN
 * BLOCKS:   SYS
 * DESC:     Total Hysteresis Threshold For Queue N Register for WAN
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_HYST_THRS 
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_FC_TOTAL_TH_HYST_Q_WANr 0x00000e28

#define BCM53101_A0_FC_TOTAL_TH_HYST_Q_WANr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_HYST_Q_WAN.
 *
 */
typedef union BCM53101_A0_FC_TOTAL_TH_HYST_Q_WANr_s {
	uint32_t v[1];
	uint32_t fc_total_th_hyst_q_wan[1];
	uint32_t _fc_total_th_hyst_q_wan;
} BCM53101_A0_FC_TOTAL_TH_HYST_Q_WANr_t;

#define BCM53101_A0_FC_TOTAL_TH_HYST_Q_WANr_CLR(r) (r).fc_total_th_hyst_q_wan[0] = 0
#define BCM53101_A0_FC_TOTAL_TH_HYST_Q_WANr_SET(r,d) (r).fc_total_th_hyst_q_wan[0] = d
#define BCM53101_A0_FC_TOTAL_TH_HYST_Q_WANr_GET(r) (r).fc_total_th_hyst_q_wan[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_TOTAL_TH_HYST_Q_WANr_TXQ_TOTAL_HYST_THRSf_GET(r) (((r).fc_total_th_hyst_q_wan[0]) & 0x3ff)
#define BCM53101_A0_FC_TOTAL_TH_HYST_Q_WANr_TXQ_TOTAL_HYST_THRSf_SET(r,f) (r).fc_total_th_hyst_q_wan[0]=(((r).fc_total_th_hyst_q_wan[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53101_A0_FC_TOTAL_TH_HYST_Q_WANr_RESERVEDf_GET(r) ((((r).fc_total_th_hyst_q_wan[0]) >> 10) & 0x3f)
#define BCM53101_A0_FC_TOTAL_TH_HYST_Q_WANr_RESERVEDf_SET(r,f) (r).fc_total_th_hyst_q_wan[0]=(((r).fc_total_th_hyst_q_wan[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TOTAL_TH_HYST_Q_WAN.
 *
 */
#define BCM53101_A0_READ_FC_TOTAL_TH_HYST_Q_WANr(u,i,r) cdk_robo_reg_read(u,BCM53101_A0_FC_TOTAL_TH_HYST_Q_WANr+(2*(i)),(r._fc_total_th_hyst_q_wan),2)
#define BCM53101_A0_WRITE_FC_TOTAL_TH_HYST_Q_WANr(u,i,r) cdk_robo_reg_write(u,BCM53101_A0_FC_TOTAL_TH_HYST_Q_WANr+(2*(i)),&(r._fc_total_th_hyst_q_wan),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_HYST_Q_WANr BCM53101_A0_FC_TOTAL_TH_HYST_Q_WANr
#define FC_TOTAL_TH_HYST_Q_WANr_SIZE BCM53101_A0_FC_TOTAL_TH_HYST_Q_WANr_SIZE
typedef BCM53101_A0_FC_TOTAL_TH_HYST_Q_WANr_t FC_TOTAL_TH_HYST_Q_WANr_t;
#define FC_TOTAL_TH_HYST_Q_WANr_CLR BCM53101_A0_FC_TOTAL_TH_HYST_Q_WANr_CLR
#define FC_TOTAL_TH_HYST_Q_WANr_SET BCM53101_A0_FC_TOTAL_TH_HYST_Q_WANr_SET
#define FC_TOTAL_TH_HYST_Q_WANr_GET BCM53101_A0_FC_TOTAL_TH_HYST_Q_WANr_GET
#define FC_TOTAL_TH_HYST_Q_WANr_TXQ_TOTAL_HYST_THRSf_GET BCM53101_A0_FC_TOTAL_TH_HYST_Q_WANr_TXQ_TOTAL_HYST_THRSf_GET
#define FC_TOTAL_TH_HYST_Q_WANr_TXQ_TOTAL_HYST_THRSf_SET BCM53101_A0_FC_TOTAL_TH_HYST_Q_WANr_TXQ_TOTAL_HYST_THRSf_SET
#define FC_TOTAL_TH_HYST_Q_WANr_RESERVEDf_GET BCM53101_A0_FC_TOTAL_TH_HYST_Q_WANr_RESERVEDf_GET
#define FC_TOTAL_TH_HYST_Q_WANr_RESERVEDf_SET BCM53101_A0_FC_TOTAL_TH_HYST_Q_WANr_RESERVEDf_SET
#define READ_FC_TOTAL_TH_HYST_Q_WANr BCM53101_A0_READ_FC_TOTAL_TH_HYST_Q_WANr
#define WRITE_FC_TOTAL_TH_HYST_Q_WANr BCM53101_A0_WRITE_FC_TOTAL_TH_HYST_Q_WANr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_TOTAL_TH_HYST_Q_WANr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_TOTAL_TH_PAUSE_Q
 * BLOCKS:   SYS
 * DESC:     Total Pause Threshold For Queue N Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_PAUSE_THRS 
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_FC_TOTAL_TH_PAUSE_Qr 0x00000a30

#define BCM53101_A0_FC_TOTAL_TH_PAUSE_Qr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_PAUSE_Q.
 *
 */
typedef union BCM53101_A0_FC_TOTAL_TH_PAUSE_Qr_s {
	uint32_t v[1];
	uint32_t fc_total_th_pause_q[1];
	uint32_t _fc_total_th_pause_q;
} BCM53101_A0_FC_TOTAL_TH_PAUSE_Qr_t;

#define BCM53101_A0_FC_TOTAL_TH_PAUSE_Qr_CLR(r) (r).fc_total_th_pause_q[0] = 0
#define BCM53101_A0_FC_TOTAL_TH_PAUSE_Qr_SET(r,d) (r).fc_total_th_pause_q[0] = d
#define BCM53101_A0_FC_TOTAL_TH_PAUSE_Qr_GET(r) (r).fc_total_th_pause_q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_TOTAL_TH_PAUSE_Qr_TXQ_TOTAL_PAUSE_THRSf_GET(r) (((r).fc_total_th_pause_q[0]) & 0x3ff)
#define BCM53101_A0_FC_TOTAL_TH_PAUSE_Qr_TXQ_TOTAL_PAUSE_THRSf_SET(r,f) (r).fc_total_th_pause_q[0]=(((r).fc_total_th_pause_q[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53101_A0_FC_TOTAL_TH_PAUSE_Qr_RESERVEDf_GET(r) ((((r).fc_total_th_pause_q[0]) >> 10) & 0x3f)
#define BCM53101_A0_FC_TOTAL_TH_PAUSE_Qr_RESERVEDf_SET(r,f) (r).fc_total_th_pause_q[0]=(((r).fc_total_th_pause_q[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TOTAL_TH_PAUSE_Q.
 *
 */
#define BCM53101_A0_READ_FC_TOTAL_TH_PAUSE_Qr(u,i,r) cdk_robo_reg_read(u,BCM53101_A0_FC_TOTAL_TH_PAUSE_Qr+(2*(i)),(r._fc_total_th_pause_q),2)
#define BCM53101_A0_WRITE_FC_TOTAL_TH_PAUSE_Qr(u,i,r) cdk_robo_reg_write(u,BCM53101_A0_FC_TOTAL_TH_PAUSE_Qr+(2*(i)),&(r._fc_total_th_pause_q),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_PAUSE_Qr BCM53101_A0_FC_TOTAL_TH_PAUSE_Qr
#define FC_TOTAL_TH_PAUSE_Qr_SIZE BCM53101_A0_FC_TOTAL_TH_PAUSE_Qr_SIZE
typedef BCM53101_A0_FC_TOTAL_TH_PAUSE_Qr_t FC_TOTAL_TH_PAUSE_Qr_t;
#define FC_TOTAL_TH_PAUSE_Qr_CLR BCM53101_A0_FC_TOTAL_TH_PAUSE_Qr_CLR
#define FC_TOTAL_TH_PAUSE_Qr_SET BCM53101_A0_FC_TOTAL_TH_PAUSE_Qr_SET
#define FC_TOTAL_TH_PAUSE_Qr_GET BCM53101_A0_FC_TOTAL_TH_PAUSE_Qr_GET
#define FC_TOTAL_TH_PAUSE_Qr_TXQ_TOTAL_PAUSE_THRSf_GET BCM53101_A0_FC_TOTAL_TH_PAUSE_Qr_TXQ_TOTAL_PAUSE_THRSf_GET
#define FC_TOTAL_TH_PAUSE_Qr_TXQ_TOTAL_PAUSE_THRSf_SET BCM53101_A0_FC_TOTAL_TH_PAUSE_Qr_TXQ_TOTAL_PAUSE_THRSf_SET
#define FC_TOTAL_TH_PAUSE_Qr_RESERVEDf_GET BCM53101_A0_FC_TOTAL_TH_PAUSE_Qr_RESERVEDf_GET
#define FC_TOTAL_TH_PAUSE_Qr_RESERVEDf_SET BCM53101_A0_FC_TOTAL_TH_PAUSE_Qr_RESERVEDf_SET
#define READ_FC_TOTAL_TH_PAUSE_Qr BCM53101_A0_READ_FC_TOTAL_TH_PAUSE_Qr
#define WRITE_FC_TOTAL_TH_PAUSE_Qr BCM53101_A0_WRITE_FC_TOTAL_TH_PAUSE_Qr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_TOTAL_TH_PAUSE_Qr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_TOTAL_TH_PAUSE_Q45
 * BLOCKS:   SYS
 * DESC:     Total Pause Threshold For Queue N(4~5) Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_PAUSE_THRS 
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_FC_TOTAL_TH_PAUSE_Q45r 0x00000ac0

#define BCM53101_A0_FC_TOTAL_TH_PAUSE_Q45r_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_PAUSE_Q45.
 *
 */
typedef union BCM53101_A0_FC_TOTAL_TH_PAUSE_Q45r_s {
	uint32_t v[1];
	uint32_t fc_total_th_pause_q45[1];
	uint32_t _fc_total_th_pause_q45;
} BCM53101_A0_FC_TOTAL_TH_PAUSE_Q45r_t;

#define BCM53101_A0_FC_TOTAL_TH_PAUSE_Q45r_CLR(r) (r).fc_total_th_pause_q45[0] = 0
#define BCM53101_A0_FC_TOTAL_TH_PAUSE_Q45r_SET(r,d) (r).fc_total_th_pause_q45[0] = d
#define BCM53101_A0_FC_TOTAL_TH_PAUSE_Q45r_GET(r) (r).fc_total_th_pause_q45[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_TOTAL_TH_PAUSE_Q45r_TXQ_TOTAL_PAUSE_THRSf_GET(r) (((r).fc_total_th_pause_q45[0]) & 0x3ff)
#define BCM53101_A0_FC_TOTAL_TH_PAUSE_Q45r_TXQ_TOTAL_PAUSE_THRSf_SET(r,f) (r).fc_total_th_pause_q45[0]=(((r).fc_total_th_pause_q45[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53101_A0_FC_TOTAL_TH_PAUSE_Q45r_RESERVEDf_GET(r) ((((r).fc_total_th_pause_q45[0]) >> 10) & 0x3f)
#define BCM53101_A0_FC_TOTAL_TH_PAUSE_Q45r_RESERVEDf_SET(r,f) (r).fc_total_th_pause_q45[0]=(((r).fc_total_th_pause_q45[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TOTAL_TH_PAUSE_Q45.
 *
 */
#define BCM53101_A0_READ_FC_TOTAL_TH_PAUSE_Q45r(u,i,r) cdk_robo_reg_read(u,BCM53101_A0_FC_TOTAL_TH_PAUSE_Q45r+(2*(i)),(r._fc_total_th_pause_q45),2)
#define BCM53101_A0_WRITE_FC_TOTAL_TH_PAUSE_Q45r(u,i,r) cdk_robo_reg_write(u,BCM53101_A0_FC_TOTAL_TH_PAUSE_Q45r+(2*(i)),&(r._fc_total_th_pause_q45),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_PAUSE_Q45r BCM53101_A0_FC_TOTAL_TH_PAUSE_Q45r
#define FC_TOTAL_TH_PAUSE_Q45r_SIZE BCM53101_A0_FC_TOTAL_TH_PAUSE_Q45r_SIZE
typedef BCM53101_A0_FC_TOTAL_TH_PAUSE_Q45r_t FC_TOTAL_TH_PAUSE_Q45r_t;
#define FC_TOTAL_TH_PAUSE_Q45r_CLR BCM53101_A0_FC_TOTAL_TH_PAUSE_Q45r_CLR
#define FC_TOTAL_TH_PAUSE_Q45r_SET BCM53101_A0_FC_TOTAL_TH_PAUSE_Q45r_SET
#define FC_TOTAL_TH_PAUSE_Q45r_GET BCM53101_A0_FC_TOTAL_TH_PAUSE_Q45r_GET
#define FC_TOTAL_TH_PAUSE_Q45r_TXQ_TOTAL_PAUSE_THRSf_GET BCM53101_A0_FC_TOTAL_TH_PAUSE_Q45r_TXQ_TOTAL_PAUSE_THRSf_GET
#define FC_TOTAL_TH_PAUSE_Q45r_TXQ_TOTAL_PAUSE_THRSf_SET BCM53101_A0_FC_TOTAL_TH_PAUSE_Q45r_TXQ_TOTAL_PAUSE_THRSf_SET
#define FC_TOTAL_TH_PAUSE_Q45r_RESERVEDf_GET BCM53101_A0_FC_TOTAL_TH_PAUSE_Q45r_RESERVEDf_GET
#define FC_TOTAL_TH_PAUSE_Q45r_RESERVEDf_SET BCM53101_A0_FC_TOTAL_TH_PAUSE_Q45r_RESERVEDf_SET
#define READ_FC_TOTAL_TH_PAUSE_Q45r BCM53101_A0_READ_FC_TOTAL_TH_PAUSE_Q45r
#define WRITE_FC_TOTAL_TH_PAUSE_Q45r BCM53101_A0_WRITE_FC_TOTAL_TH_PAUSE_Q45r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_TOTAL_TH_PAUSE_Q45r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_TOTAL_TH_PAUSE_Q_IMP
 * BLOCKS:   SYS
 * DESC:     Total Pause Threshold For Queue N Register for IMP
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_PAUSE_THRS 
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_IMPr 0x00000d30

#define BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_PAUSE_Q_IMP.
 *
 */
typedef union BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_s {
	uint32_t v[1];
	uint32_t fc_total_th_pause_q_imp[1];
	uint32_t _fc_total_th_pause_q_imp;
} BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_t;

#define BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_CLR(r) (r).fc_total_th_pause_q_imp[0] = 0
#define BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_SET(r,d) (r).fc_total_th_pause_q_imp[0] = d
#define BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_GET(r) (r).fc_total_th_pause_q_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_TXQ_TOTAL_PAUSE_THRSf_GET(r) (((r).fc_total_th_pause_q_imp[0]) & 0x3ff)
#define BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_TXQ_TOTAL_PAUSE_THRSf_SET(r,f) (r).fc_total_th_pause_q_imp[0]=(((r).fc_total_th_pause_q_imp[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_RESERVEDf_GET(r) ((((r).fc_total_th_pause_q_imp[0]) >> 10) & 0x3f)
#define BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_RESERVEDf_SET(r,f) (r).fc_total_th_pause_q_imp[0]=(((r).fc_total_th_pause_q_imp[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TOTAL_TH_PAUSE_Q_IMP.
 *
 */
#define BCM53101_A0_READ_FC_TOTAL_TH_PAUSE_Q_IMPr(u,i,r) cdk_robo_reg_read(u,BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_IMPr+(2*(i)),(r._fc_total_th_pause_q_imp),2)
#define BCM53101_A0_WRITE_FC_TOTAL_TH_PAUSE_Q_IMPr(u,i,r) cdk_robo_reg_write(u,BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_IMPr+(2*(i)),&(r._fc_total_th_pause_q_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_PAUSE_Q_IMPr BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_IMPr
#define FC_TOTAL_TH_PAUSE_Q_IMPr_SIZE BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_SIZE
typedef BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_t FC_TOTAL_TH_PAUSE_Q_IMPr_t;
#define FC_TOTAL_TH_PAUSE_Q_IMPr_CLR BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_CLR
#define FC_TOTAL_TH_PAUSE_Q_IMPr_SET BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_SET
#define FC_TOTAL_TH_PAUSE_Q_IMPr_GET BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_GET
#define FC_TOTAL_TH_PAUSE_Q_IMPr_TXQ_TOTAL_PAUSE_THRSf_GET BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_TXQ_TOTAL_PAUSE_THRSf_GET
#define FC_TOTAL_TH_PAUSE_Q_IMPr_TXQ_TOTAL_PAUSE_THRSf_SET BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_TXQ_TOTAL_PAUSE_THRSf_SET
#define FC_TOTAL_TH_PAUSE_Q_IMPr_RESERVEDf_GET BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_RESERVEDf_GET
#define FC_TOTAL_TH_PAUSE_Q_IMPr_RESERVEDf_SET BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_IMPr_RESERVEDf_SET
#define READ_FC_TOTAL_TH_PAUSE_Q_IMPr BCM53101_A0_READ_FC_TOTAL_TH_PAUSE_Q_IMPr
#define WRITE_FC_TOTAL_TH_PAUSE_Q_IMPr BCM53101_A0_WRITE_FC_TOTAL_TH_PAUSE_Q_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_TOTAL_TH_PAUSE_Q_WAN
 * BLOCKS:   SYS
 * DESC:     Total Pause Threshold For Queue N Register for WAN
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_PAUSE_THRS 
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_WANr 0x00000e30

#define BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_WANr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_PAUSE_Q_WAN.
 *
 */
typedef union BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_WANr_s {
	uint32_t v[1];
	uint32_t fc_total_th_pause_q_wan[1];
	uint32_t _fc_total_th_pause_q_wan;
} BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_WANr_t;

#define BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_WANr_CLR(r) (r).fc_total_th_pause_q_wan[0] = 0
#define BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_WANr_SET(r,d) (r).fc_total_th_pause_q_wan[0] = d
#define BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_WANr_GET(r) (r).fc_total_th_pause_q_wan[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_WANr_TXQ_TOTAL_PAUSE_THRSf_GET(r) (((r).fc_total_th_pause_q_wan[0]) & 0x3ff)
#define BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_WANr_TXQ_TOTAL_PAUSE_THRSf_SET(r,f) (r).fc_total_th_pause_q_wan[0]=(((r).fc_total_th_pause_q_wan[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_WANr_RESERVEDf_GET(r) ((((r).fc_total_th_pause_q_wan[0]) >> 10) & 0x3f)
#define BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_WANr_RESERVEDf_SET(r,f) (r).fc_total_th_pause_q_wan[0]=(((r).fc_total_th_pause_q_wan[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TOTAL_TH_PAUSE_Q_WAN.
 *
 */
#define BCM53101_A0_READ_FC_TOTAL_TH_PAUSE_Q_WANr(u,i,r) cdk_robo_reg_read(u,BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_WANr+(2*(i)),(r._fc_total_th_pause_q_wan),2)
#define BCM53101_A0_WRITE_FC_TOTAL_TH_PAUSE_Q_WANr(u,i,r) cdk_robo_reg_write(u,BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_WANr+(2*(i)),&(r._fc_total_th_pause_q_wan),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_PAUSE_Q_WANr BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_WANr
#define FC_TOTAL_TH_PAUSE_Q_WANr_SIZE BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_WANr_SIZE
typedef BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_WANr_t FC_TOTAL_TH_PAUSE_Q_WANr_t;
#define FC_TOTAL_TH_PAUSE_Q_WANr_CLR BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_WANr_CLR
#define FC_TOTAL_TH_PAUSE_Q_WANr_SET BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_WANr_SET
#define FC_TOTAL_TH_PAUSE_Q_WANr_GET BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_WANr_GET
#define FC_TOTAL_TH_PAUSE_Q_WANr_TXQ_TOTAL_PAUSE_THRSf_GET BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_WANr_TXQ_TOTAL_PAUSE_THRSf_GET
#define FC_TOTAL_TH_PAUSE_Q_WANr_TXQ_TOTAL_PAUSE_THRSf_SET BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_WANr_TXQ_TOTAL_PAUSE_THRSf_SET
#define FC_TOTAL_TH_PAUSE_Q_WANr_RESERVEDf_GET BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_WANr_RESERVEDf_GET
#define FC_TOTAL_TH_PAUSE_Q_WANr_RESERVEDf_SET BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_WANr_RESERVEDf_SET
#define READ_FC_TOTAL_TH_PAUSE_Q_WANr BCM53101_A0_READ_FC_TOTAL_TH_PAUSE_Q_WANr
#define WRITE_FC_TOTAL_TH_PAUSE_Q_WANr BCM53101_A0_WRITE_FC_TOTAL_TH_PAUSE_Q_WANr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_TOTAL_TH_PAUSE_Q_WANr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_TOTAL_TH_RSRV_Q
 * BLOCKS:   SYS
 * DESC:     Total Reserved Threshold For Queue N Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_TOTAL_RSRV_THRS if QOS is off, default is 512.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_FC_TOTAL_TH_RSRV_Qr 0x00000a40

#define BCM53101_A0_FC_TOTAL_TH_RSRV_Qr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_TH_RSRV_Q.
 *
 */
typedef union BCM53101_A0_FC_TOTAL_TH_RSRV_Qr_s {
	uint32_t v[1];
	uint32_t fc_total_th_rsrv_q[1];
	uint32_t _fc_total_th_rsrv_q;
} BCM53101_A0_FC_TOTAL_TH_RSRV_Qr_t;

#define BCM53101_A0_FC_TOTAL_TH_RSRV_Qr_CLR(r) (r).fc_total_th_rsrv_q[0] = 0
#define BCM53101_A0_FC_TOTAL_TH_RSRV_Qr_SET(r,d) (r).fc_total_th_rsrv_q[0] = d
#define BCM53101_A0_FC_TOTAL_TH_RSRV_Qr_GET(r) (r).fc_total_th_rsrv_q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_TOTAL_TH_RSRV_Qr_TXQ_TOTAL_RSRV_THRSf_GET(r) (((r).fc_total_th_rsrv_q[0]) & 0x3ff)
#define BCM53101_A0_FC_TOTAL_TH_RSRV_Qr_TXQ_TOTAL_RSRV_THRSf_SET(r,f) (r).fc_total_th_rsrv_q[0]=(((r).fc_total_th_rsrv_q[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53101_A0_FC_TOTAL_TH_RSRV_Qr_RESERVEDf_GET(r) ((((r).fc_total_th_rsrv_q[0]) >> 10) & 0x3f)
#define BCM53101_A0_FC_TOTAL_TH_RSRV_Qr_RESERVEDf_SET(r,f) (r).fc_total_th_rsrv_q[0]=(((r).fc_total_th_rsrv_q[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TOTAL_TH_RSRV_Q.
 *
 */
#define BCM53101_A0_READ_FC_TOTAL_TH_RSRV_Qr(u,i,r) cdk_robo_reg_read(u,BCM53101_A0_FC_TOTAL_TH_RSRV_Qr+(2*(i)),(r._fc_total_th_rsrv_q),2)
#define BCM53101_A0_WRITE_FC_TOTAL_TH_RSRV_Qr(u,i,r) cdk_robo_reg_write(u,BCM53101_A0_FC_TOTAL_TH_RSRV_Qr+(2*(i)),&(r._fc_total_th_rsrv_q),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_TH_RSRV_Qr BCM53101_A0_FC_TOTAL_TH_RSRV_Qr
#define FC_TOTAL_TH_RSRV_Qr_SIZE BCM53101_A0_FC_TOTAL_TH_RSRV_Qr_SIZE
typedef BCM53101_A0_FC_TOTAL_TH_RSRV_Qr_t FC_TOTAL_TH_RSRV_Qr_t;
#define FC_TOTAL_TH_RSRV_Qr_CLR BCM53101_A0_FC_TOTAL_TH_RSRV_Qr_CLR
#define FC_TOTAL_TH_RSRV_Qr_SET BCM53101_A0_FC_TOTAL_TH_RSRV_Qr_SET
#define FC_TOTAL_TH_RSRV_Qr_GET BCM53101_A0_FC_TOTAL_TH_RSRV_Qr_GET
#define FC_TOTAL_TH_RSRV_Qr_TXQ_TOTAL_RSRV_THRSf_GET BCM53101_A0_FC_TOTAL_TH_RSRV_Qr_TXQ_TOTAL_RSRV_THRSf_GET
#define FC_TOTAL_TH_RSRV_Qr_TXQ_TOTAL_RSRV_THRSf_SET BCM53101_A0_FC_TOTAL_TH_RSRV_Qr_TXQ_TOTAL_RSRV_THRSf_SET
#define FC_TOTAL_TH_RSRV_Qr_RESERVEDf_GET BCM53101_A0_FC_TOTAL_TH_RSRV_Qr_RESERVEDf_GET
#define FC_TOTAL_TH_RSRV_Qr_RESERVEDf_SET BCM53101_A0_FC_TOTAL_TH_RSRV_Qr_RESERVEDf_SET
#define READ_FC_TOTAL_TH_RSRV_Qr BCM53101_A0_READ_FC_TOTAL_TH_RSRV_Qr
#define WRITE_FC_TOTAL_TH_RSRV_Qr BCM53101_A0_WRITE_FC_TOTAL_TH_RSRV_Qr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_TOTAL_TH_RSRV_Qr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_TOTAL_USED
 * BLOCKS:   SYS
 * DESC:     Total Used Count Register
 * SIZE:     16
 * FIELDS:
 *     TOTAL_USE        Total Used count.This register records the current total used count.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_FC_TOTAL_USEDr 0x00000a82

#define BCM53101_A0_FC_TOTAL_USEDr_SIZE 2

/*
 * This structure should be used to declare and program FC_TOTAL_USED.
 *
 */
typedef union BCM53101_A0_FC_TOTAL_USEDr_s {
	uint32_t v[1];
	uint32_t fc_total_used[1];
	uint32_t _fc_total_used;
} BCM53101_A0_FC_TOTAL_USEDr_t;

#define BCM53101_A0_FC_TOTAL_USEDr_CLR(r) (r).fc_total_used[0] = 0
#define BCM53101_A0_FC_TOTAL_USEDr_SET(r,d) (r).fc_total_used[0] = d
#define BCM53101_A0_FC_TOTAL_USEDr_GET(r) (r).fc_total_used[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_TOTAL_USEDr_TOTAL_USEf_GET(r) (((r).fc_total_used[0]) & 0x7ff)
#define BCM53101_A0_FC_TOTAL_USEDr_TOTAL_USEf_SET(r,f) (r).fc_total_used[0]=(((r).fc_total_used[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53101_A0_FC_TOTAL_USEDr_RESERVEDf_GET(r) ((((r).fc_total_used[0]) >> 11) & 0x1f)
#define BCM53101_A0_FC_TOTAL_USEDr_RESERVEDf_SET(r,f) (r).fc_total_used[0]=(((r).fc_total_used[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_TOTAL_USED.
 *
 */
#define BCM53101_A0_READ_FC_TOTAL_USEDr(u,r) cdk_robo_reg_read(u,BCM53101_A0_FC_TOTAL_USEDr,(r._fc_total_used),2)
#define BCM53101_A0_WRITE_FC_TOTAL_USEDr(u,r) cdk_robo_reg_write(u,BCM53101_A0_FC_TOTAL_USEDr,&(r._fc_total_used),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TOTAL_USEDr BCM53101_A0_FC_TOTAL_USEDr
#define FC_TOTAL_USEDr_SIZE BCM53101_A0_FC_TOTAL_USEDr_SIZE
typedef BCM53101_A0_FC_TOTAL_USEDr_t FC_TOTAL_USEDr_t;
#define FC_TOTAL_USEDr_CLR BCM53101_A0_FC_TOTAL_USEDr_CLR
#define FC_TOTAL_USEDr_SET BCM53101_A0_FC_TOTAL_USEDr_SET
#define FC_TOTAL_USEDr_GET BCM53101_A0_FC_TOTAL_USEDr_GET
#define FC_TOTAL_USEDr_TOTAL_USEf_GET BCM53101_A0_FC_TOTAL_USEDr_TOTAL_USEf_GET
#define FC_TOTAL_USEDr_TOTAL_USEf_SET BCM53101_A0_FC_TOTAL_USEDr_TOTAL_USEf_SET
#define FC_TOTAL_USEDr_RESERVEDf_GET BCM53101_A0_FC_TOTAL_USEDr_RESERVEDf_GET
#define FC_TOTAL_USEDr_RESERVEDf_SET BCM53101_A0_FC_TOTAL_USEDr_RESERVEDf_SET
#define READ_FC_TOTAL_USEDr BCM53101_A0_READ_FC_TOTAL_USEDr
#define WRITE_FC_TOTAL_USEDr BCM53101_A0_WRITE_FC_TOTAL_USEDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_TOTAL_USEDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_TXPAUSE_HIS
 * BLOCKS:   SYS
 * DESC:     TX Pause History Register
 * SIZE:     16
 * FIELDS:
 *     TXPAUSE_HIS      
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_FC_TXPAUSE_HISr 0x00000aa2

#define BCM53101_A0_FC_TXPAUSE_HISr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXPAUSE_HIS.
 *
 */
typedef union BCM53101_A0_FC_TXPAUSE_HISr_s {
	uint32_t v[1];
	uint32_t fc_txpause_his[1];
	uint32_t _fc_txpause_his;
} BCM53101_A0_FC_TXPAUSE_HISr_t;

#define BCM53101_A0_FC_TXPAUSE_HISr_CLR(r) (r).fc_txpause_his[0] = 0
#define BCM53101_A0_FC_TXPAUSE_HISr_SET(r,d) (r).fc_txpause_his[0] = d
#define BCM53101_A0_FC_TXPAUSE_HISr_GET(r) (r).fc_txpause_his[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_TXPAUSE_HISr_TXPAUSE_HISf_GET(r) (((r).fc_txpause_his[0]) & 0x7ff)
#define BCM53101_A0_FC_TXPAUSE_HISr_TXPAUSE_HISf_SET(r,f) (r).fc_txpause_his[0]=(((r).fc_txpause_his[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53101_A0_FC_TXPAUSE_HISr_RESERVEDf_GET(r) ((((r).fc_txpause_his[0]) >> 11) & 0x1f)
#define BCM53101_A0_FC_TXPAUSE_HISr_RESERVEDf_SET(r,f) (r).fc_txpause_his[0]=(((r).fc_txpause_his[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11))

/*
 * These macros can be used to access FC_TXPAUSE_HIS.
 *
 */
#define BCM53101_A0_READ_FC_TXPAUSE_HISr(u,r) cdk_robo_reg_read(u,BCM53101_A0_FC_TXPAUSE_HISr,(r._fc_txpause_his),2)
#define BCM53101_A0_WRITE_FC_TXPAUSE_HISr(u,r) cdk_robo_reg_write(u,BCM53101_A0_FC_TXPAUSE_HISr,&(r._fc_txpause_his),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXPAUSE_HISr BCM53101_A0_FC_TXPAUSE_HISr
#define FC_TXPAUSE_HISr_SIZE BCM53101_A0_FC_TXPAUSE_HISr_SIZE
typedef BCM53101_A0_FC_TXPAUSE_HISr_t FC_TXPAUSE_HISr_t;
#define FC_TXPAUSE_HISr_CLR BCM53101_A0_FC_TXPAUSE_HISr_CLR
#define FC_TXPAUSE_HISr_SET BCM53101_A0_FC_TXPAUSE_HISr_SET
#define FC_TXPAUSE_HISr_GET BCM53101_A0_FC_TXPAUSE_HISr_GET
#define FC_TXPAUSE_HISr_TXPAUSE_HISf_GET BCM53101_A0_FC_TXPAUSE_HISr_TXPAUSE_HISf_GET
#define FC_TXPAUSE_HISr_TXPAUSE_HISf_SET BCM53101_A0_FC_TXPAUSE_HISr_TXPAUSE_HISf_SET
#define FC_TXPAUSE_HISr_RESERVEDf_GET BCM53101_A0_FC_TXPAUSE_HISr_RESERVEDf_GET
#define FC_TXPAUSE_HISr_RESERVEDf_SET BCM53101_A0_FC_TXPAUSE_HISr_RESERVEDf_SET
#define READ_FC_TXPAUSE_HISr BCM53101_A0_READ_FC_TXPAUSE_HISr
#define WRITE_FC_TXPAUSE_HISr BCM53101_A0_WRITE_FC_TXPAUSE_HISr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_TXPAUSE_HISr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_TXQ_TH_DROP_Q
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(0~3) Drop Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_DROP_THRS    
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_FC_TXQ_TH_DROP_Qr 0x00000a20

#define BCM53101_A0_FC_TXQ_TH_DROP_Qr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_DROP_Q.
 *
 */
typedef union BCM53101_A0_FC_TXQ_TH_DROP_Qr_s {
	uint32_t v[1];
	uint32_t fc_txq_th_drop_q[1];
	uint32_t _fc_txq_th_drop_q;
} BCM53101_A0_FC_TXQ_TH_DROP_Qr_t;

#define BCM53101_A0_FC_TXQ_TH_DROP_Qr_CLR(r) (r).fc_txq_th_drop_q[0] = 0
#define BCM53101_A0_FC_TXQ_TH_DROP_Qr_SET(r,d) (r).fc_txq_th_drop_q[0] = d
#define BCM53101_A0_FC_TXQ_TH_DROP_Qr_GET(r) (r).fc_txq_th_drop_q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_TXQ_TH_DROP_Qr_TXQ_DROP_THRSf_GET(r) (((r).fc_txq_th_drop_q[0]) & 0x3ff)
#define BCM53101_A0_FC_TXQ_TH_DROP_Qr_TXQ_DROP_THRSf_SET(r,f) (r).fc_txq_th_drop_q[0]=(((r).fc_txq_th_drop_q[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53101_A0_FC_TXQ_TH_DROP_Qr_RESERVEDf_GET(r) ((((r).fc_txq_th_drop_q[0]) >> 10) & 0x3f)
#define BCM53101_A0_FC_TXQ_TH_DROP_Qr_RESERVEDf_SET(r,f) (r).fc_txq_th_drop_q[0]=(((r).fc_txq_th_drop_q[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_DROP_Q.
 *
 */
#define BCM53101_A0_READ_FC_TXQ_TH_DROP_Qr(u,i,r) cdk_robo_reg_read(u,BCM53101_A0_FC_TXQ_TH_DROP_Qr+(2*(i)),(r._fc_txq_th_drop_q),2)
#define BCM53101_A0_WRITE_FC_TXQ_TH_DROP_Qr(u,i,r) cdk_robo_reg_write(u,BCM53101_A0_FC_TXQ_TH_DROP_Qr+(2*(i)),&(r._fc_txq_th_drop_q),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_DROP_Qr BCM53101_A0_FC_TXQ_TH_DROP_Qr
#define FC_TXQ_TH_DROP_Qr_SIZE BCM53101_A0_FC_TXQ_TH_DROP_Qr_SIZE
typedef BCM53101_A0_FC_TXQ_TH_DROP_Qr_t FC_TXQ_TH_DROP_Qr_t;
#define FC_TXQ_TH_DROP_Qr_CLR BCM53101_A0_FC_TXQ_TH_DROP_Qr_CLR
#define FC_TXQ_TH_DROP_Qr_SET BCM53101_A0_FC_TXQ_TH_DROP_Qr_SET
#define FC_TXQ_TH_DROP_Qr_GET BCM53101_A0_FC_TXQ_TH_DROP_Qr_GET
#define FC_TXQ_TH_DROP_Qr_TXQ_DROP_THRSf_GET BCM53101_A0_FC_TXQ_TH_DROP_Qr_TXQ_DROP_THRSf_GET
#define FC_TXQ_TH_DROP_Qr_TXQ_DROP_THRSf_SET BCM53101_A0_FC_TXQ_TH_DROP_Qr_TXQ_DROP_THRSf_SET
#define FC_TXQ_TH_DROP_Qr_RESERVEDf_GET BCM53101_A0_FC_TXQ_TH_DROP_Qr_RESERVEDf_GET
#define FC_TXQ_TH_DROP_Qr_RESERVEDf_SET BCM53101_A0_FC_TXQ_TH_DROP_Qr_RESERVEDf_SET
#define READ_FC_TXQ_TH_DROP_Qr BCM53101_A0_READ_FC_TXQ_TH_DROP_Qr
#define WRITE_FC_TXQ_TH_DROP_Qr BCM53101_A0_WRITE_FC_TXQ_TH_DROP_Qr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_TXQ_TH_DROP_Qr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_TXQ_TH_DROP_Q45
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(4~5)) Drop Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_DROP_THRS    
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_FC_TXQ_TH_DROP_Q45r 0x00000ab8

#define BCM53101_A0_FC_TXQ_TH_DROP_Q45r_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_DROP_Q45.
 *
 */
typedef union BCM53101_A0_FC_TXQ_TH_DROP_Q45r_s {
	uint32_t v[1];
	uint32_t fc_txq_th_drop_q45[1];
	uint32_t _fc_txq_th_drop_q45;
} BCM53101_A0_FC_TXQ_TH_DROP_Q45r_t;

#define BCM53101_A0_FC_TXQ_TH_DROP_Q45r_CLR(r) (r).fc_txq_th_drop_q45[0] = 0
#define BCM53101_A0_FC_TXQ_TH_DROP_Q45r_SET(r,d) (r).fc_txq_th_drop_q45[0] = d
#define BCM53101_A0_FC_TXQ_TH_DROP_Q45r_GET(r) (r).fc_txq_th_drop_q45[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_TXQ_TH_DROP_Q45r_TXQ_DROP_THRSf_GET(r) (((r).fc_txq_th_drop_q45[0]) & 0x3ff)
#define BCM53101_A0_FC_TXQ_TH_DROP_Q45r_TXQ_DROP_THRSf_SET(r,f) (r).fc_txq_th_drop_q45[0]=(((r).fc_txq_th_drop_q45[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53101_A0_FC_TXQ_TH_DROP_Q45r_RESERVEDf_GET(r) ((((r).fc_txq_th_drop_q45[0]) >> 10) & 0x3f)
#define BCM53101_A0_FC_TXQ_TH_DROP_Q45r_RESERVEDf_SET(r,f) (r).fc_txq_th_drop_q45[0]=(((r).fc_txq_th_drop_q45[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_DROP_Q45.
 *
 */
#define BCM53101_A0_READ_FC_TXQ_TH_DROP_Q45r(u,i,r) cdk_robo_reg_read(u,BCM53101_A0_FC_TXQ_TH_DROP_Q45r+(2*(i)),(r._fc_txq_th_drop_q45),2)
#define BCM53101_A0_WRITE_FC_TXQ_TH_DROP_Q45r(u,i,r) cdk_robo_reg_write(u,BCM53101_A0_FC_TXQ_TH_DROP_Q45r+(2*(i)),&(r._fc_txq_th_drop_q45),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_DROP_Q45r BCM53101_A0_FC_TXQ_TH_DROP_Q45r
#define FC_TXQ_TH_DROP_Q45r_SIZE BCM53101_A0_FC_TXQ_TH_DROP_Q45r_SIZE
typedef BCM53101_A0_FC_TXQ_TH_DROP_Q45r_t FC_TXQ_TH_DROP_Q45r_t;
#define FC_TXQ_TH_DROP_Q45r_CLR BCM53101_A0_FC_TXQ_TH_DROP_Q45r_CLR
#define FC_TXQ_TH_DROP_Q45r_SET BCM53101_A0_FC_TXQ_TH_DROP_Q45r_SET
#define FC_TXQ_TH_DROP_Q45r_GET BCM53101_A0_FC_TXQ_TH_DROP_Q45r_GET
#define FC_TXQ_TH_DROP_Q45r_TXQ_DROP_THRSf_GET BCM53101_A0_FC_TXQ_TH_DROP_Q45r_TXQ_DROP_THRSf_GET
#define FC_TXQ_TH_DROP_Q45r_TXQ_DROP_THRSf_SET BCM53101_A0_FC_TXQ_TH_DROP_Q45r_TXQ_DROP_THRSf_SET
#define FC_TXQ_TH_DROP_Q45r_RESERVEDf_GET BCM53101_A0_FC_TXQ_TH_DROP_Q45r_RESERVEDf_GET
#define FC_TXQ_TH_DROP_Q45r_RESERVEDf_SET BCM53101_A0_FC_TXQ_TH_DROP_Q45r_RESERVEDf_SET
#define READ_FC_TXQ_TH_DROP_Q45r BCM53101_A0_READ_FC_TXQ_TH_DROP_Q45r
#define WRITE_FC_TXQ_TH_DROP_Q45r BCM53101_A0_WRITE_FC_TXQ_TH_DROP_Q45r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_TXQ_TH_DROP_Q45r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_TXQ_TH_DROP_Q_IMP
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(0~3) Drop Register for IMP
 * SIZE:     16
 * FIELDS:
 *     TXQ_DROP_THRS    
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_FC_TXQ_TH_DROP_Q_IMPr 0x00000d20

#define BCM53101_A0_FC_TXQ_TH_DROP_Q_IMPr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_DROP_Q_IMP.
 *
 */
typedef union BCM53101_A0_FC_TXQ_TH_DROP_Q_IMPr_s {
	uint32_t v[1];
	uint32_t fc_txq_th_drop_q_imp[1];
	uint32_t _fc_txq_th_drop_q_imp;
} BCM53101_A0_FC_TXQ_TH_DROP_Q_IMPr_t;

#define BCM53101_A0_FC_TXQ_TH_DROP_Q_IMPr_CLR(r) (r).fc_txq_th_drop_q_imp[0] = 0
#define BCM53101_A0_FC_TXQ_TH_DROP_Q_IMPr_SET(r,d) (r).fc_txq_th_drop_q_imp[0] = d
#define BCM53101_A0_FC_TXQ_TH_DROP_Q_IMPr_GET(r) (r).fc_txq_th_drop_q_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_TXQ_TH_DROP_Q_IMPr_TXQ_DROP_THRSf_GET(r) (((r).fc_txq_th_drop_q_imp[0]) & 0x3ff)
#define BCM53101_A0_FC_TXQ_TH_DROP_Q_IMPr_TXQ_DROP_THRSf_SET(r,f) (r).fc_txq_th_drop_q_imp[0]=(((r).fc_txq_th_drop_q_imp[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53101_A0_FC_TXQ_TH_DROP_Q_IMPr_RESERVEDf_GET(r) ((((r).fc_txq_th_drop_q_imp[0]) >> 10) & 0x3f)
#define BCM53101_A0_FC_TXQ_TH_DROP_Q_IMPr_RESERVEDf_SET(r,f) (r).fc_txq_th_drop_q_imp[0]=(((r).fc_txq_th_drop_q_imp[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_DROP_Q_IMP.
 *
 */
#define BCM53101_A0_READ_FC_TXQ_TH_DROP_Q_IMPr(u,i,r) cdk_robo_reg_read(u,BCM53101_A0_FC_TXQ_TH_DROP_Q_IMPr+(2*(i)),(r._fc_txq_th_drop_q_imp),2)
#define BCM53101_A0_WRITE_FC_TXQ_TH_DROP_Q_IMPr(u,i,r) cdk_robo_reg_write(u,BCM53101_A0_FC_TXQ_TH_DROP_Q_IMPr+(2*(i)),&(r._fc_txq_th_drop_q_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_DROP_Q_IMPr BCM53101_A0_FC_TXQ_TH_DROP_Q_IMPr
#define FC_TXQ_TH_DROP_Q_IMPr_SIZE BCM53101_A0_FC_TXQ_TH_DROP_Q_IMPr_SIZE
typedef BCM53101_A0_FC_TXQ_TH_DROP_Q_IMPr_t FC_TXQ_TH_DROP_Q_IMPr_t;
#define FC_TXQ_TH_DROP_Q_IMPr_CLR BCM53101_A0_FC_TXQ_TH_DROP_Q_IMPr_CLR
#define FC_TXQ_TH_DROP_Q_IMPr_SET BCM53101_A0_FC_TXQ_TH_DROP_Q_IMPr_SET
#define FC_TXQ_TH_DROP_Q_IMPr_GET BCM53101_A0_FC_TXQ_TH_DROP_Q_IMPr_GET
#define FC_TXQ_TH_DROP_Q_IMPr_TXQ_DROP_THRSf_GET BCM53101_A0_FC_TXQ_TH_DROP_Q_IMPr_TXQ_DROP_THRSf_GET
#define FC_TXQ_TH_DROP_Q_IMPr_TXQ_DROP_THRSf_SET BCM53101_A0_FC_TXQ_TH_DROP_Q_IMPr_TXQ_DROP_THRSf_SET
#define FC_TXQ_TH_DROP_Q_IMPr_RESERVEDf_GET BCM53101_A0_FC_TXQ_TH_DROP_Q_IMPr_RESERVEDf_GET
#define FC_TXQ_TH_DROP_Q_IMPr_RESERVEDf_SET BCM53101_A0_FC_TXQ_TH_DROP_Q_IMPr_RESERVEDf_SET
#define READ_FC_TXQ_TH_DROP_Q_IMPr BCM53101_A0_READ_FC_TXQ_TH_DROP_Q_IMPr
#define WRITE_FC_TXQ_TH_DROP_Q_IMPr BCM53101_A0_WRITE_FC_TXQ_TH_DROP_Q_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_TXQ_TH_DROP_Q_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_TXQ_TH_DROP_Q_WAN
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(0~3) Drop Register for WAN
 * SIZE:     16
 * FIELDS:
 *     TXQ_DROP_THRS    
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_FC_TXQ_TH_DROP_Q_WANr 0x00000e20

#define BCM53101_A0_FC_TXQ_TH_DROP_Q_WANr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_DROP_Q_WAN.
 *
 */
typedef union BCM53101_A0_FC_TXQ_TH_DROP_Q_WANr_s {
	uint32_t v[1];
	uint32_t fc_txq_th_drop_q_wan[1];
	uint32_t _fc_txq_th_drop_q_wan;
} BCM53101_A0_FC_TXQ_TH_DROP_Q_WANr_t;

#define BCM53101_A0_FC_TXQ_TH_DROP_Q_WANr_CLR(r) (r).fc_txq_th_drop_q_wan[0] = 0
#define BCM53101_A0_FC_TXQ_TH_DROP_Q_WANr_SET(r,d) (r).fc_txq_th_drop_q_wan[0] = d
#define BCM53101_A0_FC_TXQ_TH_DROP_Q_WANr_GET(r) (r).fc_txq_th_drop_q_wan[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_TXQ_TH_DROP_Q_WANr_TXQ_DROP_THRSf_GET(r) (((r).fc_txq_th_drop_q_wan[0]) & 0x3ff)
#define BCM53101_A0_FC_TXQ_TH_DROP_Q_WANr_TXQ_DROP_THRSf_SET(r,f) (r).fc_txq_th_drop_q_wan[0]=(((r).fc_txq_th_drop_q_wan[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53101_A0_FC_TXQ_TH_DROP_Q_WANr_RESERVEDf_GET(r) ((((r).fc_txq_th_drop_q_wan[0]) >> 10) & 0x3f)
#define BCM53101_A0_FC_TXQ_TH_DROP_Q_WANr_RESERVEDf_SET(r,f) (r).fc_txq_th_drop_q_wan[0]=(((r).fc_txq_th_drop_q_wan[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_DROP_Q_WAN.
 *
 */
#define BCM53101_A0_READ_FC_TXQ_TH_DROP_Q_WANr(u,i,r) cdk_robo_reg_read(u,BCM53101_A0_FC_TXQ_TH_DROP_Q_WANr+(2*(i)),(r._fc_txq_th_drop_q_wan),2)
#define BCM53101_A0_WRITE_FC_TXQ_TH_DROP_Q_WANr(u,i,r) cdk_robo_reg_write(u,BCM53101_A0_FC_TXQ_TH_DROP_Q_WANr+(2*(i)),&(r._fc_txq_th_drop_q_wan),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_DROP_Q_WANr BCM53101_A0_FC_TXQ_TH_DROP_Q_WANr
#define FC_TXQ_TH_DROP_Q_WANr_SIZE BCM53101_A0_FC_TXQ_TH_DROP_Q_WANr_SIZE
typedef BCM53101_A0_FC_TXQ_TH_DROP_Q_WANr_t FC_TXQ_TH_DROP_Q_WANr_t;
#define FC_TXQ_TH_DROP_Q_WANr_CLR BCM53101_A0_FC_TXQ_TH_DROP_Q_WANr_CLR
#define FC_TXQ_TH_DROP_Q_WANr_SET BCM53101_A0_FC_TXQ_TH_DROP_Q_WANr_SET
#define FC_TXQ_TH_DROP_Q_WANr_GET BCM53101_A0_FC_TXQ_TH_DROP_Q_WANr_GET
#define FC_TXQ_TH_DROP_Q_WANr_TXQ_DROP_THRSf_GET BCM53101_A0_FC_TXQ_TH_DROP_Q_WANr_TXQ_DROP_THRSf_GET
#define FC_TXQ_TH_DROP_Q_WANr_TXQ_DROP_THRSf_SET BCM53101_A0_FC_TXQ_TH_DROP_Q_WANr_TXQ_DROP_THRSf_SET
#define FC_TXQ_TH_DROP_Q_WANr_RESERVEDf_GET BCM53101_A0_FC_TXQ_TH_DROP_Q_WANr_RESERVEDf_GET
#define FC_TXQ_TH_DROP_Q_WANr_RESERVEDf_SET BCM53101_A0_FC_TXQ_TH_DROP_Q_WANr_RESERVEDf_SET
#define READ_FC_TXQ_TH_DROP_Q_WANr BCM53101_A0_READ_FC_TXQ_TH_DROP_Q_WANr
#define WRITE_FC_TXQ_TH_DROP_Q_WANr BCM53101_A0_WRITE_FC_TXQ_TH_DROP_Q_WANr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_TXQ_TH_DROP_Q_WANr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_TXQ_TH_PAUSE_Q
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(0~3) Pause Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_PAUSE_THRS   
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_FC_TXQ_TH_PAUSE_Qr 0x00000a18

#define BCM53101_A0_FC_TXQ_TH_PAUSE_Qr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_PAUSE_Q.
 *
 */
typedef union BCM53101_A0_FC_TXQ_TH_PAUSE_Qr_s {
	uint32_t v[1];
	uint32_t fc_txq_th_pause_q[1];
	uint32_t _fc_txq_th_pause_q;
} BCM53101_A0_FC_TXQ_TH_PAUSE_Qr_t;

#define BCM53101_A0_FC_TXQ_TH_PAUSE_Qr_CLR(r) (r).fc_txq_th_pause_q[0] = 0
#define BCM53101_A0_FC_TXQ_TH_PAUSE_Qr_SET(r,d) (r).fc_txq_th_pause_q[0] = d
#define BCM53101_A0_FC_TXQ_TH_PAUSE_Qr_GET(r) (r).fc_txq_th_pause_q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_TXQ_TH_PAUSE_Qr_TXQ_PAUSE_THRSf_GET(r) (((r).fc_txq_th_pause_q[0]) & 0x3ff)
#define BCM53101_A0_FC_TXQ_TH_PAUSE_Qr_TXQ_PAUSE_THRSf_SET(r,f) (r).fc_txq_th_pause_q[0]=(((r).fc_txq_th_pause_q[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53101_A0_FC_TXQ_TH_PAUSE_Qr_RESERVEDf_GET(r) ((((r).fc_txq_th_pause_q[0]) >> 10) & 0x3f)
#define BCM53101_A0_FC_TXQ_TH_PAUSE_Qr_RESERVEDf_SET(r,f) (r).fc_txq_th_pause_q[0]=(((r).fc_txq_th_pause_q[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_PAUSE_Q.
 *
 */
#define BCM53101_A0_READ_FC_TXQ_TH_PAUSE_Qr(u,i,r) cdk_robo_reg_read(u,BCM53101_A0_FC_TXQ_TH_PAUSE_Qr+(2*(i)),(r._fc_txq_th_pause_q),2)
#define BCM53101_A0_WRITE_FC_TXQ_TH_PAUSE_Qr(u,i,r) cdk_robo_reg_write(u,BCM53101_A0_FC_TXQ_TH_PAUSE_Qr+(2*(i)),&(r._fc_txq_th_pause_q),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_PAUSE_Qr BCM53101_A0_FC_TXQ_TH_PAUSE_Qr
#define FC_TXQ_TH_PAUSE_Qr_SIZE BCM53101_A0_FC_TXQ_TH_PAUSE_Qr_SIZE
typedef BCM53101_A0_FC_TXQ_TH_PAUSE_Qr_t FC_TXQ_TH_PAUSE_Qr_t;
#define FC_TXQ_TH_PAUSE_Qr_CLR BCM53101_A0_FC_TXQ_TH_PAUSE_Qr_CLR
#define FC_TXQ_TH_PAUSE_Qr_SET BCM53101_A0_FC_TXQ_TH_PAUSE_Qr_SET
#define FC_TXQ_TH_PAUSE_Qr_GET BCM53101_A0_FC_TXQ_TH_PAUSE_Qr_GET
#define FC_TXQ_TH_PAUSE_Qr_TXQ_PAUSE_THRSf_GET BCM53101_A0_FC_TXQ_TH_PAUSE_Qr_TXQ_PAUSE_THRSf_GET
#define FC_TXQ_TH_PAUSE_Qr_TXQ_PAUSE_THRSf_SET BCM53101_A0_FC_TXQ_TH_PAUSE_Qr_TXQ_PAUSE_THRSf_SET
#define FC_TXQ_TH_PAUSE_Qr_RESERVEDf_GET BCM53101_A0_FC_TXQ_TH_PAUSE_Qr_RESERVEDf_GET
#define FC_TXQ_TH_PAUSE_Qr_RESERVEDf_SET BCM53101_A0_FC_TXQ_TH_PAUSE_Qr_RESERVEDf_SET
#define READ_FC_TXQ_TH_PAUSE_Qr BCM53101_A0_READ_FC_TXQ_TH_PAUSE_Qr
#define WRITE_FC_TXQ_TH_PAUSE_Qr BCM53101_A0_WRITE_FC_TXQ_TH_PAUSE_Qr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_TXQ_TH_PAUSE_Qr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_TXQ_TH_PAUSE_Q45
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(4~5)) Pause Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_PAUSE_THRS   
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_FC_TXQ_TH_PAUSE_Q45r 0x00000ab4

#define BCM53101_A0_FC_TXQ_TH_PAUSE_Q45r_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_PAUSE_Q45.
 *
 */
typedef union BCM53101_A0_FC_TXQ_TH_PAUSE_Q45r_s {
	uint32_t v[1];
	uint32_t fc_txq_th_pause_q45[1];
	uint32_t _fc_txq_th_pause_q45;
} BCM53101_A0_FC_TXQ_TH_PAUSE_Q45r_t;

#define BCM53101_A0_FC_TXQ_TH_PAUSE_Q45r_CLR(r) (r).fc_txq_th_pause_q45[0] = 0
#define BCM53101_A0_FC_TXQ_TH_PAUSE_Q45r_SET(r,d) (r).fc_txq_th_pause_q45[0] = d
#define BCM53101_A0_FC_TXQ_TH_PAUSE_Q45r_GET(r) (r).fc_txq_th_pause_q45[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_TXQ_TH_PAUSE_Q45r_TXQ_PAUSE_THRSf_GET(r) (((r).fc_txq_th_pause_q45[0]) & 0x3ff)
#define BCM53101_A0_FC_TXQ_TH_PAUSE_Q45r_TXQ_PAUSE_THRSf_SET(r,f) (r).fc_txq_th_pause_q45[0]=(((r).fc_txq_th_pause_q45[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53101_A0_FC_TXQ_TH_PAUSE_Q45r_RESERVEDf_GET(r) ((((r).fc_txq_th_pause_q45[0]) >> 10) & 0x3f)
#define BCM53101_A0_FC_TXQ_TH_PAUSE_Q45r_RESERVEDf_SET(r,f) (r).fc_txq_th_pause_q45[0]=(((r).fc_txq_th_pause_q45[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_PAUSE_Q45.
 *
 */
#define BCM53101_A0_READ_FC_TXQ_TH_PAUSE_Q45r(u,i,r) cdk_robo_reg_read(u,BCM53101_A0_FC_TXQ_TH_PAUSE_Q45r+(2*(i)),(r._fc_txq_th_pause_q45),2)
#define BCM53101_A0_WRITE_FC_TXQ_TH_PAUSE_Q45r(u,i,r) cdk_robo_reg_write(u,BCM53101_A0_FC_TXQ_TH_PAUSE_Q45r+(2*(i)),&(r._fc_txq_th_pause_q45),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_PAUSE_Q45r BCM53101_A0_FC_TXQ_TH_PAUSE_Q45r
#define FC_TXQ_TH_PAUSE_Q45r_SIZE BCM53101_A0_FC_TXQ_TH_PAUSE_Q45r_SIZE
typedef BCM53101_A0_FC_TXQ_TH_PAUSE_Q45r_t FC_TXQ_TH_PAUSE_Q45r_t;
#define FC_TXQ_TH_PAUSE_Q45r_CLR BCM53101_A0_FC_TXQ_TH_PAUSE_Q45r_CLR
#define FC_TXQ_TH_PAUSE_Q45r_SET BCM53101_A0_FC_TXQ_TH_PAUSE_Q45r_SET
#define FC_TXQ_TH_PAUSE_Q45r_GET BCM53101_A0_FC_TXQ_TH_PAUSE_Q45r_GET
#define FC_TXQ_TH_PAUSE_Q45r_TXQ_PAUSE_THRSf_GET BCM53101_A0_FC_TXQ_TH_PAUSE_Q45r_TXQ_PAUSE_THRSf_GET
#define FC_TXQ_TH_PAUSE_Q45r_TXQ_PAUSE_THRSf_SET BCM53101_A0_FC_TXQ_TH_PAUSE_Q45r_TXQ_PAUSE_THRSf_SET
#define FC_TXQ_TH_PAUSE_Q45r_RESERVEDf_GET BCM53101_A0_FC_TXQ_TH_PAUSE_Q45r_RESERVEDf_GET
#define FC_TXQ_TH_PAUSE_Q45r_RESERVEDf_SET BCM53101_A0_FC_TXQ_TH_PAUSE_Q45r_RESERVEDf_SET
#define READ_FC_TXQ_TH_PAUSE_Q45r BCM53101_A0_READ_FC_TXQ_TH_PAUSE_Q45r
#define WRITE_FC_TXQ_TH_PAUSE_Q45r BCM53101_A0_WRITE_FC_TXQ_TH_PAUSE_Q45r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_TXQ_TH_PAUSE_Q45r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_TXQ_TH_PAUSE_Q_IMP
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(0~3) Pause Register for IMP
 * SIZE:     16
 * FIELDS:
 *     TXQ_PAUSE_THRS   
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_FC_TXQ_TH_PAUSE_Q_IMPr 0x00000d18

#define BCM53101_A0_FC_TXQ_TH_PAUSE_Q_IMPr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_PAUSE_Q_IMP.
 *
 */
typedef union BCM53101_A0_FC_TXQ_TH_PAUSE_Q_IMPr_s {
	uint32_t v[1];
	uint32_t fc_txq_th_pause_q_imp[1];
	uint32_t _fc_txq_th_pause_q_imp;
} BCM53101_A0_FC_TXQ_TH_PAUSE_Q_IMPr_t;

#define BCM53101_A0_FC_TXQ_TH_PAUSE_Q_IMPr_CLR(r) (r).fc_txq_th_pause_q_imp[0] = 0
#define BCM53101_A0_FC_TXQ_TH_PAUSE_Q_IMPr_SET(r,d) (r).fc_txq_th_pause_q_imp[0] = d
#define BCM53101_A0_FC_TXQ_TH_PAUSE_Q_IMPr_GET(r) (r).fc_txq_th_pause_q_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_TXQ_TH_PAUSE_Q_IMPr_TXQ_PAUSE_THRSf_GET(r) (((r).fc_txq_th_pause_q_imp[0]) & 0x3ff)
#define BCM53101_A0_FC_TXQ_TH_PAUSE_Q_IMPr_TXQ_PAUSE_THRSf_SET(r,f) (r).fc_txq_th_pause_q_imp[0]=(((r).fc_txq_th_pause_q_imp[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53101_A0_FC_TXQ_TH_PAUSE_Q_IMPr_RESERVEDf_GET(r) ((((r).fc_txq_th_pause_q_imp[0]) >> 10) & 0x3f)
#define BCM53101_A0_FC_TXQ_TH_PAUSE_Q_IMPr_RESERVEDf_SET(r,f) (r).fc_txq_th_pause_q_imp[0]=(((r).fc_txq_th_pause_q_imp[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_PAUSE_Q_IMP.
 *
 */
#define BCM53101_A0_READ_FC_TXQ_TH_PAUSE_Q_IMPr(u,i,r) cdk_robo_reg_read(u,BCM53101_A0_FC_TXQ_TH_PAUSE_Q_IMPr+(2*(i)),(r._fc_txq_th_pause_q_imp),2)
#define BCM53101_A0_WRITE_FC_TXQ_TH_PAUSE_Q_IMPr(u,i,r) cdk_robo_reg_write(u,BCM53101_A0_FC_TXQ_TH_PAUSE_Q_IMPr+(2*(i)),&(r._fc_txq_th_pause_q_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_PAUSE_Q_IMPr BCM53101_A0_FC_TXQ_TH_PAUSE_Q_IMPr
#define FC_TXQ_TH_PAUSE_Q_IMPr_SIZE BCM53101_A0_FC_TXQ_TH_PAUSE_Q_IMPr_SIZE
typedef BCM53101_A0_FC_TXQ_TH_PAUSE_Q_IMPr_t FC_TXQ_TH_PAUSE_Q_IMPr_t;
#define FC_TXQ_TH_PAUSE_Q_IMPr_CLR BCM53101_A0_FC_TXQ_TH_PAUSE_Q_IMPr_CLR
#define FC_TXQ_TH_PAUSE_Q_IMPr_SET BCM53101_A0_FC_TXQ_TH_PAUSE_Q_IMPr_SET
#define FC_TXQ_TH_PAUSE_Q_IMPr_GET BCM53101_A0_FC_TXQ_TH_PAUSE_Q_IMPr_GET
#define FC_TXQ_TH_PAUSE_Q_IMPr_TXQ_PAUSE_THRSf_GET BCM53101_A0_FC_TXQ_TH_PAUSE_Q_IMPr_TXQ_PAUSE_THRSf_GET
#define FC_TXQ_TH_PAUSE_Q_IMPr_TXQ_PAUSE_THRSf_SET BCM53101_A0_FC_TXQ_TH_PAUSE_Q_IMPr_TXQ_PAUSE_THRSf_SET
#define FC_TXQ_TH_PAUSE_Q_IMPr_RESERVEDf_GET BCM53101_A0_FC_TXQ_TH_PAUSE_Q_IMPr_RESERVEDf_GET
#define FC_TXQ_TH_PAUSE_Q_IMPr_RESERVEDf_SET BCM53101_A0_FC_TXQ_TH_PAUSE_Q_IMPr_RESERVEDf_SET
#define READ_FC_TXQ_TH_PAUSE_Q_IMPr BCM53101_A0_READ_FC_TXQ_TH_PAUSE_Q_IMPr
#define WRITE_FC_TXQ_TH_PAUSE_Q_IMPr BCM53101_A0_WRITE_FC_TXQ_TH_PAUSE_Q_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_TXQ_TH_PAUSE_Q_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_TXQ_TH_PAUSE_Q_WAN
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(0~3) Pause Register for WAN
 * SIZE:     16
 * FIELDS:
 *     TXQ_PAUSE_THRS   
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_FC_TXQ_TH_PAUSE_Q_WANr 0x00000e18

#define BCM53101_A0_FC_TXQ_TH_PAUSE_Q_WANr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_PAUSE_Q_WAN.
 *
 */
typedef union BCM53101_A0_FC_TXQ_TH_PAUSE_Q_WANr_s {
	uint32_t v[1];
	uint32_t fc_txq_th_pause_q_wan[1];
	uint32_t _fc_txq_th_pause_q_wan;
} BCM53101_A0_FC_TXQ_TH_PAUSE_Q_WANr_t;

#define BCM53101_A0_FC_TXQ_TH_PAUSE_Q_WANr_CLR(r) (r).fc_txq_th_pause_q_wan[0] = 0
#define BCM53101_A0_FC_TXQ_TH_PAUSE_Q_WANr_SET(r,d) (r).fc_txq_th_pause_q_wan[0] = d
#define BCM53101_A0_FC_TXQ_TH_PAUSE_Q_WANr_GET(r) (r).fc_txq_th_pause_q_wan[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_TXQ_TH_PAUSE_Q_WANr_TXQ_PAUSE_THRSf_GET(r) (((r).fc_txq_th_pause_q_wan[0]) & 0x3ff)
#define BCM53101_A0_FC_TXQ_TH_PAUSE_Q_WANr_TXQ_PAUSE_THRSf_SET(r,f) (r).fc_txq_th_pause_q_wan[0]=(((r).fc_txq_th_pause_q_wan[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53101_A0_FC_TXQ_TH_PAUSE_Q_WANr_RESERVEDf_GET(r) ((((r).fc_txq_th_pause_q_wan[0]) >> 10) & 0x3f)
#define BCM53101_A0_FC_TXQ_TH_PAUSE_Q_WANr_RESERVEDf_SET(r,f) (r).fc_txq_th_pause_q_wan[0]=(((r).fc_txq_th_pause_q_wan[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_PAUSE_Q_WAN.
 *
 */
#define BCM53101_A0_READ_FC_TXQ_TH_PAUSE_Q_WANr(u,i,r) cdk_robo_reg_read(u,BCM53101_A0_FC_TXQ_TH_PAUSE_Q_WANr+(2*(i)),(r._fc_txq_th_pause_q_wan),2)
#define BCM53101_A0_WRITE_FC_TXQ_TH_PAUSE_Q_WANr(u,i,r) cdk_robo_reg_write(u,BCM53101_A0_FC_TXQ_TH_PAUSE_Q_WANr+(2*(i)),&(r._fc_txq_th_pause_q_wan),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_PAUSE_Q_WANr BCM53101_A0_FC_TXQ_TH_PAUSE_Q_WANr
#define FC_TXQ_TH_PAUSE_Q_WANr_SIZE BCM53101_A0_FC_TXQ_TH_PAUSE_Q_WANr_SIZE
typedef BCM53101_A0_FC_TXQ_TH_PAUSE_Q_WANr_t FC_TXQ_TH_PAUSE_Q_WANr_t;
#define FC_TXQ_TH_PAUSE_Q_WANr_CLR BCM53101_A0_FC_TXQ_TH_PAUSE_Q_WANr_CLR
#define FC_TXQ_TH_PAUSE_Q_WANr_SET BCM53101_A0_FC_TXQ_TH_PAUSE_Q_WANr_SET
#define FC_TXQ_TH_PAUSE_Q_WANr_GET BCM53101_A0_FC_TXQ_TH_PAUSE_Q_WANr_GET
#define FC_TXQ_TH_PAUSE_Q_WANr_TXQ_PAUSE_THRSf_GET BCM53101_A0_FC_TXQ_TH_PAUSE_Q_WANr_TXQ_PAUSE_THRSf_GET
#define FC_TXQ_TH_PAUSE_Q_WANr_TXQ_PAUSE_THRSf_SET BCM53101_A0_FC_TXQ_TH_PAUSE_Q_WANr_TXQ_PAUSE_THRSf_SET
#define FC_TXQ_TH_PAUSE_Q_WANr_RESERVEDf_GET BCM53101_A0_FC_TXQ_TH_PAUSE_Q_WANr_RESERVEDf_GET
#define FC_TXQ_TH_PAUSE_Q_WANr_RESERVEDf_SET BCM53101_A0_FC_TXQ_TH_PAUSE_Q_WANr_RESERVEDf_SET
#define READ_FC_TXQ_TH_PAUSE_Q_WANr BCM53101_A0_READ_FC_TXQ_TH_PAUSE_Q_WANr
#define WRITE_FC_TXQ_TH_PAUSE_Q_WANr BCM53101_A0_WRITE_FC_TXQ_TH_PAUSE_Q_WANr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_TXQ_TH_PAUSE_Q_WANr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_TXQ_TH_RSRV_Q
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(0~3) Hysteresis Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_HYST_THRS    
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_FC_TXQ_TH_RSRV_Qr 0x00000a10

#define BCM53101_A0_FC_TXQ_TH_RSRV_Qr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_RSRV_Q.
 *
 */
typedef union BCM53101_A0_FC_TXQ_TH_RSRV_Qr_s {
	uint32_t v[1];
	uint32_t fc_txq_th_rsrv_q[1];
	uint32_t _fc_txq_th_rsrv_q;
} BCM53101_A0_FC_TXQ_TH_RSRV_Qr_t;

#define BCM53101_A0_FC_TXQ_TH_RSRV_Qr_CLR(r) (r).fc_txq_th_rsrv_q[0] = 0
#define BCM53101_A0_FC_TXQ_TH_RSRV_Qr_SET(r,d) (r).fc_txq_th_rsrv_q[0] = d
#define BCM53101_A0_FC_TXQ_TH_RSRV_Qr_GET(r) (r).fc_txq_th_rsrv_q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_TXQ_TH_RSRV_Qr_TXQ_HYST_THRSf_GET(r) (((r).fc_txq_th_rsrv_q[0]) & 0x3ff)
#define BCM53101_A0_FC_TXQ_TH_RSRV_Qr_TXQ_HYST_THRSf_SET(r,f) (r).fc_txq_th_rsrv_q[0]=(((r).fc_txq_th_rsrv_q[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53101_A0_FC_TXQ_TH_RSRV_Qr_RESERVED_1f_GET(r) ((((r).fc_txq_th_rsrv_q[0]) >> 10) & 0x3f)
#define BCM53101_A0_FC_TXQ_TH_RSRV_Qr_RESERVED_1f_SET(r,f) (r).fc_txq_th_rsrv_q[0]=(((r).fc_txq_th_rsrv_q[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_RSRV_Q.
 *
 */
#define BCM53101_A0_READ_FC_TXQ_TH_RSRV_Qr(u,i,r) cdk_robo_reg_read(u,BCM53101_A0_FC_TXQ_TH_RSRV_Qr+(2*(i)),(r._fc_txq_th_rsrv_q),2)
#define BCM53101_A0_WRITE_FC_TXQ_TH_RSRV_Qr(u,i,r) cdk_robo_reg_write(u,BCM53101_A0_FC_TXQ_TH_RSRV_Qr+(2*(i)),&(r._fc_txq_th_rsrv_q),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_RSRV_Qr BCM53101_A0_FC_TXQ_TH_RSRV_Qr
#define FC_TXQ_TH_RSRV_Qr_SIZE BCM53101_A0_FC_TXQ_TH_RSRV_Qr_SIZE
typedef BCM53101_A0_FC_TXQ_TH_RSRV_Qr_t FC_TXQ_TH_RSRV_Qr_t;
#define FC_TXQ_TH_RSRV_Qr_CLR BCM53101_A0_FC_TXQ_TH_RSRV_Qr_CLR
#define FC_TXQ_TH_RSRV_Qr_SET BCM53101_A0_FC_TXQ_TH_RSRV_Qr_SET
#define FC_TXQ_TH_RSRV_Qr_GET BCM53101_A0_FC_TXQ_TH_RSRV_Qr_GET
#define FC_TXQ_TH_RSRV_Qr_TXQ_HYST_THRSf_GET BCM53101_A0_FC_TXQ_TH_RSRV_Qr_TXQ_HYST_THRSf_GET
#define FC_TXQ_TH_RSRV_Qr_TXQ_HYST_THRSf_SET BCM53101_A0_FC_TXQ_TH_RSRV_Qr_TXQ_HYST_THRSf_SET
#define FC_TXQ_TH_RSRV_Qr_RESERVED_1f_GET BCM53101_A0_FC_TXQ_TH_RSRV_Qr_RESERVED_1f_GET
#define FC_TXQ_TH_RSRV_Qr_RESERVED_1f_SET BCM53101_A0_FC_TXQ_TH_RSRV_Qr_RESERVED_1f_SET
#define READ_FC_TXQ_TH_RSRV_Qr BCM53101_A0_READ_FC_TXQ_TH_RSRV_Qr
#define WRITE_FC_TXQ_TH_RSRV_Qr BCM53101_A0_WRITE_FC_TXQ_TH_RSRV_Qr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_TXQ_TH_RSRV_Qr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_TXQ_TH_RSRV_Q45
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(4~5)) Hysteresis Register
 * SIZE:     16
 * FIELDS:
 *     TXQ_HYST_THRS    
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_FC_TXQ_TH_RSRV_Q45r 0x00000ab0

#define BCM53101_A0_FC_TXQ_TH_RSRV_Q45r_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_RSRV_Q45.
 *
 */
typedef union BCM53101_A0_FC_TXQ_TH_RSRV_Q45r_s {
	uint32_t v[1];
	uint32_t fc_txq_th_rsrv_q45[1];
	uint32_t _fc_txq_th_rsrv_q45;
} BCM53101_A0_FC_TXQ_TH_RSRV_Q45r_t;

#define BCM53101_A0_FC_TXQ_TH_RSRV_Q45r_CLR(r) (r).fc_txq_th_rsrv_q45[0] = 0
#define BCM53101_A0_FC_TXQ_TH_RSRV_Q45r_SET(r,d) (r).fc_txq_th_rsrv_q45[0] = d
#define BCM53101_A0_FC_TXQ_TH_RSRV_Q45r_GET(r) (r).fc_txq_th_rsrv_q45[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_TXQ_TH_RSRV_Q45r_TXQ_HYST_THRSf_GET(r) (((r).fc_txq_th_rsrv_q45[0]) & 0x3ff)
#define BCM53101_A0_FC_TXQ_TH_RSRV_Q45r_TXQ_HYST_THRSf_SET(r,f) (r).fc_txq_th_rsrv_q45[0]=(((r).fc_txq_th_rsrv_q45[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53101_A0_FC_TXQ_TH_RSRV_Q45r_RESERVED_1f_GET(r) ((((r).fc_txq_th_rsrv_q45[0]) >> 10) & 0x3f)
#define BCM53101_A0_FC_TXQ_TH_RSRV_Q45r_RESERVED_1f_SET(r,f) (r).fc_txq_th_rsrv_q45[0]=(((r).fc_txq_th_rsrv_q45[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_RSRV_Q45.
 *
 */
#define BCM53101_A0_READ_FC_TXQ_TH_RSRV_Q45r(u,i,r) cdk_robo_reg_read(u,BCM53101_A0_FC_TXQ_TH_RSRV_Q45r+(2*(i)),(r._fc_txq_th_rsrv_q45),2)
#define BCM53101_A0_WRITE_FC_TXQ_TH_RSRV_Q45r(u,i,r) cdk_robo_reg_write(u,BCM53101_A0_FC_TXQ_TH_RSRV_Q45r+(2*(i)),&(r._fc_txq_th_rsrv_q45),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_RSRV_Q45r BCM53101_A0_FC_TXQ_TH_RSRV_Q45r
#define FC_TXQ_TH_RSRV_Q45r_SIZE BCM53101_A0_FC_TXQ_TH_RSRV_Q45r_SIZE
typedef BCM53101_A0_FC_TXQ_TH_RSRV_Q45r_t FC_TXQ_TH_RSRV_Q45r_t;
#define FC_TXQ_TH_RSRV_Q45r_CLR BCM53101_A0_FC_TXQ_TH_RSRV_Q45r_CLR
#define FC_TXQ_TH_RSRV_Q45r_SET BCM53101_A0_FC_TXQ_TH_RSRV_Q45r_SET
#define FC_TXQ_TH_RSRV_Q45r_GET BCM53101_A0_FC_TXQ_TH_RSRV_Q45r_GET
#define FC_TXQ_TH_RSRV_Q45r_TXQ_HYST_THRSf_GET BCM53101_A0_FC_TXQ_TH_RSRV_Q45r_TXQ_HYST_THRSf_GET
#define FC_TXQ_TH_RSRV_Q45r_TXQ_HYST_THRSf_SET BCM53101_A0_FC_TXQ_TH_RSRV_Q45r_TXQ_HYST_THRSf_SET
#define FC_TXQ_TH_RSRV_Q45r_RESERVED_1f_GET BCM53101_A0_FC_TXQ_TH_RSRV_Q45r_RESERVED_1f_GET
#define FC_TXQ_TH_RSRV_Q45r_RESERVED_1f_SET BCM53101_A0_FC_TXQ_TH_RSRV_Q45r_RESERVED_1f_SET
#define READ_FC_TXQ_TH_RSRV_Q45r BCM53101_A0_READ_FC_TXQ_TH_RSRV_Q45r
#define WRITE_FC_TXQ_TH_RSRV_Q45r BCM53101_A0_WRITE_FC_TXQ_TH_RSRV_Q45r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_TXQ_TH_RSRV_Q45r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_TXQ_TH_RSRV_Q_IMP
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(0~3) Hysteresis Register for IMP
 * SIZE:     16
 * FIELDS:
 *     TXQ_HYST_THRS    
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_FC_TXQ_TH_RSRV_Q_IMPr 0x00000d10

#define BCM53101_A0_FC_TXQ_TH_RSRV_Q_IMPr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_RSRV_Q_IMP.
 *
 */
typedef union BCM53101_A0_FC_TXQ_TH_RSRV_Q_IMPr_s {
	uint32_t v[1];
	uint32_t fc_txq_th_rsrv_q_imp[1];
	uint32_t _fc_txq_th_rsrv_q_imp;
} BCM53101_A0_FC_TXQ_TH_RSRV_Q_IMPr_t;

#define BCM53101_A0_FC_TXQ_TH_RSRV_Q_IMPr_CLR(r) (r).fc_txq_th_rsrv_q_imp[0] = 0
#define BCM53101_A0_FC_TXQ_TH_RSRV_Q_IMPr_SET(r,d) (r).fc_txq_th_rsrv_q_imp[0] = d
#define BCM53101_A0_FC_TXQ_TH_RSRV_Q_IMPr_GET(r) (r).fc_txq_th_rsrv_q_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_TXQ_TH_RSRV_Q_IMPr_TXQ_HYST_THRSf_GET(r) (((r).fc_txq_th_rsrv_q_imp[0]) & 0x3ff)
#define BCM53101_A0_FC_TXQ_TH_RSRV_Q_IMPr_TXQ_HYST_THRSf_SET(r,f) (r).fc_txq_th_rsrv_q_imp[0]=(((r).fc_txq_th_rsrv_q_imp[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53101_A0_FC_TXQ_TH_RSRV_Q_IMPr_RESERVED_1f_GET(r) ((((r).fc_txq_th_rsrv_q_imp[0]) >> 10) & 0x3f)
#define BCM53101_A0_FC_TXQ_TH_RSRV_Q_IMPr_RESERVED_1f_SET(r,f) (r).fc_txq_th_rsrv_q_imp[0]=(((r).fc_txq_th_rsrv_q_imp[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_RSRV_Q_IMP.
 *
 */
#define BCM53101_A0_READ_FC_TXQ_TH_RSRV_Q_IMPr(u,i,r) cdk_robo_reg_read(u,BCM53101_A0_FC_TXQ_TH_RSRV_Q_IMPr+(2*(i)),(r._fc_txq_th_rsrv_q_imp),2)
#define BCM53101_A0_WRITE_FC_TXQ_TH_RSRV_Q_IMPr(u,i,r) cdk_robo_reg_write(u,BCM53101_A0_FC_TXQ_TH_RSRV_Q_IMPr+(2*(i)),&(r._fc_txq_th_rsrv_q_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_RSRV_Q_IMPr BCM53101_A0_FC_TXQ_TH_RSRV_Q_IMPr
#define FC_TXQ_TH_RSRV_Q_IMPr_SIZE BCM53101_A0_FC_TXQ_TH_RSRV_Q_IMPr_SIZE
typedef BCM53101_A0_FC_TXQ_TH_RSRV_Q_IMPr_t FC_TXQ_TH_RSRV_Q_IMPr_t;
#define FC_TXQ_TH_RSRV_Q_IMPr_CLR BCM53101_A0_FC_TXQ_TH_RSRV_Q_IMPr_CLR
#define FC_TXQ_TH_RSRV_Q_IMPr_SET BCM53101_A0_FC_TXQ_TH_RSRV_Q_IMPr_SET
#define FC_TXQ_TH_RSRV_Q_IMPr_GET BCM53101_A0_FC_TXQ_TH_RSRV_Q_IMPr_GET
#define FC_TXQ_TH_RSRV_Q_IMPr_TXQ_HYST_THRSf_GET BCM53101_A0_FC_TXQ_TH_RSRV_Q_IMPr_TXQ_HYST_THRSf_GET
#define FC_TXQ_TH_RSRV_Q_IMPr_TXQ_HYST_THRSf_SET BCM53101_A0_FC_TXQ_TH_RSRV_Q_IMPr_TXQ_HYST_THRSf_SET
#define FC_TXQ_TH_RSRV_Q_IMPr_RESERVED_1f_GET BCM53101_A0_FC_TXQ_TH_RSRV_Q_IMPr_RESERVED_1f_GET
#define FC_TXQ_TH_RSRV_Q_IMPr_RESERVED_1f_SET BCM53101_A0_FC_TXQ_TH_RSRV_Q_IMPr_RESERVED_1f_SET
#define READ_FC_TXQ_TH_RSRV_Q_IMPr BCM53101_A0_READ_FC_TXQ_TH_RSRV_Q_IMPr
#define WRITE_FC_TXQ_TH_RSRV_Q_IMPr BCM53101_A0_WRITE_FC_TXQ_TH_RSRV_Q_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_TXQ_TH_RSRV_Q_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  FC_TXQ_TH_RSRV_Q_WAN
 * BLOCKS:   SYS
 * DESC:     Priority Queue N(0~3) Hysteresis Register for WAN
 * SIZE:     16
 * FIELDS:
 *     TXQ_HYST_THRS    
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_FC_TXQ_TH_RSRV_Q_WANr 0x00000e10

#define BCM53101_A0_FC_TXQ_TH_RSRV_Q_WANr_SIZE 2

/*
 * This structure should be used to declare and program FC_TXQ_TH_RSRV_Q_WAN.
 *
 */
typedef union BCM53101_A0_FC_TXQ_TH_RSRV_Q_WANr_s {
	uint32_t v[1];
	uint32_t fc_txq_th_rsrv_q_wan[1];
	uint32_t _fc_txq_th_rsrv_q_wan;
} BCM53101_A0_FC_TXQ_TH_RSRV_Q_WANr_t;

#define BCM53101_A0_FC_TXQ_TH_RSRV_Q_WANr_CLR(r) (r).fc_txq_th_rsrv_q_wan[0] = 0
#define BCM53101_A0_FC_TXQ_TH_RSRV_Q_WANr_SET(r,d) (r).fc_txq_th_rsrv_q_wan[0] = d
#define BCM53101_A0_FC_TXQ_TH_RSRV_Q_WANr_GET(r) (r).fc_txq_th_rsrv_q_wan[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FC_TXQ_TH_RSRV_Q_WANr_TXQ_HYST_THRSf_GET(r) (((r).fc_txq_th_rsrv_q_wan[0]) & 0x3ff)
#define BCM53101_A0_FC_TXQ_TH_RSRV_Q_WANr_TXQ_HYST_THRSf_SET(r,f) (r).fc_txq_th_rsrv_q_wan[0]=(((r).fc_txq_th_rsrv_q_wan[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53101_A0_FC_TXQ_TH_RSRV_Q_WANr_RESERVED_1f_GET(r) ((((r).fc_txq_th_rsrv_q_wan[0]) >> 10) & 0x3f)
#define BCM53101_A0_FC_TXQ_TH_RSRV_Q_WANr_RESERVED_1f_SET(r,f) (r).fc_txq_th_rsrv_q_wan[0]=(((r).fc_txq_th_rsrv_q_wan[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access FC_TXQ_TH_RSRV_Q_WAN.
 *
 */
#define BCM53101_A0_READ_FC_TXQ_TH_RSRV_Q_WANr(u,i,r) cdk_robo_reg_read(u,BCM53101_A0_FC_TXQ_TH_RSRV_Q_WANr+(2*(i)),(r._fc_txq_th_rsrv_q_wan),2)
#define BCM53101_A0_WRITE_FC_TXQ_TH_RSRV_Q_WANr(u,i,r) cdk_robo_reg_write(u,BCM53101_A0_FC_TXQ_TH_RSRV_Q_WANr+(2*(i)),&(r._fc_txq_th_rsrv_q_wan),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FC_TXQ_TH_RSRV_Q_WANr BCM53101_A0_FC_TXQ_TH_RSRV_Q_WANr
#define FC_TXQ_TH_RSRV_Q_WANr_SIZE BCM53101_A0_FC_TXQ_TH_RSRV_Q_WANr_SIZE
typedef BCM53101_A0_FC_TXQ_TH_RSRV_Q_WANr_t FC_TXQ_TH_RSRV_Q_WANr_t;
#define FC_TXQ_TH_RSRV_Q_WANr_CLR BCM53101_A0_FC_TXQ_TH_RSRV_Q_WANr_CLR
#define FC_TXQ_TH_RSRV_Q_WANr_SET BCM53101_A0_FC_TXQ_TH_RSRV_Q_WANr_SET
#define FC_TXQ_TH_RSRV_Q_WANr_GET BCM53101_A0_FC_TXQ_TH_RSRV_Q_WANr_GET
#define FC_TXQ_TH_RSRV_Q_WANr_TXQ_HYST_THRSf_GET BCM53101_A0_FC_TXQ_TH_RSRV_Q_WANr_TXQ_HYST_THRSf_GET
#define FC_TXQ_TH_RSRV_Q_WANr_TXQ_HYST_THRSf_SET BCM53101_A0_FC_TXQ_TH_RSRV_Q_WANr_TXQ_HYST_THRSf_SET
#define FC_TXQ_TH_RSRV_Q_WANr_RESERVED_1f_GET BCM53101_A0_FC_TXQ_TH_RSRV_Q_WANr_RESERVED_1f_GET
#define FC_TXQ_TH_RSRV_Q_WANr_RESERVED_1f_SET BCM53101_A0_FC_TXQ_TH_RSRV_Q_WANr_RESERVED_1f_SET
#define READ_FC_TXQ_TH_RSRV_Q_WANr BCM53101_A0_READ_FC_TXQ_TH_RSRV_Q_WANr
#define WRITE_FC_TXQ_TH_RSRV_Q_WANr BCM53101_A0_WRITE_FC_TXQ_TH_RSRV_Q_WANr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FC_TXQ_TH_RSRV_Q_WANr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * MEMORY:  FRAME_BUF
 * BLOCKS:   SYS
 * DESC:     Frame Buffer Memory
 * SIZE:     64
 * FIELDS:
 *     GENMEM_DATA      RAM data entry
 *
 ******************************************************************************/
#define BCM53101_A0_FRAME_BUFm 0x00000000

#define BCM53101_A0_FRAME_BUFm_MIN 0
#define BCM53101_A0_FRAME_BUFm_MAX 4095
#define BCM53101_A0_FRAME_BUFm_CMAX(u) 4095
#define BCM53101_A0_FRAME_BUFm_SIZE 8

/*
 * This structure should be used to declare and program FRAME_BUF.
 *
 */
typedef union BCM53101_A0_FRAME_BUFm_s {
	uint32_t v[2];
	uint32_t frame_buf[2];
	uint32_t _frame_buf;
} BCM53101_A0_FRAME_BUFm_t;

#define BCM53101_A0_FRAME_BUFm_CLR(r) CDK_MEMSET(&((r)._frame_buf), 0, sizeof(BCM53101_A0_FRAME_BUFm_t))
#define BCM53101_A0_FRAME_BUFm_SET(r,i,d) (r).frame_buf[i] = d
#define BCM53101_A0_FRAME_BUFm_GET(r,i) (r).frame_buf[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_FRAME_BUFm_GENMEM_DATAf_GET(r,a) cdk_field_get((r).frame_buf,0,63,a)
#define BCM53101_A0_FRAME_BUFm_GENMEM_DATAf_SET(r,a) cdk_field_set((r).frame_buf,0,63,a)

/*
 * These macros can be used to access FRAME_BUF.
 *
 */
#define BCM53101_A0_READ_FRAME_BUFm(u,i,m) cdk_robo_mem_read(u,BCM53101_A0_FRAME_BUFm,i,(m),8)
#define BCM53101_A0_WRITE_FRAME_BUFm(u,i,m) cdk_robo_mem_write(u,BCM53101_A0_FRAME_BUFm,i,&(m),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define FRAME_BUFm BCM53101_A0_FRAME_BUFm
#define FRAME_BUFm_MIN BCM53101_A0_FRAME_BUFm_MIN
#define FRAME_BUFm_MAX BCM53101_A0_FRAME_BUFm_MAX
#define FRAME_BUFm_CMAX(u) BCM53101_A0_FRAME_BUFm_CMAX(u)
#define FRAME_BUFm_SIZE BCM53101_A0_FRAME_BUFm_SIZE
typedef BCM53101_A0_FRAME_BUFm_t FRAME_BUFm_t;
#define FRAME_BUFm_CLR BCM53101_A0_FRAME_BUFm_CLR
#define FRAME_BUFm_SET BCM53101_A0_FRAME_BUFm_SET
#define FRAME_BUFm_GET BCM53101_A0_FRAME_BUFm_GET
#define FRAME_BUFm_GENMEM_DATAf_GET BCM53101_A0_FRAME_BUFm_GENMEM_DATAf_GET
#define FRAME_BUFm_GENMEM_DATAf_SET BCM53101_A0_FRAME_BUFm_GENMEM_DATAf_SET
#define READ_FRAME_BUFm BCM53101_A0_READ_FRAME_BUFm
#define WRITE_FRAME_BUFm BCM53101_A0_WRITE_FRAME_BUFm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_FRAME_BUFm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  GARLCFG
 * BLOCKS:   SYS
 * DESC:     Global ARL Configuration Register
 * SIZE:     8
 * FIELDS:
 *     HASH_DISABLE     Disable The hash function for the ARL such that entries are direct mapped to the table. The hash function is enabled as the default for the Lotus ARL,but can be disabled by setting this bit.
 *     RESERVED_0       Reserved
 *     AGE_ACC          Age Accele rate, test only.1: accelerate 128 times for age process.0: Keep original age process.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_GARLCFGr 0x00000400

#define BCM53101_A0_GARLCFGr_SIZE 1

/*
 * This structure should be used to declare and program GARLCFG.
 *
 */
typedef union BCM53101_A0_GARLCFGr_s {
	uint32_t v[1];
	uint32_t garlcfg[1];
	uint32_t _garlcfg;
} BCM53101_A0_GARLCFGr_t;

#define BCM53101_A0_GARLCFGr_CLR(r) (r).garlcfg[0] = 0
#define BCM53101_A0_GARLCFGr_SET(r,d) (r).garlcfg[0] = d
#define BCM53101_A0_GARLCFGr_GET(r) (r).garlcfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_GARLCFGr_HASH_DISABLEf_GET(r) (((r).garlcfg[0]) & 0x1)
#define BCM53101_A0_GARLCFGr_HASH_DISABLEf_SET(r,f) (r).garlcfg[0]=(((r).garlcfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_GARLCFGr_RESERVED_0f_GET(r) ((((r).garlcfg[0]) >> 1) & 0x1)
#define BCM53101_A0_GARLCFGr_RESERVED_0f_SET(r,f) (r).garlcfg[0]=(((r).garlcfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_GARLCFGr_AGE_ACCf_GET(r) ((((r).garlcfg[0]) >> 2) & 0x1)
#define BCM53101_A0_GARLCFGr_AGE_ACCf_SET(r,f) (r).garlcfg[0]=(((r).garlcfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_GARLCFGr_RESERVED_1f_GET(r) ((((r).garlcfg[0]) >> 3) & 0x1f)
#define BCM53101_A0_GARLCFGr_RESERVED_1f_SET(r,f) (r).garlcfg[0]=(((r).garlcfg[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3))

/*
 * These macros can be used to access GARLCFG.
 *
 */
#define BCM53101_A0_READ_GARLCFGr(u,r) cdk_robo_reg_read(u,BCM53101_A0_GARLCFGr,(r._garlcfg),1)
#define BCM53101_A0_WRITE_GARLCFGr(u,r) cdk_robo_reg_write(u,BCM53101_A0_GARLCFGr,&(r._garlcfg),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GARLCFGr BCM53101_A0_GARLCFGr
#define GARLCFGr_SIZE BCM53101_A0_GARLCFGr_SIZE
typedef BCM53101_A0_GARLCFGr_t GARLCFGr_t;
#define GARLCFGr_CLR BCM53101_A0_GARLCFGr_CLR
#define GARLCFGr_SET BCM53101_A0_GARLCFGr_SET
#define GARLCFGr_GET BCM53101_A0_GARLCFGr_GET
#define GARLCFGr_HASH_DISABLEf_GET BCM53101_A0_GARLCFGr_HASH_DISABLEf_GET
#define GARLCFGr_HASH_DISABLEf_SET BCM53101_A0_GARLCFGr_HASH_DISABLEf_SET
#define GARLCFGr_RESERVED_0f_GET BCM53101_A0_GARLCFGr_RESERVED_0f_GET
#define GARLCFGr_RESERVED_0f_SET BCM53101_A0_GARLCFGr_RESERVED_0f_SET
#define GARLCFGr_AGE_ACCf_GET BCM53101_A0_GARLCFGr_AGE_ACCf_GET
#define GARLCFGr_AGE_ACCf_SET BCM53101_A0_GARLCFGr_AGE_ACCf_SET
#define GARLCFGr_RESERVED_1f_GET BCM53101_A0_GARLCFGr_RESERVED_1f_GET
#define GARLCFGr_RESERVED_1f_SET BCM53101_A0_GARLCFGr_RESERVED_1f_SET
#define READ_GARLCFGr BCM53101_A0_READ_GARLCFGr
#define WRITE_GARLCFGr BCM53101_A0_WRITE_GARLCFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_GARLCFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  GMNGCFG
 * BLOCKS:   SYS
 * DESC:     Global Management Configuration Register
 * SIZE:     8
 * FIELDS:
 *     RST_MIB_CNT      Reset MIB CountersResets all MIB counters for all ports to zero (Pages 20h-28h). The host must set the bit and then clear the bit in successive write cycles to activate the reset operation.
 *     RXBPDU_EN        Receive BPDU Enable.Enables all ports to receive BPDUs and forward to the defined Physical Management Port. Management CPU must set this bit to globally allow BPDUs to be received.
 *     RESERVED_0       Reserved
 *     INT_EN           0: disable link status change interrupt1: enable link status change interrupt
 *     RESERVED_1       Reserved
 *     FRM_MNGP         IMP Port EnableThis field enables the IMP(In-band Management Port) function under manabement mode.00=No IMP Port01=Reserved10=Enable IMP Port(IMP0) only   All traffic to CPU from LAN ports and WAN ports will be forwarded to IMP0.11=Enable Dual-IMP ports(both IMP0 and IMP1)   All traffic to CPU from LAN ports and WAN ports will be forwarded to IMP0; and All traffic from WAN ports will be forwarded to IMP1.These bits are ignored when SW_FWD_MODE=Unmanaged in the Switch Mode Register, and the device will behave as if there is no defined management port.In Lotus, IMP0 is Port 8 and IMP1 is Port 5.When only IMP0 is enabled,(FRM_MNGT_PORT = 10), IMP0 is also called IMP port.
 *
 ******************************************************************************/
#define BCM53101_A0_GMNGCFGr 0x00000200

#define BCM53101_A0_GMNGCFGr_SIZE 1

/*
 * This structure should be used to declare and program GMNGCFG.
 *
 */
typedef union BCM53101_A0_GMNGCFGr_s {
	uint32_t v[1];
	uint32_t gmngcfg[1];
	uint32_t _gmngcfg;
} BCM53101_A0_GMNGCFGr_t;

#define BCM53101_A0_GMNGCFGr_CLR(r) (r).gmngcfg[0] = 0
#define BCM53101_A0_GMNGCFGr_SET(r,d) (r).gmngcfg[0] = d
#define BCM53101_A0_GMNGCFGr_GET(r) (r).gmngcfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_GMNGCFGr_RST_MIB_CNTf_GET(r) (((r).gmngcfg[0]) & 0x1)
#define BCM53101_A0_GMNGCFGr_RST_MIB_CNTf_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_GMNGCFGr_RXBPDU_ENf_GET(r) ((((r).gmngcfg[0]) >> 1) & 0x1)
#define BCM53101_A0_GMNGCFGr_RXBPDU_ENf_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_GMNGCFGr_RESERVED_0f_GET(r) ((((r).gmngcfg[0]) >> 2) & 0x3)
#define BCM53101_A0_GMNGCFGr_RESERVED_0f_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53101_A0_GMNGCFGr_INT_ENf_GET(r) ((((r).gmngcfg[0]) >> 4) & 0x1)
#define BCM53101_A0_GMNGCFGr_INT_ENf_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_GMNGCFGr_RESERVED_1f_GET(r) ((((r).gmngcfg[0]) >> 5) & 0x1)
#define BCM53101_A0_GMNGCFGr_RESERVED_1f_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_GMNGCFGr_FRM_MNGPf_GET(r) ((((r).gmngcfg[0]) >> 6) & 0x3)
#define BCM53101_A0_GMNGCFGr_FRM_MNGPf_SET(r,f) (r).gmngcfg[0]=(((r).gmngcfg[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access GMNGCFG.
 *
 */
#define BCM53101_A0_READ_GMNGCFGr(u,r) cdk_robo_reg_read(u,BCM53101_A0_GMNGCFGr,(r._gmngcfg),1)
#define BCM53101_A0_WRITE_GMNGCFGr(u,r) cdk_robo_reg_write(u,BCM53101_A0_GMNGCFGr,&(r._gmngcfg),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define GMNGCFGr BCM53101_A0_GMNGCFGr
#define GMNGCFGr_SIZE BCM53101_A0_GMNGCFGr_SIZE
typedef BCM53101_A0_GMNGCFGr_t GMNGCFGr_t;
#define GMNGCFGr_CLR BCM53101_A0_GMNGCFGr_CLR
#define GMNGCFGr_SET BCM53101_A0_GMNGCFGr_SET
#define GMNGCFGr_GET BCM53101_A0_GMNGCFGr_GET
#define GMNGCFGr_RST_MIB_CNTf_GET BCM53101_A0_GMNGCFGr_RST_MIB_CNTf_GET
#define GMNGCFGr_RST_MIB_CNTf_SET BCM53101_A0_GMNGCFGr_RST_MIB_CNTf_SET
#define GMNGCFGr_RXBPDU_ENf_GET BCM53101_A0_GMNGCFGr_RXBPDU_ENf_GET
#define GMNGCFGr_RXBPDU_ENf_SET BCM53101_A0_GMNGCFGr_RXBPDU_ENf_SET
#define GMNGCFGr_RESERVED_0f_GET BCM53101_A0_GMNGCFGr_RESERVED_0f_GET
#define GMNGCFGr_RESERVED_0f_SET BCM53101_A0_GMNGCFGr_RESERVED_0f_SET
#define GMNGCFGr_INT_ENf_GET BCM53101_A0_GMNGCFGr_INT_ENf_GET
#define GMNGCFGr_INT_ENf_SET BCM53101_A0_GMNGCFGr_INT_ENf_SET
#define GMNGCFGr_RESERVED_1f_GET BCM53101_A0_GMNGCFGr_RESERVED_1f_GET
#define GMNGCFGr_RESERVED_1f_SET BCM53101_A0_GMNGCFGr_RESERVED_1f_SET
#define GMNGCFGr_FRM_MNGPf_GET BCM53101_A0_GMNGCFGr_FRM_MNGPf_GET
#define GMNGCFGr_FRM_MNGPf_SET BCM53101_A0_GMNGCFGr_FRM_MNGPf_SET
#define READ_GMNGCFGr BCM53101_A0_READ_GMNGCFGr
#define WRITE_GMNGCFGr BCM53101_A0_WRITE_GMNGCFGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_GMNGCFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  G_ANADV_EXT
 * BLOCKS:   SYS
 * DESC:     External Auto-Negotiation Advertisement Register
 * SIZE:     16
 * FIELDS:
 *     PROTOCOL_SEL     00001 = IEEE 802.3 CSMA/CD.
 *     ADV_B10T         1 = 10Base-T half duplex capable,0 = not 10Base-T half duplex capable.
 *     ADV_B10T_FDX     1 = 10Base-T full duplex capable,0 = not 10Base-T full duplex capable.
 *     ADV_B100X        1 = 100Base-TX capable,0 = not 100Base-TX capable.
 *     ADV_B100_FDX     1 = 100Base-TX full duplex capable,0 = not 100Base-TX full duplex capable.
 *     B100T4           1 = 100Base-T4 capable,0 = not 100Base-T4 capable.
 *     ADV_PAUSE_CAP    1 = capable of full duplex Pause operation,0 = not capable of Pause operation.
 *     ASY_PAUSE        1 = Advertise asymmetric pause,0 = Advertise no asymmetric pause.
 *     RESERVED_1       write as 0, ignore on read.
 *     REMOTE_FAULT     1 = advertise remote fault detected0 = advertise no remote fault detected
 *     RESERVED_2       write as 0, ignore on read.
 *     NEXT_PAGE        1 = next page ability supported.0 = next page ability not supported.
 *
 ******************************************************************************/
#define BCM53101_A0_G_ANADV_EXTr 0x00008808

#define BCM53101_A0_G_ANADV_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_ANADV_EXT.
 *
 */
typedef union BCM53101_A0_G_ANADV_EXTr_s {
	uint32_t v[1];
	uint32_t g_anadv_ext[1];
	uint32_t _g_anadv_ext;
} BCM53101_A0_G_ANADV_EXTr_t;

#define BCM53101_A0_G_ANADV_EXTr_CLR(r) (r).g_anadv_ext[0] = 0
#define BCM53101_A0_G_ANADV_EXTr_SET(r,d) (r).g_anadv_ext[0] = d
#define BCM53101_A0_G_ANADV_EXTr_GET(r) (r).g_anadv_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_G_ANADV_EXTr_PROTOCOL_SELf_GET(r) (((r).g_anadv_ext[0]) & 0x1f)
#define BCM53101_A0_G_ANADV_EXTr_PROTOCOL_SELf_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53101_A0_G_ANADV_EXTr_ADV_B10Tf_GET(r) ((((r).g_anadv_ext[0]) >> 5) & 0x1)
#define BCM53101_A0_G_ANADV_EXTr_ADV_B10Tf_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_G_ANADV_EXTr_ADV_B10T_FDXf_GET(r) ((((r).g_anadv_ext[0]) >> 6) & 0x1)
#define BCM53101_A0_G_ANADV_EXTr_ADV_B10T_FDXf_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_G_ANADV_EXTr_ADV_B100Xf_GET(r) ((((r).g_anadv_ext[0]) >> 7) & 0x1)
#define BCM53101_A0_G_ANADV_EXTr_ADV_B100Xf_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53101_A0_G_ANADV_EXTr_ADV_B100_FDXf_GET(r) ((((r).g_anadv_ext[0]) >> 8) & 0x1)
#define BCM53101_A0_G_ANADV_EXTr_ADV_B100_FDXf_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53101_A0_G_ANADV_EXTr_B100T4f_GET(r) ((((r).g_anadv_ext[0]) >> 9) & 0x1)
#define BCM53101_A0_G_ANADV_EXTr_B100T4f_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53101_A0_G_ANADV_EXTr_ADV_PAUSE_CAPf_GET(r) ((((r).g_anadv_ext[0]) >> 10) & 0x1)
#define BCM53101_A0_G_ANADV_EXTr_ADV_PAUSE_CAPf_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53101_A0_G_ANADV_EXTr_ASY_PAUSEf_GET(r) ((((r).g_anadv_ext[0]) >> 11) & 0x1)
#define BCM53101_A0_G_ANADV_EXTr_ASY_PAUSEf_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53101_A0_G_ANADV_EXTr_RESERVED_1f_GET(r) ((((r).g_anadv_ext[0]) >> 12) & 0x1)
#define BCM53101_A0_G_ANADV_EXTr_RESERVED_1f_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53101_A0_G_ANADV_EXTr_REMOTE_FAULTf_GET(r) ((((r).g_anadv_ext[0]) >> 13) & 0x1)
#define BCM53101_A0_G_ANADV_EXTr_REMOTE_FAULTf_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53101_A0_G_ANADV_EXTr_RESERVED_2f_GET(r) ((((r).g_anadv_ext[0]) >> 14) & 0x1)
#define BCM53101_A0_G_ANADV_EXTr_RESERVED_2f_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_G_ANADV_EXTr_NEXT_PAGEf_GET(r) ((((r).g_anadv_ext[0]) >> 15) & 0x1)
#define BCM53101_A0_G_ANADV_EXTr_NEXT_PAGEf_SET(r,f) (r).g_anadv_ext[0]=(((r).g_anadv_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANADV_EXT.
 *
 */
#define BCM53101_A0_READ_G_ANADV_EXTr(u,r) cdk_robo_reg_read(u,BCM53101_A0_G_ANADV_EXTr,(r._g_anadv_ext),2)
#define BCM53101_A0_WRITE_G_ANADV_EXTr(u,r) cdk_robo_reg_write(u,BCM53101_A0_G_ANADV_EXTr,&(r._g_anadv_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANADV_EXTr BCM53101_A0_G_ANADV_EXTr
#define G_ANADV_EXTr_SIZE BCM53101_A0_G_ANADV_EXTr_SIZE
typedef BCM53101_A0_G_ANADV_EXTr_t G_ANADV_EXTr_t;
#define G_ANADV_EXTr_CLR BCM53101_A0_G_ANADV_EXTr_CLR
#define G_ANADV_EXTr_SET BCM53101_A0_G_ANADV_EXTr_SET
#define G_ANADV_EXTr_GET BCM53101_A0_G_ANADV_EXTr_GET
#define G_ANADV_EXTr_PROTOCOL_SELf_GET BCM53101_A0_G_ANADV_EXTr_PROTOCOL_SELf_GET
#define G_ANADV_EXTr_PROTOCOL_SELf_SET BCM53101_A0_G_ANADV_EXTr_PROTOCOL_SELf_SET
#define G_ANADV_EXTr_ADV_B10Tf_GET BCM53101_A0_G_ANADV_EXTr_ADV_B10Tf_GET
#define G_ANADV_EXTr_ADV_B10Tf_SET BCM53101_A0_G_ANADV_EXTr_ADV_B10Tf_SET
#define G_ANADV_EXTr_ADV_B10T_FDXf_GET BCM53101_A0_G_ANADV_EXTr_ADV_B10T_FDXf_GET
#define G_ANADV_EXTr_ADV_B10T_FDXf_SET BCM53101_A0_G_ANADV_EXTr_ADV_B10T_FDXf_SET
#define G_ANADV_EXTr_ADV_B100Xf_GET BCM53101_A0_G_ANADV_EXTr_ADV_B100Xf_GET
#define G_ANADV_EXTr_ADV_B100Xf_SET BCM53101_A0_G_ANADV_EXTr_ADV_B100Xf_SET
#define G_ANADV_EXTr_ADV_B100_FDXf_GET BCM53101_A0_G_ANADV_EXTr_ADV_B100_FDXf_GET
#define G_ANADV_EXTr_ADV_B100_FDXf_SET BCM53101_A0_G_ANADV_EXTr_ADV_B100_FDXf_SET
#define G_ANADV_EXTr_B100T4f_GET BCM53101_A0_G_ANADV_EXTr_B100T4f_GET
#define G_ANADV_EXTr_B100T4f_SET BCM53101_A0_G_ANADV_EXTr_B100T4f_SET
#define G_ANADV_EXTr_ADV_PAUSE_CAPf_GET BCM53101_A0_G_ANADV_EXTr_ADV_PAUSE_CAPf_GET
#define G_ANADV_EXTr_ADV_PAUSE_CAPf_SET BCM53101_A0_G_ANADV_EXTr_ADV_PAUSE_CAPf_SET
#define G_ANADV_EXTr_ASY_PAUSEf_GET BCM53101_A0_G_ANADV_EXTr_ASY_PAUSEf_GET
#define G_ANADV_EXTr_ASY_PAUSEf_SET BCM53101_A0_G_ANADV_EXTr_ASY_PAUSEf_SET
#define G_ANADV_EXTr_RESERVED_1f_GET BCM53101_A0_G_ANADV_EXTr_RESERVED_1f_GET
#define G_ANADV_EXTr_RESERVED_1f_SET BCM53101_A0_G_ANADV_EXTr_RESERVED_1f_SET
#define G_ANADV_EXTr_REMOTE_FAULTf_GET BCM53101_A0_G_ANADV_EXTr_REMOTE_FAULTf_GET
#define G_ANADV_EXTr_REMOTE_FAULTf_SET BCM53101_A0_G_ANADV_EXTr_REMOTE_FAULTf_SET
#define G_ANADV_EXTr_RESERVED_2f_GET BCM53101_A0_G_ANADV_EXTr_RESERVED_2f_GET
#define G_ANADV_EXTr_RESERVED_2f_SET BCM53101_A0_G_ANADV_EXTr_RESERVED_2f_SET
#define G_ANADV_EXTr_NEXT_PAGEf_GET BCM53101_A0_G_ANADV_EXTr_NEXT_PAGEf_GET
#define G_ANADV_EXTr_NEXT_PAGEf_SET BCM53101_A0_G_ANADV_EXTr_NEXT_PAGEf_SET
#define READ_G_ANADV_EXTr BCM53101_A0_READ_G_ANADV_EXTr
#define WRITE_G_ANADV_EXTr BCM53101_A0_WRITE_G_ANADV_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_G_ANADV_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  G_ANEXP_EXT
 * BLOCKS:   SYS
 * DESC:     External Auto-Negotiation Expansion Register
 * SIZE:     16
 * FIELDS:
 *     LP_AN_ABI        1 = link partner is auto-negotiation able0 = link partner is not auto-negotiation able.
 *     PAGE_REC         1 = new link code word has been received0 = new link code word has not been received.
 *     NEXT_PAGE_ABI    1 = local device is next page able,0 = local device is not next page able.
 *     LP_NEXT_PAGE_ABI 1 = link partner is next page able0 = link partner is not next page able.
 *     PAR_DET_FAIL     1 = link partner is 100Base-T4 capable0 = link partner is not 100Base-T4 capable.
 *     NEXT_PAGE        1 = next pages stored in register 8,0 = next pages stored in register 5.
 *     NEXT_PAGE_ABLE   1 = register 6.5 determines next page receive location,0 = register 6.5 does not determine next page receive location.
 *     RESERVED_1       ignore on read.
 *
 ******************************************************************************/
#define BCM53101_A0_G_ANEXP_EXTr 0x0000880c

#define BCM53101_A0_G_ANEXP_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_ANEXP_EXT.
 *
 */
typedef union BCM53101_A0_G_ANEXP_EXTr_s {
	uint32_t v[1];
	uint32_t g_anexp_ext[1];
	uint32_t _g_anexp_ext;
} BCM53101_A0_G_ANEXP_EXTr_t;

#define BCM53101_A0_G_ANEXP_EXTr_CLR(r) (r).g_anexp_ext[0] = 0
#define BCM53101_A0_G_ANEXP_EXTr_SET(r,d) (r).g_anexp_ext[0] = d
#define BCM53101_A0_G_ANEXP_EXTr_GET(r) (r).g_anexp_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_G_ANEXP_EXTr_LP_AN_ABIf_GET(r) (((r).g_anexp_ext[0]) & 0x1)
#define BCM53101_A0_G_ANEXP_EXTr_LP_AN_ABIf_SET(r,f) (r).g_anexp_ext[0]=(((r).g_anexp_ext[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_G_ANEXP_EXTr_PAGE_RECf_GET(r) ((((r).g_anexp_ext[0]) >> 1) & 0x1)
#define BCM53101_A0_G_ANEXP_EXTr_PAGE_RECf_SET(r,f) (r).g_anexp_ext[0]=(((r).g_anexp_ext[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_G_ANEXP_EXTr_NEXT_PAGE_ABIf_GET(r) ((((r).g_anexp_ext[0]) >> 2) & 0x1)
#define BCM53101_A0_G_ANEXP_EXTr_NEXT_PAGE_ABIf_SET(r,f) (r).g_anexp_ext[0]=(((r).g_anexp_ext[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_G_ANEXP_EXTr_LP_NEXT_PAGE_ABIf_GET(r) ((((r).g_anexp_ext[0]) >> 3) & 0x1)
#define BCM53101_A0_G_ANEXP_EXTr_LP_NEXT_PAGE_ABIf_SET(r,f) (r).g_anexp_ext[0]=(((r).g_anexp_ext[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_G_ANEXP_EXTr_PAR_DET_FAILf_GET(r) ((((r).g_anexp_ext[0]) >> 4) & 0x1)
#define BCM53101_A0_G_ANEXP_EXTr_PAR_DET_FAILf_SET(r,f) (r).g_anexp_ext[0]=(((r).g_anexp_ext[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_G_ANEXP_EXTr_NEXT_PAGEf_GET(r) ((((r).g_anexp_ext[0]) >> 5) & 0x1)
#define BCM53101_A0_G_ANEXP_EXTr_NEXT_PAGEf_SET(r,f) (r).g_anexp_ext[0]=(((r).g_anexp_ext[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_G_ANEXP_EXTr_NEXT_PAGE_ABLEf_GET(r) ((((r).g_anexp_ext[0]) >> 6) & 0x1)
#define BCM53101_A0_G_ANEXP_EXTr_NEXT_PAGE_ABLEf_SET(r,f) (r).g_anexp_ext[0]=(((r).g_anexp_ext[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_G_ANEXP_EXTr_RESERVED_1f_GET(r) ((((r).g_anexp_ext[0]) >> 7) & 0x1ff)
#define BCM53101_A0_G_ANEXP_EXTr_RESERVED_1f_SET(r,f) (r).g_anexp_ext[0]=(((r).g_anexp_ext[0] & ~((uint32_t)0x1ff << 7)) | ((((uint32_t)f) & 0x1ff) << 7))

/*
 * These macros can be used to access G_ANEXP_EXT.
 *
 */
#define BCM53101_A0_READ_G_ANEXP_EXTr(u,r) cdk_robo_reg_read(u,BCM53101_A0_G_ANEXP_EXTr,(r._g_anexp_ext),2)
#define BCM53101_A0_WRITE_G_ANEXP_EXTr(u,r) cdk_robo_reg_write(u,BCM53101_A0_G_ANEXP_EXTr,&(r._g_anexp_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANEXP_EXTr BCM53101_A0_G_ANEXP_EXTr
#define G_ANEXP_EXTr_SIZE BCM53101_A0_G_ANEXP_EXTr_SIZE
typedef BCM53101_A0_G_ANEXP_EXTr_t G_ANEXP_EXTr_t;
#define G_ANEXP_EXTr_CLR BCM53101_A0_G_ANEXP_EXTr_CLR
#define G_ANEXP_EXTr_SET BCM53101_A0_G_ANEXP_EXTr_SET
#define G_ANEXP_EXTr_GET BCM53101_A0_G_ANEXP_EXTr_GET
#define G_ANEXP_EXTr_LP_AN_ABIf_GET BCM53101_A0_G_ANEXP_EXTr_LP_AN_ABIf_GET
#define G_ANEXP_EXTr_LP_AN_ABIf_SET BCM53101_A0_G_ANEXP_EXTr_LP_AN_ABIf_SET
#define G_ANEXP_EXTr_PAGE_RECf_GET BCM53101_A0_G_ANEXP_EXTr_PAGE_RECf_GET
#define G_ANEXP_EXTr_PAGE_RECf_SET BCM53101_A0_G_ANEXP_EXTr_PAGE_RECf_SET
#define G_ANEXP_EXTr_NEXT_PAGE_ABIf_GET BCM53101_A0_G_ANEXP_EXTr_NEXT_PAGE_ABIf_GET
#define G_ANEXP_EXTr_NEXT_PAGE_ABIf_SET BCM53101_A0_G_ANEXP_EXTr_NEXT_PAGE_ABIf_SET
#define G_ANEXP_EXTr_LP_NEXT_PAGE_ABIf_GET BCM53101_A0_G_ANEXP_EXTr_LP_NEXT_PAGE_ABIf_GET
#define G_ANEXP_EXTr_LP_NEXT_PAGE_ABIf_SET BCM53101_A0_G_ANEXP_EXTr_LP_NEXT_PAGE_ABIf_SET
#define G_ANEXP_EXTr_PAR_DET_FAILf_GET BCM53101_A0_G_ANEXP_EXTr_PAR_DET_FAILf_GET
#define G_ANEXP_EXTr_PAR_DET_FAILf_SET BCM53101_A0_G_ANEXP_EXTr_PAR_DET_FAILf_SET
#define G_ANEXP_EXTr_NEXT_PAGEf_GET BCM53101_A0_G_ANEXP_EXTr_NEXT_PAGEf_GET
#define G_ANEXP_EXTr_NEXT_PAGEf_SET BCM53101_A0_G_ANEXP_EXTr_NEXT_PAGEf_SET
#define G_ANEXP_EXTr_NEXT_PAGE_ABLEf_GET BCM53101_A0_G_ANEXP_EXTr_NEXT_PAGE_ABLEf_GET
#define G_ANEXP_EXTr_NEXT_PAGE_ABLEf_SET BCM53101_A0_G_ANEXP_EXTr_NEXT_PAGE_ABLEf_SET
#define G_ANEXP_EXTr_RESERVED_1f_GET BCM53101_A0_G_ANEXP_EXTr_RESERVED_1f_GET
#define G_ANEXP_EXTr_RESERVED_1f_SET BCM53101_A0_G_ANEXP_EXTr_RESERVED_1f_SET
#define READ_G_ANEXP_EXTr BCM53101_A0_READ_G_ANEXP_EXTr
#define WRITE_G_ANEXP_EXTr BCM53101_A0_WRITE_G_ANEXP_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_G_ANEXP_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  G_ANLPA_EXT
 * BLOCKS:   SYS
 * DESC:     External Auto-Negotiation Link Partner (LP) Ability Register
 * SIZE:     16
 * FIELDS:
 *     PROTOCOL_SEL     link partners protocol selector (see IEEE spec for encodings)
 *     B10T_FD_CAP      1 = link partner is 10Base-T half duplex capable0 = link partner is not 10Base-T half duplex capable.
 *     B100_TXHD_CAP    1 = link partner is 100Base-TX half duplex capable0 = link partner is not 100Base-TX half duplex capable.
 *     B100_TXFD_CAP    1 = link partner is 100Base-TX full duplex capable0 = link partner is not 100Base-TX full duplex capable.
 *     B100T4_CAP       1 = link partner is 100Base-T4 capable0 = link partner is not 100Base-T4 capable.
 *     PAUSE_CAP        1 = link partner is capable of Pause operation,0 = link partner not capable of Pause operation.
 *     LK_PAR_ASYM_CAP  link partners asymmetric pause bit.
 *     RESERVED_1       write as 0, ignore on read.
 *     REMOTE_FAULT     1 = link partner has detected remote fault0 = link partner has not detected remote fault.
 *     ACKNOWLEDGE      1 = link partner has received link code word0 = link partner has not received link code word.
 *     NEXT_PAGE        1 = link partner is next page able,0 = link partner is not next page able.
 *
 ******************************************************************************/
#define BCM53101_A0_G_ANLPA_EXTr 0x0000880a

#define BCM53101_A0_G_ANLPA_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_ANLPA_EXT.
 *
 */
typedef union BCM53101_A0_G_ANLPA_EXTr_s {
	uint32_t v[1];
	uint32_t g_anlpa_ext[1];
	uint32_t _g_anlpa_ext;
} BCM53101_A0_G_ANLPA_EXTr_t;

#define BCM53101_A0_G_ANLPA_EXTr_CLR(r) (r).g_anlpa_ext[0] = 0
#define BCM53101_A0_G_ANLPA_EXTr_SET(r,d) (r).g_anlpa_ext[0] = d
#define BCM53101_A0_G_ANLPA_EXTr_GET(r) (r).g_anlpa_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_G_ANLPA_EXTr_PROTOCOL_SELf_GET(r) (((r).g_anlpa_ext[0]) & 0x1f)
#define BCM53101_A0_G_ANLPA_EXTr_PROTOCOL_SELf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53101_A0_G_ANLPA_EXTr_B10T_FD_CAPf_GET(r) ((((r).g_anlpa_ext[0]) >> 5) & 0x1)
#define BCM53101_A0_G_ANLPA_EXTr_B10T_FD_CAPf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_G_ANLPA_EXTr_B100_TXHD_CAPf_GET(r) ((((r).g_anlpa_ext[0]) >> 7) & 0x1)
#define BCM53101_A0_G_ANLPA_EXTr_B100_TXHD_CAPf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53101_A0_G_ANLPA_EXTr_B100_TXFD_CAPf_GET(r) ((((r).g_anlpa_ext[0]) >> 8) & 0x1)
#define BCM53101_A0_G_ANLPA_EXTr_B100_TXFD_CAPf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53101_A0_G_ANLPA_EXTr_B100T4_CAPf_GET(r) ((((r).g_anlpa_ext[0]) >> 9) & 0x1)
#define BCM53101_A0_G_ANLPA_EXTr_B100T4_CAPf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53101_A0_G_ANLPA_EXTr_PAUSE_CAPf_GET(r) ((((r).g_anlpa_ext[0]) >> 10) & 0x1)
#define BCM53101_A0_G_ANLPA_EXTr_PAUSE_CAPf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53101_A0_G_ANLPA_EXTr_LK_PAR_ASYM_CAPf_GET(r) ((((r).g_anlpa_ext[0]) >> 11) & 0x1)
#define BCM53101_A0_G_ANLPA_EXTr_LK_PAR_ASYM_CAPf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53101_A0_G_ANLPA_EXTr_RESERVED_1f_GET(r) ((((r).g_anlpa_ext[0]) >> 12) & 0x1)
#define BCM53101_A0_G_ANLPA_EXTr_RESERVED_1f_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53101_A0_G_ANLPA_EXTr_REMOTE_FAULTf_GET(r) ((((r).g_anlpa_ext[0]) >> 13) & 0x1)
#define BCM53101_A0_G_ANLPA_EXTr_REMOTE_FAULTf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53101_A0_G_ANLPA_EXTr_ACKNOWLEDGEf_GET(r) ((((r).g_anlpa_ext[0]) >> 14) & 0x1)
#define BCM53101_A0_G_ANLPA_EXTr_ACKNOWLEDGEf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_G_ANLPA_EXTr_NEXT_PAGEf_GET(r) ((((r).g_anlpa_ext[0]) >> 15) & 0x1)
#define BCM53101_A0_G_ANLPA_EXTr_NEXT_PAGEf_SET(r,f) (r).g_anlpa_ext[0]=(((r).g_anlpa_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANLPA_EXT.
 *
 */
#define BCM53101_A0_READ_G_ANLPA_EXTr(u,r) cdk_robo_reg_read(u,BCM53101_A0_G_ANLPA_EXTr,(r._g_anlpa_ext),2)
#define BCM53101_A0_WRITE_G_ANLPA_EXTr(u,r) cdk_robo_reg_write(u,BCM53101_A0_G_ANLPA_EXTr,&(r._g_anlpa_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANLPA_EXTr BCM53101_A0_G_ANLPA_EXTr
#define G_ANLPA_EXTr_SIZE BCM53101_A0_G_ANLPA_EXTr_SIZE
typedef BCM53101_A0_G_ANLPA_EXTr_t G_ANLPA_EXTr_t;
#define G_ANLPA_EXTr_CLR BCM53101_A0_G_ANLPA_EXTr_CLR
#define G_ANLPA_EXTr_SET BCM53101_A0_G_ANLPA_EXTr_SET
#define G_ANLPA_EXTr_GET BCM53101_A0_G_ANLPA_EXTr_GET
#define G_ANLPA_EXTr_PROTOCOL_SELf_GET BCM53101_A0_G_ANLPA_EXTr_PROTOCOL_SELf_GET
#define G_ANLPA_EXTr_PROTOCOL_SELf_SET BCM53101_A0_G_ANLPA_EXTr_PROTOCOL_SELf_SET
#define G_ANLPA_EXTr_B10T_FD_CAPf_GET BCM53101_A0_G_ANLPA_EXTr_B10T_FD_CAPf_GET
#define G_ANLPA_EXTr_B10T_FD_CAPf_SET BCM53101_A0_G_ANLPA_EXTr_B10T_FD_CAPf_SET
#define G_ANLPA_EXTr_B100_TXHD_CAPf_GET BCM53101_A0_G_ANLPA_EXTr_B100_TXHD_CAPf_GET
#define G_ANLPA_EXTr_B100_TXHD_CAPf_SET BCM53101_A0_G_ANLPA_EXTr_B100_TXHD_CAPf_SET
#define G_ANLPA_EXTr_B100_TXFD_CAPf_GET BCM53101_A0_G_ANLPA_EXTr_B100_TXFD_CAPf_GET
#define G_ANLPA_EXTr_B100_TXFD_CAPf_SET BCM53101_A0_G_ANLPA_EXTr_B100_TXFD_CAPf_SET
#define G_ANLPA_EXTr_B100T4_CAPf_GET BCM53101_A0_G_ANLPA_EXTr_B100T4_CAPf_GET
#define G_ANLPA_EXTr_B100T4_CAPf_SET BCM53101_A0_G_ANLPA_EXTr_B100T4_CAPf_SET
#define G_ANLPA_EXTr_PAUSE_CAPf_GET BCM53101_A0_G_ANLPA_EXTr_PAUSE_CAPf_GET
#define G_ANLPA_EXTr_PAUSE_CAPf_SET BCM53101_A0_G_ANLPA_EXTr_PAUSE_CAPf_SET
#define G_ANLPA_EXTr_LK_PAR_ASYM_CAPf_GET BCM53101_A0_G_ANLPA_EXTr_LK_PAR_ASYM_CAPf_GET
#define G_ANLPA_EXTr_LK_PAR_ASYM_CAPf_SET BCM53101_A0_G_ANLPA_EXTr_LK_PAR_ASYM_CAPf_SET
#define G_ANLPA_EXTr_RESERVED_1f_GET BCM53101_A0_G_ANLPA_EXTr_RESERVED_1f_GET
#define G_ANLPA_EXTr_RESERVED_1f_SET BCM53101_A0_G_ANLPA_EXTr_RESERVED_1f_SET
#define G_ANLPA_EXTr_REMOTE_FAULTf_GET BCM53101_A0_G_ANLPA_EXTr_REMOTE_FAULTf_GET
#define G_ANLPA_EXTr_REMOTE_FAULTf_SET BCM53101_A0_G_ANLPA_EXTr_REMOTE_FAULTf_SET
#define G_ANLPA_EXTr_ACKNOWLEDGEf_GET BCM53101_A0_G_ANLPA_EXTr_ACKNOWLEDGEf_GET
#define G_ANLPA_EXTr_ACKNOWLEDGEf_SET BCM53101_A0_G_ANLPA_EXTr_ACKNOWLEDGEf_SET
#define G_ANLPA_EXTr_NEXT_PAGEf_GET BCM53101_A0_G_ANLPA_EXTr_NEXT_PAGEf_GET
#define G_ANLPA_EXTr_NEXT_PAGEf_SET BCM53101_A0_G_ANLPA_EXTr_NEXT_PAGEf_SET
#define READ_G_ANLPA_EXTr BCM53101_A0_READ_G_ANLPA_EXTr
#define WRITE_G_ANLPA_EXTr BCM53101_A0_WRITE_G_ANLPA_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_G_ANLPA_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  G_ANNXP_EXT
 * BLOCKS:   SYS
 * DESC:     External Auto-Negotiation Next Page Transmit Register
 * SIZE:     16
 * FIELDS:
 *     CODE_FIELD       message code field or unformatted code field.
 *     TOGGLE           1 = register 6.5 determines next page receive location,0 = register 6.5 does not determine next page receive location.
 *     ACKNOWLEDGE_2    1 = will comply with message (not used during 1000Base-T next pages)0 = cannot comply with message
 *     MES_PAGE         1 = message page,0 = unformatted page.
 *     RESERVED_1       ignore on read.
 *     NEXT_PAGE        1 = additional next pages will follow,0 = sending last page.
 *
 ******************************************************************************/
#define BCM53101_A0_G_ANNXP_EXTr 0x0000880e

#define BCM53101_A0_G_ANNXP_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_ANNXP_EXT.
 *
 */
typedef union BCM53101_A0_G_ANNXP_EXTr_s {
	uint32_t v[1];
	uint32_t g_annxp_ext[1];
	uint32_t _g_annxp_ext;
} BCM53101_A0_G_ANNXP_EXTr_t;

#define BCM53101_A0_G_ANNXP_EXTr_CLR(r) (r).g_annxp_ext[0] = 0
#define BCM53101_A0_G_ANNXP_EXTr_SET(r,d) (r).g_annxp_ext[0] = d
#define BCM53101_A0_G_ANNXP_EXTr_GET(r) (r).g_annxp_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_G_ANNXP_EXTr_CODE_FIELDf_GET(r) ((((r).g_annxp_ext[0]) >> 5) & 0x1)
#define BCM53101_A0_G_ANNXP_EXTr_CODE_FIELDf_SET(r,f) (r).g_annxp_ext[0]=(((r).g_annxp_ext[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_G_ANNXP_EXTr_TOGGLEf_GET(r) ((((r).g_annxp_ext[0]) >> 11) & 0x1)
#define BCM53101_A0_G_ANNXP_EXTr_TOGGLEf_SET(r,f) (r).g_annxp_ext[0]=(((r).g_annxp_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53101_A0_G_ANNXP_EXTr_ACKNOWLEDGE_2f_GET(r) ((((r).g_annxp_ext[0]) >> 12) & 0x1)
#define BCM53101_A0_G_ANNXP_EXTr_ACKNOWLEDGE_2f_SET(r,f) (r).g_annxp_ext[0]=(((r).g_annxp_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53101_A0_G_ANNXP_EXTr_MES_PAGEf_GET(r) ((((r).g_annxp_ext[0]) >> 13) & 0x1)
#define BCM53101_A0_G_ANNXP_EXTr_MES_PAGEf_SET(r,f) (r).g_annxp_ext[0]=(((r).g_annxp_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53101_A0_G_ANNXP_EXTr_RESERVED_1f_GET(r) ((((r).g_annxp_ext[0]) >> 14) & 0x1)
#define BCM53101_A0_G_ANNXP_EXTr_RESERVED_1f_SET(r,f) (r).g_annxp_ext[0]=(((r).g_annxp_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_G_ANNXP_EXTr_NEXT_PAGEf_GET(r) ((((r).g_annxp_ext[0]) >> 15) & 0x1)
#define BCM53101_A0_G_ANNXP_EXTr_NEXT_PAGEf_SET(r,f) (r).g_annxp_ext[0]=(((r).g_annxp_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_ANNXP_EXT.
 *
 */
#define BCM53101_A0_READ_G_ANNXP_EXTr(u,r) cdk_robo_reg_read(u,BCM53101_A0_G_ANNXP_EXTr,(r._g_annxp_ext),2)
#define BCM53101_A0_WRITE_G_ANNXP_EXTr(u,r) cdk_robo_reg_write(u,BCM53101_A0_G_ANNXP_EXTr,&(r._g_annxp_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_ANNXP_EXTr BCM53101_A0_G_ANNXP_EXTr
#define G_ANNXP_EXTr_SIZE BCM53101_A0_G_ANNXP_EXTr_SIZE
typedef BCM53101_A0_G_ANNXP_EXTr_t G_ANNXP_EXTr_t;
#define G_ANNXP_EXTr_CLR BCM53101_A0_G_ANNXP_EXTr_CLR
#define G_ANNXP_EXTr_SET BCM53101_A0_G_ANNXP_EXTr_SET
#define G_ANNXP_EXTr_GET BCM53101_A0_G_ANNXP_EXTr_GET
#define G_ANNXP_EXTr_CODE_FIELDf_GET BCM53101_A0_G_ANNXP_EXTr_CODE_FIELDf_GET
#define G_ANNXP_EXTr_CODE_FIELDf_SET BCM53101_A0_G_ANNXP_EXTr_CODE_FIELDf_SET
#define G_ANNXP_EXTr_TOGGLEf_GET BCM53101_A0_G_ANNXP_EXTr_TOGGLEf_GET
#define G_ANNXP_EXTr_TOGGLEf_SET BCM53101_A0_G_ANNXP_EXTr_TOGGLEf_SET
#define G_ANNXP_EXTr_ACKNOWLEDGE_2f_GET BCM53101_A0_G_ANNXP_EXTr_ACKNOWLEDGE_2f_GET
#define G_ANNXP_EXTr_ACKNOWLEDGE_2f_SET BCM53101_A0_G_ANNXP_EXTr_ACKNOWLEDGE_2f_SET
#define G_ANNXP_EXTr_MES_PAGEf_GET BCM53101_A0_G_ANNXP_EXTr_MES_PAGEf_GET
#define G_ANNXP_EXTr_MES_PAGEf_SET BCM53101_A0_G_ANNXP_EXTr_MES_PAGEf_SET
#define G_ANNXP_EXTr_RESERVED_1f_GET BCM53101_A0_G_ANNXP_EXTr_RESERVED_1f_GET
#define G_ANNXP_EXTr_RESERVED_1f_SET BCM53101_A0_G_ANNXP_EXTr_RESERVED_1f_SET
#define G_ANNXP_EXTr_NEXT_PAGEf_GET BCM53101_A0_G_ANNXP_EXTr_NEXT_PAGEf_GET
#define G_ANNXP_EXTr_NEXT_PAGEf_SET BCM53101_A0_G_ANNXP_EXTr_NEXT_PAGEf_SET
#define READ_G_ANNXP_EXTr BCM53101_A0_READ_G_ANNXP_EXTr
#define WRITE_G_ANNXP_EXTr BCM53101_A0_WRITE_G_ANNXP_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_G_ANNXP_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  G_AUX_CTL_EXT
 * BLOCKS:   SYS
 * DESC:     External Auxiliary Control Register
 * SIZE:     16
 * FIELDS:
 *     SHADOW_REG       Shadow Registers:001 => 10 Base-T010 => Power Control011 => IP Phone100 => Misc Test101 => Misc Test 2110 => Manual IP Phone seed111 => Misc Control
 *
 ******************************************************************************/
#define BCM53101_A0_G_AUX_CTL_EXTr 0x00008830

#define BCM53101_A0_G_AUX_CTL_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_AUX_CTL_EXT.
 *
 */
typedef union BCM53101_A0_G_AUX_CTL_EXTr_s {
	uint32_t v[1];
	uint32_t g_aux_ctl_ext[1];
	uint32_t _g_aux_ctl_ext;
} BCM53101_A0_G_AUX_CTL_EXTr_t;

#define BCM53101_A0_G_AUX_CTL_EXTr_CLR(r) (r).g_aux_ctl_ext[0] = 0
#define BCM53101_A0_G_AUX_CTL_EXTr_SET(r,d) (r).g_aux_ctl_ext[0] = d
#define BCM53101_A0_G_AUX_CTL_EXTr_GET(r) (r).g_aux_ctl_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_G_AUX_CTL_EXTr_SHADOW_REGf_GET(r) (((r).g_aux_ctl_ext[0]) & 0xffff)
#define BCM53101_A0_G_AUX_CTL_EXTr_SHADOW_REGf_SET(r,f) (r).g_aux_ctl_ext[0]=(((r).g_aux_ctl_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_AUX_CTL_EXT.
 *
 */
#define BCM53101_A0_READ_G_AUX_CTL_EXTr(u,r) cdk_robo_reg_read(u,BCM53101_A0_G_AUX_CTL_EXTr,(r._g_aux_ctl_ext),2)
#define BCM53101_A0_WRITE_G_AUX_CTL_EXTr(u,r) cdk_robo_reg_write(u,BCM53101_A0_G_AUX_CTL_EXTr,&(r._g_aux_ctl_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_AUX_CTL_EXTr BCM53101_A0_G_AUX_CTL_EXTr
#define G_AUX_CTL_EXTr_SIZE BCM53101_A0_G_AUX_CTL_EXTr_SIZE
typedef BCM53101_A0_G_AUX_CTL_EXTr_t G_AUX_CTL_EXTr_t;
#define G_AUX_CTL_EXTr_CLR BCM53101_A0_G_AUX_CTL_EXTr_CLR
#define G_AUX_CTL_EXTr_SET BCM53101_A0_G_AUX_CTL_EXTr_SET
#define G_AUX_CTL_EXTr_GET BCM53101_A0_G_AUX_CTL_EXTr_GET
#define G_AUX_CTL_EXTr_SHADOW_REGf_GET BCM53101_A0_G_AUX_CTL_EXTr_SHADOW_REGf_GET
#define G_AUX_CTL_EXTr_SHADOW_REGf_SET BCM53101_A0_G_AUX_CTL_EXTr_SHADOW_REGf_SET
#define READ_G_AUX_CTL_EXTr BCM53101_A0_READ_G_AUX_CTL_EXTr
#define WRITE_G_AUX_CTL_EXTr BCM53101_A0_WRITE_G_AUX_CTL_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_G_AUX_CTL_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  G_AUX_STS_EXT
 * BLOCKS:   SYS
 * DESC:     External Auxiliary Status Register
 * SIZE:     16
 * FIELDS:
 *     AUX_STS          
 *
 ******************************************************************************/
#define BCM53101_A0_G_AUX_STS_EXTr 0x00008832

#define BCM53101_A0_G_AUX_STS_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_AUX_STS_EXT.
 *
 */
typedef union BCM53101_A0_G_AUX_STS_EXTr_s {
	uint32_t v[1];
	uint32_t g_aux_sts_ext[1];
	uint32_t _g_aux_sts_ext;
} BCM53101_A0_G_AUX_STS_EXTr_t;

#define BCM53101_A0_G_AUX_STS_EXTr_CLR(r) (r).g_aux_sts_ext[0] = 0
#define BCM53101_A0_G_AUX_STS_EXTr_SET(r,d) (r).g_aux_sts_ext[0] = d
#define BCM53101_A0_G_AUX_STS_EXTr_GET(r) (r).g_aux_sts_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_G_AUX_STS_EXTr_AUX_STSf_GET(r) (((r).g_aux_sts_ext[0]) & 0xffff)
#define BCM53101_A0_G_AUX_STS_EXTr_AUX_STSf_SET(r,f) (r).g_aux_sts_ext[0]=(((r).g_aux_sts_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_AUX_STS_EXT.
 *
 */
#define BCM53101_A0_READ_G_AUX_STS_EXTr(u,r) cdk_robo_reg_read(u,BCM53101_A0_G_AUX_STS_EXTr,(r._g_aux_sts_ext),2)
#define BCM53101_A0_WRITE_G_AUX_STS_EXTr(u,r) cdk_robo_reg_write(u,BCM53101_A0_G_AUX_STS_EXTr,&(r._g_aux_sts_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_AUX_STS_EXTr BCM53101_A0_G_AUX_STS_EXTr
#define G_AUX_STS_EXTr_SIZE BCM53101_A0_G_AUX_STS_EXTr_SIZE
typedef BCM53101_A0_G_AUX_STS_EXTr_t G_AUX_STS_EXTr_t;
#define G_AUX_STS_EXTr_CLR BCM53101_A0_G_AUX_STS_EXTr_CLR
#define G_AUX_STS_EXTr_SET BCM53101_A0_G_AUX_STS_EXTr_SET
#define G_AUX_STS_EXTr_GET BCM53101_A0_G_AUX_STS_EXTr_GET
#define G_AUX_STS_EXTr_AUX_STSf_GET BCM53101_A0_G_AUX_STS_EXTr_AUX_STSf_GET
#define G_AUX_STS_EXTr_AUX_STSf_SET BCM53101_A0_G_AUX_STS_EXTr_AUX_STSf_SET
#define READ_G_AUX_STS_EXTr BCM53101_A0_READ_G_AUX_STS_EXTr
#define WRITE_G_AUX_STS_EXTr BCM53101_A0_WRITE_G_AUX_STS_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_G_AUX_STS_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  G_B1000T_CTL_EXT
 * BLOCKS:   SYS
 * DESC:     External 1000Base-T Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         write as 0, ignore on read.
 *     ADV_B1000T_HD    1 = Advertise 1000Base-T half duplex capable,0 = Advertise not 1000Base-T half duplex capable.
 *     ADV_B1000T_FD    1 = Advertise 1000Base-T full duplex capable,0 = Advertise not 1000Base-T full duplex capable.
 *     REPEATER_DTE     1 = Repeater/switch device port,0 = DTE device port.
 *     MAST_SLV_CONG_VALUE 1 = configure PHY as Master when 9.12 is set0 = configure PHY as Slave when 9.12 is set.
 *     MAST_SLV_CONG_EN 1 = enable Master/Slave manual config value,0 = disable Master/Slave manual config value.
 *     TEST_MODE        1xx = Test Mode 4011 = Test Mode 3010 = Test Mode 2001 = Test Mode 1000 = Normal Operation.
 *
 ******************************************************************************/
#define BCM53101_A0_G_B1000T_CTL_EXTr 0x00008812

#define BCM53101_A0_G_B1000T_CTL_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_B1000T_CTL_EXT.
 *
 */
typedef union BCM53101_A0_G_B1000T_CTL_EXTr_s {
	uint32_t v[1];
	uint32_t g_b1000t_ctl_ext[1];
	uint32_t _g_b1000t_ctl_ext;
} BCM53101_A0_G_B1000T_CTL_EXTr_t;

#define BCM53101_A0_G_B1000T_CTL_EXTr_CLR(r) (r).g_b1000t_ctl_ext[0] = 0
#define BCM53101_A0_G_B1000T_CTL_EXTr_SET(r,d) (r).g_b1000t_ctl_ext[0] = d
#define BCM53101_A0_G_B1000T_CTL_EXTr_GET(r) (r).g_b1000t_ctl_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_G_B1000T_CTL_EXTr_RESERVEDf_GET(r) (((r).g_b1000t_ctl_ext[0]) & 0xff)
#define BCM53101_A0_G_B1000T_CTL_EXTr_RESERVEDf_SET(r,f) (r).g_b1000t_ctl_ext[0]=(((r).g_b1000t_ctl_ext[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53101_A0_G_B1000T_CTL_EXTr_ADV_B1000T_HDf_GET(r) ((((r).g_b1000t_ctl_ext[0]) >> 8) & 0x1)
#define BCM53101_A0_G_B1000T_CTL_EXTr_ADV_B1000T_HDf_SET(r,f) (r).g_b1000t_ctl_ext[0]=(((r).g_b1000t_ctl_ext[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53101_A0_G_B1000T_CTL_EXTr_ADV_B1000T_FDf_GET(r) ((((r).g_b1000t_ctl_ext[0]) >> 9) & 0x1)
#define BCM53101_A0_G_B1000T_CTL_EXTr_ADV_B1000T_FDf_SET(r,f) (r).g_b1000t_ctl_ext[0]=(((r).g_b1000t_ctl_ext[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53101_A0_G_B1000T_CTL_EXTr_REPEATER_DTEf_GET(r) ((((r).g_b1000t_ctl_ext[0]) >> 10) & 0x1)
#define BCM53101_A0_G_B1000T_CTL_EXTr_REPEATER_DTEf_SET(r,f) (r).g_b1000t_ctl_ext[0]=(((r).g_b1000t_ctl_ext[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53101_A0_G_B1000T_CTL_EXTr_MAST_SLV_CONG_VALUEf_GET(r) ((((r).g_b1000t_ctl_ext[0]) >> 11) & 0x1)
#define BCM53101_A0_G_B1000T_CTL_EXTr_MAST_SLV_CONG_VALUEf_SET(r,f) (r).g_b1000t_ctl_ext[0]=(((r).g_b1000t_ctl_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53101_A0_G_B1000T_CTL_EXTr_MAST_SLV_CONG_ENf_GET(r) ((((r).g_b1000t_ctl_ext[0]) >> 12) & 0x1)
#define BCM53101_A0_G_B1000T_CTL_EXTr_MAST_SLV_CONG_ENf_SET(r,f) (r).g_b1000t_ctl_ext[0]=(((r).g_b1000t_ctl_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53101_A0_G_B1000T_CTL_EXTr_TEST_MODEf_GET(r) ((((r).g_b1000t_ctl_ext[0]) >> 13) & 0x7)
#define BCM53101_A0_G_B1000T_CTL_EXTr_TEST_MODEf_SET(r,f) (r).g_b1000t_ctl_ext[0]=(((r).g_b1000t_ctl_ext[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access G_B1000T_CTL_EXT.
 *
 */
#define BCM53101_A0_READ_G_B1000T_CTL_EXTr(u,r) cdk_robo_reg_read(u,BCM53101_A0_G_B1000T_CTL_EXTr,(r._g_b1000t_ctl_ext),2)
#define BCM53101_A0_WRITE_G_B1000T_CTL_EXTr(u,r) cdk_robo_reg_write(u,BCM53101_A0_G_B1000T_CTL_EXTr,&(r._g_b1000t_ctl_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_B1000T_CTL_EXTr BCM53101_A0_G_B1000T_CTL_EXTr
#define G_B1000T_CTL_EXTr_SIZE BCM53101_A0_G_B1000T_CTL_EXTr_SIZE
typedef BCM53101_A0_G_B1000T_CTL_EXTr_t G_B1000T_CTL_EXTr_t;
#define G_B1000T_CTL_EXTr_CLR BCM53101_A0_G_B1000T_CTL_EXTr_CLR
#define G_B1000T_CTL_EXTr_SET BCM53101_A0_G_B1000T_CTL_EXTr_SET
#define G_B1000T_CTL_EXTr_GET BCM53101_A0_G_B1000T_CTL_EXTr_GET
#define G_B1000T_CTL_EXTr_RESERVEDf_GET BCM53101_A0_G_B1000T_CTL_EXTr_RESERVEDf_GET
#define G_B1000T_CTL_EXTr_RESERVEDf_SET BCM53101_A0_G_B1000T_CTL_EXTr_RESERVEDf_SET
#define G_B1000T_CTL_EXTr_ADV_B1000T_HDf_GET BCM53101_A0_G_B1000T_CTL_EXTr_ADV_B1000T_HDf_GET
#define G_B1000T_CTL_EXTr_ADV_B1000T_HDf_SET BCM53101_A0_G_B1000T_CTL_EXTr_ADV_B1000T_HDf_SET
#define G_B1000T_CTL_EXTr_ADV_B1000T_FDf_GET BCM53101_A0_G_B1000T_CTL_EXTr_ADV_B1000T_FDf_GET
#define G_B1000T_CTL_EXTr_ADV_B1000T_FDf_SET BCM53101_A0_G_B1000T_CTL_EXTr_ADV_B1000T_FDf_SET
#define G_B1000T_CTL_EXTr_REPEATER_DTEf_GET BCM53101_A0_G_B1000T_CTL_EXTr_REPEATER_DTEf_GET
#define G_B1000T_CTL_EXTr_REPEATER_DTEf_SET BCM53101_A0_G_B1000T_CTL_EXTr_REPEATER_DTEf_SET
#define G_B1000T_CTL_EXTr_MAST_SLV_CONG_VALUEf_GET BCM53101_A0_G_B1000T_CTL_EXTr_MAST_SLV_CONG_VALUEf_GET
#define G_B1000T_CTL_EXTr_MAST_SLV_CONG_VALUEf_SET BCM53101_A0_G_B1000T_CTL_EXTr_MAST_SLV_CONG_VALUEf_SET
#define G_B1000T_CTL_EXTr_MAST_SLV_CONG_ENf_GET BCM53101_A0_G_B1000T_CTL_EXTr_MAST_SLV_CONG_ENf_GET
#define G_B1000T_CTL_EXTr_MAST_SLV_CONG_ENf_SET BCM53101_A0_G_B1000T_CTL_EXTr_MAST_SLV_CONG_ENf_SET
#define G_B1000T_CTL_EXTr_TEST_MODEf_GET BCM53101_A0_G_B1000T_CTL_EXTr_TEST_MODEf_GET
#define G_B1000T_CTL_EXTr_TEST_MODEf_SET BCM53101_A0_G_B1000T_CTL_EXTr_TEST_MODEf_SET
#define READ_G_B1000T_CTL_EXTr BCM53101_A0_READ_G_B1000T_CTL_EXTr
#define WRITE_G_B1000T_CTL_EXTr BCM53101_A0_WRITE_G_B1000T_CTL_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_G_B1000T_CTL_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  G_B1000T_STS_EXT
 * BLOCKS:   SYS
 * DESC:     External 1000Base-T Status Register
 * SIZE:     16
 * FIELDS:
 *     IDLE_ERR_CNT     Number of idle errors since last read.
 *     RESERVED         ignore on read.
 *     LP_B1000T_HD_CAP 1 = link partner is 1000Base-T half duplex capable,0 = link partner is not 1000Base-T half duplex capable.
 *     LP_B1000T_FD_CAP 1 = link partner is 1000Base-T full duplex capable,0 = link partner is not 1000Base-T full duplex capable.
 *     REMOTE_REC_STS   1 = remote receiver status OK,0 = remote receiver status not OK.
 *     LOCAL_REC_STS    1 = local receiver status OK,0 = local receiver status not OK.
 *     MAST_SLV_CONG_STS 1 = local PHY configured as Master,0 = local PHY configured as Slave.
 *     MAST_SLV_CONG_FAULT 1 = Master/Slave configuration fault detected0 = no Master/Slave configuration fault detected(cleared by restart_an, an_complete or reg read)
 *
 ******************************************************************************/
#define BCM53101_A0_G_B1000T_STS_EXTr 0x00008814

#define BCM53101_A0_G_B1000T_STS_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_B1000T_STS_EXT.
 *
 */
typedef union BCM53101_A0_G_B1000T_STS_EXTr_s {
	uint32_t v[1];
	uint32_t g_b1000t_sts_ext[1];
	uint32_t _g_b1000t_sts_ext;
} BCM53101_A0_G_B1000T_STS_EXTr_t;

#define BCM53101_A0_G_B1000T_STS_EXTr_CLR(r) (r).g_b1000t_sts_ext[0] = 0
#define BCM53101_A0_G_B1000T_STS_EXTr_SET(r,d) (r).g_b1000t_sts_ext[0] = d
#define BCM53101_A0_G_B1000T_STS_EXTr_GET(r) (r).g_b1000t_sts_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_G_B1000T_STS_EXTr_IDLE_ERR_CNTf_GET(r) (((r).g_b1000t_sts_ext[0]) & 0xff)
#define BCM53101_A0_G_B1000T_STS_EXTr_IDLE_ERR_CNTf_SET(r,f) (r).g_b1000t_sts_ext[0]=(((r).g_b1000t_sts_ext[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53101_A0_G_B1000T_STS_EXTr_RESERVEDf_GET(r) ((((r).g_b1000t_sts_ext[0]) >> 8) & 0x3)
#define BCM53101_A0_G_B1000T_STS_EXTr_RESERVEDf_SET(r,f) (r).g_b1000t_sts_ext[0]=(((r).g_b1000t_sts_ext[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM53101_A0_G_B1000T_STS_EXTr_LP_B1000T_HD_CAPf_GET(r) ((((r).g_b1000t_sts_ext[0]) >> 10) & 0x1)
#define BCM53101_A0_G_B1000T_STS_EXTr_LP_B1000T_HD_CAPf_SET(r,f) (r).g_b1000t_sts_ext[0]=(((r).g_b1000t_sts_ext[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53101_A0_G_B1000T_STS_EXTr_LP_B1000T_FD_CAPf_GET(r) ((((r).g_b1000t_sts_ext[0]) >> 11) & 0x1)
#define BCM53101_A0_G_B1000T_STS_EXTr_LP_B1000T_FD_CAPf_SET(r,f) (r).g_b1000t_sts_ext[0]=(((r).g_b1000t_sts_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53101_A0_G_B1000T_STS_EXTr_REMOTE_REC_STSf_GET(r) ((((r).g_b1000t_sts_ext[0]) >> 12) & 0x1)
#define BCM53101_A0_G_B1000T_STS_EXTr_REMOTE_REC_STSf_SET(r,f) (r).g_b1000t_sts_ext[0]=(((r).g_b1000t_sts_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53101_A0_G_B1000T_STS_EXTr_LOCAL_REC_STSf_GET(r) ((((r).g_b1000t_sts_ext[0]) >> 13) & 0x1)
#define BCM53101_A0_G_B1000T_STS_EXTr_LOCAL_REC_STSf_SET(r,f) (r).g_b1000t_sts_ext[0]=(((r).g_b1000t_sts_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53101_A0_G_B1000T_STS_EXTr_MAST_SLV_CONG_STSf_GET(r) ((((r).g_b1000t_sts_ext[0]) >> 14) & 0x1)
#define BCM53101_A0_G_B1000T_STS_EXTr_MAST_SLV_CONG_STSf_SET(r,f) (r).g_b1000t_sts_ext[0]=(((r).g_b1000t_sts_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_G_B1000T_STS_EXTr_MAST_SLV_CONG_FAULTf_GET(r) ((((r).g_b1000t_sts_ext[0]) >> 15) & 0x1)
#define BCM53101_A0_G_B1000T_STS_EXTr_MAST_SLV_CONG_FAULTf_SET(r,f) (r).g_b1000t_sts_ext[0]=(((r).g_b1000t_sts_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_B1000T_STS_EXT.
 *
 */
#define BCM53101_A0_READ_G_B1000T_STS_EXTr(u,r) cdk_robo_reg_read(u,BCM53101_A0_G_B1000T_STS_EXTr,(r._g_b1000t_sts_ext),2)
#define BCM53101_A0_WRITE_G_B1000T_STS_EXTr(u,r) cdk_robo_reg_write(u,BCM53101_A0_G_B1000T_STS_EXTr,&(r._g_b1000t_sts_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_B1000T_STS_EXTr BCM53101_A0_G_B1000T_STS_EXTr
#define G_B1000T_STS_EXTr_SIZE BCM53101_A0_G_B1000T_STS_EXTr_SIZE
typedef BCM53101_A0_G_B1000T_STS_EXTr_t G_B1000T_STS_EXTr_t;
#define G_B1000T_STS_EXTr_CLR BCM53101_A0_G_B1000T_STS_EXTr_CLR
#define G_B1000T_STS_EXTr_SET BCM53101_A0_G_B1000T_STS_EXTr_SET
#define G_B1000T_STS_EXTr_GET BCM53101_A0_G_B1000T_STS_EXTr_GET
#define G_B1000T_STS_EXTr_IDLE_ERR_CNTf_GET BCM53101_A0_G_B1000T_STS_EXTr_IDLE_ERR_CNTf_GET
#define G_B1000T_STS_EXTr_IDLE_ERR_CNTf_SET BCM53101_A0_G_B1000T_STS_EXTr_IDLE_ERR_CNTf_SET
#define G_B1000T_STS_EXTr_RESERVEDf_GET BCM53101_A0_G_B1000T_STS_EXTr_RESERVEDf_GET
#define G_B1000T_STS_EXTr_RESERVEDf_SET BCM53101_A0_G_B1000T_STS_EXTr_RESERVEDf_SET
#define G_B1000T_STS_EXTr_LP_B1000T_HD_CAPf_GET BCM53101_A0_G_B1000T_STS_EXTr_LP_B1000T_HD_CAPf_GET
#define G_B1000T_STS_EXTr_LP_B1000T_HD_CAPf_SET BCM53101_A0_G_B1000T_STS_EXTr_LP_B1000T_HD_CAPf_SET
#define G_B1000T_STS_EXTr_LP_B1000T_FD_CAPf_GET BCM53101_A0_G_B1000T_STS_EXTr_LP_B1000T_FD_CAPf_GET
#define G_B1000T_STS_EXTr_LP_B1000T_FD_CAPf_SET BCM53101_A0_G_B1000T_STS_EXTr_LP_B1000T_FD_CAPf_SET
#define G_B1000T_STS_EXTr_REMOTE_REC_STSf_GET BCM53101_A0_G_B1000T_STS_EXTr_REMOTE_REC_STSf_GET
#define G_B1000T_STS_EXTr_REMOTE_REC_STSf_SET BCM53101_A0_G_B1000T_STS_EXTr_REMOTE_REC_STSf_SET
#define G_B1000T_STS_EXTr_LOCAL_REC_STSf_GET BCM53101_A0_G_B1000T_STS_EXTr_LOCAL_REC_STSf_GET
#define G_B1000T_STS_EXTr_LOCAL_REC_STSf_SET BCM53101_A0_G_B1000T_STS_EXTr_LOCAL_REC_STSf_SET
#define G_B1000T_STS_EXTr_MAST_SLV_CONG_STSf_GET BCM53101_A0_G_B1000T_STS_EXTr_MAST_SLV_CONG_STSf_GET
#define G_B1000T_STS_EXTr_MAST_SLV_CONG_STSf_SET BCM53101_A0_G_B1000T_STS_EXTr_MAST_SLV_CONG_STSf_SET
#define G_B1000T_STS_EXTr_MAST_SLV_CONG_FAULTf_GET BCM53101_A0_G_B1000T_STS_EXTr_MAST_SLV_CONG_FAULTf_GET
#define G_B1000T_STS_EXTr_MAST_SLV_CONG_FAULTf_SET BCM53101_A0_G_B1000T_STS_EXTr_MAST_SLV_CONG_FAULTf_SET
#define READ_G_B1000T_STS_EXTr BCM53101_A0_READ_G_B1000T_STS_EXTr
#define WRITE_G_B1000T_STS_EXTr BCM53101_A0_WRITE_G_B1000T_STS_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_G_B1000T_STS_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  G_DSP_COEFFICIENT_ADDR_EXT
 * BLOCKS:   SYS
 * DESC:     External DSP Coefficient Address Register
 * SIZE:     16
 * FIELDS:
 *     TAP_NUM          selects which tap is to be read/written within the selected filter (taps are numbered from 0 to n in chronological order (earliest to latest))when filter select = 000 (misc. receiver regs):0 = AGC A Register1 = AGC B & IPRF Register2 = MSE/Pair Status Register3 = Soft Decision Register4 = Phase Register5 = WireMap/Skew & ECHO/NEXT & TX & ADC Register6 -8 = reserved9 = Frequency Register10 = PLL Bandwith & Path Metric Register11 = PLL Phase Offset Register ...to 31, 61:63
 *     FILTER_SEL       select DSP filter for coefficient read/write:1111 = EXPANSION REGISTERS1110 = EXTERNAL SERDES REGISTERS1101 = reserved1100 = DCOFFSET1011 = reserved1010 = reserved1001 = reserved1000 = reserved0111 = NEXT[3]0110 = NEXT[2]0101 = NEXT[1]0100 = NEXT[0]0011 = ECHO0010 = DFE0001 = FFE0000 = misc. receiver registers (see bits 7:0)note: NEXT[n] does not exist for channel n. If NEXT[n] is selected for channel n, all NEXT cancellers for that channel are selected when writing control bits.BIT 12 (CONTROL ALL FILTERS) MUST BE ZERO IN ORDER TO SELECT MISC, DCOFFSET, or FFE.
 *     ALL_FILTER_CTL   when this bit is set, writes to per-filter control bits affect all filters in the specified channel, regardless of bits 11:8 (when bit 15 is also set, writes to DSP control bits affect all echo, next, and dfe filters in the chip)
 *     CHANNEL_SEL      channel select for DSP coefficient read/writes andper-channel control/status register bits (marked by*):11 = channel 310 = channel 201 = channel 100 = channel 0
 *     ALL_CHANNEL_CTL  when this bit is set, writes to per-channel control bits affect all channels, regardless of bits 14:13
 *
 ******************************************************************************/
#define BCM53101_A0_G_DSP_COEFFICIENT_ADDR_EXTr 0x0000882e

#define BCM53101_A0_G_DSP_COEFFICIENT_ADDR_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_DSP_COEFFICIENT_ADDR_EXT.
 *
 */
typedef union BCM53101_A0_G_DSP_COEFFICIENT_ADDR_EXTr_s {
	uint32_t v[1];
	uint32_t g_dsp_coefficient_addr_ext[1];
	uint32_t _g_dsp_coefficient_addr_ext;
} BCM53101_A0_G_DSP_COEFFICIENT_ADDR_EXTr_t;

#define BCM53101_A0_G_DSP_COEFFICIENT_ADDR_EXTr_CLR(r) (r).g_dsp_coefficient_addr_ext[0] = 0
#define BCM53101_A0_G_DSP_COEFFICIENT_ADDR_EXTr_SET(r,d) (r).g_dsp_coefficient_addr_ext[0] = d
#define BCM53101_A0_G_DSP_COEFFICIENT_ADDR_EXTr_GET(r) (r).g_dsp_coefficient_addr_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_G_DSP_COEFFICIENT_ADDR_EXTr_TAP_NUMf_GET(r) (((r).g_dsp_coefficient_addr_ext[0]) & 0xff)
#define BCM53101_A0_G_DSP_COEFFICIENT_ADDR_EXTr_TAP_NUMf_SET(r,f) (r).g_dsp_coefficient_addr_ext[0]=(((r).g_dsp_coefficient_addr_ext[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53101_A0_G_DSP_COEFFICIENT_ADDR_EXTr_FILTER_SELf_GET(r) ((((r).g_dsp_coefficient_addr_ext[0]) >> 8) & 0xf)
#define BCM53101_A0_G_DSP_COEFFICIENT_ADDR_EXTr_FILTER_SELf_SET(r,f) (r).g_dsp_coefficient_addr_ext[0]=(((r).g_dsp_coefficient_addr_ext[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53101_A0_G_DSP_COEFFICIENT_ADDR_EXTr_ALL_FILTER_CTLf_GET(r) ((((r).g_dsp_coefficient_addr_ext[0]) >> 12) & 0x1)
#define BCM53101_A0_G_DSP_COEFFICIENT_ADDR_EXTr_ALL_FILTER_CTLf_SET(r,f) (r).g_dsp_coefficient_addr_ext[0]=(((r).g_dsp_coefficient_addr_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53101_A0_G_DSP_COEFFICIENT_ADDR_EXTr_CHANNEL_SELf_GET(r) ((((r).g_dsp_coefficient_addr_ext[0]) >> 13) & 0x3)
#define BCM53101_A0_G_DSP_COEFFICIENT_ADDR_EXTr_CHANNEL_SELf_SET(r,f) (r).g_dsp_coefficient_addr_ext[0]=(((r).g_dsp_coefficient_addr_ext[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13))
#define BCM53101_A0_G_DSP_COEFFICIENT_ADDR_EXTr_ALL_CHANNEL_CTLf_GET(r) ((((r).g_dsp_coefficient_addr_ext[0]) >> 15) & 0x1)
#define BCM53101_A0_G_DSP_COEFFICIENT_ADDR_EXTr_ALL_CHANNEL_CTLf_SET(r,f) (r).g_dsp_coefficient_addr_ext[0]=(((r).g_dsp_coefficient_addr_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_DSP_COEFFICIENT_ADDR_EXT.
 *
 */
#define BCM53101_A0_READ_G_DSP_COEFFICIENT_ADDR_EXTr(u,r) cdk_robo_reg_read(u,BCM53101_A0_G_DSP_COEFFICIENT_ADDR_EXTr,(r._g_dsp_coefficient_addr_ext),2)
#define BCM53101_A0_WRITE_G_DSP_COEFFICIENT_ADDR_EXTr(u,r) cdk_robo_reg_write(u,BCM53101_A0_G_DSP_COEFFICIENT_ADDR_EXTr,&(r._g_dsp_coefficient_addr_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_DSP_COEFFICIENT_ADDR_EXTr BCM53101_A0_G_DSP_COEFFICIENT_ADDR_EXTr
#define G_DSP_COEFFICIENT_ADDR_EXTr_SIZE BCM53101_A0_G_DSP_COEFFICIENT_ADDR_EXTr_SIZE
typedef BCM53101_A0_G_DSP_COEFFICIENT_ADDR_EXTr_t G_DSP_COEFFICIENT_ADDR_EXTr_t;
#define G_DSP_COEFFICIENT_ADDR_EXTr_CLR BCM53101_A0_G_DSP_COEFFICIENT_ADDR_EXTr_CLR
#define G_DSP_COEFFICIENT_ADDR_EXTr_SET BCM53101_A0_G_DSP_COEFFICIENT_ADDR_EXTr_SET
#define G_DSP_COEFFICIENT_ADDR_EXTr_GET BCM53101_A0_G_DSP_COEFFICIENT_ADDR_EXTr_GET
#define G_DSP_COEFFICIENT_ADDR_EXTr_TAP_NUMf_GET BCM53101_A0_G_DSP_COEFFICIENT_ADDR_EXTr_TAP_NUMf_GET
#define G_DSP_COEFFICIENT_ADDR_EXTr_TAP_NUMf_SET BCM53101_A0_G_DSP_COEFFICIENT_ADDR_EXTr_TAP_NUMf_SET
#define G_DSP_COEFFICIENT_ADDR_EXTr_FILTER_SELf_GET BCM53101_A0_G_DSP_COEFFICIENT_ADDR_EXTr_FILTER_SELf_GET
#define G_DSP_COEFFICIENT_ADDR_EXTr_FILTER_SELf_SET BCM53101_A0_G_DSP_COEFFICIENT_ADDR_EXTr_FILTER_SELf_SET
#define G_DSP_COEFFICIENT_ADDR_EXTr_ALL_FILTER_CTLf_GET BCM53101_A0_G_DSP_COEFFICIENT_ADDR_EXTr_ALL_FILTER_CTLf_GET
#define G_DSP_COEFFICIENT_ADDR_EXTr_ALL_FILTER_CTLf_SET BCM53101_A0_G_DSP_COEFFICIENT_ADDR_EXTr_ALL_FILTER_CTLf_SET
#define G_DSP_COEFFICIENT_ADDR_EXTr_CHANNEL_SELf_GET BCM53101_A0_G_DSP_COEFFICIENT_ADDR_EXTr_CHANNEL_SELf_GET
#define G_DSP_COEFFICIENT_ADDR_EXTr_CHANNEL_SELf_SET BCM53101_A0_G_DSP_COEFFICIENT_ADDR_EXTr_CHANNEL_SELf_SET
#define G_DSP_COEFFICIENT_ADDR_EXTr_ALL_CHANNEL_CTLf_GET BCM53101_A0_G_DSP_COEFFICIENT_ADDR_EXTr_ALL_CHANNEL_CTLf_GET
#define G_DSP_COEFFICIENT_ADDR_EXTr_ALL_CHANNEL_CTLf_SET BCM53101_A0_G_DSP_COEFFICIENT_ADDR_EXTr_ALL_CHANNEL_CTLf_SET
#define READ_G_DSP_COEFFICIENT_ADDR_EXTr BCM53101_A0_READ_G_DSP_COEFFICIENT_ADDR_EXTr
#define WRITE_G_DSP_COEFFICIENT_ADDR_EXTr BCM53101_A0_WRITE_G_DSP_COEFFICIENT_ADDR_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_G_DSP_COEFFICIENT_ADDR_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  G_DSP_COEFFICIENT_EXT
 * BLOCKS:   SYS
 * DESC:     External DSP Coefficient Read/Write Port Register
 * SIZE:     16
 * FIELDS:
 *     DSP_COEFFICIENT  
 *
 ******************************************************************************/
#define BCM53101_A0_G_DSP_COEFFICIENT_EXTr 0x0000882a

#define BCM53101_A0_G_DSP_COEFFICIENT_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_DSP_COEFFICIENT_EXT.
 *
 */
typedef union BCM53101_A0_G_DSP_COEFFICIENT_EXTr_s {
	uint32_t v[1];
	uint32_t g_dsp_coefficient_ext[1];
	uint32_t _g_dsp_coefficient_ext;
} BCM53101_A0_G_DSP_COEFFICIENT_EXTr_t;

#define BCM53101_A0_G_DSP_COEFFICIENT_EXTr_CLR(r) (r).g_dsp_coefficient_ext[0] = 0
#define BCM53101_A0_G_DSP_COEFFICIENT_EXTr_SET(r,d) (r).g_dsp_coefficient_ext[0] = d
#define BCM53101_A0_G_DSP_COEFFICIENT_EXTr_GET(r) (r).g_dsp_coefficient_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_G_DSP_COEFFICIENT_EXTr_DSP_COEFFICIENTf_GET(r) (((r).g_dsp_coefficient_ext[0]) & 0xffff)
#define BCM53101_A0_G_DSP_COEFFICIENT_EXTr_DSP_COEFFICIENTf_SET(r,f) (r).g_dsp_coefficient_ext[0]=(((r).g_dsp_coefficient_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_DSP_COEFFICIENT_EXT.
 *
 */
#define BCM53101_A0_READ_G_DSP_COEFFICIENT_EXTr(u,r) cdk_robo_reg_read(u,BCM53101_A0_G_DSP_COEFFICIENT_EXTr,(r._g_dsp_coefficient_ext),2)
#define BCM53101_A0_WRITE_G_DSP_COEFFICIENT_EXTr(u,r) cdk_robo_reg_write(u,BCM53101_A0_G_DSP_COEFFICIENT_EXTr,&(r._g_dsp_coefficient_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_DSP_COEFFICIENT_EXTr BCM53101_A0_G_DSP_COEFFICIENT_EXTr
#define G_DSP_COEFFICIENT_EXTr_SIZE BCM53101_A0_G_DSP_COEFFICIENT_EXTr_SIZE
typedef BCM53101_A0_G_DSP_COEFFICIENT_EXTr_t G_DSP_COEFFICIENT_EXTr_t;
#define G_DSP_COEFFICIENT_EXTr_CLR BCM53101_A0_G_DSP_COEFFICIENT_EXTr_CLR
#define G_DSP_COEFFICIENT_EXTr_SET BCM53101_A0_G_DSP_COEFFICIENT_EXTr_SET
#define G_DSP_COEFFICIENT_EXTr_GET BCM53101_A0_G_DSP_COEFFICIENT_EXTr_GET
#define G_DSP_COEFFICIENT_EXTr_DSP_COEFFICIENTf_GET BCM53101_A0_G_DSP_COEFFICIENT_EXTr_DSP_COEFFICIENTf_GET
#define G_DSP_COEFFICIENT_EXTr_DSP_COEFFICIENTf_SET BCM53101_A0_G_DSP_COEFFICIENT_EXTr_DSP_COEFFICIENTf_SET
#define READ_G_DSP_COEFFICIENT_EXTr BCM53101_A0_READ_G_DSP_COEFFICIENT_EXTr
#define WRITE_G_DSP_COEFFICIENT_EXTr BCM53101_A0_WRITE_G_DSP_COEFFICIENT_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_G_DSP_COEFFICIENT_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  G_EXT_STS_EXT
 * BLOCKS:   SYS
 * DESC:     External Extended Status Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         ignore on read.
 *     B1000T_HD_CAP    1 = 1000Base-T half duplex capable,0 = not 1000Base-T half duplex capable.
 *     B1000T_FD_CAP    1 = 1000Base-T full duplex capable0 = not 1000Base-T full duplex capable.
 *     B1000X_HD_CAP    1 = 1000Base-X half duplex capable,0 = not 1000Base-X half duplex capable.
 *     B1000X_FD_CAP    1 = 1000Base-X full duplex capable0 = not 1000Base-X full duplex capable.
 *
 ******************************************************************************/
#define BCM53101_A0_G_EXT_STS_EXTr 0x0000881e

#define BCM53101_A0_G_EXT_STS_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_EXT_STS_EXT.
 *
 */
typedef union BCM53101_A0_G_EXT_STS_EXTr_s {
	uint32_t v[1];
	uint32_t g_ext_sts_ext[1];
	uint32_t _g_ext_sts_ext;
} BCM53101_A0_G_EXT_STS_EXTr_t;

#define BCM53101_A0_G_EXT_STS_EXTr_CLR(r) (r).g_ext_sts_ext[0] = 0
#define BCM53101_A0_G_EXT_STS_EXTr_SET(r,d) (r).g_ext_sts_ext[0] = d
#define BCM53101_A0_G_EXT_STS_EXTr_GET(r) (r).g_ext_sts_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_G_EXT_STS_EXTr_RESERVEDf_GET(r) (((r).g_ext_sts_ext[0]) & 0xfff)
#define BCM53101_A0_G_EXT_STS_EXTr_RESERVEDf_SET(r,f) (r).g_ext_sts_ext[0]=(((r).g_ext_sts_ext[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53101_A0_G_EXT_STS_EXTr_B1000T_HD_CAPf_GET(r) ((((r).g_ext_sts_ext[0]) >> 12) & 0x1)
#define BCM53101_A0_G_EXT_STS_EXTr_B1000T_HD_CAPf_SET(r,f) (r).g_ext_sts_ext[0]=(((r).g_ext_sts_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53101_A0_G_EXT_STS_EXTr_B1000T_FD_CAPf_GET(r) ((((r).g_ext_sts_ext[0]) >> 13) & 0x1)
#define BCM53101_A0_G_EXT_STS_EXTr_B1000T_FD_CAPf_SET(r,f) (r).g_ext_sts_ext[0]=(((r).g_ext_sts_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53101_A0_G_EXT_STS_EXTr_B1000X_HD_CAPf_GET(r) ((((r).g_ext_sts_ext[0]) >> 14) & 0x1)
#define BCM53101_A0_G_EXT_STS_EXTr_B1000X_HD_CAPf_SET(r,f) (r).g_ext_sts_ext[0]=(((r).g_ext_sts_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_G_EXT_STS_EXTr_B1000X_FD_CAPf_GET(r) ((((r).g_ext_sts_ext[0]) >> 15) & 0x1)
#define BCM53101_A0_G_EXT_STS_EXTr_B1000X_FD_CAPf_SET(r,f) (r).g_ext_sts_ext[0]=(((r).g_ext_sts_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_EXT_STS_EXT.
 *
 */
#define BCM53101_A0_READ_G_EXT_STS_EXTr(u,r) cdk_robo_reg_read(u,BCM53101_A0_G_EXT_STS_EXTr,(r._g_ext_sts_ext),2)
#define BCM53101_A0_WRITE_G_EXT_STS_EXTr(u,r) cdk_robo_reg_write(u,BCM53101_A0_G_EXT_STS_EXTr,&(r._g_ext_sts_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_EXT_STS_EXTr BCM53101_A0_G_EXT_STS_EXTr
#define G_EXT_STS_EXTr_SIZE BCM53101_A0_G_EXT_STS_EXTr_SIZE
typedef BCM53101_A0_G_EXT_STS_EXTr_t G_EXT_STS_EXTr_t;
#define G_EXT_STS_EXTr_CLR BCM53101_A0_G_EXT_STS_EXTr_CLR
#define G_EXT_STS_EXTr_SET BCM53101_A0_G_EXT_STS_EXTr_SET
#define G_EXT_STS_EXTr_GET BCM53101_A0_G_EXT_STS_EXTr_GET
#define G_EXT_STS_EXTr_RESERVEDf_GET BCM53101_A0_G_EXT_STS_EXTr_RESERVEDf_GET
#define G_EXT_STS_EXTr_RESERVEDf_SET BCM53101_A0_G_EXT_STS_EXTr_RESERVEDf_SET
#define G_EXT_STS_EXTr_B1000T_HD_CAPf_GET BCM53101_A0_G_EXT_STS_EXTr_B1000T_HD_CAPf_GET
#define G_EXT_STS_EXTr_B1000T_HD_CAPf_SET BCM53101_A0_G_EXT_STS_EXTr_B1000T_HD_CAPf_SET
#define G_EXT_STS_EXTr_B1000T_FD_CAPf_GET BCM53101_A0_G_EXT_STS_EXTr_B1000T_FD_CAPf_GET
#define G_EXT_STS_EXTr_B1000T_FD_CAPf_SET BCM53101_A0_G_EXT_STS_EXTr_B1000T_FD_CAPf_SET
#define G_EXT_STS_EXTr_B1000X_HD_CAPf_GET BCM53101_A0_G_EXT_STS_EXTr_B1000X_HD_CAPf_GET
#define G_EXT_STS_EXTr_B1000X_HD_CAPf_SET BCM53101_A0_G_EXT_STS_EXTr_B1000X_HD_CAPf_SET
#define G_EXT_STS_EXTr_B1000X_FD_CAPf_GET BCM53101_A0_G_EXT_STS_EXTr_B1000X_FD_CAPf_GET
#define G_EXT_STS_EXTr_B1000X_FD_CAPf_SET BCM53101_A0_G_EXT_STS_EXTr_B1000X_FD_CAPf_SET
#define READ_G_EXT_STS_EXTr BCM53101_A0_READ_G_EXT_STS_EXTr
#define WRITE_G_EXT_STS_EXTr BCM53101_A0_WRITE_G_EXT_STS_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_G_EXT_STS_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  G_FALSE_CARR_CNT_EXT
 * BLOCKS:   SYS
 * DESC:     External False Carrier Sense Counter
 * SIZE:     16
 * FIELDS:
 *     REC_ERR_CNT      Number of false carrier sense events since last read.Counts packets received with transmit error codes when TXERVIS bit in test register is set. Freezes at FFh.(Counts serdes errors when register 1ch shadow 11011 bit 9 = 1 otherwise copper errors)
 *     SERDES_BER_CNT   Number of invalid code groups received while sync_status = 1 since last cleared.Cleared by writing expansion register 4D bit 15 = 1.
 *
 ******************************************************************************/
#define BCM53101_A0_G_FALSE_CARR_CNT_EXTr 0x00008826

#define BCM53101_A0_G_FALSE_CARR_CNT_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_FALSE_CARR_CNT_EXT.
 *
 */
typedef union BCM53101_A0_G_FALSE_CARR_CNT_EXTr_s {
	uint32_t v[1];
	uint32_t g_false_carr_cnt_ext[1];
	uint32_t _g_false_carr_cnt_ext;
} BCM53101_A0_G_FALSE_CARR_CNT_EXTr_t;

#define BCM53101_A0_G_FALSE_CARR_CNT_EXTr_CLR(r) (r).g_false_carr_cnt_ext[0] = 0
#define BCM53101_A0_G_FALSE_CARR_CNT_EXTr_SET(r,d) (r).g_false_carr_cnt_ext[0] = d
#define BCM53101_A0_G_FALSE_CARR_CNT_EXTr_GET(r) (r).g_false_carr_cnt_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_G_FALSE_CARR_CNT_EXTr_REC_ERR_CNTf_GET(r) (((r).g_false_carr_cnt_ext[0]) & 0xff)
#define BCM53101_A0_G_FALSE_CARR_CNT_EXTr_REC_ERR_CNTf_SET(r,f) (r).g_false_carr_cnt_ext[0]=(((r).g_false_carr_cnt_ext[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53101_A0_G_FALSE_CARR_CNT_EXTr_SERDES_BER_CNTf_GET(r) ((((r).g_false_carr_cnt_ext[0]) >> 8) & 0xff)
#define BCM53101_A0_G_FALSE_CARR_CNT_EXTr_SERDES_BER_CNTf_SET(r,f) (r).g_false_carr_cnt_ext[0]=(((r).g_false_carr_cnt_ext[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access G_FALSE_CARR_CNT_EXT.
 *
 */
#define BCM53101_A0_READ_G_FALSE_CARR_CNT_EXTr(u,r) cdk_robo_reg_read(u,BCM53101_A0_G_FALSE_CARR_CNT_EXTr,(r._g_false_carr_cnt_ext),2)
#define BCM53101_A0_WRITE_G_FALSE_CARR_CNT_EXTr(u,r) cdk_robo_reg_write(u,BCM53101_A0_G_FALSE_CARR_CNT_EXTr,&(r._g_false_carr_cnt_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_FALSE_CARR_CNT_EXTr BCM53101_A0_G_FALSE_CARR_CNT_EXTr
#define G_FALSE_CARR_CNT_EXTr_SIZE BCM53101_A0_G_FALSE_CARR_CNT_EXTr_SIZE
typedef BCM53101_A0_G_FALSE_CARR_CNT_EXTr_t G_FALSE_CARR_CNT_EXTr_t;
#define G_FALSE_CARR_CNT_EXTr_CLR BCM53101_A0_G_FALSE_CARR_CNT_EXTr_CLR
#define G_FALSE_CARR_CNT_EXTr_SET BCM53101_A0_G_FALSE_CARR_CNT_EXTr_SET
#define G_FALSE_CARR_CNT_EXTr_GET BCM53101_A0_G_FALSE_CARR_CNT_EXTr_GET
#define G_FALSE_CARR_CNT_EXTr_REC_ERR_CNTf_GET BCM53101_A0_G_FALSE_CARR_CNT_EXTr_REC_ERR_CNTf_GET
#define G_FALSE_CARR_CNT_EXTr_REC_ERR_CNTf_SET BCM53101_A0_G_FALSE_CARR_CNT_EXTr_REC_ERR_CNTf_SET
#define G_FALSE_CARR_CNT_EXTr_SERDES_BER_CNTf_GET BCM53101_A0_G_FALSE_CARR_CNT_EXTr_SERDES_BER_CNTf_GET
#define G_FALSE_CARR_CNT_EXTr_SERDES_BER_CNTf_SET BCM53101_A0_G_FALSE_CARR_CNT_EXTr_SERDES_BER_CNTf_SET
#define READ_G_FALSE_CARR_CNT_EXTr BCM53101_A0_READ_G_FALSE_CARR_CNT_EXTr
#define WRITE_G_FALSE_CARR_CNT_EXTr BCM53101_A0_WRITE_G_FALSE_CARR_CNT_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_G_FALSE_CARR_CNT_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  G_INTERRUPT_MSK_EXT
 * BLOCKS:   SYS
 * DESC:     External Interrupt Mask Register
 * SIZE:     16
 * FIELDS:
 *     INTERRUPT_MSK    
 *
 ******************************************************************************/
#define BCM53101_A0_G_INTERRUPT_MSK_EXTr 0x00008836

#define BCM53101_A0_G_INTERRUPT_MSK_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_INTERRUPT_MSK_EXT.
 *
 */
typedef union BCM53101_A0_G_INTERRUPT_MSK_EXTr_s {
	uint32_t v[1];
	uint32_t g_interrupt_msk_ext[1];
	uint32_t _g_interrupt_msk_ext;
} BCM53101_A0_G_INTERRUPT_MSK_EXTr_t;

#define BCM53101_A0_G_INTERRUPT_MSK_EXTr_CLR(r) (r).g_interrupt_msk_ext[0] = 0
#define BCM53101_A0_G_INTERRUPT_MSK_EXTr_SET(r,d) (r).g_interrupt_msk_ext[0] = d
#define BCM53101_A0_G_INTERRUPT_MSK_EXTr_GET(r) (r).g_interrupt_msk_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_G_INTERRUPT_MSK_EXTr_INTERRUPT_MSKf_GET(r) (((r).g_interrupt_msk_ext[0]) & 0xffff)
#define BCM53101_A0_G_INTERRUPT_MSK_EXTr_INTERRUPT_MSKf_SET(r,f) (r).g_interrupt_msk_ext[0]=(((r).g_interrupt_msk_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_INTERRUPT_MSK_EXT.
 *
 */
#define BCM53101_A0_READ_G_INTERRUPT_MSK_EXTr(u,r) cdk_robo_reg_read(u,BCM53101_A0_G_INTERRUPT_MSK_EXTr,(r._g_interrupt_msk_ext),2)
#define BCM53101_A0_WRITE_G_INTERRUPT_MSK_EXTr(u,r) cdk_robo_reg_write(u,BCM53101_A0_G_INTERRUPT_MSK_EXTr,&(r._g_interrupt_msk_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_INTERRUPT_MSK_EXTr BCM53101_A0_G_INTERRUPT_MSK_EXTr
#define G_INTERRUPT_MSK_EXTr_SIZE BCM53101_A0_G_INTERRUPT_MSK_EXTr_SIZE
typedef BCM53101_A0_G_INTERRUPT_MSK_EXTr_t G_INTERRUPT_MSK_EXTr_t;
#define G_INTERRUPT_MSK_EXTr_CLR BCM53101_A0_G_INTERRUPT_MSK_EXTr_CLR
#define G_INTERRUPT_MSK_EXTr_SET BCM53101_A0_G_INTERRUPT_MSK_EXTr_SET
#define G_INTERRUPT_MSK_EXTr_GET BCM53101_A0_G_INTERRUPT_MSK_EXTr_GET
#define G_INTERRUPT_MSK_EXTr_INTERRUPT_MSKf_GET BCM53101_A0_G_INTERRUPT_MSK_EXTr_INTERRUPT_MSKf_GET
#define G_INTERRUPT_MSK_EXTr_INTERRUPT_MSKf_SET BCM53101_A0_G_INTERRUPT_MSK_EXTr_INTERRUPT_MSKf_SET
#define READ_G_INTERRUPT_MSK_EXTr BCM53101_A0_READ_G_INTERRUPT_MSK_EXTr
#define WRITE_G_INTERRUPT_MSK_EXTr BCM53101_A0_WRITE_G_INTERRUPT_MSK_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_G_INTERRUPT_MSK_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  G_INTERRUPT_STS_EXT
 * BLOCKS:   SYS
 * DESC:     External Interrupt Status Register
 * SIZE:     16
 * FIELDS:
 *     INTERRUPT_STS    
 *
 ******************************************************************************/
#define BCM53101_A0_G_INTERRUPT_STS_EXTr 0x00008834

#define BCM53101_A0_G_INTERRUPT_STS_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_INTERRUPT_STS_EXT.
 *
 */
typedef union BCM53101_A0_G_INTERRUPT_STS_EXTr_s {
	uint32_t v[1];
	uint32_t g_interrupt_sts_ext[1];
	uint32_t _g_interrupt_sts_ext;
} BCM53101_A0_G_INTERRUPT_STS_EXTr_t;

#define BCM53101_A0_G_INTERRUPT_STS_EXTr_CLR(r) (r).g_interrupt_sts_ext[0] = 0
#define BCM53101_A0_G_INTERRUPT_STS_EXTr_SET(r,d) (r).g_interrupt_sts_ext[0] = d
#define BCM53101_A0_G_INTERRUPT_STS_EXTr_GET(r) (r).g_interrupt_sts_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_G_INTERRUPT_STS_EXTr_INTERRUPT_STSf_GET(r) (((r).g_interrupt_sts_ext[0]) & 0xffff)
#define BCM53101_A0_G_INTERRUPT_STS_EXTr_INTERRUPT_STSf_SET(r,f) (r).g_interrupt_sts_ext[0]=(((r).g_interrupt_sts_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_INTERRUPT_STS_EXT.
 *
 */
#define BCM53101_A0_READ_G_INTERRUPT_STS_EXTr(u,r) cdk_robo_reg_read(u,BCM53101_A0_G_INTERRUPT_STS_EXTr,(r._g_interrupt_sts_ext),2)
#define BCM53101_A0_WRITE_G_INTERRUPT_STS_EXTr(u,r) cdk_robo_reg_write(u,BCM53101_A0_G_INTERRUPT_STS_EXTr,&(r._g_interrupt_sts_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_INTERRUPT_STS_EXTr BCM53101_A0_G_INTERRUPT_STS_EXTr
#define G_INTERRUPT_STS_EXTr_SIZE BCM53101_A0_G_INTERRUPT_STS_EXTr_SIZE
typedef BCM53101_A0_G_INTERRUPT_STS_EXTr_t G_INTERRUPT_STS_EXTr_t;
#define G_INTERRUPT_STS_EXTr_CLR BCM53101_A0_G_INTERRUPT_STS_EXTr_CLR
#define G_INTERRUPT_STS_EXTr_SET BCM53101_A0_G_INTERRUPT_STS_EXTr_SET
#define G_INTERRUPT_STS_EXTr_GET BCM53101_A0_G_INTERRUPT_STS_EXTr_GET
#define G_INTERRUPT_STS_EXTr_INTERRUPT_STSf_GET BCM53101_A0_G_INTERRUPT_STS_EXTr_INTERRUPT_STSf_GET
#define G_INTERRUPT_STS_EXTr_INTERRUPT_STSf_SET BCM53101_A0_G_INTERRUPT_STS_EXTr_INTERRUPT_STSf_SET
#define READ_G_INTERRUPT_STS_EXTr BCM53101_A0_READ_G_INTERRUPT_STS_EXTr
#define WRITE_G_INTERRUPT_STS_EXTr BCM53101_A0_WRITE_G_INTERRUPT_STS_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_G_INTERRUPT_STS_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  G_LPNXP_EXT
 * BLOCKS:   SYS
 * DESC:     External Link Partner next Page Ability Register
 * SIZE:     16
 * FIELDS:
 *     CODE_FIELD       message code field or unformatted code field.
 *     TOGGLE           1 = sent 0 during previous Link Code Word0 = sent 1 during previous Link Code Word.
 *     ACKNOWLEDGE_2    1 = will comply with message (not used during 1000Base-T next pages)0 = cannot comply with message
 *     MES_PAGE         1 = message page,0 = unformatted page.
 *     ACK              1 = acknowledge,0 = no acknowledge.
 *     NEXT_PAGE        1 = additional next pages will follow,0 = sending last page.
 *
 ******************************************************************************/
#define BCM53101_A0_G_LPNXP_EXTr 0x00008810

#define BCM53101_A0_G_LPNXP_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_LPNXP_EXT.
 *
 */
typedef union BCM53101_A0_G_LPNXP_EXTr_s {
	uint32_t v[1];
	uint32_t g_lpnxp_ext[1];
	uint32_t _g_lpnxp_ext;
} BCM53101_A0_G_LPNXP_EXTr_t;

#define BCM53101_A0_G_LPNXP_EXTr_CLR(r) (r).g_lpnxp_ext[0] = 0
#define BCM53101_A0_G_LPNXP_EXTr_SET(r,d) (r).g_lpnxp_ext[0] = d
#define BCM53101_A0_G_LPNXP_EXTr_GET(r) (r).g_lpnxp_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_G_LPNXP_EXTr_CODE_FIELDf_GET(r) ((((r).g_lpnxp_ext[0]) >> 5) & 0x1)
#define BCM53101_A0_G_LPNXP_EXTr_CODE_FIELDf_SET(r,f) (r).g_lpnxp_ext[0]=(((r).g_lpnxp_ext[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_G_LPNXP_EXTr_TOGGLEf_GET(r) ((((r).g_lpnxp_ext[0]) >> 11) & 0x1)
#define BCM53101_A0_G_LPNXP_EXTr_TOGGLEf_SET(r,f) (r).g_lpnxp_ext[0]=(((r).g_lpnxp_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53101_A0_G_LPNXP_EXTr_ACKNOWLEDGE_2f_GET(r) ((((r).g_lpnxp_ext[0]) >> 12) & 0x1)
#define BCM53101_A0_G_LPNXP_EXTr_ACKNOWLEDGE_2f_SET(r,f) (r).g_lpnxp_ext[0]=(((r).g_lpnxp_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53101_A0_G_LPNXP_EXTr_MES_PAGEf_GET(r) ((((r).g_lpnxp_ext[0]) >> 13) & 0x1)
#define BCM53101_A0_G_LPNXP_EXTr_MES_PAGEf_SET(r,f) (r).g_lpnxp_ext[0]=(((r).g_lpnxp_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53101_A0_G_LPNXP_EXTr_ACKf_GET(r) ((((r).g_lpnxp_ext[0]) >> 14) & 0x1)
#define BCM53101_A0_G_LPNXP_EXTr_ACKf_SET(r,f) (r).g_lpnxp_ext[0]=(((r).g_lpnxp_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_G_LPNXP_EXTr_NEXT_PAGEf_GET(r) ((((r).g_lpnxp_ext[0]) >> 15) & 0x1)
#define BCM53101_A0_G_LPNXP_EXTr_NEXT_PAGEf_SET(r,f) (r).g_lpnxp_ext[0]=(((r).g_lpnxp_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_LPNXP_EXT.
 *
 */
#define BCM53101_A0_READ_G_LPNXP_EXTr(u,r) cdk_robo_reg_read(u,BCM53101_A0_G_LPNXP_EXTr,(r._g_lpnxp_ext),2)
#define BCM53101_A0_WRITE_G_LPNXP_EXTr(u,r) cdk_robo_reg_write(u,BCM53101_A0_G_LPNXP_EXTr,&(r._g_lpnxp_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_LPNXP_EXTr BCM53101_A0_G_LPNXP_EXTr
#define G_LPNXP_EXTr_SIZE BCM53101_A0_G_LPNXP_EXTr_SIZE
typedef BCM53101_A0_G_LPNXP_EXTr_t G_LPNXP_EXTr_t;
#define G_LPNXP_EXTr_CLR BCM53101_A0_G_LPNXP_EXTr_CLR
#define G_LPNXP_EXTr_SET BCM53101_A0_G_LPNXP_EXTr_SET
#define G_LPNXP_EXTr_GET BCM53101_A0_G_LPNXP_EXTr_GET
#define G_LPNXP_EXTr_CODE_FIELDf_GET BCM53101_A0_G_LPNXP_EXTr_CODE_FIELDf_GET
#define G_LPNXP_EXTr_CODE_FIELDf_SET BCM53101_A0_G_LPNXP_EXTr_CODE_FIELDf_SET
#define G_LPNXP_EXTr_TOGGLEf_GET BCM53101_A0_G_LPNXP_EXTr_TOGGLEf_GET
#define G_LPNXP_EXTr_TOGGLEf_SET BCM53101_A0_G_LPNXP_EXTr_TOGGLEf_SET
#define G_LPNXP_EXTr_ACKNOWLEDGE_2f_GET BCM53101_A0_G_LPNXP_EXTr_ACKNOWLEDGE_2f_GET
#define G_LPNXP_EXTr_ACKNOWLEDGE_2f_SET BCM53101_A0_G_LPNXP_EXTr_ACKNOWLEDGE_2f_SET
#define G_LPNXP_EXTr_MES_PAGEf_GET BCM53101_A0_G_LPNXP_EXTr_MES_PAGEf_GET
#define G_LPNXP_EXTr_MES_PAGEf_SET BCM53101_A0_G_LPNXP_EXTr_MES_PAGEf_SET
#define G_LPNXP_EXTr_ACKf_GET BCM53101_A0_G_LPNXP_EXTr_ACKf_GET
#define G_LPNXP_EXTr_ACKf_SET BCM53101_A0_G_LPNXP_EXTr_ACKf_SET
#define G_LPNXP_EXTr_NEXT_PAGEf_GET BCM53101_A0_G_LPNXP_EXTr_NEXT_PAGEf_GET
#define G_LPNXP_EXTr_NEXT_PAGEf_SET BCM53101_A0_G_LPNXP_EXTr_NEXT_PAGEf_SET
#define READ_G_LPNXP_EXTr BCM53101_A0_READ_G_LPNXP_EXTr
#define WRITE_G_LPNXP_EXTr BCM53101_A0_WRITE_G_LPNXP_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_G_LPNXP_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  G_MASTER_SLAVE_SEED_EXT
 * BLOCKS:   SYS
 * DESC:     External Master/Slave Seed Register
 * SIZE:     16
 * FIELDS:
 *     SEED             Shadow Register:1 => HCD Status
 *
 ******************************************************************************/
#define BCM53101_A0_G_MASTER_SLAVE_SEED_EXTr 0x0000883a

#define BCM53101_A0_G_MASTER_SLAVE_SEED_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_MASTER_SLAVE_SEED_EXT.
 *
 */
typedef union BCM53101_A0_G_MASTER_SLAVE_SEED_EXTr_s {
	uint32_t v[1];
	uint32_t g_master_slave_seed_ext[1];
	uint32_t _g_master_slave_seed_ext;
} BCM53101_A0_G_MASTER_SLAVE_SEED_EXTr_t;

#define BCM53101_A0_G_MASTER_SLAVE_SEED_EXTr_CLR(r) (r).g_master_slave_seed_ext[0] = 0
#define BCM53101_A0_G_MASTER_SLAVE_SEED_EXTr_SET(r,d) (r).g_master_slave_seed_ext[0] = d
#define BCM53101_A0_G_MASTER_SLAVE_SEED_EXTr_GET(r) (r).g_master_slave_seed_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_G_MASTER_SLAVE_SEED_EXTr_SEEDf_GET(r) (((r).g_master_slave_seed_ext[0]) & 0xffff)
#define BCM53101_A0_G_MASTER_SLAVE_SEED_EXTr_SEEDf_SET(r,f) (r).g_master_slave_seed_ext[0]=(((r).g_master_slave_seed_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_MASTER_SLAVE_SEED_EXT.
 *
 */
#define BCM53101_A0_READ_G_MASTER_SLAVE_SEED_EXTr(u,r) cdk_robo_reg_read(u,BCM53101_A0_G_MASTER_SLAVE_SEED_EXTr,(r._g_master_slave_seed_ext),2)
#define BCM53101_A0_WRITE_G_MASTER_SLAVE_SEED_EXTr(u,r) cdk_robo_reg_write(u,BCM53101_A0_G_MASTER_SLAVE_SEED_EXTr,&(r._g_master_slave_seed_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MASTER_SLAVE_SEED_EXTr BCM53101_A0_G_MASTER_SLAVE_SEED_EXTr
#define G_MASTER_SLAVE_SEED_EXTr_SIZE BCM53101_A0_G_MASTER_SLAVE_SEED_EXTr_SIZE
typedef BCM53101_A0_G_MASTER_SLAVE_SEED_EXTr_t G_MASTER_SLAVE_SEED_EXTr_t;
#define G_MASTER_SLAVE_SEED_EXTr_CLR BCM53101_A0_G_MASTER_SLAVE_SEED_EXTr_CLR
#define G_MASTER_SLAVE_SEED_EXTr_SET BCM53101_A0_G_MASTER_SLAVE_SEED_EXTr_SET
#define G_MASTER_SLAVE_SEED_EXTr_GET BCM53101_A0_G_MASTER_SLAVE_SEED_EXTr_GET
#define G_MASTER_SLAVE_SEED_EXTr_SEEDf_GET BCM53101_A0_G_MASTER_SLAVE_SEED_EXTr_SEEDf_GET
#define G_MASTER_SLAVE_SEED_EXTr_SEEDf_SET BCM53101_A0_G_MASTER_SLAVE_SEED_EXTr_SEEDf_SET
#define READ_G_MASTER_SLAVE_SEED_EXTr BCM53101_A0_READ_G_MASTER_SLAVE_SEED_EXTr
#define WRITE_G_MASTER_SLAVE_SEED_EXTr BCM53101_A0_WRITE_G_MASTER_SLAVE_SEED_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_G_MASTER_SLAVE_SEED_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  G_MIICTL_EXT
 * BLOCKS:   SYS
 * DESC:     External MII Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         External Ignore when read.
 *     SPD_SEL_MSB      {SPD_SEL_MSB, SPD_SEL_LSB}11 = Reserved10 = 1000 Mbit/s01 = 100 Mbit/s00 = 10 Mbit/s
 *     COL_TEST         1 = collision test mode enabled,0 = collision test mode disabled.
 *     DUPLEX_MOD       1: Full Duplex.0: Half Duplex.
 *     RE_AN            RESTART AUTO-NEGOTIATION.1: Restart Auto-Negotiation process.0: Normal operation.
 *     ISOLATE          1: Electrically isolate PHY from MII.0: Normal operation.
 *     PWR_DOWN         1:low power mode,0:Normal operation.
 *     AN_EN            1: Auto-Negotiation Enable.0: Auto-Negotiation disable.
 *     SPD_SEL_LSB      {SPD_SEL_MSB, SPD_SEL_LSB}11 = Reserved10 = 1000 Mbit/s01 = 100 Mbit/s00 = 10 Mbit/s
 *     LOOPBACK         1: Loopback mode.0: Normal operation.
 *     RESET            1: PHY reset.0: Normal operation.
 *
 ******************************************************************************/
#define BCM53101_A0_G_MIICTL_EXTr 0x00008800

#define BCM53101_A0_G_MIICTL_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_MIICTL_EXT.
 *
 */
typedef union BCM53101_A0_G_MIICTL_EXTr_s {
	uint32_t v[1];
	uint32_t g_miictl_ext[1];
	uint32_t _g_miictl_ext;
} BCM53101_A0_G_MIICTL_EXTr_t;

#define BCM53101_A0_G_MIICTL_EXTr_CLR(r) (r).g_miictl_ext[0] = 0
#define BCM53101_A0_G_MIICTL_EXTr_SET(r,d) (r).g_miictl_ext[0] = d
#define BCM53101_A0_G_MIICTL_EXTr_GET(r) (r).g_miictl_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_G_MIICTL_EXTr_RESERVEDf_GET(r) (((r).g_miictl_ext[0]) & 0x3f)
#define BCM53101_A0_G_MIICTL_EXTr_RESERVEDf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53101_A0_G_MIICTL_EXTr_SPD_SEL_MSBf_GET(r) ((((r).g_miictl_ext[0]) >> 6) & 0x1)
#define BCM53101_A0_G_MIICTL_EXTr_SPD_SEL_MSBf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_G_MIICTL_EXTr_COL_TESTf_GET(r) ((((r).g_miictl_ext[0]) >> 7) & 0x1)
#define BCM53101_A0_G_MIICTL_EXTr_COL_TESTf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53101_A0_G_MIICTL_EXTr_DUPLEX_MODf_GET(r) ((((r).g_miictl_ext[0]) >> 8) & 0x1)
#define BCM53101_A0_G_MIICTL_EXTr_DUPLEX_MODf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53101_A0_G_MIICTL_EXTr_RE_ANf_GET(r) ((((r).g_miictl_ext[0]) >> 9) & 0x1)
#define BCM53101_A0_G_MIICTL_EXTr_RE_ANf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53101_A0_G_MIICTL_EXTr_ISOLATEf_GET(r) ((((r).g_miictl_ext[0]) >> 10) & 0x1)
#define BCM53101_A0_G_MIICTL_EXTr_ISOLATEf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53101_A0_G_MIICTL_EXTr_PWR_DOWNf_GET(r) ((((r).g_miictl_ext[0]) >> 11) & 0x1)
#define BCM53101_A0_G_MIICTL_EXTr_PWR_DOWNf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53101_A0_G_MIICTL_EXTr_AN_ENf_GET(r) ((((r).g_miictl_ext[0]) >> 12) & 0x1)
#define BCM53101_A0_G_MIICTL_EXTr_AN_ENf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53101_A0_G_MIICTL_EXTr_SPD_SEL_LSBf_GET(r) ((((r).g_miictl_ext[0]) >> 13) & 0x1)
#define BCM53101_A0_G_MIICTL_EXTr_SPD_SEL_LSBf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53101_A0_G_MIICTL_EXTr_LOOPBACKf_GET(r) ((((r).g_miictl_ext[0]) >> 14) & 0x1)
#define BCM53101_A0_G_MIICTL_EXTr_LOOPBACKf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_G_MIICTL_EXTr_RESETf_GET(r) ((((r).g_miictl_ext[0]) >> 15) & 0x1)
#define BCM53101_A0_G_MIICTL_EXTr_RESETf_SET(r,f) (r).g_miictl_ext[0]=(((r).g_miictl_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_MIICTL_EXT.
 *
 */
#define BCM53101_A0_READ_G_MIICTL_EXTr(u,r) cdk_robo_reg_read(u,BCM53101_A0_G_MIICTL_EXTr,(r._g_miictl_ext),2)
#define BCM53101_A0_WRITE_G_MIICTL_EXTr(u,r) cdk_robo_reg_write(u,BCM53101_A0_G_MIICTL_EXTr,&(r._g_miictl_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MIICTL_EXTr BCM53101_A0_G_MIICTL_EXTr
#define G_MIICTL_EXTr_SIZE BCM53101_A0_G_MIICTL_EXTr_SIZE
typedef BCM53101_A0_G_MIICTL_EXTr_t G_MIICTL_EXTr_t;
#define G_MIICTL_EXTr_CLR BCM53101_A0_G_MIICTL_EXTr_CLR
#define G_MIICTL_EXTr_SET BCM53101_A0_G_MIICTL_EXTr_SET
#define G_MIICTL_EXTr_GET BCM53101_A0_G_MIICTL_EXTr_GET
#define G_MIICTL_EXTr_RESERVEDf_GET BCM53101_A0_G_MIICTL_EXTr_RESERVEDf_GET
#define G_MIICTL_EXTr_RESERVEDf_SET BCM53101_A0_G_MIICTL_EXTr_RESERVEDf_SET
#define G_MIICTL_EXTr_SPD_SEL_MSBf_GET BCM53101_A0_G_MIICTL_EXTr_SPD_SEL_MSBf_GET
#define G_MIICTL_EXTr_SPD_SEL_MSBf_SET BCM53101_A0_G_MIICTL_EXTr_SPD_SEL_MSBf_SET
#define G_MIICTL_EXTr_COL_TESTf_GET BCM53101_A0_G_MIICTL_EXTr_COL_TESTf_GET
#define G_MIICTL_EXTr_COL_TESTf_SET BCM53101_A0_G_MIICTL_EXTr_COL_TESTf_SET
#define G_MIICTL_EXTr_DUPLEX_MODf_GET BCM53101_A0_G_MIICTL_EXTr_DUPLEX_MODf_GET
#define G_MIICTL_EXTr_DUPLEX_MODf_SET BCM53101_A0_G_MIICTL_EXTr_DUPLEX_MODf_SET
#define G_MIICTL_EXTr_RE_ANf_GET BCM53101_A0_G_MIICTL_EXTr_RE_ANf_GET
#define G_MIICTL_EXTr_RE_ANf_SET BCM53101_A0_G_MIICTL_EXTr_RE_ANf_SET
#define G_MIICTL_EXTr_ISOLATEf_GET BCM53101_A0_G_MIICTL_EXTr_ISOLATEf_GET
#define G_MIICTL_EXTr_ISOLATEf_SET BCM53101_A0_G_MIICTL_EXTr_ISOLATEf_SET
#define G_MIICTL_EXTr_PWR_DOWNf_GET BCM53101_A0_G_MIICTL_EXTr_PWR_DOWNf_GET
#define G_MIICTL_EXTr_PWR_DOWNf_SET BCM53101_A0_G_MIICTL_EXTr_PWR_DOWNf_SET
#define G_MIICTL_EXTr_AN_ENf_GET BCM53101_A0_G_MIICTL_EXTr_AN_ENf_GET
#define G_MIICTL_EXTr_AN_ENf_SET BCM53101_A0_G_MIICTL_EXTr_AN_ENf_SET
#define G_MIICTL_EXTr_SPD_SEL_LSBf_GET BCM53101_A0_G_MIICTL_EXTr_SPD_SEL_LSBf_GET
#define G_MIICTL_EXTr_SPD_SEL_LSBf_SET BCM53101_A0_G_MIICTL_EXTr_SPD_SEL_LSBf_SET
#define G_MIICTL_EXTr_LOOPBACKf_GET BCM53101_A0_G_MIICTL_EXTr_LOOPBACKf_GET
#define G_MIICTL_EXTr_LOOPBACKf_SET BCM53101_A0_G_MIICTL_EXTr_LOOPBACKf_SET
#define G_MIICTL_EXTr_RESETf_GET BCM53101_A0_G_MIICTL_EXTr_RESETf_GET
#define G_MIICTL_EXTr_RESETf_SET BCM53101_A0_G_MIICTL_EXTr_RESETf_SET
#define READ_G_MIICTL_EXTr BCM53101_A0_READ_G_MIICTL_EXTr
#define WRITE_G_MIICTL_EXTr BCM53101_A0_WRITE_G_MIICTL_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_G_MIICTL_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  G_MIISTS_EXT
 * BLOCKS:   SYS
 * DESC:     External MII Status Register
 * SIZE:     16
 * FIELDS:
 *     EXT_CAP          1 = extended register capabilities supported0 = basic register set capabilities only
 *     JABBER_DET       1 = jabber condition detected0 = no jabber condition detected
 *     LINK_STA         1 = link pass0 = link fail
 *     AUTO_NEGO_CAP    1 = auto-negotiation capable0 = not auto-negotiation capable
 *     REMOTE_FAULT     1 = remote fault detected0 = no remote fault detected
 *     AUTO_NEGO_COMP   1 = auto-negotiation complete0 = auto-negotiation in progress
 *     MF_PRE_SUP       1 = PHY will accept management frames with preamble suppressed0 = PHY will not accept management frames with preamble suppressed
 *     RESERVED         Reserved.
 *     EXT_STS          1 = extended status information in register 0Fh0 = no extended status info in register 0Fh
 *     B100T2_HD_CAP    1 = 100Base-T2 half duplex capable0 = not 100Base-T2 half duplex capable
 *     B100T2_FD_CAP    1 = 100Base-T2 full duplex capable0 = not 100Base-T2 full duplex capable
 *     B10T_CAP         1 = 10Base-T half duplex capable0 = not 10Base-T half duplex capable
 *     B10T_FDX_CAP     1 = 10Base-T full duplex capable0 = not 10Base-T full duplex capable
 *     B100TX_CAP       1 = 100Base-X half duplex capable0 = not 100Base-X half duplex capable
 *     B100TX_FDX_CAP   1 = 100Base-X full duplex capable0 = not 100Base-X full duplex capable
 *     B100T4_CAP       1 = 100Base-T4 capable0 = not 100Base-T4 capable
 *
 ******************************************************************************/
#define BCM53101_A0_G_MIISTS_EXTr 0x00008802

#define BCM53101_A0_G_MIISTS_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_MIISTS_EXT.
 *
 */
typedef union BCM53101_A0_G_MIISTS_EXTr_s {
	uint32_t v[1];
	uint32_t g_miists_ext[1];
	uint32_t _g_miists_ext;
} BCM53101_A0_G_MIISTS_EXTr_t;

#define BCM53101_A0_G_MIISTS_EXTr_CLR(r) (r).g_miists_ext[0] = 0
#define BCM53101_A0_G_MIISTS_EXTr_SET(r,d) (r).g_miists_ext[0] = d
#define BCM53101_A0_G_MIISTS_EXTr_GET(r) (r).g_miists_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_G_MIISTS_EXTr_EXT_CAPf_GET(r) (((r).g_miists_ext[0]) & 0x1)
#define BCM53101_A0_G_MIISTS_EXTr_EXT_CAPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_G_MIISTS_EXTr_JABBER_DETf_GET(r) ((((r).g_miists_ext[0]) >> 1) & 0x1)
#define BCM53101_A0_G_MIISTS_EXTr_JABBER_DETf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_G_MIISTS_EXTr_LINK_STAf_GET(r) ((((r).g_miists_ext[0]) >> 2) & 0x1)
#define BCM53101_A0_G_MIISTS_EXTr_LINK_STAf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_G_MIISTS_EXTr_AUTO_NEGO_CAPf_GET(r) ((((r).g_miists_ext[0]) >> 3) & 0x1)
#define BCM53101_A0_G_MIISTS_EXTr_AUTO_NEGO_CAPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_G_MIISTS_EXTr_REMOTE_FAULTf_GET(r) ((((r).g_miists_ext[0]) >> 4) & 0x1)
#define BCM53101_A0_G_MIISTS_EXTr_REMOTE_FAULTf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_G_MIISTS_EXTr_AUTO_NEGO_COMPf_GET(r) ((((r).g_miists_ext[0]) >> 5) & 0x1)
#define BCM53101_A0_G_MIISTS_EXTr_AUTO_NEGO_COMPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_G_MIISTS_EXTr_MF_PRE_SUPf_GET(r) ((((r).g_miists_ext[0]) >> 6) & 0x1)
#define BCM53101_A0_G_MIISTS_EXTr_MF_PRE_SUPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_G_MIISTS_EXTr_RESERVEDf_GET(r) ((((r).g_miists_ext[0]) >> 7) & 0x1)
#define BCM53101_A0_G_MIISTS_EXTr_RESERVEDf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53101_A0_G_MIISTS_EXTr_EXT_STSf_GET(r) ((((r).g_miists_ext[0]) >> 8) & 0x1)
#define BCM53101_A0_G_MIISTS_EXTr_EXT_STSf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53101_A0_G_MIISTS_EXTr_B100T2_HD_CAPf_GET(r) ((((r).g_miists_ext[0]) >> 9) & 0x1)
#define BCM53101_A0_G_MIISTS_EXTr_B100T2_HD_CAPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53101_A0_G_MIISTS_EXTr_B100T2_FD_CAPf_GET(r) ((((r).g_miists_ext[0]) >> 10) & 0x1)
#define BCM53101_A0_G_MIISTS_EXTr_B100T2_FD_CAPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53101_A0_G_MIISTS_EXTr_B10T_CAPf_GET(r) ((((r).g_miists_ext[0]) >> 11) & 0x1)
#define BCM53101_A0_G_MIISTS_EXTr_B10T_CAPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53101_A0_G_MIISTS_EXTr_B10T_FDX_CAPf_GET(r) ((((r).g_miists_ext[0]) >> 12) & 0x1)
#define BCM53101_A0_G_MIISTS_EXTr_B10T_FDX_CAPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53101_A0_G_MIISTS_EXTr_B100TX_CAPf_GET(r) ((((r).g_miists_ext[0]) >> 13) & 0x1)
#define BCM53101_A0_G_MIISTS_EXTr_B100TX_CAPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53101_A0_G_MIISTS_EXTr_B100TX_FDX_CAPf_GET(r) ((((r).g_miists_ext[0]) >> 14) & 0x1)
#define BCM53101_A0_G_MIISTS_EXTr_B100TX_FDX_CAPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_G_MIISTS_EXTr_B100T4_CAPf_GET(r) ((((r).g_miists_ext[0]) >> 15) & 0x1)
#define BCM53101_A0_G_MIISTS_EXTr_B100T4_CAPf_SET(r,f) (r).g_miists_ext[0]=(((r).g_miists_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_MIISTS_EXT.
 *
 */
#define BCM53101_A0_READ_G_MIISTS_EXTr(u,r) cdk_robo_reg_read(u,BCM53101_A0_G_MIISTS_EXTr,(r._g_miists_ext),2)
#define BCM53101_A0_WRITE_G_MIISTS_EXTr(u,r) cdk_robo_reg_write(u,BCM53101_A0_G_MIISTS_EXTr,&(r._g_miists_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MIISTS_EXTr BCM53101_A0_G_MIISTS_EXTr
#define G_MIISTS_EXTr_SIZE BCM53101_A0_G_MIISTS_EXTr_SIZE
typedef BCM53101_A0_G_MIISTS_EXTr_t G_MIISTS_EXTr_t;
#define G_MIISTS_EXTr_CLR BCM53101_A0_G_MIISTS_EXTr_CLR
#define G_MIISTS_EXTr_SET BCM53101_A0_G_MIISTS_EXTr_SET
#define G_MIISTS_EXTr_GET BCM53101_A0_G_MIISTS_EXTr_GET
#define G_MIISTS_EXTr_EXT_CAPf_GET BCM53101_A0_G_MIISTS_EXTr_EXT_CAPf_GET
#define G_MIISTS_EXTr_EXT_CAPf_SET BCM53101_A0_G_MIISTS_EXTr_EXT_CAPf_SET
#define G_MIISTS_EXTr_JABBER_DETf_GET BCM53101_A0_G_MIISTS_EXTr_JABBER_DETf_GET
#define G_MIISTS_EXTr_JABBER_DETf_SET BCM53101_A0_G_MIISTS_EXTr_JABBER_DETf_SET
#define G_MIISTS_EXTr_LINK_STAf_GET BCM53101_A0_G_MIISTS_EXTr_LINK_STAf_GET
#define G_MIISTS_EXTr_LINK_STAf_SET BCM53101_A0_G_MIISTS_EXTr_LINK_STAf_SET
#define G_MIISTS_EXTr_AUTO_NEGO_CAPf_GET BCM53101_A0_G_MIISTS_EXTr_AUTO_NEGO_CAPf_GET
#define G_MIISTS_EXTr_AUTO_NEGO_CAPf_SET BCM53101_A0_G_MIISTS_EXTr_AUTO_NEGO_CAPf_SET
#define G_MIISTS_EXTr_REMOTE_FAULTf_GET BCM53101_A0_G_MIISTS_EXTr_REMOTE_FAULTf_GET
#define G_MIISTS_EXTr_REMOTE_FAULTf_SET BCM53101_A0_G_MIISTS_EXTr_REMOTE_FAULTf_SET
#define G_MIISTS_EXTr_AUTO_NEGO_COMPf_GET BCM53101_A0_G_MIISTS_EXTr_AUTO_NEGO_COMPf_GET
#define G_MIISTS_EXTr_AUTO_NEGO_COMPf_SET BCM53101_A0_G_MIISTS_EXTr_AUTO_NEGO_COMPf_SET
#define G_MIISTS_EXTr_MF_PRE_SUPf_GET BCM53101_A0_G_MIISTS_EXTr_MF_PRE_SUPf_GET
#define G_MIISTS_EXTr_MF_PRE_SUPf_SET BCM53101_A0_G_MIISTS_EXTr_MF_PRE_SUPf_SET
#define G_MIISTS_EXTr_RESERVEDf_GET BCM53101_A0_G_MIISTS_EXTr_RESERVEDf_GET
#define G_MIISTS_EXTr_RESERVEDf_SET BCM53101_A0_G_MIISTS_EXTr_RESERVEDf_SET
#define G_MIISTS_EXTr_EXT_STSf_GET BCM53101_A0_G_MIISTS_EXTr_EXT_STSf_GET
#define G_MIISTS_EXTr_EXT_STSf_SET BCM53101_A0_G_MIISTS_EXTr_EXT_STSf_SET
#define G_MIISTS_EXTr_B100T2_HD_CAPf_GET BCM53101_A0_G_MIISTS_EXTr_B100T2_HD_CAPf_GET
#define G_MIISTS_EXTr_B100T2_HD_CAPf_SET BCM53101_A0_G_MIISTS_EXTr_B100T2_HD_CAPf_SET
#define G_MIISTS_EXTr_B100T2_FD_CAPf_GET BCM53101_A0_G_MIISTS_EXTr_B100T2_FD_CAPf_GET
#define G_MIISTS_EXTr_B100T2_FD_CAPf_SET BCM53101_A0_G_MIISTS_EXTr_B100T2_FD_CAPf_SET
#define G_MIISTS_EXTr_B10T_CAPf_GET BCM53101_A0_G_MIISTS_EXTr_B10T_CAPf_GET
#define G_MIISTS_EXTr_B10T_CAPf_SET BCM53101_A0_G_MIISTS_EXTr_B10T_CAPf_SET
#define G_MIISTS_EXTr_B10T_FDX_CAPf_GET BCM53101_A0_G_MIISTS_EXTr_B10T_FDX_CAPf_GET
#define G_MIISTS_EXTr_B10T_FDX_CAPf_SET BCM53101_A0_G_MIISTS_EXTr_B10T_FDX_CAPf_SET
#define G_MIISTS_EXTr_B100TX_CAPf_GET BCM53101_A0_G_MIISTS_EXTr_B100TX_CAPf_GET
#define G_MIISTS_EXTr_B100TX_CAPf_SET BCM53101_A0_G_MIISTS_EXTr_B100TX_CAPf_SET
#define G_MIISTS_EXTr_B100TX_FDX_CAPf_GET BCM53101_A0_G_MIISTS_EXTr_B100TX_FDX_CAPf_GET
#define G_MIISTS_EXTr_B100TX_FDX_CAPf_SET BCM53101_A0_G_MIISTS_EXTr_B100TX_FDX_CAPf_SET
#define G_MIISTS_EXTr_B100T4_CAPf_GET BCM53101_A0_G_MIISTS_EXTr_B100T4_CAPf_GET
#define G_MIISTS_EXTr_B100T4_CAPf_SET BCM53101_A0_G_MIISTS_EXTr_B100T4_CAPf_SET
#define READ_G_MIISTS_EXTr BCM53101_A0_READ_G_MIISTS_EXTr
#define WRITE_G_MIISTS_EXTr BCM53101_A0_WRITE_G_MIISTS_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_G_MIISTS_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  G_MISC_SHADOW_EXT
 * BLOCKS:   SYS
 * DESC:     External Miscellaneous Shadow Registers
 * SIZE:     16
 * FIELDS:
 *     INTERRUPT_MSK    00000 => Cabletron LED modes00001 => DLL Control00010 => Spare Control 100011 => Clock Aligner00100 => Spare Control 200101 => Spare Control 300110 => TDR Control 100111 => TDR Control 201000 => Led Status01001 => Led Control01010 => Auto-Power Down01011 => External Control 101100 => External Control 201101 => LED Selector 101110 => LED Selector 201111 => LED GPIO Control/Status10000 => CISCO Enhanced Linkstatus Mode Control10001 => Serdes 100-FX Status10010 => Serdes 100-FX Test10011 => Serdes 100-FX Control10100 => External Serdes Control10101 => Sgmii Slave Control10110 => Misc 1000X Control 210111 => Misc 1000X Control11000 => Auto-Detect SGMII/GBIC11001 => Test 1000X11010 => Autoneg 1000X Debug11011 => Auxiliary 1000X Control11100 => Auxiliary 1000X Status11101 => Misc 1000X Status11110 => Auto-Detect Medium11111 => Mode Control
 *
 ******************************************************************************/
#define BCM53101_A0_G_MISC_SHADOW_EXTr 0x00008838

#define BCM53101_A0_G_MISC_SHADOW_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_MISC_SHADOW_EXT.
 *
 */
typedef union BCM53101_A0_G_MISC_SHADOW_EXTr_s {
	uint32_t v[1];
	uint32_t g_misc_shadow_ext[1];
	uint32_t _g_misc_shadow_ext;
} BCM53101_A0_G_MISC_SHADOW_EXTr_t;

#define BCM53101_A0_G_MISC_SHADOW_EXTr_CLR(r) (r).g_misc_shadow_ext[0] = 0
#define BCM53101_A0_G_MISC_SHADOW_EXTr_SET(r,d) (r).g_misc_shadow_ext[0] = d
#define BCM53101_A0_G_MISC_SHADOW_EXTr_GET(r) (r).g_misc_shadow_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_G_MISC_SHADOW_EXTr_INTERRUPT_MSKf_GET(r) (((r).g_misc_shadow_ext[0]) & 0xffff)
#define BCM53101_A0_G_MISC_SHADOW_EXTr_INTERRUPT_MSKf_SET(r,f) (r).g_misc_shadow_ext[0]=(((r).g_misc_shadow_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_MISC_SHADOW_EXT.
 *
 */
#define BCM53101_A0_READ_G_MISC_SHADOW_EXTr(u,r) cdk_robo_reg_read(u,BCM53101_A0_G_MISC_SHADOW_EXTr,(r._g_misc_shadow_ext),2)
#define BCM53101_A0_WRITE_G_MISC_SHADOW_EXTr(u,r) cdk_robo_reg_write(u,BCM53101_A0_G_MISC_SHADOW_EXTr,&(r._g_misc_shadow_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_MISC_SHADOW_EXTr BCM53101_A0_G_MISC_SHADOW_EXTr
#define G_MISC_SHADOW_EXTr_SIZE BCM53101_A0_G_MISC_SHADOW_EXTr_SIZE
typedef BCM53101_A0_G_MISC_SHADOW_EXTr_t G_MISC_SHADOW_EXTr_t;
#define G_MISC_SHADOW_EXTr_CLR BCM53101_A0_G_MISC_SHADOW_EXTr_CLR
#define G_MISC_SHADOW_EXTr_SET BCM53101_A0_G_MISC_SHADOW_EXTr_SET
#define G_MISC_SHADOW_EXTr_GET BCM53101_A0_G_MISC_SHADOW_EXTr_GET
#define G_MISC_SHADOW_EXTr_INTERRUPT_MSKf_GET BCM53101_A0_G_MISC_SHADOW_EXTr_INTERRUPT_MSKf_GET
#define G_MISC_SHADOW_EXTr_INTERRUPT_MSKf_SET BCM53101_A0_G_MISC_SHADOW_EXTr_INTERRUPT_MSKf_SET
#define READ_G_MISC_SHADOW_EXTr BCM53101_A0_READ_G_MISC_SHADOW_EXTr
#define WRITE_G_MISC_SHADOW_EXTr BCM53101_A0_WRITE_G_MISC_SHADOW_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_G_MISC_SHADOW_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  G_PCTL
 * BLOCKS:   CPIC EPIC0
 * DESC:     10/100/1000 Port Control Register
 * SIZE:     8
 * FIELDS:
 *     RX_DIS           Disables the receive function of the port at the MAC level.
 *     TX_DIS           Disables the transmit function of the port at the MAC level.
 *     RESERVED         Reserved.
 *     G_MISTP_STATE    CPU writes the current computed states of its Spanning Tree Algorithmfor this port.3b'b000: No Spanning Tree(default by HW_FWDG_EN).3b'b001: Disable State(default by ~HW_FWDG_EN).3b'b010: Blocking State.3b'b011: Listening State.3b'b100: Learning State.3b'b101: Forwarding State.3b'b110 - 3b'b111: Reserved.Programmed frome the HW_FWDG_EN Strap Option.Can be overwritten subsequently.
 *
 ******************************************************************************/
#define BCM53101_A0_G_PCTLr 0x00000000

#define BCM53101_A0_G_PCTLr_SIZE 1

/*
 * This structure should be used to declare and program G_PCTL.
 *
 */
typedef union BCM53101_A0_G_PCTLr_s {
	uint32_t v[1];
	uint32_t g_pctl[1];
	uint32_t _g_pctl;
} BCM53101_A0_G_PCTLr_t;

#define BCM53101_A0_G_PCTLr_CLR(r) (r).g_pctl[0] = 0
#define BCM53101_A0_G_PCTLr_SET(r,d) (r).g_pctl[0] = d
#define BCM53101_A0_G_PCTLr_GET(r) (r).g_pctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_G_PCTLr_RX_DISf_GET(r) (((r).g_pctl[0]) & 0x1)
#define BCM53101_A0_G_PCTLr_RX_DISf_SET(r,f) (r).g_pctl[0]=(((r).g_pctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_G_PCTLr_TX_DISf_GET(r) ((((r).g_pctl[0]) >> 1) & 0x1)
#define BCM53101_A0_G_PCTLr_TX_DISf_SET(r,f) (r).g_pctl[0]=(((r).g_pctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_G_PCTLr_RESERVEDf_GET(r) ((((r).g_pctl[0]) >> 2) & 0x7)
#define BCM53101_A0_G_PCTLr_RESERVEDf_SET(r,f) (r).g_pctl[0]=(((r).g_pctl[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2))
#define BCM53101_A0_G_PCTLr_G_MISTP_STATEf_GET(r) ((((r).g_pctl[0]) >> 5) & 0x7)
#define BCM53101_A0_G_PCTLr_G_MISTP_STATEf_SET(r,f) (r).g_pctl[0]=(((r).g_pctl[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access G_PCTL.
 *
 */
#define BCM53101_A0_READ_G_PCTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_G_PCTLr,(r._g_pctl),1)
#define BCM53101_A0_WRITE_G_PCTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_G_PCTLr,&(r._g_pctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PCTLr BCM53101_A0_G_PCTLr
#define G_PCTLr_SIZE BCM53101_A0_G_PCTLr_SIZE
typedef BCM53101_A0_G_PCTLr_t G_PCTLr_t;
#define G_PCTLr_CLR BCM53101_A0_G_PCTLr_CLR
#define G_PCTLr_SET BCM53101_A0_G_PCTLr_SET
#define G_PCTLr_GET BCM53101_A0_G_PCTLr_GET
#define G_PCTLr_RX_DISf_GET BCM53101_A0_G_PCTLr_RX_DISf_GET
#define G_PCTLr_RX_DISf_SET BCM53101_A0_G_PCTLr_RX_DISf_SET
#define G_PCTLr_TX_DISf_GET BCM53101_A0_G_PCTLr_TX_DISf_GET
#define G_PCTLr_TX_DISf_SET BCM53101_A0_G_PCTLr_TX_DISf_SET
#define G_PCTLr_RESERVEDf_GET BCM53101_A0_G_PCTLr_RESERVEDf_GET
#define G_PCTLr_RESERVEDf_SET BCM53101_A0_G_PCTLr_RESERVEDf_SET
#define G_PCTLr_G_MISTP_STATEf_GET BCM53101_A0_G_PCTLr_G_MISTP_STATEf_GET
#define G_PCTLr_G_MISTP_STATEf_SET BCM53101_A0_G_PCTLr_G_MISTP_STATEf_SET
#define READ_G_PCTLr BCM53101_A0_READ_G_PCTLr
#define WRITE_G_PCTLr BCM53101_A0_WRITE_G_PCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_G_PCTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  G_PHYIDH_EXT
 * BLOCKS:   SYS
 * DESC:     External PHY ID High Register
 * SIZE:     16
 * FIELDS:
 *     OUI              Bits 3:18 of organizationally unique identifier.
 *
 ******************************************************************************/
#define BCM53101_A0_G_PHYIDH_EXTr 0x00008804

#define BCM53101_A0_G_PHYIDH_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_PHYIDH_EXT.
 *
 */
typedef union BCM53101_A0_G_PHYIDH_EXTr_s {
	uint32_t v[1];
	uint32_t g_phyidh_ext[1];
	uint32_t _g_phyidh_ext;
} BCM53101_A0_G_PHYIDH_EXTr_t;

#define BCM53101_A0_G_PHYIDH_EXTr_CLR(r) (r).g_phyidh_ext[0] = 0
#define BCM53101_A0_G_PHYIDH_EXTr_SET(r,d) (r).g_phyidh_ext[0] = d
#define BCM53101_A0_G_PHYIDH_EXTr_GET(r) (r).g_phyidh_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_G_PHYIDH_EXTr_OUIf_GET(r) (((r).g_phyidh_ext[0]) & 0xffff)
#define BCM53101_A0_G_PHYIDH_EXTr_OUIf_SET(r,f) (r).g_phyidh_ext[0]=(((r).g_phyidh_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_PHYIDH_EXT.
 *
 */
#define BCM53101_A0_READ_G_PHYIDH_EXTr(u,r) cdk_robo_reg_read(u,BCM53101_A0_G_PHYIDH_EXTr,(r._g_phyidh_ext),2)
#define BCM53101_A0_WRITE_G_PHYIDH_EXTr(u,r) cdk_robo_reg_write(u,BCM53101_A0_G_PHYIDH_EXTr,&(r._g_phyidh_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHYIDH_EXTr BCM53101_A0_G_PHYIDH_EXTr
#define G_PHYIDH_EXTr_SIZE BCM53101_A0_G_PHYIDH_EXTr_SIZE
typedef BCM53101_A0_G_PHYIDH_EXTr_t G_PHYIDH_EXTr_t;
#define G_PHYIDH_EXTr_CLR BCM53101_A0_G_PHYIDH_EXTr_CLR
#define G_PHYIDH_EXTr_SET BCM53101_A0_G_PHYIDH_EXTr_SET
#define G_PHYIDH_EXTr_GET BCM53101_A0_G_PHYIDH_EXTr_GET
#define G_PHYIDH_EXTr_OUIf_GET BCM53101_A0_G_PHYIDH_EXTr_OUIf_GET
#define G_PHYIDH_EXTr_OUIf_SET BCM53101_A0_G_PHYIDH_EXTr_OUIf_SET
#define READ_G_PHYIDH_EXTr BCM53101_A0_READ_G_PHYIDH_EXTr
#define WRITE_G_PHYIDH_EXTr BCM53101_A0_WRITE_G_PHYIDH_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_G_PHYIDH_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  G_PHYIDL_EXT
 * BLOCKS:   SYS
 * DESC:     External PHY ID LOW Register
 * SIZE:     16
 * FIELDS:
 *     REVISION         Device revision number (metal programmable).
 *     MODEL            Device model number (metal programmable).
 *     OUI              Bits 19:24 of organizationally unique identifier.
 *
 ******************************************************************************/
#define BCM53101_A0_G_PHYIDL_EXTr 0x00008806

#define BCM53101_A0_G_PHYIDL_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_PHYIDL_EXT.
 *
 */
typedef union BCM53101_A0_G_PHYIDL_EXTr_s {
	uint32_t v[1];
	uint32_t g_phyidl_ext[1];
	uint32_t _g_phyidl_ext;
} BCM53101_A0_G_PHYIDL_EXTr_t;

#define BCM53101_A0_G_PHYIDL_EXTr_CLR(r) (r).g_phyidl_ext[0] = 0
#define BCM53101_A0_G_PHYIDL_EXTr_SET(r,d) (r).g_phyidl_ext[0] = d
#define BCM53101_A0_G_PHYIDL_EXTr_GET(r) (r).g_phyidl_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_G_PHYIDL_EXTr_REVISIONf_GET(r) (((r).g_phyidl_ext[0]) & 0xf)
#define BCM53101_A0_G_PHYIDL_EXTr_REVISIONf_SET(r,f) (r).g_phyidl_ext[0]=(((r).g_phyidl_ext[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53101_A0_G_PHYIDL_EXTr_MODELf_GET(r) ((((r).g_phyidl_ext[0]) >> 4) & 0x3f)
#define BCM53101_A0_G_PHYIDL_EXTr_MODELf_SET(r,f) (r).g_phyidl_ext[0]=(((r).g_phyidl_ext[0] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4))
#define BCM53101_A0_G_PHYIDL_EXTr_OUIf_GET(r) ((((r).g_phyidl_ext[0]) >> 10) & 0x3f)
#define BCM53101_A0_G_PHYIDL_EXTr_OUIf_SET(r,f) (r).g_phyidl_ext[0]=(((r).g_phyidl_ext[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access G_PHYIDL_EXT.
 *
 */
#define BCM53101_A0_READ_G_PHYIDL_EXTr(u,r) cdk_robo_reg_read(u,BCM53101_A0_G_PHYIDL_EXTr,(r._g_phyidl_ext),2)
#define BCM53101_A0_WRITE_G_PHYIDL_EXTr(u,r) cdk_robo_reg_write(u,BCM53101_A0_G_PHYIDL_EXTr,&(r._g_phyidl_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHYIDL_EXTr BCM53101_A0_G_PHYIDL_EXTr
#define G_PHYIDL_EXTr_SIZE BCM53101_A0_G_PHYIDL_EXTr_SIZE
typedef BCM53101_A0_G_PHYIDL_EXTr_t G_PHYIDL_EXTr_t;
#define G_PHYIDL_EXTr_CLR BCM53101_A0_G_PHYIDL_EXTr_CLR
#define G_PHYIDL_EXTr_SET BCM53101_A0_G_PHYIDL_EXTr_SET
#define G_PHYIDL_EXTr_GET BCM53101_A0_G_PHYIDL_EXTr_GET
#define G_PHYIDL_EXTr_REVISIONf_GET BCM53101_A0_G_PHYIDL_EXTr_REVISIONf_GET
#define G_PHYIDL_EXTr_REVISIONf_SET BCM53101_A0_G_PHYIDL_EXTr_REVISIONf_SET
#define G_PHYIDL_EXTr_MODELf_GET BCM53101_A0_G_PHYIDL_EXTr_MODELf_GET
#define G_PHYIDL_EXTr_MODELf_SET BCM53101_A0_G_PHYIDL_EXTr_MODELf_SET
#define G_PHYIDL_EXTr_OUIf_GET BCM53101_A0_G_PHYIDL_EXTr_OUIf_GET
#define G_PHYIDL_EXTr_OUIf_SET BCM53101_A0_G_PHYIDL_EXTr_OUIf_SET
#define READ_G_PHYIDL_EXTr BCM53101_A0_READ_G_PHYIDL_EXTr
#define WRITE_G_PHYIDL_EXTr BCM53101_A0_WRITE_G_PHYIDL_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_G_PHYIDL_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  G_PHY_EXT_CTL_EXT
 * BLOCKS:   SYS
 * DESC:     External PHY Extended Control Register
 * SIZE:     16
 * FIELDS:
 *     B1000T_PCS_TRANS_FIFO 1 = High latency (jumbo packets),0 = Low latency (low elasticity).
 *     GMII_FIFO_MOD    0=new synchronous mode,1=old asynchronous mode.
 *     BLK_TXEN_MOD     1 = extend transmit IPGs to at least 4 nibbles in 100Base-TX mode,0 = do not extend short transmit IPGs.
 *     FORCE_LED_OFF    1 = force all LEDs into OFF state,0 = normal LED operation.
 *     FORCE_LED_ON     1 = force all LEDs into ON state,0 = normal LED operation.
 *     EN_LED_TRAFFIC_MOD 1 = LED traffic mode enabled,0 = LED traffic mode disabled.
 *     RST_SCRAMBLER    1 = reset scrambler to all 1s state0 = normal scrambler operation.
 *     BYPASS_ALIGNMENT 1 = bypass receive symbol alignment,0 = normal operation.
 *     BYPASS_NRZI_MLT3 1 = bypass NRZI/MLT3 encoder and decoder,0 = normal operation.
 *     BYPASS_SCRAMBLER 1 = bypass scrambler and descrambler,0 = normal operation.
 *     BYPASS_ENCODE    1 = bypass 4B5B encoder and decoder,0 = normal operation.
 *     FORCE_INTERRUPT  1 = force interrupt status to active,0 = normal interrupt operation.
 *     INTERRUPT_DIS    1 = interrupts disabled,0 = interrupts enabled.
 *     TRANSMIT_DIS     1 = force transmit output to high impedance,0 = normal operation.
 *     DIS_AUTO_MDI_CROS 1 = automatic MDI crossover disabled,0 = automatic MDI crossover enabled.
 *     MAC_PHY_MODE     1 = 10B interface mode0 = GMII mode.
 *
 ******************************************************************************/
#define BCM53101_A0_G_PHY_EXT_CTL_EXTr 0x00008820

#define BCM53101_A0_G_PHY_EXT_CTL_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_PHY_EXT_CTL_EXT.
 *
 */
typedef union BCM53101_A0_G_PHY_EXT_CTL_EXTr_s {
	uint32_t v[1];
	uint32_t g_phy_ext_ctl_ext[1];
	uint32_t _g_phy_ext_ctl_ext;
} BCM53101_A0_G_PHY_EXT_CTL_EXTr_t;

#define BCM53101_A0_G_PHY_EXT_CTL_EXTr_CLR(r) (r).g_phy_ext_ctl_ext[0] = 0
#define BCM53101_A0_G_PHY_EXT_CTL_EXTr_SET(r,d) (r).g_phy_ext_ctl_ext[0] = d
#define BCM53101_A0_G_PHY_EXT_CTL_EXTr_GET(r) (r).g_phy_ext_ctl_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_G_PHY_EXT_CTL_EXTr_B1000T_PCS_TRANS_FIFOf_GET(r) (((r).g_phy_ext_ctl_ext[0]) & 0x1)
#define BCM53101_A0_G_PHY_EXT_CTL_EXTr_B1000T_PCS_TRANS_FIFOf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_G_PHY_EXT_CTL_EXTr_GMII_FIFO_MODf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 1) & 0x1)
#define BCM53101_A0_G_PHY_EXT_CTL_EXTr_GMII_FIFO_MODf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_G_PHY_EXT_CTL_EXTr_BLK_TXEN_MODf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 2) & 0x1)
#define BCM53101_A0_G_PHY_EXT_CTL_EXTr_BLK_TXEN_MODf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_G_PHY_EXT_CTL_EXTr_FORCE_LED_OFFf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 3) & 0x1)
#define BCM53101_A0_G_PHY_EXT_CTL_EXTr_FORCE_LED_OFFf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_G_PHY_EXT_CTL_EXTr_FORCE_LED_ONf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 4) & 0x1)
#define BCM53101_A0_G_PHY_EXT_CTL_EXTr_FORCE_LED_ONf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_G_PHY_EXT_CTL_EXTr_EN_LED_TRAFFIC_MODf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 5) & 0x1)
#define BCM53101_A0_G_PHY_EXT_CTL_EXTr_EN_LED_TRAFFIC_MODf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_G_PHY_EXT_CTL_EXTr_RST_SCRAMBLERf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 6) & 0x1)
#define BCM53101_A0_G_PHY_EXT_CTL_EXTr_RST_SCRAMBLERf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_G_PHY_EXT_CTL_EXTr_BYPASS_ALIGNMENTf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 7) & 0x1)
#define BCM53101_A0_G_PHY_EXT_CTL_EXTr_BYPASS_ALIGNMENTf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53101_A0_G_PHY_EXT_CTL_EXTr_BYPASS_NRZI_MLT3f_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 8) & 0x1)
#define BCM53101_A0_G_PHY_EXT_CTL_EXTr_BYPASS_NRZI_MLT3f_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53101_A0_G_PHY_EXT_CTL_EXTr_BYPASS_SCRAMBLERf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 9) & 0x1)
#define BCM53101_A0_G_PHY_EXT_CTL_EXTr_BYPASS_SCRAMBLERf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53101_A0_G_PHY_EXT_CTL_EXTr_BYPASS_ENCODEf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 10) & 0x1)
#define BCM53101_A0_G_PHY_EXT_CTL_EXTr_BYPASS_ENCODEf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53101_A0_G_PHY_EXT_CTL_EXTr_FORCE_INTERRUPTf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 11) & 0x1)
#define BCM53101_A0_G_PHY_EXT_CTL_EXTr_FORCE_INTERRUPTf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53101_A0_G_PHY_EXT_CTL_EXTr_INTERRUPT_DISf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 12) & 0x1)
#define BCM53101_A0_G_PHY_EXT_CTL_EXTr_INTERRUPT_DISf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53101_A0_G_PHY_EXT_CTL_EXTr_TRANSMIT_DISf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 13) & 0x1)
#define BCM53101_A0_G_PHY_EXT_CTL_EXTr_TRANSMIT_DISf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53101_A0_G_PHY_EXT_CTL_EXTr_DIS_AUTO_MDI_CROSf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 14) & 0x1)
#define BCM53101_A0_G_PHY_EXT_CTL_EXTr_DIS_AUTO_MDI_CROSf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_G_PHY_EXT_CTL_EXTr_MAC_PHY_MODEf_GET(r) ((((r).g_phy_ext_ctl_ext[0]) >> 15) & 0x1)
#define BCM53101_A0_G_PHY_EXT_CTL_EXTr_MAC_PHY_MODEf_SET(r,f) (r).g_phy_ext_ctl_ext[0]=(((r).g_phy_ext_ctl_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_PHY_EXT_CTL_EXT.
 *
 */
#define BCM53101_A0_READ_G_PHY_EXT_CTL_EXTr(u,r) cdk_robo_reg_read(u,BCM53101_A0_G_PHY_EXT_CTL_EXTr,(r._g_phy_ext_ctl_ext),2)
#define BCM53101_A0_WRITE_G_PHY_EXT_CTL_EXTr(u,r) cdk_robo_reg_write(u,BCM53101_A0_G_PHY_EXT_CTL_EXTr,&(r._g_phy_ext_ctl_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHY_EXT_CTL_EXTr BCM53101_A0_G_PHY_EXT_CTL_EXTr
#define G_PHY_EXT_CTL_EXTr_SIZE BCM53101_A0_G_PHY_EXT_CTL_EXTr_SIZE
typedef BCM53101_A0_G_PHY_EXT_CTL_EXTr_t G_PHY_EXT_CTL_EXTr_t;
#define G_PHY_EXT_CTL_EXTr_CLR BCM53101_A0_G_PHY_EXT_CTL_EXTr_CLR
#define G_PHY_EXT_CTL_EXTr_SET BCM53101_A0_G_PHY_EXT_CTL_EXTr_SET
#define G_PHY_EXT_CTL_EXTr_GET BCM53101_A0_G_PHY_EXT_CTL_EXTr_GET
#define G_PHY_EXT_CTL_EXTr_B1000T_PCS_TRANS_FIFOf_GET BCM53101_A0_G_PHY_EXT_CTL_EXTr_B1000T_PCS_TRANS_FIFOf_GET
#define G_PHY_EXT_CTL_EXTr_B1000T_PCS_TRANS_FIFOf_SET BCM53101_A0_G_PHY_EXT_CTL_EXTr_B1000T_PCS_TRANS_FIFOf_SET
#define G_PHY_EXT_CTL_EXTr_GMII_FIFO_MODf_GET BCM53101_A0_G_PHY_EXT_CTL_EXTr_GMII_FIFO_MODf_GET
#define G_PHY_EXT_CTL_EXTr_GMII_FIFO_MODf_SET BCM53101_A0_G_PHY_EXT_CTL_EXTr_GMII_FIFO_MODf_SET
#define G_PHY_EXT_CTL_EXTr_BLK_TXEN_MODf_GET BCM53101_A0_G_PHY_EXT_CTL_EXTr_BLK_TXEN_MODf_GET
#define G_PHY_EXT_CTL_EXTr_BLK_TXEN_MODf_SET BCM53101_A0_G_PHY_EXT_CTL_EXTr_BLK_TXEN_MODf_SET
#define G_PHY_EXT_CTL_EXTr_FORCE_LED_OFFf_GET BCM53101_A0_G_PHY_EXT_CTL_EXTr_FORCE_LED_OFFf_GET
#define G_PHY_EXT_CTL_EXTr_FORCE_LED_OFFf_SET BCM53101_A0_G_PHY_EXT_CTL_EXTr_FORCE_LED_OFFf_SET
#define G_PHY_EXT_CTL_EXTr_FORCE_LED_ONf_GET BCM53101_A0_G_PHY_EXT_CTL_EXTr_FORCE_LED_ONf_GET
#define G_PHY_EXT_CTL_EXTr_FORCE_LED_ONf_SET BCM53101_A0_G_PHY_EXT_CTL_EXTr_FORCE_LED_ONf_SET
#define G_PHY_EXT_CTL_EXTr_EN_LED_TRAFFIC_MODf_GET BCM53101_A0_G_PHY_EXT_CTL_EXTr_EN_LED_TRAFFIC_MODf_GET
#define G_PHY_EXT_CTL_EXTr_EN_LED_TRAFFIC_MODf_SET BCM53101_A0_G_PHY_EXT_CTL_EXTr_EN_LED_TRAFFIC_MODf_SET
#define G_PHY_EXT_CTL_EXTr_RST_SCRAMBLERf_GET BCM53101_A0_G_PHY_EXT_CTL_EXTr_RST_SCRAMBLERf_GET
#define G_PHY_EXT_CTL_EXTr_RST_SCRAMBLERf_SET BCM53101_A0_G_PHY_EXT_CTL_EXTr_RST_SCRAMBLERf_SET
#define G_PHY_EXT_CTL_EXTr_BYPASS_ALIGNMENTf_GET BCM53101_A0_G_PHY_EXT_CTL_EXTr_BYPASS_ALIGNMENTf_GET
#define G_PHY_EXT_CTL_EXTr_BYPASS_ALIGNMENTf_SET BCM53101_A0_G_PHY_EXT_CTL_EXTr_BYPASS_ALIGNMENTf_SET
#define G_PHY_EXT_CTL_EXTr_BYPASS_NRZI_MLT3f_GET BCM53101_A0_G_PHY_EXT_CTL_EXTr_BYPASS_NRZI_MLT3f_GET
#define G_PHY_EXT_CTL_EXTr_BYPASS_NRZI_MLT3f_SET BCM53101_A0_G_PHY_EXT_CTL_EXTr_BYPASS_NRZI_MLT3f_SET
#define G_PHY_EXT_CTL_EXTr_BYPASS_SCRAMBLERf_GET BCM53101_A0_G_PHY_EXT_CTL_EXTr_BYPASS_SCRAMBLERf_GET
#define G_PHY_EXT_CTL_EXTr_BYPASS_SCRAMBLERf_SET BCM53101_A0_G_PHY_EXT_CTL_EXTr_BYPASS_SCRAMBLERf_SET
#define G_PHY_EXT_CTL_EXTr_BYPASS_ENCODEf_GET BCM53101_A0_G_PHY_EXT_CTL_EXTr_BYPASS_ENCODEf_GET
#define G_PHY_EXT_CTL_EXTr_BYPASS_ENCODEf_SET BCM53101_A0_G_PHY_EXT_CTL_EXTr_BYPASS_ENCODEf_SET
#define G_PHY_EXT_CTL_EXTr_FORCE_INTERRUPTf_GET BCM53101_A0_G_PHY_EXT_CTL_EXTr_FORCE_INTERRUPTf_GET
#define G_PHY_EXT_CTL_EXTr_FORCE_INTERRUPTf_SET BCM53101_A0_G_PHY_EXT_CTL_EXTr_FORCE_INTERRUPTf_SET
#define G_PHY_EXT_CTL_EXTr_INTERRUPT_DISf_GET BCM53101_A0_G_PHY_EXT_CTL_EXTr_INTERRUPT_DISf_GET
#define G_PHY_EXT_CTL_EXTr_INTERRUPT_DISf_SET BCM53101_A0_G_PHY_EXT_CTL_EXTr_INTERRUPT_DISf_SET
#define G_PHY_EXT_CTL_EXTr_TRANSMIT_DISf_GET BCM53101_A0_G_PHY_EXT_CTL_EXTr_TRANSMIT_DISf_GET
#define G_PHY_EXT_CTL_EXTr_TRANSMIT_DISf_SET BCM53101_A0_G_PHY_EXT_CTL_EXTr_TRANSMIT_DISf_SET
#define G_PHY_EXT_CTL_EXTr_DIS_AUTO_MDI_CROSf_GET BCM53101_A0_G_PHY_EXT_CTL_EXTr_DIS_AUTO_MDI_CROSf_GET
#define G_PHY_EXT_CTL_EXTr_DIS_AUTO_MDI_CROSf_SET BCM53101_A0_G_PHY_EXT_CTL_EXTr_DIS_AUTO_MDI_CROSf_SET
#define G_PHY_EXT_CTL_EXTr_MAC_PHY_MODEf_GET BCM53101_A0_G_PHY_EXT_CTL_EXTr_MAC_PHY_MODEf_GET
#define G_PHY_EXT_CTL_EXTr_MAC_PHY_MODEf_SET BCM53101_A0_G_PHY_EXT_CTL_EXTr_MAC_PHY_MODEf_SET
#define READ_G_PHY_EXT_CTL_EXTr BCM53101_A0_READ_G_PHY_EXT_CTL_EXTr
#define WRITE_G_PHY_EXT_CTL_EXTr BCM53101_A0_WRITE_G_PHY_EXT_CTL_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_G_PHY_EXT_CTL_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  G_PHY_EXT_STS_EXT
 * BLOCKS:   SYS
 * DESC:     External PHY Extended Status Register
 * SIZE:     16
 * FIELDS:
 *     MLT3_ERR_DET     1 = MLT3 code error detected since last read,0 = no MLT3 error detected since last read.
 *     LCK_ERR_DET      1 = lock error detected since last read,0 = no lock error detected since last read.
 *     TRMIT_ERR_DET    1 = transmit error code detected since last read,0 = no transmit error detected since last read.
 *     REC_ERR_DET      1 = receive coding error detected since last read,0 = no receive error detected since last read.
 *     BAD_ESD_DET      1 = bad ESD error detected since last read,0 = no bad ESD error detected since last read.
 *     BAD_SSD_DET      1 = bad SSD error detected since last read,0 = no bad SSD error detected since last read.
 *     CARR_ERR_DET     1 = carrier ext. error detected since last read,0 = no carrier ext. error detected since last read.
 *     CRC_ERR_DET      1 = CRC error detected since last read,0 = no CRC error detected since last read.
 *     LINK_STS         1 = link pass,0 = link fail.
 *     LOCK             1 = descrambler locked,0 = descrambler unlocked.
 *     LOCAL_REC_STS    1 = local receiver status OK,0 = local receiver status not OK.
 *     REMOTE_REC_STS   1 = remote receiver status OK,0 = remote receiver status not OK.
 *     INTERRUPT_STS    1 = unmasked interrupt currently active0 = interrupts clear.
 *     MDI_CROS_STATE   1 = MDIX,0 = MDI.
 *     WIRESPEED_DOWNGRADE 1 = autoneg advertising downgraded0 = autoneg advertised as shown in regs 04h & 09h.
 *     AN_PAGE_SEL_MISMATCH 1 = link partner base page selector field mismatched advertised selector field since last read0 = no mismatch detected since last read.
 *
 ******************************************************************************/
#define BCM53101_A0_G_PHY_EXT_STS_EXTr 0x00008822

#define BCM53101_A0_G_PHY_EXT_STS_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_PHY_EXT_STS_EXT.
 *
 */
typedef union BCM53101_A0_G_PHY_EXT_STS_EXTr_s {
	uint32_t v[1];
	uint32_t g_phy_ext_sts_ext[1];
	uint32_t _g_phy_ext_sts_ext;
} BCM53101_A0_G_PHY_EXT_STS_EXTr_t;

#define BCM53101_A0_G_PHY_EXT_STS_EXTr_CLR(r) (r).g_phy_ext_sts_ext[0] = 0
#define BCM53101_A0_G_PHY_EXT_STS_EXTr_SET(r,d) (r).g_phy_ext_sts_ext[0] = d
#define BCM53101_A0_G_PHY_EXT_STS_EXTr_GET(r) (r).g_phy_ext_sts_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_G_PHY_EXT_STS_EXTr_MLT3_ERR_DETf_GET(r) (((r).g_phy_ext_sts_ext[0]) & 0x1)
#define BCM53101_A0_G_PHY_EXT_STS_EXTr_MLT3_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_G_PHY_EXT_STS_EXTr_LCK_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 1) & 0x1)
#define BCM53101_A0_G_PHY_EXT_STS_EXTr_LCK_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_G_PHY_EXT_STS_EXTr_TRMIT_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 2) & 0x1)
#define BCM53101_A0_G_PHY_EXT_STS_EXTr_TRMIT_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_G_PHY_EXT_STS_EXTr_REC_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 3) & 0x1)
#define BCM53101_A0_G_PHY_EXT_STS_EXTr_REC_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_G_PHY_EXT_STS_EXTr_BAD_ESD_DETf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 4) & 0x1)
#define BCM53101_A0_G_PHY_EXT_STS_EXTr_BAD_ESD_DETf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_G_PHY_EXT_STS_EXTr_BAD_SSD_DETf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 5) & 0x1)
#define BCM53101_A0_G_PHY_EXT_STS_EXTr_BAD_SSD_DETf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_G_PHY_EXT_STS_EXTr_CARR_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 6) & 0x1)
#define BCM53101_A0_G_PHY_EXT_STS_EXTr_CARR_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_G_PHY_EXT_STS_EXTr_CRC_ERR_DETf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 7) & 0x1)
#define BCM53101_A0_G_PHY_EXT_STS_EXTr_CRC_ERR_DETf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53101_A0_G_PHY_EXT_STS_EXTr_LINK_STSf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 8) & 0x1)
#define BCM53101_A0_G_PHY_EXT_STS_EXTr_LINK_STSf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53101_A0_G_PHY_EXT_STS_EXTr_LOCKf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 9) & 0x1)
#define BCM53101_A0_G_PHY_EXT_STS_EXTr_LOCKf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53101_A0_G_PHY_EXT_STS_EXTr_LOCAL_REC_STSf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 10) & 0x1)
#define BCM53101_A0_G_PHY_EXT_STS_EXTr_LOCAL_REC_STSf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53101_A0_G_PHY_EXT_STS_EXTr_REMOTE_REC_STSf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 11) & 0x1)
#define BCM53101_A0_G_PHY_EXT_STS_EXTr_REMOTE_REC_STSf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53101_A0_G_PHY_EXT_STS_EXTr_INTERRUPT_STSf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 12) & 0x1)
#define BCM53101_A0_G_PHY_EXT_STS_EXTr_INTERRUPT_STSf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53101_A0_G_PHY_EXT_STS_EXTr_MDI_CROS_STATEf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 13) & 0x1)
#define BCM53101_A0_G_PHY_EXT_STS_EXTr_MDI_CROS_STATEf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53101_A0_G_PHY_EXT_STS_EXTr_WIRESPEED_DOWNGRADEf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 14) & 0x1)
#define BCM53101_A0_G_PHY_EXT_STS_EXTr_WIRESPEED_DOWNGRADEf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_G_PHY_EXT_STS_EXTr_AN_PAGE_SEL_MISMATCHf_GET(r) ((((r).g_phy_ext_sts_ext[0]) >> 15) & 0x1)
#define BCM53101_A0_G_PHY_EXT_STS_EXTr_AN_PAGE_SEL_MISMATCHf_SET(r,f) (r).g_phy_ext_sts_ext[0]=(((r).g_phy_ext_sts_ext[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access G_PHY_EXT_STS_EXT.
 *
 */
#define BCM53101_A0_READ_G_PHY_EXT_STS_EXTr(u,r) cdk_robo_reg_read(u,BCM53101_A0_G_PHY_EXT_STS_EXTr,(r._g_phy_ext_sts_ext),2)
#define BCM53101_A0_WRITE_G_PHY_EXT_STS_EXTr(u,r) cdk_robo_reg_write(u,BCM53101_A0_G_PHY_EXT_STS_EXTr,&(r._g_phy_ext_sts_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_PHY_EXT_STS_EXTr BCM53101_A0_G_PHY_EXT_STS_EXTr
#define G_PHY_EXT_STS_EXTr_SIZE BCM53101_A0_G_PHY_EXT_STS_EXTr_SIZE
typedef BCM53101_A0_G_PHY_EXT_STS_EXTr_t G_PHY_EXT_STS_EXTr_t;
#define G_PHY_EXT_STS_EXTr_CLR BCM53101_A0_G_PHY_EXT_STS_EXTr_CLR
#define G_PHY_EXT_STS_EXTr_SET BCM53101_A0_G_PHY_EXT_STS_EXTr_SET
#define G_PHY_EXT_STS_EXTr_GET BCM53101_A0_G_PHY_EXT_STS_EXTr_GET
#define G_PHY_EXT_STS_EXTr_MLT3_ERR_DETf_GET BCM53101_A0_G_PHY_EXT_STS_EXTr_MLT3_ERR_DETf_GET
#define G_PHY_EXT_STS_EXTr_MLT3_ERR_DETf_SET BCM53101_A0_G_PHY_EXT_STS_EXTr_MLT3_ERR_DETf_SET
#define G_PHY_EXT_STS_EXTr_LCK_ERR_DETf_GET BCM53101_A0_G_PHY_EXT_STS_EXTr_LCK_ERR_DETf_GET
#define G_PHY_EXT_STS_EXTr_LCK_ERR_DETf_SET BCM53101_A0_G_PHY_EXT_STS_EXTr_LCK_ERR_DETf_SET
#define G_PHY_EXT_STS_EXTr_TRMIT_ERR_DETf_GET BCM53101_A0_G_PHY_EXT_STS_EXTr_TRMIT_ERR_DETf_GET
#define G_PHY_EXT_STS_EXTr_TRMIT_ERR_DETf_SET BCM53101_A0_G_PHY_EXT_STS_EXTr_TRMIT_ERR_DETf_SET
#define G_PHY_EXT_STS_EXTr_REC_ERR_DETf_GET BCM53101_A0_G_PHY_EXT_STS_EXTr_REC_ERR_DETf_GET
#define G_PHY_EXT_STS_EXTr_REC_ERR_DETf_SET BCM53101_A0_G_PHY_EXT_STS_EXTr_REC_ERR_DETf_SET
#define G_PHY_EXT_STS_EXTr_BAD_ESD_DETf_GET BCM53101_A0_G_PHY_EXT_STS_EXTr_BAD_ESD_DETf_GET
#define G_PHY_EXT_STS_EXTr_BAD_ESD_DETf_SET BCM53101_A0_G_PHY_EXT_STS_EXTr_BAD_ESD_DETf_SET
#define G_PHY_EXT_STS_EXTr_BAD_SSD_DETf_GET BCM53101_A0_G_PHY_EXT_STS_EXTr_BAD_SSD_DETf_GET
#define G_PHY_EXT_STS_EXTr_BAD_SSD_DETf_SET BCM53101_A0_G_PHY_EXT_STS_EXTr_BAD_SSD_DETf_SET
#define G_PHY_EXT_STS_EXTr_CARR_ERR_DETf_GET BCM53101_A0_G_PHY_EXT_STS_EXTr_CARR_ERR_DETf_GET
#define G_PHY_EXT_STS_EXTr_CARR_ERR_DETf_SET BCM53101_A0_G_PHY_EXT_STS_EXTr_CARR_ERR_DETf_SET
#define G_PHY_EXT_STS_EXTr_CRC_ERR_DETf_GET BCM53101_A0_G_PHY_EXT_STS_EXTr_CRC_ERR_DETf_GET
#define G_PHY_EXT_STS_EXTr_CRC_ERR_DETf_SET BCM53101_A0_G_PHY_EXT_STS_EXTr_CRC_ERR_DETf_SET
#define G_PHY_EXT_STS_EXTr_LINK_STSf_GET BCM53101_A0_G_PHY_EXT_STS_EXTr_LINK_STSf_GET
#define G_PHY_EXT_STS_EXTr_LINK_STSf_SET BCM53101_A0_G_PHY_EXT_STS_EXTr_LINK_STSf_SET
#define G_PHY_EXT_STS_EXTr_LOCKf_GET BCM53101_A0_G_PHY_EXT_STS_EXTr_LOCKf_GET
#define G_PHY_EXT_STS_EXTr_LOCKf_SET BCM53101_A0_G_PHY_EXT_STS_EXTr_LOCKf_SET
#define G_PHY_EXT_STS_EXTr_LOCAL_REC_STSf_GET BCM53101_A0_G_PHY_EXT_STS_EXTr_LOCAL_REC_STSf_GET
#define G_PHY_EXT_STS_EXTr_LOCAL_REC_STSf_SET BCM53101_A0_G_PHY_EXT_STS_EXTr_LOCAL_REC_STSf_SET
#define G_PHY_EXT_STS_EXTr_REMOTE_REC_STSf_GET BCM53101_A0_G_PHY_EXT_STS_EXTr_REMOTE_REC_STSf_GET
#define G_PHY_EXT_STS_EXTr_REMOTE_REC_STSf_SET BCM53101_A0_G_PHY_EXT_STS_EXTr_REMOTE_REC_STSf_SET
#define G_PHY_EXT_STS_EXTr_INTERRUPT_STSf_GET BCM53101_A0_G_PHY_EXT_STS_EXTr_INTERRUPT_STSf_GET
#define G_PHY_EXT_STS_EXTr_INTERRUPT_STSf_SET BCM53101_A0_G_PHY_EXT_STS_EXTr_INTERRUPT_STSf_SET
#define G_PHY_EXT_STS_EXTr_MDI_CROS_STATEf_GET BCM53101_A0_G_PHY_EXT_STS_EXTr_MDI_CROS_STATEf_GET
#define G_PHY_EXT_STS_EXTr_MDI_CROS_STATEf_SET BCM53101_A0_G_PHY_EXT_STS_EXTr_MDI_CROS_STATEf_SET
#define G_PHY_EXT_STS_EXTr_WIRESPEED_DOWNGRADEf_GET BCM53101_A0_G_PHY_EXT_STS_EXTr_WIRESPEED_DOWNGRADEf_GET
#define G_PHY_EXT_STS_EXTr_WIRESPEED_DOWNGRADEf_SET BCM53101_A0_G_PHY_EXT_STS_EXTr_WIRESPEED_DOWNGRADEf_SET
#define G_PHY_EXT_STS_EXTr_AN_PAGE_SEL_MISMATCHf_GET BCM53101_A0_G_PHY_EXT_STS_EXTr_AN_PAGE_SEL_MISMATCHf_GET
#define G_PHY_EXT_STS_EXTr_AN_PAGE_SEL_MISMATCHf_SET BCM53101_A0_G_PHY_EXT_STS_EXTr_AN_PAGE_SEL_MISMATCHf_SET
#define READ_G_PHY_EXT_STS_EXTr BCM53101_A0_READ_G_PHY_EXT_STS_EXTr
#define WRITE_G_PHY_EXT_STS_EXTr BCM53101_A0_WRITE_G_PHY_EXT_STS_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_G_PHY_EXT_STS_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  G_REC_ERR_CNT_EXT
 * BLOCKS:   SYS
 * DESC:     External Receive Error Counter
 * SIZE:     16
 * FIELDS:
 *     REC_ERR_CNT      Number of non-collision packets with receive errors since last read. Freezes at FFFFh.(Counts serdes errors when register 1ch shadow 11011 bit 9 = 1 otherwise copper errors)
 *
 ******************************************************************************/
#define BCM53101_A0_G_REC_ERR_CNT_EXTr 0x00008824

#define BCM53101_A0_G_REC_ERR_CNT_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_REC_ERR_CNT_EXT.
 *
 */
typedef union BCM53101_A0_G_REC_ERR_CNT_EXTr_s {
	uint32_t v[1];
	uint32_t g_rec_err_cnt_ext[1];
	uint32_t _g_rec_err_cnt_ext;
} BCM53101_A0_G_REC_ERR_CNT_EXTr_t;

#define BCM53101_A0_G_REC_ERR_CNT_EXTr_CLR(r) (r).g_rec_err_cnt_ext[0] = 0
#define BCM53101_A0_G_REC_ERR_CNT_EXTr_SET(r,d) (r).g_rec_err_cnt_ext[0] = d
#define BCM53101_A0_G_REC_ERR_CNT_EXTr_GET(r) (r).g_rec_err_cnt_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_G_REC_ERR_CNT_EXTr_REC_ERR_CNTf_GET(r) (((r).g_rec_err_cnt_ext[0]) & 0xffff)
#define BCM53101_A0_G_REC_ERR_CNT_EXTr_REC_ERR_CNTf_SET(r,f) (r).g_rec_err_cnt_ext[0]=(((r).g_rec_err_cnt_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_REC_ERR_CNT_EXT.
 *
 */
#define BCM53101_A0_READ_G_REC_ERR_CNT_EXTr(u,r) cdk_robo_reg_read(u,BCM53101_A0_G_REC_ERR_CNT_EXTr,(r._g_rec_err_cnt_ext),2)
#define BCM53101_A0_WRITE_G_REC_ERR_CNT_EXTr(u,r) cdk_robo_reg_write(u,BCM53101_A0_G_REC_ERR_CNT_EXTr,&(r._g_rec_err_cnt_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_REC_ERR_CNT_EXTr BCM53101_A0_G_REC_ERR_CNT_EXTr
#define G_REC_ERR_CNT_EXTr_SIZE BCM53101_A0_G_REC_ERR_CNT_EXTr_SIZE
typedef BCM53101_A0_G_REC_ERR_CNT_EXTr_t G_REC_ERR_CNT_EXTr_t;
#define G_REC_ERR_CNT_EXTr_CLR BCM53101_A0_G_REC_ERR_CNT_EXTr_CLR
#define G_REC_ERR_CNT_EXTr_SET BCM53101_A0_G_REC_ERR_CNT_EXTr_SET
#define G_REC_ERR_CNT_EXTr_GET BCM53101_A0_G_REC_ERR_CNT_EXTr_GET
#define G_REC_ERR_CNT_EXTr_REC_ERR_CNTf_GET BCM53101_A0_G_REC_ERR_CNT_EXTr_REC_ERR_CNTf_GET
#define G_REC_ERR_CNT_EXTr_REC_ERR_CNTf_SET BCM53101_A0_G_REC_ERR_CNT_EXTr_REC_ERR_CNTf_SET
#define READ_G_REC_ERR_CNT_EXTr BCM53101_A0_READ_G_REC_ERR_CNT_EXTr
#define WRITE_G_REC_ERR_CNT_EXTr BCM53101_A0_WRITE_G_REC_ERR_CNT_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_G_REC_ERR_CNT_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  G_REC_NOTOK_CNT_EXT
 * BLOCKS:   SYS
 * DESC:     External Local/Remote Receiver NOT_OK Counters
 * SIZE:     16
 * FIELDS:
 *     REMOTE_REC_NOTOK_CNT number of times remote receiver status was not OKsince last read. Freezes at FFh.
 *     LOCAL_REC_NOTOK_CNT since last read. Freezes at FFh.
 *
 ******************************************************************************/
#define BCM53101_A0_G_REC_NOTOK_CNT_EXTr 0x00008828

#define BCM53101_A0_G_REC_NOTOK_CNT_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_REC_NOTOK_CNT_EXT.
 *
 */
typedef union BCM53101_A0_G_REC_NOTOK_CNT_EXTr_s {
	uint32_t v[1];
	uint32_t g_rec_notok_cnt_ext[1];
	uint32_t _g_rec_notok_cnt_ext;
} BCM53101_A0_G_REC_NOTOK_CNT_EXTr_t;

#define BCM53101_A0_G_REC_NOTOK_CNT_EXTr_CLR(r) (r).g_rec_notok_cnt_ext[0] = 0
#define BCM53101_A0_G_REC_NOTOK_CNT_EXTr_SET(r,d) (r).g_rec_notok_cnt_ext[0] = d
#define BCM53101_A0_G_REC_NOTOK_CNT_EXTr_GET(r) (r).g_rec_notok_cnt_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_G_REC_NOTOK_CNT_EXTr_REMOTE_REC_NOTOK_CNTf_GET(r) (((r).g_rec_notok_cnt_ext[0]) & 0xff)
#define BCM53101_A0_G_REC_NOTOK_CNT_EXTr_REMOTE_REC_NOTOK_CNTf_SET(r,f) (r).g_rec_notok_cnt_ext[0]=(((r).g_rec_notok_cnt_ext[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53101_A0_G_REC_NOTOK_CNT_EXTr_LOCAL_REC_NOTOK_CNTf_GET(r) ((((r).g_rec_notok_cnt_ext[0]) >> 8) & 0xff)
#define BCM53101_A0_G_REC_NOTOK_CNT_EXTr_LOCAL_REC_NOTOK_CNTf_SET(r,f) (r).g_rec_notok_cnt_ext[0]=(((r).g_rec_notok_cnt_ext[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access G_REC_NOTOK_CNT_EXT.
 *
 */
#define BCM53101_A0_READ_G_REC_NOTOK_CNT_EXTr(u,r) cdk_robo_reg_read(u,BCM53101_A0_G_REC_NOTOK_CNT_EXTr,(r._g_rec_notok_cnt_ext),2)
#define BCM53101_A0_WRITE_G_REC_NOTOK_CNT_EXTr(u,r) cdk_robo_reg_write(u,BCM53101_A0_G_REC_NOTOK_CNT_EXTr,&(r._g_rec_notok_cnt_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_REC_NOTOK_CNT_EXTr BCM53101_A0_G_REC_NOTOK_CNT_EXTr
#define G_REC_NOTOK_CNT_EXTr_SIZE BCM53101_A0_G_REC_NOTOK_CNT_EXTr_SIZE
typedef BCM53101_A0_G_REC_NOTOK_CNT_EXTr_t G_REC_NOTOK_CNT_EXTr_t;
#define G_REC_NOTOK_CNT_EXTr_CLR BCM53101_A0_G_REC_NOTOK_CNT_EXTr_CLR
#define G_REC_NOTOK_CNT_EXTr_SET BCM53101_A0_G_REC_NOTOK_CNT_EXTr_SET
#define G_REC_NOTOK_CNT_EXTr_GET BCM53101_A0_G_REC_NOTOK_CNT_EXTr_GET
#define G_REC_NOTOK_CNT_EXTr_REMOTE_REC_NOTOK_CNTf_GET BCM53101_A0_G_REC_NOTOK_CNT_EXTr_REMOTE_REC_NOTOK_CNTf_GET
#define G_REC_NOTOK_CNT_EXTr_REMOTE_REC_NOTOK_CNTf_SET BCM53101_A0_G_REC_NOTOK_CNT_EXTr_REMOTE_REC_NOTOK_CNTf_SET
#define G_REC_NOTOK_CNT_EXTr_LOCAL_REC_NOTOK_CNTf_GET BCM53101_A0_G_REC_NOTOK_CNT_EXTr_LOCAL_REC_NOTOK_CNTf_GET
#define G_REC_NOTOK_CNT_EXTr_LOCAL_REC_NOTOK_CNTf_SET BCM53101_A0_G_REC_NOTOK_CNT_EXTr_LOCAL_REC_NOTOK_CNTf_SET
#define READ_G_REC_NOTOK_CNT_EXTr BCM53101_A0_READ_G_REC_NOTOK_CNT_EXTr
#define WRITE_G_REC_NOTOK_CNT_EXTr BCM53101_A0_WRITE_G_REC_NOTOK_CNT_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_G_REC_NOTOK_CNT_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  G_TEST1_EXT
 * BLOCKS:   SYS
 * DESC:     External Test Register 1
 * SIZE:     16
 * FIELDS:
 *     TEST             
 *
 ******************************************************************************/
#define BCM53101_A0_G_TEST1_EXTr 0x0000883c

#define BCM53101_A0_G_TEST1_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_TEST1_EXT.
 *
 */
typedef union BCM53101_A0_G_TEST1_EXTr_s {
	uint32_t v[1];
	uint32_t g_test1_ext[1];
	uint32_t _g_test1_ext;
} BCM53101_A0_G_TEST1_EXTr_t;

#define BCM53101_A0_G_TEST1_EXTr_CLR(r) (r).g_test1_ext[0] = 0
#define BCM53101_A0_G_TEST1_EXTr_SET(r,d) (r).g_test1_ext[0] = d
#define BCM53101_A0_G_TEST1_EXTr_GET(r) (r).g_test1_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_G_TEST1_EXTr_TESTf_GET(r) (((r).g_test1_ext[0]) & 0xffff)
#define BCM53101_A0_G_TEST1_EXTr_TESTf_SET(r,f) (r).g_test1_ext[0]=(((r).g_test1_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_TEST1_EXT.
 *
 */
#define BCM53101_A0_READ_G_TEST1_EXTr(u,r) cdk_robo_reg_read(u,BCM53101_A0_G_TEST1_EXTr,(r._g_test1_ext),2)
#define BCM53101_A0_WRITE_G_TEST1_EXTr(u,r) cdk_robo_reg_write(u,BCM53101_A0_G_TEST1_EXTr,&(r._g_test1_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_TEST1_EXTr BCM53101_A0_G_TEST1_EXTr
#define G_TEST1_EXTr_SIZE BCM53101_A0_G_TEST1_EXTr_SIZE
typedef BCM53101_A0_G_TEST1_EXTr_t G_TEST1_EXTr_t;
#define G_TEST1_EXTr_CLR BCM53101_A0_G_TEST1_EXTr_CLR
#define G_TEST1_EXTr_SET BCM53101_A0_G_TEST1_EXTr_SET
#define G_TEST1_EXTr_GET BCM53101_A0_G_TEST1_EXTr_GET
#define G_TEST1_EXTr_TESTf_GET BCM53101_A0_G_TEST1_EXTr_TESTf_GET
#define G_TEST1_EXTr_TESTf_SET BCM53101_A0_G_TEST1_EXTr_TESTf_SET
#define READ_G_TEST1_EXTr BCM53101_A0_READ_G_TEST1_EXTr
#define WRITE_G_TEST1_EXTr BCM53101_A0_WRITE_G_TEST1_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_G_TEST1_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  G_TEST2_EXT
 * BLOCKS:   SYS
 * DESC:     External Test Register 2
 * SIZE:     16
 * FIELDS:
 *     TEST             
 *
 ******************************************************************************/
#define BCM53101_A0_G_TEST2_EXTr 0x0000883e

#define BCM53101_A0_G_TEST2_EXTr_SIZE 2

/*
 * This structure should be used to declare and program G_TEST2_EXT.
 *
 */
typedef union BCM53101_A0_G_TEST2_EXTr_s {
	uint32_t v[1];
	uint32_t g_test2_ext[1];
	uint32_t _g_test2_ext;
} BCM53101_A0_G_TEST2_EXTr_t;

#define BCM53101_A0_G_TEST2_EXTr_CLR(r) (r).g_test2_ext[0] = 0
#define BCM53101_A0_G_TEST2_EXTr_SET(r,d) (r).g_test2_ext[0] = d
#define BCM53101_A0_G_TEST2_EXTr_GET(r) (r).g_test2_ext[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_G_TEST2_EXTr_TESTf_GET(r) (((r).g_test2_ext[0]) & 0xffff)
#define BCM53101_A0_G_TEST2_EXTr_TESTf_SET(r,f) (r).g_test2_ext[0]=(((r).g_test2_ext[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access G_TEST2_EXT.
 *
 */
#define BCM53101_A0_READ_G_TEST2_EXTr(u,r) cdk_robo_reg_read(u,BCM53101_A0_G_TEST2_EXTr,(r._g_test2_ext),2)
#define BCM53101_A0_WRITE_G_TEST2_EXTr(u,r) cdk_robo_reg_write(u,BCM53101_A0_G_TEST2_EXTr,&(r._g_test2_ext),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define G_TEST2_EXTr BCM53101_A0_G_TEST2_EXTr
#define G_TEST2_EXTr_SIZE BCM53101_A0_G_TEST2_EXTr_SIZE
typedef BCM53101_A0_G_TEST2_EXTr_t G_TEST2_EXTr_t;
#define G_TEST2_EXTr_CLR BCM53101_A0_G_TEST2_EXTr_CLR
#define G_TEST2_EXTr_SET BCM53101_A0_G_TEST2_EXTr_SET
#define G_TEST2_EXTr_GET BCM53101_A0_G_TEST2_EXTr_GET
#define G_TEST2_EXTr_TESTf_GET BCM53101_A0_G_TEST2_EXTr_TESTf_GET
#define G_TEST2_EXTr_TESTf_SET BCM53101_A0_G_TEST2_EXTr_TESTf_SET
#define READ_G_TEST2_EXTr BCM53101_A0_READ_G_TEST2_EXTr
#define WRITE_G_TEST2_EXTr BCM53101_A0_WRITE_G_TEST2_EXTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_G_TEST2_EXTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  HL_PRTC_CTRL
 * BLOCKS:   SYS
 * DESC:     High Level Protocol Control Register
 * SIZE:     32
 * FIELDS:
 *     ARP_EN           ARP Snooping Enable1: ARP frames will be forwarded by L2 result and also copied to CPU.0: ARP frames will be forwarded by L2 result .
 *     RARP_EN          RARP Snooping Enable1: RARP frames will be forwarded by L2 result and also copied to CPU.0: RARP frames will be forwarded by L2 result .
 *     DHCP_EN          DHCP Snooping Enable1: DHCP frames will be forwarded by L2 result and also copied to CPU.0: DHCP frames will be forwarded by L2 result.
 *     ICMPV4_EN        ICMPv4 Snooping Enable1: ICMPv4 frames will be forwarded by L2 result and also copied to CPU.0: ICMPv4 frames will be forwarded by L2 result.
 *     ICMPV6_EN        ICMPv6(exclude MLD) Snooping/ Redirect EnableICMPv6, with a next header value of 58, will be classified by IPv6 datagram.
 *     ICMPV6_FWD_MODE  ICMPv6(exclude MLD) Forwarding Mode1: ICMPv6 frames will be trapped to CPU port only.0: ICMPv6 frames will be forwarded by L2 result and also copied to CPU.
 *     RESERVED_0       Reserved
 *     IGMP_DIP_EN      IGMP L3 DIP Checking EnableIn addition to the IP datagram with a protocol value of 2, IGMP will be classified by matching its DIP with the Class D IP address (224.0.0.0 ~ 239.255.255.255).
 *     IGMP_RPTLVE_EN   IGMP Report/Leave Message Snooping/Redirect Enable1: Enable IGMP Report/Leave Message Snooping/Redirect.0: Disable.
 *     IGMP_RPTLVE_FWD_MODE IGMP Report/Leave Message Forwarding Mode1: IGMP Report/Leave Message frames will be trapped to CPU port only.0: IGMP Report/Leave Message frames will be forwarded by L2 result and also copied to CPU.
 *     IGMP_QRY_EN      IGMP Query Message Snooping/Redirect Enable1: Enable IGMP Query Message Snooping/Redirect.0: Disable.
 *     IGMP_QRY_FWD_MODE IGMP Query Message Forwarding Mode1: IGMP Query Message frames will be trapped to CPU port only.0: IGMP Query Message frames will be forwarded by L2 result and also copied to CPU.
 *     IGMP_UKN_EN      IGMP Unknown Message Snooping/Redirect Enable1: Enable IGMP Unknown Message Snooping/Redirect.0: Disable.
 *     IGMP_UKN_FWD_MODE IGMP Unknown Message Forwarding Mode1: IGMP Unknown Message frames will be trapped to CPU port only.0: IGMP Unknown Message frames will be forwarded by L2 result and also copied to CPU.
 *     MLD_RPTDONE_EN   MLD Report/Done Message Snooping/Redirect Enable1: Enable MLD Report/Done Message Snooping/Redirect.0: Disable.
 *     MLD_RPTDONE_FWD_MODE MLD Report/Done Message Forwarding Mode1: MLD Report/Done Message frames will be trapped to CPU port only.0: MLD Report/Done Message frames will be forwarded by L2 result and also copied to CPU.
 *     MLD_QRY_EN       MLD Query Message Snooping/Redirect Enable1: Enable MLD Query Message Snooping/Redirect.0: Disable.
 *     MLD_QRY_FWD_MODE MLD Query Message Forwarding Mode1: MLD Query Message frames will be trapped to CPU port only.0: MLD Query Message frames will be forwarded by L2 result and also copied to CPU.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_HL_PRTC_CTRLr 0x00000250

#define BCM53101_A0_HL_PRTC_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program HL_PRTC_CTRL.
 *
 */
typedef union BCM53101_A0_HL_PRTC_CTRLr_s {
	uint32_t v[1];
	uint32_t hl_prtc_ctrl[1];
	uint32_t _hl_prtc_ctrl;
} BCM53101_A0_HL_PRTC_CTRLr_t;

#define BCM53101_A0_HL_PRTC_CTRLr_CLR(r) (r).hl_prtc_ctrl[0] = 0
#define BCM53101_A0_HL_PRTC_CTRLr_SET(r,d) (r).hl_prtc_ctrl[0] = d
#define BCM53101_A0_HL_PRTC_CTRLr_GET(r) (r).hl_prtc_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_HL_PRTC_CTRLr_ARP_ENf_GET(r) (((r).hl_prtc_ctrl[0]) & 0x1)
#define BCM53101_A0_HL_PRTC_CTRLr_ARP_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_HL_PRTC_CTRLr_RARP_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 1) & 0x1)
#define BCM53101_A0_HL_PRTC_CTRLr_RARP_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_HL_PRTC_CTRLr_DHCP_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 2) & 0x1)
#define BCM53101_A0_HL_PRTC_CTRLr_DHCP_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_HL_PRTC_CTRLr_ICMPV4_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 3) & 0x1)
#define BCM53101_A0_HL_PRTC_CTRLr_ICMPV4_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_HL_PRTC_CTRLr_ICMPV6_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 4) & 0x1)
#define BCM53101_A0_HL_PRTC_CTRLr_ICMPV6_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_HL_PRTC_CTRLr_ICMPV6_FWD_MODEf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 5) & 0x1)
#define BCM53101_A0_HL_PRTC_CTRLr_ICMPV6_FWD_MODEf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_HL_PRTC_CTRLr_RESERVED_0f_GET(r) ((((r).hl_prtc_ctrl[0]) >> 6) & 0x3)
#define BCM53101_A0_HL_PRTC_CTRLr_RESERVED_0f_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53101_A0_HL_PRTC_CTRLr_IGMP_DIP_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 8) & 0x1)
#define BCM53101_A0_HL_PRTC_CTRLr_IGMP_DIP_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53101_A0_HL_PRTC_CTRLr_IGMP_RPTLVE_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 9) & 0x1)
#define BCM53101_A0_HL_PRTC_CTRLr_IGMP_RPTLVE_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53101_A0_HL_PRTC_CTRLr_IGMP_RPTLVE_FWD_MODEf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 10) & 0x1)
#define BCM53101_A0_HL_PRTC_CTRLr_IGMP_RPTLVE_FWD_MODEf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53101_A0_HL_PRTC_CTRLr_IGMP_QRY_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 11) & 0x1)
#define BCM53101_A0_HL_PRTC_CTRLr_IGMP_QRY_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53101_A0_HL_PRTC_CTRLr_IGMP_QRY_FWD_MODEf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 12) & 0x1)
#define BCM53101_A0_HL_PRTC_CTRLr_IGMP_QRY_FWD_MODEf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53101_A0_HL_PRTC_CTRLr_IGMP_UKN_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 13) & 0x1)
#define BCM53101_A0_HL_PRTC_CTRLr_IGMP_UKN_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53101_A0_HL_PRTC_CTRLr_IGMP_UKN_FWD_MODEf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 14) & 0x1)
#define BCM53101_A0_HL_PRTC_CTRLr_IGMP_UKN_FWD_MODEf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_HL_PRTC_CTRLr_MLD_RPTDONE_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 15) & 0x1)
#define BCM53101_A0_HL_PRTC_CTRLr_MLD_RPTDONE_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))
#define BCM53101_A0_HL_PRTC_CTRLr_MLD_RPTDONE_FWD_MODEf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 16) & 0x1)
#define BCM53101_A0_HL_PRTC_CTRLr_MLD_RPTDONE_FWD_MODEf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53101_A0_HL_PRTC_CTRLr_MLD_QRY_ENf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 17) & 0x1)
#define BCM53101_A0_HL_PRTC_CTRLr_MLD_QRY_ENf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 17)) | ((((uint32_t)f) & 0x1) << 17))
#define BCM53101_A0_HL_PRTC_CTRLr_MLD_QRY_FWD_MODEf_GET(r) ((((r).hl_prtc_ctrl[0]) >> 18) & 0x1)
#define BCM53101_A0_HL_PRTC_CTRLr_MLD_QRY_FWD_MODEf_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1 << 18)) | ((((uint32_t)f) & 0x1) << 18))
#define BCM53101_A0_HL_PRTC_CTRLr_RESERVED_1f_GET(r) ((((r).hl_prtc_ctrl[0]) >> 19) & 0x1fff)
#define BCM53101_A0_HL_PRTC_CTRLr_RESERVED_1f_SET(r,f) (r).hl_prtc_ctrl[0]=(((r).hl_prtc_ctrl[0] & ~((uint32_t)0x1fff << 19)) | ((((uint32_t)f) & 0x1fff) << 19))

/*
 * These macros can be used to access HL_PRTC_CTRL.
 *
 */
#define BCM53101_A0_READ_HL_PRTC_CTRLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_HL_PRTC_CTRLr,(r._hl_prtc_ctrl),4)
#define BCM53101_A0_WRITE_HL_PRTC_CTRLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_HL_PRTC_CTRLr,&(r._hl_prtc_ctrl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define HL_PRTC_CTRLr BCM53101_A0_HL_PRTC_CTRLr
#define HL_PRTC_CTRLr_SIZE BCM53101_A0_HL_PRTC_CTRLr_SIZE
typedef BCM53101_A0_HL_PRTC_CTRLr_t HL_PRTC_CTRLr_t;
#define HL_PRTC_CTRLr_CLR BCM53101_A0_HL_PRTC_CTRLr_CLR
#define HL_PRTC_CTRLr_SET BCM53101_A0_HL_PRTC_CTRLr_SET
#define HL_PRTC_CTRLr_GET BCM53101_A0_HL_PRTC_CTRLr_GET
#define HL_PRTC_CTRLr_ARP_ENf_GET BCM53101_A0_HL_PRTC_CTRLr_ARP_ENf_GET
#define HL_PRTC_CTRLr_ARP_ENf_SET BCM53101_A0_HL_PRTC_CTRLr_ARP_ENf_SET
#define HL_PRTC_CTRLr_RARP_ENf_GET BCM53101_A0_HL_PRTC_CTRLr_RARP_ENf_GET
#define HL_PRTC_CTRLr_RARP_ENf_SET BCM53101_A0_HL_PRTC_CTRLr_RARP_ENf_SET
#define HL_PRTC_CTRLr_DHCP_ENf_GET BCM53101_A0_HL_PRTC_CTRLr_DHCP_ENf_GET
#define HL_PRTC_CTRLr_DHCP_ENf_SET BCM53101_A0_HL_PRTC_CTRLr_DHCP_ENf_SET
#define HL_PRTC_CTRLr_ICMPV4_ENf_GET BCM53101_A0_HL_PRTC_CTRLr_ICMPV4_ENf_GET
#define HL_PRTC_CTRLr_ICMPV4_ENf_SET BCM53101_A0_HL_PRTC_CTRLr_ICMPV4_ENf_SET
#define HL_PRTC_CTRLr_ICMPV6_ENf_GET BCM53101_A0_HL_PRTC_CTRLr_ICMPV6_ENf_GET
#define HL_PRTC_CTRLr_ICMPV6_ENf_SET BCM53101_A0_HL_PRTC_CTRLr_ICMPV6_ENf_SET
#define HL_PRTC_CTRLr_ICMPV6_FWD_MODEf_GET BCM53101_A0_HL_PRTC_CTRLr_ICMPV6_FWD_MODEf_GET
#define HL_PRTC_CTRLr_ICMPV6_FWD_MODEf_SET BCM53101_A0_HL_PRTC_CTRLr_ICMPV6_FWD_MODEf_SET
#define HL_PRTC_CTRLr_RESERVED_0f_GET BCM53101_A0_HL_PRTC_CTRLr_RESERVED_0f_GET
#define HL_PRTC_CTRLr_RESERVED_0f_SET BCM53101_A0_HL_PRTC_CTRLr_RESERVED_0f_SET
#define HL_PRTC_CTRLr_IGMP_DIP_ENf_GET BCM53101_A0_HL_PRTC_CTRLr_IGMP_DIP_ENf_GET
#define HL_PRTC_CTRLr_IGMP_DIP_ENf_SET BCM53101_A0_HL_PRTC_CTRLr_IGMP_DIP_ENf_SET
#define HL_PRTC_CTRLr_IGMP_RPTLVE_ENf_GET BCM53101_A0_HL_PRTC_CTRLr_IGMP_RPTLVE_ENf_GET
#define HL_PRTC_CTRLr_IGMP_RPTLVE_ENf_SET BCM53101_A0_HL_PRTC_CTRLr_IGMP_RPTLVE_ENf_SET
#define HL_PRTC_CTRLr_IGMP_RPTLVE_FWD_MODEf_GET BCM53101_A0_HL_PRTC_CTRLr_IGMP_RPTLVE_FWD_MODEf_GET
#define HL_PRTC_CTRLr_IGMP_RPTLVE_FWD_MODEf_SET BCM53101_A0_HL_PRTC_CTRLr_IGMP_RPTLVE_FWD_MODEf_SET
#define HL_PRTC_CTRLr_IGMP_QRY_ENf_GET BCM53101_A0_HL_PRTC_CTRLr_IGMP_QRY_ENf_GET
#define HL_PRTC_CTRLr_IGMP_QRY_ENf_SET BCM53101_A0_HL_PRTC_CTRLr_IGMP_QRY_ENf_SET
#define HL_PRTC_CTRLr_IGMP_QRY_FWD_MODEf_GET BCM53101_A0_HL_PRTC_CTRLr_IGMP_QRY_FWD_MODEf_GET
#define HL_PRTC_CTRLr_IGMP_QRY_FWD_MODEf_SET BCM53101_A0_HL_PRTC_CTRLr_IGMP_QRY_FWD_MODEf_SET
#define HL_PRTC_CTRLr_IGMP_UKN_ENf_GET BCM53101_A0_HL_PRTC_CTRLr_IGMP_UKN_ENf_GET
#define HL_PRTC_CTRLr_IGMP_UKN_ENf_SET BCM53101_A0_HL_PRTC_CTRLr_IGMP_UKN_ENf_SET
#define HL_PRTC_CTRLr_IGMP_UKN_FWD_MODEf_GET BCM53101_A0_HL_PRTC_CTRLr_IGMP_UKN_FWD_MODEf_GET
#define HL_PRTC_CTRLr_IGMP_UKN_FWD_MODEf_SET BCM53101_A0_HL_PRTC_CTRLr_IGMP_UKN_FWD_MODEf_SET
#define HL_PRTC_CTRLr_MLD_RPTDONE_ENf_GET BCM53101_A0_HL_PRTC_CTRLr_MLD_RPTDONE_ENf_GET
#define HL_PRTC_CTRLr_MLD_RPTDONE_ENf_SET BCM53101_A0_HL_PRTC_CTRLr_MLD_RPTDONE_ENf_SET
#define HL_PRTC_CTRLr_MLD_RPTDONE_FWD_MODEf_GET BCM53101_A0_HL_PRTC_CTRLr_MLD_RPTDONE_FWD_MODEf_GET
#define HL_PRTC_CTRLr_MLD_RPTDONE_FWD_MODEf_SET BCM53101_A0_HL_PRTC_CTRLr_MLD_RPTDONE_FWD_MODEf_SET
#define HL_PRTC_CTRLr_MLD_QRY_ENf_GET BCM53101_A0_HL_PRTC_CTRLr_MLD_QRY_ENf_GET
#define HL_PRTC_CTRLr_MLD_QRY_ENf_SET BCM53101_A0_HL_PRTC_CTRLr_MLD_QRY_ENf_SET
#define HL_PRTC_CTRLr_MLD_QRY_FWD_MODEf_GET BCM53101_A0_HL_PRTC_CTRLr_MLD_QRY_FWD_MODEf_GET
#define HL_PRTC_CTRLr_MLD_QRY_FWD_MODEf_SET BCM53101_A0_HL_PRTC_CTRLr_MLD_QRY_FWD_MODEf_SET
#define HL_PRTC_CTRLr_RESERVED_1f_GET BCM53101_A0_HL_PRTC_CTRLr_RESERVED_1f_GET
#define HL_PRTC_CTRLr_RESERVED_1f_SET BCM53101_A0_HL_PRTC_CTRLr_RESERVED_1f_SET
#define READ_HL_PRTC_CTRLr BCM53101_A0_READ_HL_PRTC_CTRLr
#define WRITE_HL_PRTC_CTRLr BCM53101_A0_WRITE_HL_PRTC_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_HL_PRTC_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  IGMIRCTL
 * BLOCKS:   SYS
 * DESC:     Ingress Mirror Control Register
 * SIZE:     16
 * FIELDS:
 *     IN_MIR_MSK       Ingress Mirror Port Mask.9 bit mask which selectively allows any port with its corresponding bit set, to be mirrored to the port identified by the MIRROR_CAPTURE_PORT value. Note that while multiple bits in a device may be set, severe congestion and/or frame loss may occur if excessive bandwidth from the mirrored port(s) is directed to the MIRROR_CAPTURE_PORT.Bits 0-5 = Port 0-5Bit 8= IMP Port.
 *     RESERVED         Reserved
 *     IN_DIV_EN        Ingress Divider Enable.Mirror every nth received frame (n=IN_MIRROR_DIV + 1) that has passed through the IN_MIRROR_FILTER.
 *     IN_MIR_FLTR      Ingress Mirror Filter.Defines the conditions under which frames received on a port that has been selected in the IN_MRROR_MASK[10:0], will be compared in order to determine if they should be forwarded to the MIRROR_CAPTURE_PORT.00: Mirror all ingress frames.01: Mirror all received frames with DA = IN_MIRROR_MAC.10: Mirror all received frames with SA = IN_MIRROR_MAC.11: Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_IGMIRCTLr 0x00000212

#define BCM53101_A0_IGMIRCTLr_SIZE 2

/*
 * This structure should be used to declare and program IGMIRCTL.
 *
 */
typedef union BCM53101_A0_IGMIRCTLr_s {
	uint32_t v[1];
	uint32_t igmirctl[1];
	uint32_t _igmirctl;
} BCM53101_A0_IGMIRCTLr_t;

#define BCM53101_A0_IGMIRCTLr_CLR(r) (r).igmirctl[0] = 0
#define BCM53101_A0_IGMIRCTLr_SET(r,d) (r).igmirctl[0] = d
#define BCM53101_A0_IGMIRCTLr_GET(r) (r).igmirctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_IGMIRCTLr_IN_MIR_MSKf_GET(r) (((r).igmirctl[0]) & 0x1ff)
#define BCM53101_A0_IGMIRCTLr_IN_MIR_MSKf_SET(r,f) (r).igmirctl[0]=(((r).igmirctl[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_IGMIRCTLr_RESERVEDf_GET(r) ((((r).igmirctl[0]) >> 9) & 0xf)
#define BCM53101_A0_IGMIRCTLr_RESERVEDf_SET(r,f) (r).igmirctl[0]=(((r).igmirctl[0] & ~((uint32_t)0xf << 9)) | ((((uint32_t)f) & 0xf) << 9))
#define BCM53101_A0_IGMIRCTLr_IN_DIV_ENf_GET(r) ((((r).igmirctl[0]) >> 13) & 0x1)
#define BCM53101_A0_IGMIRCTLr_IN_DIV_ENf_SET(r,f) (r).igmirctl[0]=(((r).igmirctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53101_A0_IGMIRCTLr_IN_MIR_FLTRf_GET(r) ((((r).igmirctl[0]) >> 14) & 0x3)
#define BCM53101_A0_IGMIRCTLr_IN_MIR_FLTRf_SET(r,f) (r).igmirctl[0]=(((r).igmirctl[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access IGMIRCTL.
 *
 */
#define BCM53101_A0_READ_IGMIRCTLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_IGMIRCTLr,(r._igmirctl),2)
#define BCM53101_A0_WRITE_IGMIRCTLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_IGMIRCTLr,&(r._igmirctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IGMIRCTLr BCM53101_A0_IGMIRCTLr
#define IGMIRCTLr_SIZE BCM53101_A0_IGMIRCTLr_SIZE
typedef BCM53101_A0_IGMIRCTLr_t IGMIRCTLr_t;
#define IGMIRCTLr_CLR BCM53101_A0_IGMIRCTLr_CLR
#define IGMIRCTLr_SET BCM53101_A0_IGMIRCTLr_SET
#define IGMIRCTLr_GET BCM53101_A0_IGMIRCTLr_GET
#define IGMIRCTLr_IN_MIR_MSKf_GET BCM53101_A0_IGMIRCTLr_IN_MIR_MSKf_GET
#define IGMIRCTLr_IN_MIR_MSKf_SET BCM53101_A0_IGMIRCTLr_IN_MIR_MSKf_SET
#define IGMIRCTLr_RESERVEDf_GET BCM53101_A0_IGMIRCTLr_RESERVEDf_GET
#define IGMIRCTLr_RESERVEDf_SET BCM53101_A0_IGMIRCTLr_RESERVEDf_SET
#define IGMIRCTLr_IN_DIV_ENf_GET BCM53101_A0_IGMIRCTLr_IN_DIV_ENf_GET
#define IGMIRCTLr_IN_DIV_ENf_SET BCM53101_A0_IGMIRCTLr_IN_DIV_ENf_SET
#define IGMIRCTLr_IN_MIR_FLTRf_GET BCM53101_A0_IGMIRCTLr_IN_MIR_FLTRf_GET
#define IGMIRCTLr_IN_MIR_FLTRf_SET BCM53101_A0_IGMIRCTLr_IN_MIR_FLTRf_SET
#define READ_IGMIRCTLr BCM53101_A0_READ_IGMIRCTLr
#define WRITE_IGMIRCTLr BCM53101_A0_WRITE_IGMIRCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_IGMIRCTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  IGMIRDIV
 * BLOCKS:   SYS
 * DESC:     Ingress Mirror Divider Register
 * SIZE:     16
 * FIELDS:
 *     IN_MIR_DIV       Ingress Mirror Divider.Receive frames that have passed the IN_MIRROR_FILTER rule can further be pruned to reduce the overall number of frames returned to the MIRROR_CAPTURE_PORT. When the IN_DIV_EN bit in the Ingress Mirror Control register is set, frames that pass the IN_MIRROR_FILTER rule are further divided by the value loaded into this register, so that only one in n frames (where n = IN_MIRROR_DIV + 1) will be mirrored.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_IGMIRDIVr 0x00000214

#define BCM53101_A0_IGMIRDIVr_SIZE 2

/*
 * This structure should be used to declare and program IGMIRDIV.
 *
 */
typedef union BCM53101_A0_IGMIRDIVr_s {
	uint32_t v[1];
	uint32_t igmirdiv[1];
	uint32_t _igmirdiv;
} BCM53101_A0_IGMIRDIVr_t;

#define BCM53101_A0_IGMIRDIVr_CLR(r) (r).igmirdiv[0] = 0
#define BCM53101_A0_IGMIRDIVr_SET(r,d) (r).igmirdiv[0] = d
#define BCM53101_A0_IGMIRDIVr_GET(r) (r).igmirdiv[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_IGMIRDIVr_IN_MIR_DIVf_GET(r) (((r).igmirdiv[0]) & 0x3ff)
#define BCM53101_A0_IGMIRDIVr_IN_MIR_DIVf_SET(r,f) (r).igmirdiv[0]=(((r).igmirdiv[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff))
#define BCM53101_A0_IGMIRDIVr_RESERVEDf_GET(r) ((((r).igmirdiv[0]) >> 10) & 0x3f)
#define BCM53101_A0_IGMIRDIVr_RESERVEDf_SET(r,f) (r).igmirdiv[0]=(((r).igmirdiv[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access IGMIRDIV.
 *
 */
#define BCM53101_A0_READ_IGMIRDIVr(u,r) cdk_robo_reg_read(u,BCM53101_A0_IGMIRDIVr,(r._igmirdiv),2)
#define BCM53101_A0_WRITE_IGMIRDIVr(u,r) cdk_robo_reg_write(u,BCM53101_A0_IGMIRDIVr,&(r._igmirdiv),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IGMIRDIVr BCM53101_A0_IGMIRDIVr
#define IGMIRDIVr_SIZE BCM53101_A0_IGMIRDIVr_SIZE
typedef BCM53101_A0_IGMIRDIVr_t IGMIRDIVr_t;
#define IGMIRDIVr_CLR BCM53101_A0_IGMIRDIVr_CLR
#define IGMIRDIVr_SET BCM53101_A0_IGMIRDIVr_SET
#define IGMIRDIVr_GET BCM53101_A0_IGMIRDIVr_GET
#define IGMIRDIVr_IN_MIR_DIVf_GET BCM53101_A0_IGMIRDIVr_IN_MIR_DIVf_GET
#define IGMIRDIVr_IN_MIR_DIVf_SET BCM53101_A0_IGMIRDIVr_IN_MIR_DIVf_SET
#define IGMIRDIVr_RESERVEDf_GET BCM53101_A0_IGMIRDIVr_RESERVEDf_GET
#define IGMIRDIVr_RESERVEDf_SET BCM53101_A0_IGMIRDIVr_RESERVEDf_SET
#define READ_IGMIRDIVr BCM53101_A0_READ_IGMIRDIVr
#define WRITE_IGMIRDIVr BCM53101_A0_WRITE_IGMIRDIVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_IGMIRDIVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  IGMIRMAC
 * BLOCKS:   SYS
 * DESC:     Ingress Mirror Mac Address Register
 * SIZE:     48
 * FIELDS:
 *     IN_MIR_MAC       Ingress Mirror MAC AddressMAC address that will be compared against ingress frames in accordance with the IN_MIRROR_FILTER rules.
 *
 ******************************************************************************/
#define BCM53101_A0_IGMIRMACr 0x00000216

#define BCM53101_A0_IGMIRMACr_SIZE 6

/*
 * This structure should be used to declare and program IGMIRMAC.
 *
 */
typedef union BCM53101_A0_IGMIRMACr_s {
	uint32_t v[2];
	uint32_t igmirmac[2];
	uint32_t _igmirmac;
} BCM53101_A0_IGMIRMACr_t;

#define BCM53101_A0_IGMIRMACr_CLR(r) CDK_MEMSET(&((r)._igmirmac), 0, sizeof(BCM53101_A0_IGMIRMACr_t))
#define BCM53101_A0_IGMIRMACr_SET(r,i,d) (r).igmirmac[i] = d
#define BCM53101_A0_IGMIRMACr_GET(r,i) (r).igmirmac[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_IGMIRMACr_IN_MIR_MACf_GET(r,a) cdk_field_get((r).igmirmac,0,47,a)
#define BCM53101_A0_IGMIRMACr_IN_MIR_MACf_SET(r,a) cdk_field_set((r).igmirmac,0,47,a)

/*
 * These macros can be used to access IGMIRMAC.
 *
 */
#define BCM53101_A0_READ_IGMIRMACr(u,r) cdk_robo_reg_read(u,BCM53101_A0_IGMIRMACr,(r._igmirmac),6)
#define BCM53101_A0_WRITE_IGMIRMACr(u,r) cdk_robo_reg_write(u,BCM53101_A0_IGMIRMACr,&(r._igmirmac),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IGMIRMACr BCM53101_A0_IGMIRMACr
#define IGMIRMACr_SIZE BCM53101_A0_IGMIRMACr_SIZE
typedef BCM53101_A0_IGMIRMACr_t IGMIRMACr_t;
#define IGMIRMACr_CLR BCM53101_A0_IGMIRMACr_CLR
#define IGMIRMACr_SET BCM53101_A0_IGMIRMACr_SET
#define IGMIRMACr_GET BCM53101_A0_IGMIRMACr_GET
#define IGMIRMACr_IN_MIR_MACf_GET BCM53101_A0_IGMIRMACr_IN_MIR_MACf_GET
#define IGMIRMACr_IN_MIR_MACf_SET BCM53101_A0_IGMIRMACr_IN_MIR_MACf_SET
#define READ_IGMIRMACr BCM53101_A0_READ_IGMIRMACr
#define WRITE_IGMIRMACr BCM53101_A0_WRITE_IGMIRMACr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_IGMIRMACr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  IMP0_PRT_ID
 * BLOCKS:   SYS
 * DESC:     IMP/IMP0 Port ID Register
 * SIZE:     8
 * FIELDS:
 *     IMP0_PRT_ID      IMP/IMP0 Port IDThis field specifies the port ID of the IMP/IMP0 port.In Lotus, IMP/IMP0 is fixed at Port 8.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_IMP0_PRT_IDr 0x00000201

#define BCM53101_A0_IMP0_PRT_IDr_SIZE 1

/*
 * This structure should be used to declare and program IMP0_PRT_ID.
 *
 */
typedef union BCM53101_A0_IMP0_PRT_IDr_s {
	uint32_t v[1];
	uint32_t imp0_prt_id[1];
	uint32_t _imp0_prt_id;
} BCM53101_A0_IMP0_PRT_IDr_t;

#define BCM53101_A0_IMP0_PRT_IDr_CLR(r) (r).imp0_prt_id[0] = 0
#define BCM53101_A0_IMP0_PRT_IDr_SET(r,d) (r).imp0_prt_id[0] = d
#define BCM53101_A0_IMP0_PRT_IDr_GET(r) (r).imp0_prt_id[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_IMP0_PRT_IDr_IMP0_PRT_IDf_GET(r) (((r).imp0_prt_id[0]) & 0xf)
#define BCM53101_A0_IMP0_PRT_IDr_IMP0_PRT_IDf_SET(r,f) (r).imp0_prt_id[0]=(((r).imp0_prt_id[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53101_A0_IMP0_PRT_IDr_RESERVEDf_GET(r) ((((r).imp0_prt_id[0]) >> 4) & 0xf)
#define BCM53101_A0_IMP0_PRT_IDr_RESERVEDf_SET(r,f) (r).imp0_prt_id[0]=(((r).imp0_prt_id[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access IMP0_PRT_ID.
 *
 */
#define BCM53101_A0_READ_IMP0_PRT_IDr(u,r) cdk_robo_reg_read(u,BCM53101_A0_IMP0_PRT_IDr,(r._imp0_prt_id),1)
#define BCM53101_A0_WRITE_IMP0_PRT_IDr(u,r) cdk_robo_reg_write(u,BCM53101_A0_IMP0_PRT_IDr,&(r._imp0_prt_id),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP0_PRT_IDr BCM53101_A0_IMP0_PRT_IDr
#define IMP0_PRT_IDr_SIZE BCM53101_A0_IMP0_PRT_IDr_SIZE
typedef BCM53101_A0_IMP0_PRT_IDr_t IMP0_PRT_IDr_t;
#define IMP0_PRT_IDr_CLR BCM53101_A0_IMP0_PRT_IDr_CLR
#define IMP0_PRT_IDr_SET BCM53101_A0_IMP0_PRT_IDr_SET
#define IMP0_PRT_IDr_GET BCM53101_A0_IMP0_PRT_IDr_GET
#define IMP0_PRT_IDr_IMP0_PRT_IDf_GET BCM53101_A0_IMP0_PRT_IDr_IMP0_PRT_IDf_GET
#define IMP0_PRT_IDr_IMP0_PRT_IDf_SET BCM53101_A0_IMP0_PRT_IDr_IMP0_PRT_IDf_SET
#define IMP0_PRT_IDr_RESERVEDf_GET BCM53101_A0_IMP0_PRT_IDr_RESERVEDf_GET
#define IMP0_PRT_IDr_RESERVEDf_SET BCM53101_A0_IMP0_PRT_IDr_RESERVEDf_SET
#define READ_IMP0_PRT_IDr BCM53101_A0_READ_IMP0_PRT_IDr
#define WRITE_IMP0_PRT_IDr BCM53101_A0_WRITE_IMP0_PRT_IDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_IMP0_PRT_IDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  IMP1_PRT_ID
 * BLOCKS:   SYS
 * DESC:     IMP1 Port ID Register
 * SIZE:     8
 * FIELDS:
 *     IMP1_PRT_ID      IMP/IMP1 Port IDThis field specifies the port ID of the IMP/IMP1 port.In Lotus, IMP/IMP1 is fixed at Port 5.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_IMP1_PRT_IDr 0x00000202

#define BCM53101_A0_IMP1_PRT_IDr_SIZE 1

/*
 * This structure should be used to declare and program IMP1_PRT_ID.
 *
 */
typedef union BCM53101_A0_IMP1_PRT_IDr_s {
	uint32_t v[1];
	uint32_t imp1_prt_id[1];
	uint32_t _imp1_prt_id;
} BCM53101_A0_IMP1_PRT_IDr_t;

#define BCM53101_A0_IMP1_PRT_IDr_CLR(r) (r).imp1_prt_id[0] = 0
#define BCM53101_A0_IMP1_PRT_IDr_SET(r,d) (r).imp1_prt_id[0] = d
#define BCM53101_A0_IMP1_PRT_IDr_GET(r) (r).imp1_prt_id[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_IMP1_PRT_IDr_IMP1_PRT_IDf_GET(r) (((r).imp1_prt_id[0]) & 0xf)
#define BCM53101_A0_IMP1_PRT_IDr_IMP1_PRT_IDf_SET(r,f) (r).imp1_prt_id[0]=(((r).imp1_prt_id[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53101_A0_IMP1_PRT_IDr_RESERVEDf_GET(r) ((((r).imp1_prt_id[0]) >> 4) & 0xf)
#define BCM53101_A0_IMP1_PRT_IDr_RESERVEDf_SET(r,f) (r).imp1_prt_id[0]=(((r).imp1_prt_id[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access IMP1_PRT_ID.
 *
 */
#define BCM53101_A0_READ_IMP1_PRT_IDr(u,r) cdk_robo_reg_read(u,BCM53101_A0_IMP1_PRT_IDr,(r._imp1_prt_id),1)
#define BCM53101_A0_WRITE_IMP1_PRT_IDr(u,r) cdk_robo_reg_write(u,BCM53101_A0_IMP1_PRT_IDr,&(r._imp1_prt_id),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP1_PRT_IDr BCM53101_A0_IMP1_PRT_IDr
#define IMP1_PRT_IDr_SIZE BCM53101_A0_IMP1_PRT_IDr_SIZE
typedef BCM53101_A0_IMP1_PRT_IDr_t IMP1_PRT_IDr_t;
#define IMP1_PRT_IDr_CLR BCM53101_A0_IMP1_PRT_IDr_CLR
#define IMP1_PRT_IDr_SET BCM53101_A0_IMP1_PRT_IDr_SET
#define IMP1_PRT_IDr_GET BCM53101_A0_IMP1_PRT_IDr_GET
#define IMP1_PRT_IDr_IMP1_PRT_IDf_GET BCM53101_A0_IMP1_PRT_IDr_IMP1_PRT_IDf_GET
#define IMP1_PRT_IDr_IMP1_PRT_IDf_SET BCM53101_A0_IMP1_PRT_IDr_IMP1_PRT_IDf_SET
#define IMP1_PRT_IDr_RESERVEDf_GET BCM53101_A0_IMP1_PRT_IDr_RESERVEDf_GET
#define IMP1_PRT_IDr_RESERVEDf_SET BCM53101_A0_IMP1_PRT_IDr_RESERVEDf_SET
#define READ_IMP1_PRT_IDr BCM53101_A0_READ_IMP1_PRT_IDr
#define WRITE_IMP1_PRT_IDr BCM53101_A0_WRITE_IMP1_PRT_IDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_IMP1_PRT_IDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  IMP_CTL
 * BLOCKS:   CPIC
 * DESC:     IMP Port Control Register
 * SIZE:     8
 * FIELDS:
 *     RX_DIS           Disables the receive function of the port at the MAC levelnot release for custom.
 *     TX_DIS           Disables the transmit function of the port at the MAC levelnot release for custom.
 *     RX_BCST_EN       Receive Broadcast Enable.Allow broadcast frames to be forwarded to the IMP, when the IMP is configured as the Frame Management Port.When cleared, multicast frames that meet the Mirror Ingree/Egress Rules will still be forwarded to the Frame Management Port.Ignored if the IMP is not selected as the Frame Management Port.
 *     RX_MCST_EN       Receive Multicast Enable.Allow multicast frames to be forwarded to the IMP, when the IMP is configured as the Frame Management Port, and the frame was flodded due to no matching address table entry.When cleared, multicast frames that meet the Mirror Ingree/Egress Rules will still be forwarded to the Frame Management Port.Ignored if the IMP is not selected as the Frame Management Port.
 *     RX_UCST_EN       Receive Unicast Enable.Allow unicast frames to be forwarded to the IMP, when the IMP is configured as the Frame Management Port, and the frame was flooded due to no matching address table entry.When cleared, unicast frames that meet the Mirror Ingree/Egress Rules will still be forwarded to the Frame Management Port.Ignored if the IMP is not selected as the Frame Management Port.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_IMP_CTLr 0x00000008

#define BCM53101_A0_IMP_CTLr_SIZE 1

/*
 * This structure should be used to declare and program IMP_CTL.
 *
 */
typedef union BCM53101_A0_IMP_CTLr_s {
	uint32_t v[1];
	uint32_t imp_ctl[1];
	uint32_t _imp_ctl;
} BCM53101_A0_IMP_CTLr_t;

#define BCM53101_A0_IMP_CTLr_CLR(r) (r).imp_ctl[0] = 0
#define BCM53101_A0_IMP_CTLr_SET(r,d) (r).imp_ctl[0] = d
#define BCM53101_A0_IMP_CTLr_GET(r) (r).imp_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_IMP_CTLr_RX_DISf_GET(r) (((r).imp_ctl[0]) & 0x1)
#define BCM53101_A0_IMP_CTLr_RX_DISf_SET(r,f) (r).imp_ctl[0]=(((r).imp_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_IMP_CTLr_TX_DISf_GET(r) ((((r).imp_ctl[0]) >> 1) & 0x1)
#define BCM53101_A0_IMP_CTLr_TX_DISf_SET(r,f) (r).imp_ctl[0]=(((r).imp_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_IMP_CTLr_RX_BCST_ENf_GET(r) ((((r).imp_ctl[0]) >> 2) & 0x1)
#define BCM53101_A0_IMP_CTLr_RX_BCST_ENf_SET(r,f) (r).imp_ctl[0]=(((r).imp_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_IMP_CTLr_RX_MCST_ENf_GET(r) ((((r).imp_ctl[0]) >> 3) & 0x1)
#define BCM53101_A0_IMP_CTLr_RX_MCST_ENf_SET(r,f) (r).imp_ctl[0]=(((r).imp_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_IMP_CTLr_RX_UCST_ENf_GET(r) ((((r).imp_ctl[0]) >> 4) & 0x1)
#define BCM53101_A0_IMP_CTLr_RX_UCST_ENf_SET(r,f) (r).imp_ctl[0]=(((r).imp_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_IMP_CTLr_RESERVEDf_GET(r) ((((r).imp_ctl[0]) >> 5) & 0x7)
#define BCM53101_A0_IMP_CTLr_RESERVEDf_SET(r,f) (r).imp_ctl[0]=(((r).imp_ctl[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access IMP_CTL.
 *
 */
#define BCM53101_A0_READ_IMP_CTLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_IMP_CTLr,(r._imp_ctl),1)
#define BCM53101_A0_WRITE_IMP_CTLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_IMP_CTLr,&(r._imp_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP_CTLr BCM53101_A0_IMP_CTLr
#define IMP_CTLr_SIZE BCM53101_A0_IMP_CTLr_SIZE
typedef BCM53101_A0_IMP_CTLr_t IMP_CTLr_t;
#define IMP_CTLr_CLR BCM53101_A0_IMP_CTLr_CLR
#define IMP_CTLr_SET BCM53101_A0_IMP_CTLr_SET
#define IMP_CTLr_GET BCM53101_A0_IMP_CTLr_GET
#define IMP_CTLr_RX_DISf_GET BCM53101_A0_IMP_CTLr_RX_DISf_GET
#define IMP_CTLr_RX_DISf_SET BCM53101_A0_IMP_CTLr_RX_DISf_SET
#define IMP_CTLr_TX_DISf_GET BCM53101_A0_IMP_CTLr_TX_DISf_GET
#define IMP_CTLr_TX_DISf_SET BCM53101_A0_IMP_CTLr_TX_DISf_SET
#define IMP_CTLr_RX_BCST_ENf_GET BCM53101_A0_IMP_CTLr_RX_BCST_ENf_GET
#define IMP_CTLr_RX_BCST_ENf_SET BCM53101_A0_IMP_CTLr_RX_BCST_ENf_SET
#define IMP_CTLr_RX_MCST_ENf_GET BCM53101_A0_IMP_CTLr_RX_MCST_ENf_GET
#define IMP_CTLr_RX_MCST_ENf_SET BCM53101_A0_IMP_CTLr_RX_MCST_ENf_SET
#define IMP_CTLr_RX_UCST_ENf_GET BCM53101_A0_IMP_CTLr_RX_UCST_ENf_GET
#define IMP_CTLr_RX_UCST_ENf_SET BCM53101_A0_IMP_CTLr_RX_UCST_ENf_SET
#define IMP_CTLr_RESERVEDf_GET BCM53101_A0_IMP_CTLr_RESERVEDf_GET
#define IMP_CTLr_RESERVEDf_SET BCM53101_A0_IMP_CTLr_RESERVEDf_SET
#define READ_IMP_CTLr BCM53101_A0_READ_IMP_CTLr
#define WRITE_IMP_CTLr BCM53101_A0_WRITE_IMP_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_IMP_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  IMP_EGRESS_RATE_CTRL_CFG_REG
 * BLOCKS:   SYS
 * DESC:     IMP0/1 Egress Rate Control Configuration Registers
 * SIZE:     8
 * FIELDS:
 *     RATE_INDEX       The rate_index is used to configure different egress rate for IMP in terms of Packet Per Second(PPS). When setting to 0, the egress rate is limited to a maximum of 384 packets/second for continuous minimum sized packet(68 bytes, including 4 byte BRCM header). When setting to 63, the egress rate control function is disabled and all packets are transmitted at wire-speed. The rate_index setting is not affected by the network speed configuration. For example, once you set the rate_index at certain value, the egress rate is limitted to the corresponding speed no matter the switch is running at 10Mbps, 100Mbps or 1Gbps. However, the maximum rate you programmed should be a reasonable value under the corresponding network speed configuration. For example, it doesn't make sense to set a value of 63 with the network configuration at 10Mbps. In that case, the egress rate is limitted up to 10Mbps no matter what.      Rate_index :        Packets/sec           0     :             384           1     :             512           2     :             639           3     :             768           4     :            1024           5     :            1280           6     :            1536           7     :            1791           8     :            2048           9     :            2303          10     :            2559          11     :            2815          12     :            3328          13     :            3840          14     :            4352          15     :            4863          16     :            5376          17     :            5887          18     :            6400          19     :            6911          20     :            7936          21     :            8960          22     :            9984          23     :           11008          24     :           12030          25     :           13054          26     :           14076          27     :           15105          28     :           17146          29     :           19201          30     :           21240          31     :           23299          32     :           25354          33     :           27382          34     :           29446          35     :           31486          36     :           35561          37     :           39682          38     :           42589          39     :           56818          40     :           71023          41     :           85324          42     :           99602          43     :          113636          44     :          127551          45     :          142045          46     :          213675          47     :          284091          48     :          357143          49     :          423729          50     :          500000          51     :          568182          52     :          641026          53     :          714286          54     :          781250          55     :          862069          56     :          925926          57     :         1000000          58     :         1086957          59     :         1136364          60     :         1190476          61     :         1250000          62     :         1315789          63     :         1388889
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr 0x000041c0

#define BCM53101_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_SIZE 1

/*
 * This structure should be used to declare and program IMP_EGRESS_RATE_CTRL_CFG_REG.
 *
 */
typedef union BCM53101_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_s {
	uint32_t v[1];
	uint32_t imp_egress_rate_ctrl_cfg_reg[1];
	uint32_t _imp_egress_rate_ctrl_cfg_reg;
} BCM53101_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_t;

#define BCM53101_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_CLR(r) (r).imp_egress_rate_ctrl_cfg_reg[0] = 0
#define BCM53101_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_SET(r,d) (r).imp_egress_rate_ctrl_cfg_reg[0] = d
#define BCM53101_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_GET(r) (r).imp_egress_rate_ctrl_cfg_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_RATE_INDEXf_GET(r) (((r).imp_egress_rate_ctrl_cfg_reg[0]) & 0x3f)
#define BCM53101_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_RATE_INDEXf_SET(r,f) (r).imp_egress_rate_ctrl_cfg_reg[0]=(((r).imp_egress_rate_ctrl_cfg_reg[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53101_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_RESERVEDf_GET(r) ((((r).imp_egress_rate_ctrl_cfg_reg[0]) >> 6) & 0x3)
#define BCM53101_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_RESERVEDf_SET(r,f) (r).imp_egress_rate_ctrl_cfg_reg[0]=(((r).imp_egress_rate_ctrl_cfg_reg[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access IMP_EGRESS_RATE_CTRL_CFG_REG.
 *
 */
#define BCM53101_A0_READ_IMP_EGRESS_RATE_CTRL_CFG_REGr(u,i,r) cdk_robo_reg_read(u,BCM53101_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr+(1*(i)),(r._imp_egress_rate_ctrl_cfg_reg),1)
#define BCM53101_A0_WRITE_IMP_EGRESS_RATE_CTRL_CFG_REGr(u,i,r) cdk_robo_reg_write(u,BCM53101_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr+(1*(i)),&(r._imp_egress_rate_ctrl_cfg_reg),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP_EGRESS_RATE_CTRL_CFG_REGr BCM53101_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr
#define IMP_EGRESS_RATE_CTRL_CFG_REGr_SIZE BCM53101_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_SIZE
typedef BCM53101_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_t IMP_EGRESS_RATE_CTRL_CFG_REGr_t;
#define IMP_EGRESS_RATE_CTRL_CFG_REGr_CLR BCM53101_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_CLR
#define IMP_EGRESS_RATE_CTRL_CFG_REGr_SET BCM53101_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_SET
#define IMP_EGRESS_RATE_CTRL_CFG_REGr_GET BCM53101_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_GET
#define IMP_EGRESS_RATE_CTRL_CFG_REGr_RATE_INDEXf_GET BCM53101_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_RATE_INDEXf_GET
#define IMP_EGRESS_RATE_CTRL_CFG_REGr_RATE_INDEXf_SET BCM53101_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_RATE_INDEXf_SET
#define IMP_EGRESS_RATE_CTRL_CFG_REGr_RESERVEDf_GET BCM53101_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_RESERVEDf_GET
#define IMP_EGRESS_RATE_CTRL_CFG_REGr_RESERVEDf_SET BCM53101_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr_RESERVEDf_SET
#define READ_IMP_EGRESS_RATE_CTRL_CFG_REGr BCM53101_A0_READ_IMP_EGRESS_RATE_CTRL_CFG_REGr
#define WRITE_IMP_EGRESS_RATE_CTRL_CFG_REGr BCM53101_A0_WRITE_IMP_EGRESS_RATE_CTRL_CFG_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_IMP_EGRESS_RATE_CTRL_CFG_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  IMP_PCP2TC
 * BLOCKS:   SYS
 * DESC:     Port 8 PCP to TC Map Register
 * SIZE:     32
 * FIELDS:
 *     TAG000_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 000 to Priority ID map Register
 *     TAG001_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 001 to Priority ID map Register
 *     TAG010_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 010 to Priority ID map Register
 *     TAG011_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 011 to Priority ID map Register
 *     TAG100_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 100 to Priority ID map Register
 *     TAG101_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 101 to Priority ID map Register
 *     TAG110_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 110 to Priority ID map Register
 *     TAG111_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 111 to Priority ID map Register
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_IMP_PCP2TCr 0x00003028

#define BCM53101_A0_IMP_PCP2TCr_SIZE 4

/*
 * This structure should be used to declare and program IMP_PCP2TC.
 *
 */
typedef union BCM53101_A0_IMP_PCP2TCr_s {
	uint32_t v[1];
	uint32_t imp_pcp2tc[1];
	uint32_t _imp_pcp2tc;
} BCM53101_A0_IMP_PCP2TCr_t;

#define BCM53101_A0_IMP_PCP2TCr_CLR(r) (r).imp_pcp2tc[0] = 0
#define BCM53101_A0_IMP_PCP2TCr_SET(r,d) (r).imp_pcp2tc[0] = d
#define BCM53101_A0_IMP_PCP2TCr_GET(r) (r).imp_pcp2tc[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_IMP_PCP2TCr_TAG000_PRI_MAPf_GET(r) (((r).imp_pcp2tc[0]) & 0x7)
#define BCM53101_A0_IMP_PCP2TCr_TAG000_PRI_MAPf_SET(r,f) (r).imp_pcp2tc[0]=(((r).imp_pcp2tc[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53101_A0_IMP_PCP2TCr_TAG001_PRI_MAPf_GET(r) ((((r).imp_pcp2tc[0]) >> 3) & 0x7)
#define BCM53101_A0_IMP_PCP2TCr_TAG001_PRI_MAPf_SET(r,f) (r).imp_pcp2tc[0]=(((r).imp_pcp2tc[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM53101_A0_IMP_PCP2TCr_TAG010_PRI_MAPf_GET(r) ((((r).imp_pcp2tc[0]) >> 6) & 0x7)
#define BCM53101_A0_IMP_PCP2TCr_TAG010_PRI_MAPf_SET(r,f) (r).imp_pcp2tc[0]=(((r).imp_pcp2tc[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM53101_A0_IMP_PCP2TCr_TAG011_PRI_MAPf_GET(r) ((((r).imp_pcp2tc[0]) >> 9) & 0x7)
#define BCM53101_A0_IMP_PCP2TCr_TAG011_PRI_MAPf_SET(r,f) (r).imp_pcp2tc[0]=(((r).imp_pcp2tc[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM53101_A0_IMP_PCP2TCr_TAG100_PRI_MAPf_GET(r) ((((r).imp_pcp2tc[0]) >> 12) & 0x7)
#define BCM53101_A0_IMP_PCP2TCr_TAG100_PRI_MAPf_SET(r,f) (r).imp_pcp2tc[0]=(((r).imp_pcp2tc[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53101_A0_IMP_PCP2TCr_TAG101_PRI_MAPf_GET(r) ((((r).imp_pcp2tc[0]) >> 15) & 0x7)
#define BCM53101_A0_IMP_PCP2TCr_TAG101_PRI_MAPf_SET(r,f) (r).imp_pcp2tc[0]=(((r).imp_pcp2tc[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM53101_A0_IMP_PCP2TCr_TAG110_PRI_MAPf_GET(r) ((((r).imp_pcp2tc[0]) >> 18) & 0x7)
#define BCM53101_A0_IMP_PCP2TCr_TAG110_PRI_MAPf_SET(r,f) (r).imp_pcp2tc[0]=(((r).imp_pcp2tc[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM53101_A0_IMP_PCP2TCr_TAG111_PRI_MAPf_GET(r) ((((r).imp_pcp2tc[0]) >> 21) & 0x7)
#define BCM53101_A0_IMP_PCP2TCr_TAG111_PRI_MAPf_SET(r,f) (r).imp_pcp2tc[0]=(((r).imp_pcp2tc[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM53101_A0_IMP_PCP2TCr_RESERVEDf_GET(r) ((((r).imp_pcp2tc[0]) >> 24) & 0xff)
#define BCM53101_A0_IMP_PCP2TCr_RESERVEDf_SET(r,f) (r).imp_pcp2tc[0]=(((r).imp_pcp2tc[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access IMP_PCP2TC.
 *
 */
#define BCM53101_A0_READ_IMP_PCP2TCr(u,r) cdk_robo_reg_read(u,BCM53101_A0_IMP_PCP2TCr,(r._imp_pcp2tc),4)
#define BCM53101_A0_WRITE_IMP_PCP2TCr(u,r) cdk_robo_reg_write(u,BCM53101_A0_IMP_PCP2TCr,&(r._imp_pcp2tc),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP_PCP2TCr BCM53101_A0_IMP_PCP2TCr
#define IMP_PCP2TCr_SIZE BCM53101_A0_IMP_PCP2TCr_SIZE
typedef BCM53101_A0_IMP_PCP2TCr_t IMP_PCP2TCr_t;
#define IMP_PCP2TCr_CLR BCM53101_A0_IMP_PCP2TCr_CLR
#define IMP_PCP2TCr_SET BCM53101_A0_IMP_PCP2TCr_SET
#define IMP_PCP2TCr_GET BCM53101_A0_IMP_PCP2TCr_GET
#define IMP_PCP2TCr_TAG000_PRI_MAPf_GET BCM53101_A0_IMP_PCP2TCr_TAG000_PRI_MAPf_GET
#define IMP_PCP2TCr_TAG000_PRI_MAPf_SET BCM53101_A0_IMP_PCP2TCr_TAG000_PRI_MAPf_SET
#define IMP_PCP2TCr_TAG001_PRI_MAPf_GET BCM53101_A0_IMP_PCP2TCr_TAG001_PRI_MAPf_GET
#define IMP_PCP2TCr_TAG001_PRI_MAPf_SET BCM53101_A0_IMP_PCP2TCr_TAG001_PRI_MAPf_SET
#define IMP_PCP2TCr_TAG010_PRI_MAPf_GET BCM53101_A0_IMP_PCP2TCr_TAG010_PRI_MAPf_GET
#define IMP_PCP2TCr_TAG010_PRI_MAPf_SET BCM53101_A0_IMP_PCP2TCr_TAG010_PRI_MAPf_SET
#define IMP_PCP2TCr_TAG011_PRI_MAPf_GET BCM53101_A0_IMP_PCP2TCr_TAG011_PRI_MAPf_GET
#define IMP_PCP2TCr_TAG011_PRI_MAPf_SET BCM53101_A0_IMP_PCP2TCr_TAG011_PRI_MAPf_SET
#define IMP_PCP2TCr_TAG100_PRI_MAPf_GET BCM53101_A0_IMP_PCP2TCr_TAG100_PRI_MAPf_GET
#define IMP_PCP2TCr_TAG100_PRI_MAPf_SET BCM53101_A0_IMP_PCP2TCr_TAG100_PRI_MAPf_SET
#define IMP_PCP2TCr_TAG101_PRI_MAPf_GET BCM53101_A0_IMP_PCP2TCr_TAG101_PRI_MAPf_GET
#define IMP_PCP2TCr_TAG101_PRI_MAPf_SET BCM53101_A0_IMP_PCP2TCr_TAG101_PRI_MAPf_SET
#define IMP_PCP2TCr_TAG110_PRI_MAPf_GET BCM53101_A0_IMP_PCP2TCr_TAG110_PRI_MAPf_GET
#define IMP_PCP2TCr_TAG110_PRI_MAPf_SET BCM53101_A0_IMP_PCP2TCr_TAG110_PRI_MAPf_SET
#define IMP_PCP2TCr_TAG111_PRI_MAPf_GET BCM53101_A0_IMP_PCP2TCr_TAG111_PRI_MAPf_GET
#define IMP_PCP2TCr_TAG111_PRI_MAPf_SET BCM53101_A0_IMP_PCP2TCr_TAG111_PRI_MAPf_SET
#define IMP_PCP2TCr_RESERVEDf_GET BCM53101_A0_IMP_PCP2TCr_RESERVEDf_GET
#define IMP_PCP2TCr_RESERVEDf_SET BCM53101_A0_IMP_PCP2TCr_RESERVEDf_SET
#define READ_IMP_PCP2TCr BCM53101_A0_READ_IMP_PCP2TCr
#define WRITE_IMP_PCP2TCr BCM53101_A0_WRITE_IMP_PCP2TCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_IMP_PCP2TCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  IMP_RGMII_CTL_GP
 * BLOCKS:   CPIC
 * DESC:     IMP RGMII Control register
 * SIZE:     8
 * FIELDS:
 *     TXC_DLL_DLY_EN   1: RGMII tx_clk delayed timing mode0: RGMII tx_clk aligned timing modedefault value by strap pin gtx_0_setup.
 *     RXC_DLL_DLY_EN   1: clock delay by DLL is enabled0: clock delay by DLL is disabled (Normal Mode)default value by strap pin grx_0_setup.
 *     BYP_DLL_2NS_DEL  1: bypass dll65_2ns_del IP0: go through dll65_2ns_del IPOnce this bis is enabled, the bypass_imp_2ns_del function will be affected by bit[0] and bit[1]{Bit[2], Bit[0]}= 2'b10, Bypass tx side dll65_2ns_del IP{Bit[2], Bit[0]}= 2'b11, go through tx side dll65_2ns_del IP{Bit[2], Bit[0]}= 2'b0X, go through tx side dll65_2ns_del IP{Bit[2], Bit[1]}= 2'b10, Bypass rx side dll65_2ns_del IP{Bit[2], Bit[1]}= 2'b11, go through rx side dll65_2ns_del IP{Bit[2], Bit[1}= 2'b0X, go through rx side dll65_2ns_del IP
 *     RESERVED_1       Reserved
 *     RESERVED_2       Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_IMP_RGMII_CTL_GPr 0x00000060

#define BCM53101_A0_IMP_RGMII_CTL_GPr_SIZE 1

/*
 * This structure should be used to declare and program IMP_RGMII_CTL_GP.
 *
 */
typedef union BCM53101_A0_IMP_RGMII_CTL_GPr_s {
	uint32_t v[1];
	uint32_t imp_rgmii_ctl_gp[1];
	uint32_t _imp_rgmii_ctl_gp;
} BCM53101_A0_IMP_RGMII_CTL_GPr_t;

#define BCM53101_A0_IMP_RGMII_CTL_GPr_CLR(r) (r).imp_rgmii_ctl_gp[0] = 0
#define BCM53101_A0_IMP_RGMII_CTL_GPr_SET(r,d) (r).imp_rgmii_ctl_gp[0] = d
#define BCM53101_A0_IMP_RGMII_CTL_GPr_GET(r) (r).imp_rgmii_ctl_gp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_IMP_RGMII_CTL_GPr_TXC_DLL_DLY_ENf_GET(r) (((r).imp_rgmii_ctl_gp[0]) & 0x1)
#define BCM53101_A0_IMP_RGMII_CTL_GPr_TXC_DLL_DLY_ENf_SET(r,f) (r).imp_rgmii_ctl_gp[0]=(((r).imp_rgmii_ctl_gp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_IMP_RGMII_CTL_GPr_RXC_DLL_DLY_ENf_GET(r) ((((r).imp_rgmii_ctl_gp[0]) >> 1) & 0x1)
#define BCM53101_A0_IMP_RGMII_CTL_GPr_RXC_DLL_DLY_ENf_SET(r,f) (r).imp_rgmii_ctl_gp[0]=(((r).imp_rgmii_ctl_gp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_IMP_RGMII_CTL_GPr_BYP_DLL_2NS_DELf_GET(r) ((((r).imp_rgmii_ctl_gp[0]) >> 2) & 0x1)
#define BCM53101_A0_IMP_RGMII_CTL_GPr_BYP_DLL_2NS_DELf_SET(r,f) (r).imp_rgmii_ctl_gp[0]=(((r).imp_rgmii_ctl_gp[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_IMP_RGMII_CTL_GPr_RESERVED_1f_GET(r) ((((r).imp_rgmii_ctl_gp[0]) >> 3) & 0x1)
#define BCM53101_A0_IMP_RGMII_CTL_GPr_RESERVED_1f_SET(r,f) (r).imp_rgmii_ctl_gp[0]=(((r).imp_rgmii_ctl_gp[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_IMP_RGMII_CTL_GPr_RESERVED_2f_GET(r) ((((r).imp_rgmii_ctl_gp[0]) >> 4) & 0xf)
#define BCM53101_A0_IMP_RGMII_CTL_GPr_RESERVED_2f_SET(r,f) (r).imp_rgmii_ctl_gp[0]=(((r).imp_rgmii_ctl_gp[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access IMP_RGMII_CTL_GP.
 *
 */
#define BCM53101_A0_READ_IMP_RGMII_CTL_GPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_IMP_RGMII_CTL_GPr,(r._imp_rgmii_ctl_gp),1)
#define BCM53101_A0_WRITE_IMP_RGMII_CTL_GPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_IMP_RGMII_CTL_GPr,&(r._imp_rgmii_ctl_gp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP_RGMII_CTL_GPr BCM53101_A0_IMP_RGMII_CTL_GPr
#define IMP_RGMII_CTL_GPr_SIZE BCM53101_A0_IMP_RGMII_CTL_GPr_SIZE
typedef BCM53101_A0_IMP_RGMII_CTL_GPr_t IMP_RGMII_CTL_GPr_t;
#define IMP_RGMII_CTL_GPr_CLR BCM53101_A0_IMP_RGMII_CTL_GPr_CLR
#define IMP_RGMII_CTL_GPr_SET BCM53101_A0_IMP_RGMII_CTL_GPr_SET
#define IMP_RGMII_CTL_GPr_GET BCM53101_A0_IMP_RGMII_CTL_GPr_GET
#define IMP_RGMII_CTL_GPr_TXC_DLL_DLY_ENf_GET BCM53101_A0_IMP_RGMII_CTL_GPr_TXC_DLL_DLY_ENf_GET
#define IMP_RGMII_CTL_GPr_TXC_DLL_DLY_ENf_SET BCM53101_A0_IMP_RGMII_CTL_GPr_TXC_DLL_DLY_ENf_SET
#define IMP_RGMII_CTL_GPr_RXC_DLL_DLY_ENf_GET BCM53101_A0_IMP_RGMII_CTL_GPr_RXC_DLL_DLY_ENf_GET
#define IMP_RGMII_CTL_GPr_RXC_DLL_DLY_ENf_SET BCM53101_A0_IMP_RGMII_CTL_GPr_RXC_DLL_DLY_ENf_SET
#define IMP_RGMII_CTL_GPr_BYP_DLL_2NS_DELf_GET BCM53101_A0_IMP_RGMII_CTL_GPr_BYP_DLL_2NS_DELf_GET
#define IMP_RGMII_CTL_GPr_BYP_DLL_2NS_DELf_SET BCM53101_A0_IMP_RGMII_CTL_GPr_BYP_DLL_2NS_DELf_SET
#define IMP_RGMII_CTL_GPr_RESERVED_1f_GET BCM53101_A0_IMP_RGMII_CTL_GPr_RESERVED_1f_GET
#define IMP_RGMII_CTL_GPr_RESERVED_1f_SET BCM53101_A0_IMP_RGMII_CTL_GPr_RESERVED_1f_SET
#define IMP_RGMII_CTL_GPr_RESERVED_2f_GET BCM53101_A0_IMP_RGMII_CTL_GPr_RESERVED_2f_GET
#define IMP_RGMII_CTL_GPr_RESERVED_2f_SET BCM53101_A0_IMP_RGMII_CTL_GPr_RESERVED_2f_SET
#define READ_IMP_RGMII_CTL_GPr BCM53101_A0_READ_IMP_RGMII_CTL_GPr
#define WRITE_IMP_RGMII_CTL_GPr BCM53101_A0_WRITE_IMP_RGMII_CTL_GPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_IMP_RGMII_CTL_GPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  IMP_RGMII_TIME_DLY_GP
 * BLOCKS:   CPIC
 * DESC:     IMP Port RGMII TIMING DELAY register
 * SIZE:     8
 * FIELDS:
 *     DEL_ADDR         delay timing selection4'b0111 : clk_gtxt = 1'b14'b1000 : clk_gtxg = 1'b14'b1001 : clk_gtxr = 1'b14'b1010 : clk_rxg = 1'b14'b1011 : clk_rxr = 1'b14'b1100 : Reserved4'b1101 : Reserved
 *     DEL_VALUE        110 =-1.0x111 = -0.5x000 = 0.0x001 = +0.5x010 = +1.0x
 *     DEL_STRB         Delay Value Write Enable1: CPU over-write Enable, del_value and del_addr will affect the RGMII interface timing adjustment0: Del_value and del_addr will not affect RGMII interface timing adjustment
 *
 ******************************************************************************/
#define BCM53101_A0_IMP_RGMII_TIME_DLY_GPr 0x00000068

#define BCM53101_A0_IMP_RGMII_TIME_DLY_GPr_SIZE 1

/*
 * This structure should be used to declare and program IMP_RGMII_TIME_DLY_GP.
 *
 */
typedef union BCM53101_A0_IMP_RGMII_TIME_DLY_GPr_s {
	uint32_t v[1];
	uint32_t imp_rgmii_time_dly_gp[1];
	uint32_t _imp_rgmii_time_dly_gp;
} BCM53101_A0_IMP_RGMII_TIME_DLY_GPr_t;

#define BCM53101_A0_IMP_RGMII_TIME_DLY_GPr_CLR(r) (r).imp_rgmii_time_dly_gp[0] = 0
#define BCM53101_A0_IMP_RGMII_TIME_DLY_GPr_SET(r,d) (r).imp_rgmii_time_dly_gp[0] = d
#define BCM53101_A0_IMP_RGMII_TIME_DLY_GPr_GET(r) (r).imp_rgmii_time_dly_gp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_IMP_RGMII_TIME_DLY_GPr_DEL_ADDRf_GET(r) (((r).imp_rgmii_time_dly_gp[0]) & 0xf)
#define BCM53101_A0_IMP_RGMII_TIME_DLY_GPr_DEL_ADDRf_SET(r,f) (r).imp_rgmii_time_dly_gp[0]=(((r).imp_rgmii_time_dly_gp[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53101_A0_IMP_RGMII_TIME_DLY_GPr_DEL_VALUEf_GET(r) ((((r).imp_rgmii_time_dly_gp[0]) >> 4) & 0x7)
#define BCM53101_A0_IMP_RGMII_TIME_DLY_GPr_DEL_VALUEf_SET(r,f) (r).imp_rgmii_time_dly_gp[0]=(((r).imp_rgmii_time_dly_gp[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM53101_A0_IMP_RGMII_TIME_DLY_GPr_DEL_STRBf_GET(r) ((((r).imp_rgmii_time_dly_gp[0]) >> 7) & 0x1)
#define BCM53101_A0_IMP_RGMII_TIME_DLY_GPr_DEL_STRBf_SET(r,f) (r).imp_rgmii_time_dly_gp[0]=(((r).imp_rgmii_time_dly_gp[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access IMP_RGMII_TIME_DLY_GP.
 *
 */
#define BCM53101_A0_READ_IMP_RGMII_TIME_DLY_GPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_IMP_RGMII_TIME_DLY_GPr,(r._imp_rgmii_time_dly_gp),1)
#define BCM53101_A0_WRITE_IMP_RGMII_TIME_DLY_GPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_IMP_RGMII_TIME_DLY_GPr,&(r._imp_rgmii_time_dly_gp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IMP_RGMII_TIME_DLY_GPr BCM53101_A0_IMP_RGMII_TIME_DLY_GPr
#define IMP_RGMII_TIME_DLY_GPr_SIZE BCM53101_A0_IMP_RGMII_TIME_DLY_GPr_SIZE
typedef BCM53101_A0_IMP_RGMII_TIME_DLY_GPr_t IMP_RGMII_TIME_DLY_GPr_t;
#define IMP_RGMII_TIME_DLY_GPr_CLR BCM53101_A0_IMP_RGMII_TIME_DLY_GPr_CLR
#define IMP_RGMII_TIME_DLY_GPr_SET BCM53101_A0_IMP_RGMII_TIME_DLY_GPr_SET
#define IMP_RGMII_TIME_DLY_GPr_GET BCM53101_A0_IMP_RGMII_TIME_DLY_GPr_GET
#define IMP_RGMII_TIME_DLY_GPr_DEL_ADDRf_GET BCM53101_A0_IMP_RGMII_TIME_DLY_GPr_DEL_ADDRf_GET
#define IMP_RGMII_TIME_DLY_GPr_DEL_ADDRf_SET BCM53101_A0_IMP_RGMII_TIME_DLY_GPr_DEL_ADDRf_SET
#define IMP_RGMII_TIME_DLY_GPr_DEL_VALUEf_GET BCM53101_A0_IMP_RGMII_TIME_DLY_GPr_DEL_VALUEf_GET
#define IMP_RGMII_TIME_DLY_GPr_DEL_VALUEf_SET BCM53101_A0_IMP_RGMII_TIME_DLY_GPr_DEL_VALUEf_SET
#define IMP_RGMII_TIME_DLY_GPr_DEL_STRBf_GET BCM53101_A0_IMP_RGMII_TIME_DLY_GPr_DEL_STRBf_GET
#define IMP_RGMII_TIME_DLY_GPr_DEL_STRBf_SET BCM53101_A0_IMP_RGMII_TIME_DLY_GPr_DEL_STRBf_SET
#define READ_IMP_RGMII_TIME_DLY_GPr BCM53101_A0_READ_IMP_RGMII_TIME_DLY_GPr
#define WRITE_IMP_RGMII_TIME_DLY_GPr BCM53101_A0_WRITE_IMP_RGMII_TIME_DLY_GPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_IMP_RGMII_TIME_DLY_GPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  INTERRUPT
 * BLOCKS:   EPIC0
 * DESC:     INTERRUPT REGISTER
 * SIZE:     16
 * FIELDS:
 *     INTR_STATUS      Interrupt status.
 *     LINK_CHANGE      Link change interrupt.
 *     SPD_CHANGE       Speed change interrupt.
 *     FDX_CHANGE       Duplex change interrupt.
 *     GLOBAL_INTR_INDICATOR 1 = Indicates an interrupt is present within the PHY.
 *     RESERVED         Reserved
 *     INTR_MASK        Master interrupt mask.
 *     LINK_MASK        Link interrupt mask.
 *     SPD_MASK         Speed interrupt mask.
 *     FDX_MASK         Full-duplex interrupt mask.
 *     INTR_ENABLE      Interrupt enable.
 *     FDX_LED_ENABLE   Ignore when read.
 *
 ******************************************************************************/
#define BCM53101_A0_INTERRUPTr 0x00001034

#define BCM53101_A0_INTERRUPTr_SIZE 2

/*
 * This structure should be used to declare and program INTERRUPT.
 *
 */
typedef union BCM53101_A0_INTERRUPTr_s {
	uint32_t v[1];
	uint32_t interrupt[1];
	uint32_t _interrupt;
} BCM53101_A0_INTERRUPTr_t;

#define BCM53101_A0_INTERRUPTr_CLR(r) (r).interrupt[0] = 0
#define BCM53101_A0_INTERRUPTr_SET(r,d) (r).interrupt[0] = d
#define BCM53101_A0_INTERRUPTr_GET(r) (r).interrupt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_INTERRUPTr_INTR_STATUSf_GET(r) (((r).interrupt[0]) & 0x1)
#define BCM53101_A0_INTERRUPTr_INTR_STATUSf_SET(r,f) (r).interrupt[0]=(((r).interrupt[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_INTERRUPTr_LINK_CHANGEf_GET(r) ((((r).interrupt[0]) >> 1) & 0x1)
#define BCM53101_A0_INTERRUPTr_LINK_CHANGEf_SET(r,f) (r).interrupt[0]=(((r).interrupt[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_INTERRUPTr_SPD_CHANGEf_GET(r) ((((r).interrupt[0]) >> 2) & 0x1)
#define BCM53101_A0_INTERRUPTr_SPD_CHANGEf_SET(r,f) (r).interrupt[0]=(((r).interrupt[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_INTERRUPTr_FDX_CHANGEf_GET(r) ((((r).interrupt[0]) >> 3) & 0x1)
#define BCM53101_A0_INTERRUPTr_FDX_CHANGEf_SET(r,f) (r).interrupt[0]=(((r).interrupt[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_INTERRUPTr_GLOBAL_INTR_INDICATORf_GET(r) ((((r).interrupt[0]) >> 4) & 0x1)
#define BCM53101_A0_INTERRUPTr_GLOBAL_INTR_INDICATORf_SET(r,f) (r).interrupt[0]=(((r).interrupt[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_INTERRUPTr_RESERVEDf_GET(r) ((((r).interrupt[0]) >> 5) & 0x7)
#define BCM53101_A0_INTERRUPTr_RESERVEDf_SET(r,f) (r).interrupt[0]=(((r).interrupt[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM53101_A0_INTERRUPTr_INTR_MASKf_GET(r) ((((r).interrupt[0]) >> 8) & 0x1)
#define BCM53101_A0_INTERRUPTr_INTR_MASKf_SET(r,f) (r).interrupt[0]=(((r).interrupt[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53101_A0_INTERRUPTr_LINK_MASKf_GET(r) ((((r).interrupt[0]) >> 9) & 0x1)
#define BCM53101_A0_INTERRUPTr_LINK_MASKf_SET(r,f) (r).interrupt[0]=(((r).interrupt[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53101_A0_INTERRUPTr_SPD_MASKf_GET(r) ((((r).interrupt[0]) >> 10) & 0x1)
#define BCM53101_A0_INTERRUPTr_SPD_MASKf_SET(r,f) (r).interrupt[0]=(((r).interrupt[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53101_A0_INTERRUPTr_FDX_MASKf_GET(r) ((((r).interrupt[0]) >> 11) & 0x1)
#define BCM53101_A0_INTERRUPTr_FDX_MASKf_SET(r,f) (r).interrupt[0]=(((r).interrupt[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53101_A0_INTERRUPTr_INTR_ENABLEf_GET(r) ((((r).interrupt[0]) >> 14) & 0x1)
#define BCM53101_A0_INTERRUPTr_INTR_ENABLEf_SET(r,f) (r).interrupt[0]=(((r).interrupt[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_INTERRUPTr_FDX_LED_ENABLEf_GET(r) ((((r).interrupt[0]) >> 15) & 0x1)
#define BCM53101_A0_INTERRUPTr_FDX_LED_ENABLEf_SET(r,f) (r).interrupt[0]=(((r).interrupt[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access INTERRUPT.
 *
 */
#define BCM53101_A0_READ_INTERRUPTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_INTERRUPTr,(r._interrupt),2)
#define BCM53101_A0_WRITE_INTERRUPTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_INTERRUPTr,&(r._interrupt),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define INTERRUPTr BCM53101_A0_INTERRUPTr
#define INTERRUPTr_SIZE BCM53101_A0_INTERRUPTr_SIZE
typedef BCM53101_A0_INTERRUPTr_t INTERRUPTr_t;
#define INTERRUPTr_CLR BCM53101_A0_INTERRUPTr_CLR
#define INTERRUPTr_SET BCM53101_A0_INTERRUPTr_SET
#define INTERRUPTr_GET BCM53101_A0_INTERRUPTr_GET
#define INTERRUPTr_INTR_STATUSf_GET BCM53101_A0_INTERRUPTr_INTR_STATUSf_GET
#define INTERRUPTr_INTR_STATUSf_SET BCM53101_A0_INTERRUPTr_INTR_STATUSf_SET
#define INTERRUPTr_LINK_CHANGEf_GET BCM53101_A0_INTERRUPTr_LINK_CHANGEf_GET
#define INTERRUPTr_LINK_CHANGEf_SET BCM53101_A0_INTERRUPTr_LINK_CHANGEf_SET
#define INTERRUPTr_SPD_CHANGEf_GET BCM53101_A0_INTERRUPTr_SPD_CHANGEf_GET
#define INTERRUPTr_SPD_CHANGEf_SET BCM53101_A0_INTERRUPTr_SPD_CHANGEf_SET
#define INTERRUPTr_FDX_CHANGEf_GET BCM53101_A0_INTERRUPTr_FDX_CHANGEf_GET
#define INTERRUPTr_FDX_CHANGEf_SET BCM53101_A0_INTERRUPTr_FDX_CHANGEf_SET
#define INTERRUPTr_GLOBAL_INTR_INDICATORf_GET BCM53101_A0_INTERRUPTr_GLOBAL_INTR_INDICATORf_GET
#define INTERRUPTr_GLOBAL_INTR_INDICATORf_SET BCM53101_A0_INTERRUPTr_GLOBAL_INTR_INDICATORf_SET
#define INTERRUPTr_RESERVEDf_GET BCM53101_A0_INTERRUPTr_RESERVEDf_GET
#define INTERRUPTr_RESERVEDf_SET BCM53101_A0_INTERRUPTr_RESERVEDf_SET
#define INTERRUPTr_INTR_MASKf_GET BCM53101_A0_INTERRUPTr_INTR_MASKf_GET
#define INTERRUPTr_INTR_MASKf_SET BCM53101_A0_INTERRUPTr_INTR_MASKf_SET
#define INTERRUPTr_LINK_MASKf_GET BCM53101_A0_INTERRUPTr_LINK_MASKf_GET
#define INTERRUPTr_LINK_MASKf_SET BCM53101_A0_INTERRUPTr_LINK_MASKf_SET
#define INTERRUPTr_SPD_MASKf_GET BCM53101_A0_INTERRUPTr_SPD_MASKf_GET
#define INTERRUPTr_SPD_MASKf_SET BCM53101_A0_INTERRUPTr_SPD_MASKf_SET
#define INTERRUPTr_FDX_MASKf_GET BCM53101_A0_INTERRUPTr_FDX_MASKf_GET
#define INTERRUPTr_FDX_MASKf_SET BCM53101_A0_INTERRUPTr_FDX_MASKf_SET
#define INTERRUPTr_INTR_ENABLEf_GET BCM53101_A0_INTERRUPTr_INTR_ENABLEf_GET
#define INTERRUPTr_INTR_ENABLEf_SET BCM53101_A0_INTERRUPTr_INTR_ENABLEf_SET
#define INTERRUPTr_FDX_LED_ENABLEf_GET BCM53101_A0_INTERRUPTr_FDX_LED_ENABLEf_GET
#define INTERRUPTr_FDX_LED_ENABLEf_SET BCM53101_A0_INTERRUPTr_FDX_LED_ENABLEf_SET
#define READ_INTERRUPTr BCM53101_A0_READ_INTERRUPTr
#define WRITE_INTERRUPTr BCM53101_A0_WRITE_INTERRUPTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_INTERRUPTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  INTERRUPT_EXT_P5
 * BLOCKS:   SYS
 * DESC:     INTERRUPT REGISTER
 * SIZE:     16
 * FIELDS:
 *     INTR_STATUS      Interrupt status.
 *     LINK_CHANGE      Link change interrupt.
 *     SPD_CHANGE       Speed change interrupt.
 *     FDX_CHANGE       Duplex change interrupt.
 *     GLOBAL_INTR_INDICATOR 1 = Indicates an interrupt is present within the PHY.
 *     RESERVED         Reserved
 *     INTR_MASK        Master interrupt mask.
 *     LINK_MASK        Link interrupt mask.
 *     SPD_MASK         Speed interrupt mask.
 *     FDX_MASK         Full-duplex interrupt mask.
 *     INTR_ENABLE      Interrupt enable.
 *     FDX_LED_ENABLE   Ignore when read.
 *
 ******************************************************************************/
#define BCM53101_A0_INTERRUPT_EXT_P5r 0x00008534

#define BCM53101_A0_INTERRUPT_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program INTERRUPT_EXT_P5.
 *
 */
typedef union BCM53101_A0_INTERRUPT_EXT_P5r_s {
	uint32_t v[1];
	uint32_t interrupt_ext_p5[1];
	uint32_t _interrupt_ext_p5;
} BCM53101_A0_INTERRUPT_EXT_P5r_t;

#define BCM53101_A0_INTERRUPT_EXT_P5r_CLR(r) (r).interrupt_ext_p5[0] = 0
#define BCM53101_A0_INTERRUPT_EXT_P5r_SET(r,d) (r).interrupt_ext_p5[0] = d
#define BCM53101_A0_INTERRUPT_EXT_P5r_GET(r) (r).interrupt_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_INTERRUPT_EXT_P5r_INTR_STATUSf_GET(r) (((r).interrupt_ext_p5[0]) & 0x1)
#define BCM53101_A0_INTERRUPT_EXT_P5r_INTR_STATUSf_SET(r,f) (r).interrupt_ext_p5[0]=(((r).interrupt_ext_p5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_INTERRUPT_EXT_P5r_LINK_CHANGEf_GET(r) ((((r).interrupt_ext_p5[0]) >> 1) & 0x1)
#define BCM53101_A0_INTERRUPT_EXT_P5r_LINK_CHANGEf_SET(r,f) (r).interrupt_ext_p5[0]=(((r).interrupt_ext_p5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_INTERRUPT_EXT_P5r_SPD_CHANGEf_GET(r) ((((r).interrupt_ext_p5[0]) >> 2) & 0x1)
#define BCM53101_A0_INTERRUPT_EXT_P5r_SPD_CHANGEf_SET(r,f) (r).interrupt_ext_p5[0]=(((r).interrupt_ext_p5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_INTERRUPT_EXT_P5r_FDX_CHANGEf_GET(r) ((((r).interrupt_ext_p5[0]) >> 3) & 0x1)
#define BCM53101_A0_INTERRUPT_EXT_P5r_FDX_CHANGEf_SET(r,f) (r).interrupt_ext_p5[0]=(((r).interrupt_ext_p5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_INTERRUPT_EXT_P5r_GLOBAL_INTR_INDICATORf_GET(r) ((((r).interrupt_ext_p5[0]) >> 4) & 0x1)
#define BCM53101_A0_INTERRUPT_EXT_P5r_GLOBAL_INTR_INDICATORf_SET(r,f) (r).interrupt_ext_p5[0]=(((r).interrupt_ext_p5[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_INTERRUPT_EXT_P5r_RESERVEDf_GET(r) ((((r).interrupt_ext_p5[0]) >> 5) & 0x7)
#define BCM53101_A0_INTERRUPT_EXT_P5r_RESERVEDf_SET(r,f) (r).interrupt_ext_p5[0]=(((r).interrupt_ext_p5[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))
#define BCM53101_A0_INTERRUPT_EXT_P5r_INTR_MASKf_GET(r) ((((r).interrupt_ext_p5[0]) >> 8) & 0x1)
#define BCM53101_A0_INTERRUPT_EXT_P5r_INTR_MASKf_SET(r,f) (r).interrupt_ext_p5[0]=(((r).interrupt_ext_p5[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53101_A0_INTERRUPT_EXT_P5r_LINK_MASKf_GET(r) ((((r).interrupt_ext_p5[0]) >> 9) & 0x1)
#define BCM53101_A0_INTERRUPT_EXT_P5r_LINK_MASKf_SET(r,f) (r).interrupt_ext_p5[0]=(((r).interrupt_ext_p5[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53101_A0_INTERRUPT_EXT_P5r_SPD_MASKf_GET(r) ((((r).interrupt_ext_p5[0]) >> 10) & 0x1)
#define BCM53101_A0_INTERRUPT_EXT_P5r_SPD_MASKf_SET(r,f) (r).interrupt_ext_p5[0]=(((r).interrupt_ext_p5[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53101_A0_INTERRUPT_EXT_P5r_FDX_MASKf_GET(r) ((((r).interrupt_ext_p5[0]) >> 11) & 0x1)
#define BCM53101_A0_INTERRUPT_EXT_P5r_FDX_MASKf_SET(r,f) (r).interrupt_ext_p5[0]=(((r).interrupt_ext_p5[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53101_A0_INTERRUPT_EXT_P5r_INTR_ENABLEf_GET(r) ((((r).interrupt_ext_p5[0]) >> 14) & 0x1)
#define BCM53101_A0_INTERRUPT_EXT_P5r_INTR_ENABLEf_SET(r,f) (r).interrupt_ext_p5[0]=(((r).interrupt_ext_p5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_INTERRUPT_EXT_P5r_FDX_LED_ENABLEf_GET(r) ((((r).interrupt_ext_p5[0]) >> 15) & 0x1)
#define BCM53101_A0_INTERRUPT_EXT_P5r_FDX_LED_ENABLEf_SET(r,f) (r).interrupt_ext_p5[0]=(((r).interrupt_ext_p5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access INTERRUPT_EXT_P5.
 *
 */
#define BCM53101_A0_READ_INTERRUPT_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53101_A0_INTERRUPT_EXT_P5r,(r._interrupt_ext_p5),2)
#define BCM53101_A0_WRITE_INTERRUPT_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53101_A0_INTERRUPT_EXT_P5r,&(r._interrupt_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define INTERRUPT_EXT_P5r BCM53101_A0_INTERRUPT_EXT_P5r
#define INTERRUPT_EXT_P5r_SIZE BCM53101_A0_INTERRUPT_EXT_P5r_SIZE
typedef BCM53101_A0_INTERRUPT_EXT_P5r_t INTERRUPT_EXT_P5r_t;
#define INTERRUPT_EXT_P5r_CLR BCM53101_A0_INTERRUPT_EXT_P5r_CLR
#define INTERRUPT_EXT_P5r_SET BCM53101_A0_INTERRUPT_EXT_P5r_SET
#define INTERRUPT_EXT_P5r_GET BCM53101_A0_INTERRUPT_EXT_P5r_GET
#define INTERRUPT_EXT_P5r_INTR_STATUSf_GET BCM53101_A0_INTERRUPT_EXT_P5r_INTR_STATUSf_GET
#define INTERRUPT_EXT_P5r_INTR_STATUSf_SET BCM53101_A0_INTERRUPT_EXT_P5r_INTR_STATUSf_SET
#define INTERRUPT_EXT_P5r_LINK_CHANGEf_GET BCM53101_A0_INTERRUPT_EXT_P5r_LINK_CHANGEf_GET
#define INTERRUPT_EXT_P5r_LINK_CHANGEf_SET BCM53101_A0_INTERRUPT_EXT_P5r_LINK_CHANGEf_SET
#define INTERRUPT_EXT_P5r_SPD_CHANGEf_GET BCM53101_A0_INTERRUPT_EXT_P5r_SPD_CHANGEf_GET
#define INTERRUPT_EXT_P5r_SPD_CHANGEf_SET BCM53101_A0_INTERRUPT_EXT_P5r_SPD_CHANGEf_SET
#define INTERRUPT_EXT_P5r_FDX_CHANGEf_GET BCM53101_A0_INTERRUPT_EXT_P5r_FDX_CHANGEf_GET
#define INTERRUPT_EXT_P5r_FDX_CHANGEf_SET BCM53101_A0_INTERRUPT_EXT_P5r_FDX_CHANGEf_SET
#define INTERRUPT_EXT_P5r_GLOBAL_INTR_INDICATORf_GET BCM53101_A0_INTERRUPT_EXT_P5r_GLOBAL_INTR_INDICATORf_GET
#define INTERRUPT_EXT_P5r_GLOBAL_INTR_INDICATORf_SET BCM53101_A0_INTERRUPT_EXT_P5r_GLOBAL_INTR_INDICATORf_SET
#define INTERRUPT_EXT_P5r_RESERVEDf_GET BCM53101_A0_INTERRUPT_EXT_P5r_RESERVEDf_GET
#define INTERRUPT_EXT_P5r_RESERVEDf_SET BCM53101_A0_INTERRUPT_EXT_P5r_RESERVEDf_SET
#define INTERRUPT_EXT_P5r_INTR_MASKf_GET BCM53101_A0_INTERRUPT_EXT_P5r_INTR_MASKf_GET
#define INTERRUPT_EXT_P5r_INTR_MASKf_SET BCM53101_A0_INTERRUPT_EXT_P5r_INTR_MASKf_SET
#define INTERRUPT_EXT_P5r_LINK_MASKf_GET BCM53101_A0_INTERRUPT_EXT_P5r_LINK_MASKf_GET
#define INTERRUPT_EXT_P5r_LINK_MASKf_SET BCM53101_A0_INTERRUPT_EXT_P5r_LINK_MASKf_SET
#define INTERRUPT_EXT_P5r_SPD_MASKf_GET BCM53101_A0_INTERRUPT_EXT_P5r_SPD_MASKf_GET
#define INTERRUPT_EXT_P5r_SPD_MASKf_SET BCM53101_A0_INTERRUPT_EXT_P5r_SPD_MASKf_SET
#define INTERRUPT_EXT_P5r_FDX_MASKf_GET BCM53101_A0_INTERRUPT_EXT_P5r_FDX_MASKf_GET
#define INTERRUPT_EXT_P5r_FDX_MASKf_SET BCM53101_A0_INTERRUPT_EXT_P5r_FDX_MASKf_SET
#define INTERRUPT_EXT_P5r_INTR_ENABLEf_GET BCM53101_A0_INTERRUPT_EXT_P5r_INTR_ENABLEf_GET
#define INTERRUPT_EXT_P5r_INTR_ENABLEf_SET BCM53101_A0_INTERRUPT_EXT_P5r_INTR_ENABLEf_SET
#define INTERRUPT_EXT_P5r_FDX_LED_ENABLEf_GET BCM53101_A0_INTERRUPT_EXT_P5r_FDX_LED_ENABLEf_GET
#define INTERRUPT_EXT_P5r_FDX_LED_ENABLEf_SET BCM53101_A0_INTERRUPT_EXT_P5r_FDX_LED_ENABLEf_SET
#define READ_INTERRUPT_EXT_P5r BCM53101_A0_READ_INTERRUPT_EXT_P5r
#define WRITE_INTERRUPT_EXT_P5r BCM53101_A0_WRITE_INTERRUPT_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_INTERRUPT_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  IPG_SHRNK_CTRL
 * BLOCKS:   SYS
 * DESC:     IPG Shrink Control Register
 * SIZE:     32
 * FIELDS:
 *     IPG_SHKCTRL      IPG Shrink ControlThis field specifies the IPG for each port.IPG shrinking at Egress.00: No IPG shrinking(default)01: IPG shrinking of 1-byte10: IPG shrinking of 4-byte11: IPG shrinking of 5-bytebit[17:16] = Port 8(IMP port)bit[15:12] = Reservedbit[11:0] = Port 5 ~ Port 0
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_IPG_SHRNK_CTRLr 0x0000020c

#define BCM53101_A0_IPG_SHRNK_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program IPG_SHRNK_CTRL.
 *
 */
typedef union BCM53101_A0_IPG_SHRNK_CTRLr_s {
	uint32_t v[1];
	uint32_t ipg_shrnk_ctrl[1];
	uint32_t _ipg_shrnk_ctrl;
} BCM53101_A0_IPG_SHRNK_CTRLr_t;

#define BCM53101_A0_IPG_SHRNK_CTRLr_CLR(r) (r).ipg_shrnk_ctrl[0] = 0
#define BCM53101_A0_IPG_SHRNK_CTRLr_SET(r,d) (r).ipg_shrnk_ctrl[0] = d
#define BCM53101_A0_IPG_SHRNK_CTRLr_GET(r) (r).ipg_shrnk_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_IPG_SHRNK_CTRLr_IPG_SHKCTRLf_GET(r) (((r).ipg_shrnk_ctrl[0]) & 0x3ffff)
#define BCM53101_A0_IPG_SHRNK_CTRLr_IPG_SHKCTRLf_SET(r,f) (r).ipg_shrnk_ctrl[0]=(((r).ipg_shrnk_ctrl[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))
#define BCM53101_A0_IPG_SHRNK_CTRLr_RESERVEDf_GET(r) ((((r).ipg_shrnk_ctrl[0]) >> 18) & 0x3fff)
#define BCM53101_A0_IPG_SHRNK_CTRLr_RESERVEDf_SET(r,f) (r).ipg_shrnk_ctrl[0]=(((r).ipg_shrnk_ctrl[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access IPG_SHRNK_CTRL.
 *
 */
#define BCM53101_A0_READ_IPG_SHRNK_CTRLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_IPG_SHRNK_CTRLr,(r._ipg_shrnk_ctrl),4)
#define BCM53101_A0_WRITE_IPG_SHRNK_CTRLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_IPG_SHRNK_CTRLr,&(r._ipg_shrnk_ctrl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define IPG_SHRNK_CTRLr BCM53101_A0_IPG_SHRNK_CTRLr
#define IPG_SHRNK_CTRLr_SIZE BCM53101_A0_IPG_SHRNK_CTRLr_SIZE
typedef BCM53101_A0_IPG_SHRNK_CTRLr_t IPG_SHRNK_CTRLr_t;
#define IPG_SHRNK_CTRLr_CLR BCM53101_A0_IPG_SHRNK_CTRLr_CLR
#define IPG_SHRNK_CTRLr_SET BCM53101_A0_IPG_SHRNK_CTRLr_SET
#define IPG_SHRNK_CTRLr_GET BCM53101_A0_IPG_SHRNK_CTRLr_GET
#define IPG_SHRNK_CTRLr_IPG_SHKCTRLf_GET BCM53101_A0_IPG_SHRNK_CTRLr_IPG_SHKCTRLf_GET
#define IPG_SHRNK_CTRLr_IPG_SHKCTRLf_SET BCM53101_A0_IPG_SHRNK_CTRLr_IPG_SHKCTRLf_SET
#define IPG_SHRNK_CTRLr_RESERVEDf_GET BCM53101_A0_IPG_SHRNK_CTRLr_RESERVEDf_GET
#define IPG_SHRNK_CTRLr_RESERVEDf_SET BCM53101_A0_IPG_SHRNK_CTRLr_RESERVEDf_SET
#define READ_IPG_SHRNK_CTRLr BCM53101_A0_READ_IPG_SHRNK_CTRLr
#define WRITE_IPG_SHRNK_CTRLr BCM53101_A0_WRITE_IPG_SHRNK_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_IPG_SHRNK_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  ISP_SEL_PORTMAP
 * BLOCKS:   SYS
 * DESC:     ISP Port Selection Portmap Registers
 * SIZE:     16
 * FIELDS:
 *     ISP_PORTMAP      Bittmap to define which port as ISP-port.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_ISP_SEL_PORTMAPr 0x00003432

#define BCM53101_A0_ISP_SEL_PORTMAPr_SIZE 2

/*
 * This structure should be used to declare and program ISP_SEL_PORTMAP.
 *
 */
typedef union BCM53101_A0_ISP_SEL_PORTMAPr_s {
	uint32_t v[1];
	uint32_t isp_sel_portmap[1];
	uint32_t _isp_sel_portmap;
} BCM53101_A0_ISP_SEL_PORTMAPr_t;

#define BCM53101_A0_ISP_SEL_PORTMAPr_CLR(r) (r).isp_sel_portmap[0] = 0
#define BCM53101_A0_ISP_SEL_PORTMAPr_SET(r,d) (r).isp_sel_portmap[0] = d
#define BCM53101_A0_ISP_SEL_PORTMAPr_GET(r) (r).isp_sel_portmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_ISP_SEL_PORTMAPr_ISP_PORTMAPf_GET(r) (((r).isp_sel_portmap[0]) & 0x1ff)
#define BCM53101_A0_ISP_SEL_PORTMAPr_ISP_PORTMAPf_SET(r,f) (r).isp_sel_portmap[0]=(((r).isp_sel_portmap[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_ISP_SEL_PORTMAPr_RESERVEDf_GET(r) ((((r).isp_sel_portmap[0]) >> 9) & 0x7f)
#define BCM53101_A0_ISP_SEL_PORTMAPr_RESERVEDf_SET(r,f) (r).isp_sel_portmap[0]=(((r).isp_sel_portmap[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access ISP_SEL_PORTMAP.
 *
 */
#define BCM53101_A0_READ_ISP_SEL_PORTMAPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_ISP_SEL_PORTMAPr,(r._isp_sel_portmap),2)
#define BCM53101_A0_WRITE_ISP_SEL_PORTMAPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_ISP_SEL_PORTMAPr,&(r._isp_sel_portmap),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ISP_SEL_PORTMAPr BCM53101_A0_ISP_SEL_PORTMAPr
#define ISP_SEL_PORTMAPr_SIZE BCM53101_A0_ISP_SEL_PORTMAPr_SIZE
typedef BCM53101_A0_ISP_SEL_PORTMAPr_t ISP_SEL_PORTMAPr_t;
#define ISP_SEL_PORTMAPr_CLR BCM53101_A0_ISP_SEL_PORTMAPr_CLR
#define ISP_SEL_PORTMAPr_SET BCM53101_A0_ISP_SEL_PORTMAPr_SET
#define ISP_SEL_PORTMAPr_GET BCM53101_A0_ISP_SEL_PORTMAPr_GET
#define ISP_SEL_PORTMAPr_ISP_PORTMAPf_GET BCM53101_A0_ISP_SEL_PORTMAPr_ISP_PORTMAPf_GET
#define ISP_SEL_PORTMAPr_ISP_PORTMAPf_SET BCM53101_A0_ISP_SEL_PORTMAPr_ISP_PORTMAPf_SET
#define ISP_SEL_PORTMAPr_RESERVEDf_GET BCM53101_A0_ISP_SEL_PORTMAPr_RESERVEDf_GET
#define ISP_SEL_PORTMAPr_RESERVEDf_SET BCM53101_A0_ISP_SEL_PORTMAPr_RESERVEDf_SET
#define READ_ISP_SEL_PORTMAPr BCM53101_A0_READ_ISP_SEL_PORTMAPr
#define WRITE_ISP_SEL_PORTMAPr BCM53101_A0_WRITE_ISP_SEL_PORTMAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_ISP_SEL_PORTMAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  InRangeErrCount
 * BLOCKS:   EPIC0 CPIC
 * DESC:     InRangeErrCount Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_INRANGEERRCOUNTr 0x000020b0

#define BCM53101_A0_INRANGEERRCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program InRangeErrCount.
 *
 */
typedef union BCM53101_A0_INRANGEERRCOUNTr_s {
	uint32_t v[1];
	uint32_t inrangeerrcount[1];
	uint32_t _inrangeerrcount;
} BCM53101_A0_INRANGEERRCOUNTr_t;

#define BCM53101_A0_INRANGEERRCOUNTr_CLR(r) (r).inrangeerrcount[0] = 0
#define BCM53101_A0_INRANGEERRCOUNTr_SET(r,d) (r).inrangeerrcount[0] = d
#define BCM53101_A0_INRANGEERRCOUNTr_GET(r) (r).inrangeerrcount[0]


/*
 * These macros can be used to access InRangeErrCount.
 *
 */
#define BCM53101_A0_READ_INRANGEERRCOUNTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_INRANGEERRCOUNTr,(r._inrangeerrcount),4)
#define BCM53101_A0_WRITE_INRANGEERRCOUNTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_INRANGEERRCOUNTr,&(r._inrangeerrcount),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define INRANGEERRCOUNTr BCM53101_A0_INRANGEERRCOUNTr
#define INRANGEERRCOUNTr_SIZE BCM53101_A0_INRANGEERRCOUNTr_SIZE
typedef BCM53101_A0_INRANGEERRCOUNTr_t INRANGEERRCOUNTr_t;
#define INRANGEERRCOUNTr_CLR BCM53101_A0_INRANGEERRCOUNTr_CLR
#define INRANGEERRCOUNTr_SET BCM53101_A0_INRANGEERRCOUNTr_SET
#define INRANGEERRCOUNTr_GET BCM53101_A0_INRANGEERRCOUNTr_GET
#define READ_INRANGEERRCOUNTr BCM53101_A0_READ_INRANGEERRCOUNTr
#define WRITE_INRANGEERRCOUNTr BCM53101_A0_WRITE_INRANGEERRCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_INRANGEERRCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  InRangeErrCount_IMP
 * BLOCKS:   CPIC
 * DESC:     InRangeErrCount Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_INRANGEERRCOUNT_IMPr 0x000028b0

#define BCM53101_A0_INRANGEERRCOUNT_IMPr_SIZE 4

/*
 * This structure should be used to declare and program InRangeErrCount_IMP.
 *
 */
typedef union BCM53101_A0_INRANGEERRCOUNT_IMPr_s {
	uint32_t v[1];
	uint32_t inrangeerrcount_imp[1];
	uint32_t _inrangeerrcount_imp;
} BCM53101_A0_INRANGEERRCOUNT_IMPr_t;

#define BCM53101_A0_INRANGEERRCOUNT_IMPr_CLR(r) (r).inrangeerrcount_imp[0] = 0
#define BCM53101_A0_INRANGEERRCOUNT_IMPr_SET(r,d) (r).inrangeerrcount_imp[0] = d
#define BCM53101_A0_INRANGEERRCOUNT_IMPr_GET(r) (r).inrangeerrcount_imp[0]


/*
 * These macros can be used to access InRangeErrCount_IMP.
 *
 */
#define BCM53101_A0_READ_INRANGEERRCOUNT_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_INRANGEERRCOUNT_IMPr,(r._inrangeerrcount_imp),4)
#define BCM53101_A0_WRITE_INRANGEERRCOUNT_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_INRANGEERRCOUNT_IMPr,&(r._inrangeerrcount_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define INRANGEERRCOUNT_IMPr BCM53101_A0_INRANGEERRCOUNT_IMPr
#define INRANGEERRCOUNT_IMPr_SIZE BCM53101_A0_INRANGEERRCOUNT_IMPr_SIZE
typedef BCM53101_A0_INRANGEERRCOUNT_IMPr_t INRANGEERRCOUNT_IMPr_t;
#define INRANGEERRCOUNT_IMPr_CLR BCM53101_A0_INRANGEERRCOUNT_IMPr_CLR
#define INRANGEERRCOUNT_IMPr_SET BCM53101_A0_INRANGEERRCOUNT_IMPr_SET
#define INRANGEERRCOUNT_IMPr_GET BCM53101_A0_INRANGEERRCOUNT_IMPr_GET
#define READ_INRANGEERRCOUNT_IMPr BCM53101_A0_READ_INRANGEERRCOUNT_IMPr
#define WRITE_INRANGEERRCOUNT_IMPr BCM53101_A0_WRITE_INRANGEERRCOUNT_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_INRANGEERRCOUNT_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  JUMBO_PORT_MASK
 * BLOCKS:   SYS
 * DESC:     Jumbo Frame Port Mask Registers
 * SIZE:     32
 * FIELDS:
 *     JUMBO_FM_PORT_MASK Jumbo Frame Port Mask.Ports defined in the Jumbo Frame Port Mask Register can Receive/Transmit Jumbo Frame ( Frame Size over 1522 bytes and less than 9728 bytes).Bit7:0 = Port 7-0 in chip 0.0 : Disable Jumbo Frame Capability,1 : Enable Jumbo Frame Capability,Jumbo Frames can be allowed to be delivered among these Ports. Non-Jumbo Frame will not be constrained by the register.
 *     RESERVED_0       Reserved.
 *     EN_10_100_JUMBO  Enable 10/100 Port can receive and transmit jumbo frame Only Giga Port can #receive jumbo frame as default.
 *     RESERVED_1       Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_JUMBO_PORT_MASKr 0x00004001

#define BCM53101_A0_JUMBO_PORT_MASKr_SIZE 4

/*
 * This structure should be used to declare and program JUMBO_PORT_MASK.
 *
 */
typedef union BCM53101_A0_JUMBO_PORT_MASKr_s {
	uint32_t v[1];
	uint32_t jumbo_port_mask[1];
	uint32_t _jumbo_port_mask;
} BCM53101_A0_JUMBO_PORT_MASKr_t;

#define BCM53101_A0_JUMBO_PORT_MASKr_CLR(r) (r).jumbo_port_mask[0] = 0
#define BCM53101_A0_JUMBO_PORT_MASKr_SET(r,d) (r).jumbo_port_mask[0] = d
#define BCM53101_A0_JUMBO_PORT_MASKr_GET(r) (r).jumbo_port_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_JUMBO_PORT_MASKr_JUMBO_FM_PORT_MASKf_GET(r) (((r).jumbo_port_mask[0]) & 0x1ff)
#define BCM53101_A0_JUMBO_PORT_MASKr_JUMBO_FM_PORT_MASKf_SET(r,f) (r).jumbo_port_mask[0]=(((r).jumbo_port_mask[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_JUMBO_PORT_MASKr_RESERVED_0f_GET(r) ((((r).jumbo_port_mask[0]) >> 9) & 0x7fff)
#define BCM53101_A0_JUMBO_PORT_MASKr_RESERVED_0f_SET(r,f) (r).jumbo_port_mask[0]=(((r).jumbo_port_mask[0] & ~((uint32_t)0x7fff << 9)) | ((((uint32_t)f) & 0x7fff) << 9))
#define BCM53101_A0_JUMBO_PORT_MASKr_EN_10_100_JUMBOf_GET(r) ((((r).jumbo_port_mask[0]) >> 24) & 0x1)
#define BCM53101_A0_JUMBO_PORT_MASKr_EN_10_100_JUMBOf_SET(r,f) (r).jumbo_port_mask[0]=(((r).jumbo_port_mask[0] & ~((uint32_t)0x1 << 24)) | ((((uint32_t)f) & 0x1) << 24))
#define BCM53101_A0_JUMBO_PORT_MASKr_RESERVED_1f_GET(r) ((((r).jumbo_port_mask[0]) >> 25) & 0x7f)
#define BCM53101_A0_JUMBO_PORT_MASKr_RESERVED_1f_SET(r,f) (r).jumbo_port_mask[0]=(((r).jumbo_port_mask[0] & ~((uint32_t)0x7f << 25)) | ((((uint32_t)f) & 0x7f) << 25))

/*
 * These macros can be used to access JUMBO_PORT_MASK.
 *
 */
#define BCM53101_A0_READ_JUMBO_PORT_MASKr(u,r) cdk_robo_reg_read(u,BCM53101_A0_JUMBO_PORT_MASKr,(r._jumbo_port_mask),4)
#define BCM53101_A0_WRITE_JUMBO_PORT_MASKr(u,r) cdk_robo_reg_write(u,BCM53101_A0_JUMBO_PORT_MASKr,&(r._jumbo_port_mask),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define JUMBO_PORT_MASKr BCM53101_A0_JUMBO_PORT_MASKr
#define JUMBO_PORT_MASKr_SIZE BCM53101_A0_JUMBO_PORT_MASKr_SIZE
typedef BCM53101_A0_JUMBO_PORT_MASKr_t JUMBO_PORT_MASKr_t;
#define JUMBO_PORT_MASKr_CLR BCM53101_A0_JUMBO_PORT_MASKr_CLR
#define JUMBO_PORT_MASKr_SET BCM53101_A0_JUMBO_PORT_MASKr_SET
#define JUMBO_PORT_MASKr_GET BCM53101_A0_JUMBO_PORT_MASKr_GET
#define JUMBO_PORT_MASKr_JUMBO_FM_PORT_MASKf_GET BCM53101_A0_JUMBO_PORT_MASKr_JUMBO_FM_PORT_MASKf_GET
#define JUMBO_PORT_MASKr_JUMBO_FM_PORT_MASKf_SET BCM53101_A0_JUMBO_PORT_MASKr_JUMBO_FM_PORT_MASKf_SET
#define JUMBO_PORT_MASKr_RESERVED_0f_GET BCM53101_A0_JUMBO_PORT_MASKr_RESERVED_0f_GET
#define JUMBO_PORT_MASKr_RESERVED_0f_SET BCM53101_A0_JUMBO_PORT_MASKr_RESERVED_0f_SET
#define JUMBO_PORT_MASKr_EN_10_100_JUMBOf_GET BCM53101_A0_JUMBO_PORT_MASKr_EN_10_100_JUMBOf_GET
#define JUMBO_PORT_MASKr_EN_10_100_JUMBOf_SET BCM53101_A0_JUMBO_PORT_MASKr_EN_10_100_JUMBOf_SET
#define JUMBO_PORT_MASKr_RESERVED_1f_GET BCM53101_A0_JUMBO_PORT_MASKr_RESERVED_1f_GET
#define JUMBO_PORT_MASKr_RESERVED_1f_SET BCM53101_A0_JUMBO_PORT_MASKr_RESERVED_1f_SET
#define READ_JUMBO_PORT_MASKr BCM53101_A0_READ_JUMBO_PORT_MASKr
#define WRITE_JUMBO_PORT_MASKr BCM53101_A0_WRITE_JUMBO_PORT_MASKr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_JUMBO_PORT_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  JumboPkt
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Jumbo Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_JUMBOPKTr 0x000020a8

#define BCM53101_A0_JUMBOPKTr_SIZE 4

/*
 * This structure should be used to declare and program JumboPkt.
 *
 */
typedef union BCM53101_A0_JUMBOPKTr_s {
	uint32_t v[1];
	uint32_t jumbopkt[1];
	uint32_t _jumbopkt;
} BCM53101_A0_JUMBOPKTr_t;

#define BCM53101_A0_JUMBOPKTr_CLR(r) (r).jumbopkt[0] = 0
#define BCM53101_A0_JUMBOPKTr_SET(r,d) (r).jumbopkt[0] = d
#define BCM53101_A0_JUMBOPKTr_GET(r) (r).jumbopkt[0]


/*
 * These macros can be used to access JumboPkt.
 *
 */
#define BCM53101_A0_READ_JUMBOPKTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_JUMBOPKTr,(r._jumbopkt),4)
#define BCM53101_A0_WRITE_JUMBOPKTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_JUMBOPKTr,&(r._jumbopkt),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define JUMBOPKTr BCM53101_A0_JUMBOPKTr
#define JUMBOPKTr_SIZE BCM53101_A0_JUMBOPKTr_SIZE
typedef BCM53101_A0_JUMBOPKTr_t JUMBOPKTr_t;
#define JUMBOPKTr_CLR BCM53101_A0_JUMBOPKTr_CLR
#define JUMBOPKTr_SET BCM53101_A0_JUMBOPKTr_SET
#define JUMBOPKTr_GET BCM53101_A0_JUMBOPKTr_GET
#define READ_JUMBOPKTr BCM53101_A0_READ_JUMBOPKTr
#define WRITE_JUMBOPKTr BCM53101_A0_WRITE_JUMBOPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_JUMBOPKTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  JumboPkt_IMP
 * BLOCKS:   CPIC
 * DESC:     Jumbo Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_JUMBOPKT_IMPr 0x000028a8

#define BCM53101_A0_JUMBOPKT_IMPr_SIZE 4

/*
 * This structure should be used to declare and program JumboPkt_IMP.
 *
 */
typedef union BCM53101_A0_JUMBOPKT_IMPr_s {
	uint32_t v[1];
	uint32_t jumbopkt_imp[1];
	uint32_t _jumbopkt_imp;
} BCM53101_A0_JUMBOPKT_IMPr_t;

#define BCM53101_A0_JUMBOPKT_IMPr_CLR(r) (r).jumbopkt_imp[0] = 0
#define BCM53101_A0_JUMBOPKT_IMPr_SET(r,d) (r).jumbopkt_imp[0] = d
#define BCM53101_A0_JUMBOPKT_IMPr_GET(r) (r).jumbopkt_imp[0]


/*
 * These macros can be used to access JumboPkt_IMP.
 *
 */
#define BCM53101_A0_READ_JUMBOPKT_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_JUMBOPKT_IMPr,(r._jumbopkt_imp),4)
#define BCM53101_A0_WRITE_JUMBOPKT_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_JUMBOPKT_IMPr,&(r._jumbopkt_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define JUMBOPKT_IMPr BCM53101_A0_JUMBOPKT_IMPr
#define JUMBOPKT_IMPr_SIZE BCM53101_A0_JUMBOPKT_IMPr_SIZE
typedef BCM53101_A0_JUMBOPKT_IMPr_t JUMBOPKT_IMPr_t;
#define JUMBOPKT_IMPr_CLR BCM53101_A0_JUMBOPKT_IMPr_CLR
#define JUMBOPKT_IMPr_SET BCM53101_A0_JUMBOPKT_IMPr_SET
#define JUMBOPKT_IMPr_GET BCM53101_A0_JUMBOPKT_IMPr_GET
#define READ_JUMBOPKT_IMPr BCM53101_A0_READ_JUMBOPKT_IMPr
#define WRITE_JUMBOPKT_IMPr BCM53101_A0_WRITE_JUMBOPKT_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_JUMBOPKT_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * MEMORY:  L2_ARL
 * BLOCKS:   SYS
 * DESC:     ARL Table
 * SIZE:     66
 * FIELDS:
 *     MACADDR_47_12    Source Address[47:12]
 *     VID              VID 
 *     MULTCAST_PORTMAP Multicast Portmap
 *     CONTROL          ARL control :2b'b00 : Normal ARL function.2b'b01 : Drop if MAC_DA match.(Please also set the "Static" bit)2b'b01 : Drop if MAC_SA match.(Please also set the "Static" bit)2b'b11 : Forward the destination port specified by ARL, Also send a copy to CPU.
 *     TC               Traffic Class
 *     AGE              Age bit
 *     STATIC           Static status
 *     VALID            Valid status
 *
 ******************************************************************************/
#define BCM53101_A0_L2_ARLm 0x12120808

#define BCM53101_A0_L2_ARLm_MIN 0
#define BCM53101_A0_L2_ARLm_MAX 2047
#define BCM53101_A0_L2_ARLm_CMAX(u) 2047
#define BCM53101_A0_L2_ARLm_SIZE 9

/*
 * This structure should be used to declare and program L2_ARL.
 *
 */
typedef union BCM53101_A0_L2_ARLm_s {
	uint32_t v[3];
	uint32_t l2_arl[3];
	uint32_t _l2_arl;
} BCM53101_A0_L2_ARLm_t;

#define BCM53101_A0_L2_ARLm_CLR(r) CDK_MEMSET(&((r)._l2_arl), 0, sizeof(BCM53101_A0_L2_ARLm_t))
#define BCM53101_A0_L2_ARLm_SET(r,i,d) (r).l2_arl[i] = d
#define BCM53101_A0_L2_ARLm_GET(r,i) (r).l2_arl[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_L2_ARLm_MACADDR_47_12f_GET(r,a) cdk_field_get((r).l2_arl,2,37,a)
#define BCM53101_A0_L2_ARLm_MACADDR_47_12f_SET(r,a) cdk_field_set((r).l2_arl,2,37,a)
#define BCM53101_A0_L2_ARLm_VIDf_GET(r) ((((r).l2_arl[1]) >> 7) & 0xfff)
#define BCM53101_A0_L2_ARLm_VIDf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0xfff << 7)) | ((((uint32_t)f) & 0xfff) << 7))
#define BCM53101_A0_L2_ARLm_MULTCAST_PORTMAPf_GET(r) ((((r).l2_arl[1]) >> 19) & 0x7f)
#define BCM53101_A0_L2_ARLm_MULTCAST_PORTMAPf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0x7f << 19)) | ((((uint32_t)f) & 0x7f) << 19))
#define BCM53101_A0_L2_ARLm_CONTROLf_GET(r) ((((r).l2_arl[1]) >> 26) & 0x3)
#define BCM53101_A0_L2_ARLm_CONTROLf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0x3 << 26)) | ((((uint32_t)f) & 0x3) << 26))
#define BCM53101_A0_L2_ARLm_TCf_GET(r) ((((r).l2_arl[1]) >> 28) & 0x7)
#define BCM53101_A0_L2_ARLm_TCf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0x7 << 28)) | ((((uint32_t)f) & 0x7) << 28))
#define BCM53101_A0_L2_ARLm_AGEf_GET(r) ((((r).l2_arl[1]) >> 31) & 0x1)
#define BCM53101_A0_L2_ARLm_AGEf_SET(r,f) (r).l2_arl[1]=(((r).l2_arl[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM53101_A0_L2_ARLm_STATICf_GET(r) (((r).l2_arl[2]) & 0x1)
#define BCM53101_A0_L2_ARLm_STATICf_SET(r,f) (r).l2_arl[2]=(((r).l2_arl[2] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_L2_ARLm_VALIDf_GET(r) ((((r).l2_arl[2]) >> 1) & 0x1)
#define BCM53101_A0_L2_ARLm_VALIDf_SET(r,f) (r).l2_arl[2]=(((r).l2_arl[2] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))

/*
 * These macros can be used to access L2_ARL.
 *
 */
#define BCM53101_A0_READ_L2_ARLm(u,i,m) cdk_robo_mem_read(u,BCM53101_A0_L2_ARLm,i,(m),9)
#define BCM53101_A0_WRITE_L2_ARLm(u,i,m) cdk_robo_mem_write(u,BCM53101_A0_L2_ARLm,i,&(m),9)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define L2_ARLm BCM53101_A0_L2_ARLm
#define L2_ARLm_MIN BCM53101_A0_L2_ARLm_MIN
#define L2_ARLm_MAX BCM53101_A0_L2_ARLm_MAX
#define L2_ARLm_CMAX(u) BCM53101_A0_L2_ARLm_CMAX(u)
#define L2_ARLm_SIZE BCM53101_A0_L2_ARLm_SIZE
typedef BCM53101_A0_L2_ARLm_t L2_ARLm_t;
#define L2_ARLm_CLR BCM53101_A0_L2_ARLm_CLR
#define L2_ARLm_SET BCM53101_A0_L2_ARLm_SET
#define L2_ARLm_GET BCM53101_A0_L2_ARLm_GET
#define L2_ARLm_MACADDR_47_12f_GET BCM53101_A0_L2_ARLm_MACADDR_47_12f_GET
#define L2_ARLm_MACADDR_47_12f_SET BCM53101_A0_L2_ARLm_MACADDR_47_12f_SET
#define L2_ARLm_VIDf_GET BCM53101_A0_L2_ARLm_VIDf_GET
#define L2_ARLm_VIDf_SET BCM53101_A0_L2_ARLm_VIDf_SET
#define L2_ARLm_MULTCAST_PORTMAPf_GET BCM53101_A0_L2_ARLm_MULTCAST_PORTMAPf_GET
#define L2_ARLm_MULTCAST_PORTMAPf_SET BCM53101_A0_L2_ARLm_MULTCAST_PORTMAPf_SET
#define L2_ARLm_CONTROLf_GET BCM53101_A0_L2_ARLm_CONTROLf_GET
#define L2_ARLm_CONTROLf_SET BCM53101_A0_L2_ARLm_CONTROLf_SET
#define L2_ARLm_TCf_GET BCM53101_A0_L2_ARLm_TCf_GET
#define L2_ARLm_TCf_SET BCM53101_A0_L2_ARLm_TCf_SET
#define L2_ARLm_AGEf_GET BCM53101_A0_L2_ARLm_AGEf_GET
#define L2_ARLm_AGEf_SET BCM53101_A0_L2_ARLm_AGEf_SET
#define L2_ARLm_STATICf_GET BCM53101_A0_L2_ARLm_STATICf_GET
#define L2_ARLm_STATICf_SET BCM53101_A0_L2_ARLm_STATICf_SET
#define L2_ARLm_VALIDf_GET BCM53101_A0_L2_ARLm_VALIDf_GET
#define L2_ARLm_VALIDf_SET BCM53101_A0_L2_ARLm_VALIDf_SET
#define READ_L2_ARLm BCM53101_A0_READ_L2_ARLm
#define WRITE_L2_ARLm BCM53101_A0_WRITE_L2_ARLm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_L2_ARLm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  LED_EN_MAP
 * BLOCKS:   SYS
 * DESC:     LED Enable Map register
 * SIZE:     16
 * FIELDS:
 *     LED_EN_MAP       Per port enable function bit,1: Enable LED function1: Disable LED function
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_LED_EN_MAPr 0x00000016

#define BCM53101_A0_LED_EN_MAPr_SIZE 2

/*
 * This structure should be used to declare and program LED_EN_MAP.
 *
 */
typedef union BCM53101_A0_LED_EN_MAPr_s {
	uint32_t v[1];
	uint32_t led_en_map[1];
	uint32_t _led_en_map;
} BCM53101_A0_LED_EN_MAPr_t;

#define BCM53101_A0_LED_EN_MAPr_CLR(r) (r).led_en_map[0] = 0
#define BCM53101_A0_LED_EN_MAPr_SET(r,d) (r).led_en_map[0] = d
#define BCM53101_A0_LED_EN_MAPr_GET(r) (r).led_en_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_LED_EN_MAPr_LED_EN_MAPf_GET(r) (((r).led_en_map[0]) & 0x1ff)
#define BCM53101_A0_LED_EN_MAPr_LED_EN_MAPf_SET(r,f) (r).led_en_map[0]=(((r).led_en_map[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_LED_EN_MAPr_RESERVEDf_GET(r) ((((r).led_en_map[0]) >> 9) & 0x7f)
#define BCM53101_A0_LED_EN_MAPr_RESERVEDf_SET(r,f) (r).led_en_map[0]=(((r).led_en_map[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access LED_EN_MAP.
 *
 */
#define BCM53101_A0_READ_LED_EN_MAPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_LED_EN_MAPr,(r._led_en_map),2)
#define BCM53101_A0_WRITE_LED_EN_MAPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_LED_EN_MAPr,&(r._led_en_map),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_EN_MAPr BCM53101_A0_LED_EN_MAPr
#define LED_EN_MAPr_SIZE BCM53101_A0_LED_EN_MAPr_SIZE
typedef BCM53101_A0_LED_EN_MAPr_t LED_EN_MAPr_t;
#define LED_EN_MAPr_CLR BCM53101_A0_LED_EN_MAPr_CLR
#define LED_EN_MAPr_SET BCM53101_A0_LED_EN_MAPr_SET
#define LED_EN_MAPr_GET BCM53101_A0_LED_EN_MAPr_GET
#define LED_EN_MAPr_LED_EN_MAPf_GET BCM53101_A0_LED_EN_MAPr_LED_EN_MAPf_GET
#define LED_EN_MAPr_LED_EN_MAPf_SET BCM53101_A0_LED_EN_MAPr_LED_EN_MAPf_SET
#define LED_EN_MAPr_RESERVEDf_GET BCM53101_A0_LED_EN_MAPr_RESERVEDf_GET
#define LED_EN_MAPr_RESERVEDf_SET BCM53101_A0_LED_EN_MAPr_RESERVEDf_SET
#define READ_LED_EN_MAPr BCM53101_A0_READ_LED_EN_MAPr
#define WRITE_LED_EN_MAPr BCM53101_A0_WRITE_LED_EN_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_LED_EN_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  LED_FUNC0_CTL
 * BLOCKS:   SYS
 * DESC:     LED Function 0 control register
 * SIZE:     16
 * FIELDS:
 *     LED_FUNC0        default : ledmode=00 : 16'h2024;          ledmode=01 : 16'h1021;          ledmode=10 : 16'h4804;          ledmode=11 : 16'ha010;
 *
 ******************************************************************************/
#define BCM53101_A0_LED_FUNC0_CTLr 0x00000010

#define BCM53101_A0_LED_FUNC0_CTLr_SIZE 2

/*
 * This structure should be used to declare and program LED_FUNC0_CTL.
 *
 */
typedef union BCM53101_A0_LED_FUNC0_CTLr_s {
	uint32_t v[1];
	uint32_t led_func0_ctl[1];
	uint32_t _led_func0_ctl;
} BCM53101_A0_LED_FUNC0_CTLr_t;

#define BCM53101_A0_LED_FUNC0_CTLr_CLR(r) (r).led_func0_ctl[0] = 0
#define BCM53101_A0_LED_FUNC0_CTLr_SET(r,d) (r).led_func0_ctl[0] = d
#define BCM53101_A0_LED_FUNC0_CTLr_GET(r) (r).led_func0_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_LED_FUNC0_CTLr_LED_FUNC0f_GET(r) (((r).led_func0_ctl[0]) & 0xffff)
#define BCM53101_A0_LED_FUNC0_CTLr_LED_FUNC0f_SET(r,f) (r).led_func0_ctl[0]=(((r).led_func0_ctl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LED_FUNC0_CTL.
 *
 */
#define BCM53101_A0_READ_LED_FUNC0_CTLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_LED_FUNC0_CTLr,(r._led_func0_ctl),2)
#define BCM53101_A0_WRITE_LED_FUNC0_CTLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_LED_FUNC0_CTLr,&(r._led_func0_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_FUNC0_CTLr BCM53101_A0_LED_FUNC0_CTLr
#define LED_FUNC0_CTLr_SIZE BCM53101_A0_LED_FUNC0_CTLr_SIZE
typedef BCM53101_A0_LED_FUNC0_CTLr_t LED_FUNC0_CTLr_t;
#define LED_FUNC0_CTLr_CLR BCM53101_A0_LED_FUNC0_CTLr_CLR
#define LED_FUNC0_CTLr_SET BCM53101_A0_LED_FUNC0_CTLr_SET
#define LED_FUNC0_CTLr_GET BCM53101_A0_LED_FUNC0_CTLr_GET
#define LED_FUNC0_CTLr_LED_FUNC0f_GET BCM53101_A0_LED_FUNC0_CTLr_LED_FUNC0f_GET
#define LED_FUNC0_CTLr_LED_FUNC0f_SET BCM53101_A0_LED_FUNC0_CTLr_LED_FUNC0f_SET
#define READ_LED_FUNC0_CTLr BCM53101_A0_READ_LED_FUNC0_CTLr
#define WRITE_LED_FUNC0_CTLr BCM53101_A0_WRITE_LED_FUNC0_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_LED_FUNC0_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  LED_FUNC1_CTL
 * BLOCKS:   SYS
 * DESC:     LED Function 1 control register
 * SIZE:     16
 * FIELDS:
 *     LED_FUNC1        default : ledmode=00 : 16'h2024;          ledmode=01 : 16'h1021;          ledmode=10 : 16'h4804;          ledmode=11 : 16'ha010;
 *
 ******************************************************************************/
#define BCM53101_A0_LED_FUNC1_CTLr 0x00000012

#define BCM53101_A0_LED_FUNC1_CTLr_SIZE 2

/*
 * This structure should be used to declare and program LED_FUNC1_CTL.
 *
 */
typedef union BCM53101_A0_LED_FUNC1_CTLr_s {
	uint32_t v[1];
	uint32_t led_func1_ctl[1];
	uint32_t _led_func1_ctl;
} BCM53101_A0_LED_FUNC1_CTLr_t;

#define BCM53101_A0_LED_FUNC1_CTLr_CLR(r) (r).led_func1_ctl[0] = 0
#define BCM53101_A0_LED_FUNC1_CTLr_SET(r,d) (r).led_func1_ctl[0] = d
#define BCM53101_A0_LED_FUNC1_CTLr_GET(r) (r).led_func1_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_LED_FUNC1_CTLr_LED_FUNC1f_GET(r) (((r).led_func1_ctl[0]) & 0xffff)
#define BCM53101_A0_LED_FUNC1_CTLr_LED_FUNC1f_SET(r,f) (r).led_func1_ctl[0]=(((r).led_func1_ctl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access LED_FUNC1_CTL.
 *
 */
#define BCM53101_A0_READ_LED_FUNC1_CTLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_LED_FUNC1_CTLr,(r._led_func1_ctl),2)
#define BCM53101_A0_WRITE_LED_FUNC1_CTLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_LED_FUNC1_CTLr,&(r._led_func1_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_FUNC1_CTLr BCM53101_A0_LED_FUNC1_CTLr
#define LED_FUNC1_CTLr_SIZE BCM53101_A0_LED_FUNC1_CTLr_SIZE
typedef BCM53101_A0_LED_FUNC1_CTLr_t LED_FUNC1_CTLr_t;
#define LED_FUNC1_CTLr_CLR BCM53101_A0_LED_FUNC1_CTLr_CLR
#define LED_FUNC1_CTLr_SET BCM53101_A0_LED_FUNC1_CTLr_SET
#define LED_FUNC1_CTLr_GET BCM53101_A0_LED_FUNC1_CTLr_GET
#define LED_FUNC1_CTLr_LED_FUNC1f_GET BCM53101_A0_LED_FUNC1_CTLr_LED_FUNC1f_GET
#define LED_FUNC1_CTLr_LED_FUNC1f_SET BCM53101_A0_LED_FUNC1_CTLr_LED_FUNC1f_SET
#define READ_LED_FUNC1_CTLr BCM53101_A0_READ_LED_FUNC1_CTLr
#define WRITE_LED_FUNC1_CTLr BCM53101_A0_WRITE_LED_FUNC1_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_LED_FUNC1_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  LED_FUNC_MAP
 * BLOCKS:   SYS
 * DESC:     LED Function Map register
 * SIZE:     16
 * FIELDS:
 *     LED_FUNC_MAP     Per port select function bit.1: select function 1,0: select function 0.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_LED_FUNC_MAPr 0x00000014

#define BCM53101_A0_LED_FUNC_MAPr_SIZE 2

/*
 * This structure should be used to declare and program LED_FUNC_MAP.
 *
 */
typedef union BCM53101_A0_LED_FUNC_MAPr_s {
	uint32_t v[1];
	uint32_t led_func_map[1];
	uint32_t _led_func_map;
} BCM53101_A0_LED_FUNC_MAPr_t;

#define BCM53101_A0_LED_FUNC_MAPr_CLR(r) (r).led_func_map[0] = 0
#define BCM53101_A0_LED_FUNC_MAPr_SET(r,d) (r).led_func_map[0] = d
#define BCM53101_A0_LED_FUNC_MAPr_GET(r) (r).led_func_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_LED_FUNC_MAPr_LED_FUNC_MAPf_GET(r) (((r).led_func_map[0]) & 0x1ff)
#define BCM53101_A0_LED_FUNC_MAPr_LED_FUNC_MAPf_SET(r,f) (r).led_func_map[0]=(((r).led_func_map[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_LED_FUNC_MAPr_RESERVEDf_GET(r) ((((r).led_func_map[0]) >> 9) & 0x7f)
#define BCM53101_A0_LED_FUNC_MAPr_RESERVEDf_SET(r,f) (r).led_func_map[0]=(((r).led_func_map[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access LED_FUNC_MAP.
 *
 */
#define BCM53101_A0_READ_LED_FUNC_MAPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_LED_FUNC_MAPr,(r._led_func_map),2)
#define BCM53101_A0_WRITE_LED_FUNC_MAPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_LED_FUNC_MAPr,&(r._led_func_map),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_FUNC_MAPr BCM53101_A0_LED_FUNC_MAPr
#define LED_FUNC_MAPr_SIZE BCM53101_A0_LED_FUNC_MAPr_SIZE
typedef BCM53101_A0_LED_FUNC_MAPr_t LED_FUNC_MAPr_t;
#define LED_FUNC_MAPr_CLR BCM53101_A0_LED_FUNC_MAPr_CLR
#define LED_FUNC_MAPr_SET BCM53101_A0_LED_FUNC_MAPr_SET
#define LED_FUNC_MAPr_GET BCM53101_A0_LED_FUNC_MAPr_GET
#define LED_FUNC_MAPr_LED_FUNC_MAPf_GET BCM53101_A0_LED_FUNC_MAPr_LED_FUNC_MAPf_GET
#define LED_FUNC_MAPr_LED_FUNC_MAPf_SET BCM53101_A0_LED_FUNC_MAPr_LED_FUNC_MAPf_SET
#define LED_FUNC_MAPr_RESERVEDf_GET BCM53101_A0_LED_FUNC_MAPr_RESERVEDf_GET
#define LED_FUNC_MAPr_RESERVEDf_SET BCM53101_A0_LED_FUNC_MAPr_RESERVEDf_SET
#define READ_LED_FUNC_MAPr BCM53101_A0_READ_LED_FUNC_MAPr
#define WRITE_LED_FUNC_MAPr BCM53101_A0_WRITE_LED_FUNC_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_LED_FUNC_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  LED_MODE_MAP_0
 * BLOCKS:   SYS
 * DESC:     LED Mode map 0 register
 * SIZE:     16
 * FIELDS:
 *     LED_MODE_MAP0    Combine with LED_MODEMAP1 to decide per port LED output,Mode[1:0]00 : OFF,01 : ON,10 : BLINK,11 : AUTO
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_LED_MODE_MAP_0r 0x00000018

#define BCM53101_A0_LED_MODE_MAP_0r_SIZE 2

/*
 * This structure should be used to declare and program LED_MODE_MAP_0.
 *
 */
typedef union BCM53101_A0_LED_MODE_MAP_0r_s {
	uint32_t v[1];
	uint32_t led_mode_map_0[1];
	uint32_t _led_mode_map_0;
} BCM53101_A0_LED_MODE_MAP_0r_t;

#define BCM53101_A0_LED_MODE_MAP_0r_CLR(r) (r).led_mode_map_0[0] = 0
#define BCM53101_A0_LED_MODE_MAP_0r_SET(r,d) (r).led_mode_map_0[0] = d
#define BCM53101_A0_LED_MODE_MAP_0r_GET(r) (r).led_mode_map_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_LED_MODE_MAP_0r_LED_MODE_MAP0f_GET(r) (((r).led_mode_map_0[0]) & 0x1ff)
#define BCM53101_A0_LED_MODE_MAP_0r_LED_MODE_MAP0f_SET(r,f) (r).led_mode_map_0[0]=(((r).led_mode_map_0[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_LED_MODE_MAP_0r_RESERVEDf_GET(r) ((((r).led_mode_map_0[0]) >> 9) & 0x7f)
#define BCM53101_A0_LED_MODE_MAP_0r_RESERVEDf_SET(r,f) (r).led_mode_map_0[0]=(((r).led_mode_map_0[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access LED_MODE_MAP_0.
 *
 */
#define BCM53101_A0_READ_LED_MODE_MAP_0r(u,r) cdk_robo_reg_read(u,BCM53101_A0_LED_MODE_MAP_0r,(r._led_mode_map_0),2)
#define BCM53101_A0_WRITE_LED_MODE_MAP_0r(u,r) cdk_robo_reg_write(u,BCM53101_A0_LED_MODE_MAP_0r,&(r._led_mode_map_0),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_MODE_MAP_0r BCM53101_A0_LED_MODE_MAP_0r
#define LED_MODE_MAP_0r_SIZE BCM53101_A0_LED_MODE_MAP_0r_SIZE
typedef BCM53101_A0_LED_MODE_MAP_0r_t LED_MODE_MAP_0r_t;
#define LED_MODE_MAP_0r_CLR BCM53101_A0_LED_MODE_MAP_0r_CLR
#define LED_MODE_MAP_0r_SET BCM53101_A0_LED_MODE_MAP_0r_SET
#define LED_MODE_MAP_0r_GET BCM53101_A0_LED_MODE_MAP_0r_GET
#define LED_MODE_MAP_0r_LED_MODE_MAP0f_GET BCM53101_A0_LED_MODE_MAP_0r_LED_MODE_MAP0f_GET
#define LED_MODE_MAP_0r_LED_MODE_MAP0f_SET BCM53101_A0_LED_MODE_MAP_0r_LED_MODE_MAP0f_SET
#define LED_MODE_MAP_0r_RESERVEDf_GET BCM53101_A0_LED_MODE_MAP_0r_RESERVEDf_GET
#define LED_MODE_MAP_0r_RESERVEDf_SET BCM53101_A0_LED_MODE_MAP_0r_RESERVEDf_SET
#define READ_LED_MODE_MAP_0r BCM53101_A0_READ_LED_MODE_MAP_0r
#define WRITE_LED_MODE_MAP_0r BCM53101_A0_WRITE_LED_MODE_MAP_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_LED_MODE_MAP_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  LED_MODE_MAP_1
 * BLOCKS:   SYS
 * DESC:     LED Mode map 1 register
 * SIZE:     16
 * FIELDS:
 *     LED_MODE_MAP1    Combine with LED_MODEMAP1 to decide per port LED output,Mode[1:0]00 : OFF,01 : ON,10 : BLINK,11 : AUTO
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_LED_MODE_MAP_1r 0x0000001a

#define BCM53101_A0_LED_MODE_MAP_1r_SIZE 2

/*
 * This structure should be used to declare and program LED_MODE_MAP_1.
 *
 */
typedef union BCM53101_A0_LED_MODE_MAP_1r_s {
	uint32_t v[1];
	uint32_t led_mode_map_1[1];
	uint32_t _led_mode_map_1;
} BCM53101_A0_LED_MODE_MAP_1r_t;

#define BCM53101_A0_LED_MODE_MAP_1r_CLR(r) (r).led_mode_map_1[0] = 0
#define BCM53101_A0_LED_MODE_MAP_1r_SET(r,d) (r).led_mode_map_1[0] = d
#define BCM53101_A0_LED_MODE_MAP_1r_GET(r) (r).led_mode_map_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_LED_MODE_MAP_1r_LED_MODE_MAP1f_GET(r) (((r).led_mode_map_1[0]) & 0x1ff)
#define BCM53101_A0_LED_MODE_MAP_1r_LED_MODE_MAP1f_SET(r,f) (r).led_mode_map_1[0]=(((r).led_mode_map_1[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_LED_MODE_MAP_1r_RESERVEDf_GET(r) ((((r).led_mode_map_1[0]) >> 9) & 0x7f)
#define BCM53101_A0_LED_MODE_MAP_1r_RESERVEDf_SET(r,f) (r).led_mode_map_1[0]=(((r).led_mode_map_1[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access LED_MODE_MAP_1.
 *
 */
#define BCM53101_A0_READ_LED_MODE_MAP_1r(u,r) cdk_robo_reg_read(u,BCM53101_A0_LED_MODE_MAP_1r,(r._led_mode_map_1),2)
#define BCM53101_A0_WRITE_LED_MODE_MAP_1r(u,r) cdk_robo_reg_write(u,BCM53101_A0_LED_MODE_MAP_1r,&(r._led_mode_map_1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_MODE_MAP_1r BCM53101_A0_LED_MODE_MAP_1r
#define LED_MODE_MAP_1r_SIZE BCM53101_A0_LED_MODE_MAP_1r_SIZE
typedef BCM53101_A0_LED_MODE_MAP_1r_t LED_MODE_MAP_1r_t;
#define LED_MODE_MAP_1r_CLR BCM53101_A0_LED_MODE_MAP_1r_CLR
#define LED_MODE_MAP_1r_SET BCM53101_A0_LED_MODE_MAP_1r_SET
#define LED_MODE_MAP_1r_GET BCM53101_A0_LED_MODE_MAP_1r_GET
#define LED_MODE_MAP_1r_LED_MODE_MAP1f_GET BCM53101_A0_LED_MODE_MAP_1r_LED_MODE_MAP1f_GET
#define LED_MODE_MAP_1r_LED_MODE_MAP1f_SET BCM53101_A0_LED_MODE_MAP_1r_LED_MODE_MAP1f_SET
#define LED_MODE_MAP_1r_RESERVEDf_GET BCM53101_A0_LED_MODE_MAP_1r_RESERVEDf_GET
#define LED_MODE_MAP_1r_RESERVEDf_SET BCM53101_A0_LED_MODE_MAP_1r_RESERVEDf_SET
#define READ_LED_MODE_MAP_1r BCM53101_A0_READ_LED_MODE_MAP_1r
#define WRITE_LED_MODE_MAP_1r BCM53101_A0_WRITE_LED_MODE_MAP_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_LED_MODE_MAP_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  LED_OPTIONS
 * BLOCKS:   SYS
 * DESC:     LED Output Enable Register
 * SIZE:     8
 * FIELDS:
 *     OE_PHY_LED       Enable PHY LED output through the LED pinsWhen this bits is set, the PHY LED pins will be output through the chip LED pins, this bit can only be enabled under parallel LED mode.
 *     RX_ONLY_ACT      Enable RX-only activity indicationWhen enable, TX activities and COL are masked out. ACT only present RX activity.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_LED_OPTIONSr 0x0000001c

#define BCM53101_A0_LED_OPTIONSr_SIZE 1

/*
 * This structure should be used to declare and program LED_OPTIONS.
 *
 */
typedef union BCM53101_A0_LED_OPTIONSr_s {
	uint32_t v[1];
	uint32_t led_options[1];
	uint32_t _led_options;
} BCM53101_A0_LED_OPTIONSr_t;

#define BCM53101_A0_LED_OPTIONSr_CLR(r) (r).led_options[0] = 0
#define BCM53101_A0_LED_OPTIONSr_SET(r,d) (r).led_options[0] = d
#define BCM53101_A0_LED_OPTIONSr_GET(r) (r).led_options[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_LED_OPTIONSr_OE_PHY_LEDf_GET(r) (((r).led_options[0]) & 0x1)
#define BCM53101_A0_LED_OPTIONSr_OE_PHY_LEDf_SET(r,f) (r).led_options[0]=(((r).led_options[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_LED_OPTIONSr_RX_ONLY_ACTf_GET(r) ((((r).led_options[0]) >> 1) & 0x1)
#define BCM53101_A0_LED_OPTIONSr_RX_ONLY_ACTf_SET(r,f) (r).led_options[0]=(((r).led_options[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_LED_OPTIONSr_RESERVEDf_GET(r) ((((r).led_options[0]) >> 2) & 0x3f)
#define BCM53101_A0_LED_OPTIONSr_RESERVEDf_SET(r,f) (r).led_options[0]=(((r).led_options[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))

/*
 * These macros can be used to access LED_OPTIONS.
 *
 */
#define BCM53101_A0_READ_LED_OPTIONSr(u,r) cdk_robo_reg_read(u,BCM53101_A0_LED_OPTIONSr,(r._led_options),1)
#define BCM53101_A0_WRITE_LED_OPTIONSr(u,r) cdk_robo_reg_write(u,BCM53101_A0_LED_OPTIONSr,&(r._led_options),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_OPTIONSr BCM53101_A0_LED_OPTIONSr
#define LED_OPTIONSr_SIZE BCM53101_A0_LED_OPTIONSr_SIZE
typedef BCM53101_A0_LED_OPTIONSr_t LED_OPTIONSr_t;
#define LED_OPTIONSr_CLR BCM53101_A0_LED_OPTIONSr_CLR
#define LED_OPTIONSr_SET BCM53101_A0_LED_OPTIONSr_SET
#define LED_OPTIONSr_GET BCM53101_A0_LED_OPTIONSr_GET
#define LED_OPTIONSr_OE_PHY_LEDf_GET BCM53101_A0_LED_OPTIONSr_OE_PHY_LEDf_GET
#define LED_OPTIONSr_OE_PHY_LEDf_SET BCM53101_A0_LED_OPTIONSr_OE_PHY_LEDf_SET
#define LED_OPTIONSr_RX_ONLY_ACTf_GET BCM53101_A0_LED_OPTIONSr_RX_ONLY_ACTf_GET
#define LED_OPTIONSr_RX_ONLY_ACTf_SET BCM53101_A0_LED_OPTIONSr_RX_ONLY_ACTf_SET
#define LED_OPTIONSr_RESERVEDf_GET BCM53101_A0_LED_OPTIONSr_RESERVEDf_GET
#define LED_OPTIONSr_RESERVEDf_SET BCM53101_A0_LED_OPTIONSr_RESERVEDf_SET
#define READ_LED_OPTIONSr BCM53101_A0_READ_LED_OPTIONSr
#define WRITE_LED_OPTIONSr BCM53101_A0_WRITE_LED_OPTIONSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_LED_OPTIONSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  LED_REFLSH_CTL
 * BLOCKS:   SYS
 * DESC:     LED Configuration Register
 * SIZE:     8
 * FIELDS:
 *     LED_RFS_STOP     LED reflsh control register.reflsh time = (N+1)*10ns000 : no reflsh;001 : 20ms/25Hz;010 : 30ms/16Hz;011 : 40ms/12Hz;100 : 50ms/10Hz;101 : 60ms/8Hz;110 : 70ms/7Hz;111 : 80ms/6Hz.
 *     LED_NORM_CD_EN   Write 1 to active cable diag in normal mode.
 *     LED_POST_CD_EN   Write 1 to active cable diag after POST.
 *     LED_PSCAN_EN     Write 1 to active port scan during POST.
 *     LED_POST_EXEC    Write 1 to re-start POST.
 *     LED_EN           Enable LED.
 *
 ******************************************************************************/
#define BCM53101_A0_LED_REFLSH_CTLr 0x0000000f

#define BCM53101_A0_LED_REFLSH_CTLr_SIZE 1

/*
 * This structure should be used to declare and program LED_REFLSH_CTL.
 *
 */
typedef union BCM53101_A0_LED_REFLSH_CTLr_s {
	uint32_t v[1];
	uint32_t led_reflsh_ctl[1];
	uint32_t _led_reflsh_ctl;
} BCM53101_A0_LED_REFLSH_CTLr_t;

#define BCM53101_A0_LED_REFLSH_CTLr_CLR(r) (r).led_reflsh_ctl[0] = 0
#define BCM53101_A0_LED_REFLSH_CTLr_SET(r,d) (r).led_reflsh_ctl[0] = d
#define BCM53101_A0_LED_REFLSH_CTLr_GET(r) (r).led_reflsh_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_LED_REFLSH_CTLr_LED_RFS_STOPf_GET(r) (((r).led_reflsh_ctl[0]) & 0x7)
#define BCM53101_A0_LED_REFLSH_CTLr_LED_RFS_STOPf_SET(r,f) (r).led_reflsh_ctl[0]=(((r).led_reflsh_ctl[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53101_A0_LED_REFLSH_CTLr_LED_NORM_CD_ENf_GET(r) ((((r).led_reflsh_ctl[0]) >> 3) & 0x1)
#define BCM53101_A0_LED_REFLSH_CTLr_LED_NORM_CD_ENf_SET(r,f) (r).led_reflsh_ctl[0]=(((r).led_reflsh_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_LED_REFLSH_CTLr_LED_POST_CD_ENf_GET(r) ((((r).led_reflsh_ctl[0]) >> 4) & 0x1)
#define BCM53101_A0_LED_REFLSH_CTLr_LED_POST_CD_ENf_SET(r,f) (r).led_reflsh_ctl[0]=(((r).led_reflsh_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_LED_REFLSH_CTLr_LED_PSCAN_ENf_GET(r) ((((r).led_reflsh_ctl[0]) >> 5) & 0x1)
#define BCM53101_A0_LED_REFLSH_CTLr_LED_PSCAN_ENf_SET(r,f) (r).led_reflsh_ctl[0]=(((r).led_reflsh_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_LED_REFLSH_CTLr_LED_POST_EXECf_GET(r) ((((r).led_reflsh_ctl[0]) >> 6) & 0x1)
#define BCM53101_A0_LED_REFLSH_CTLr_LED_POST_EXECf_SET(r,f) (r).led_reflsh_ctl[0]=(((r).led_reflsh_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_LED_REFLSH_CTLr_LED_ENf_GET(r) ((((r).led_reflsh_ctl[0]) >> 7) & 0x1)
#define BCM53101_A0_LED_REFLSH_CTLr_LED_ENf_SET(r,f) (r).led_reflsh_ctl[0]=(((r).led_reflsh_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access LED_REFLSH_CTL.
 *
 */
#define BCM53101_A0_READ_LED_REFLSH_CTLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_LED_REFLSH_CTLr,(r._led_reflsh_ctl),1)
#define BCM53101_A0_WRITE_LED_REFLSH_CTLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_LED_REFLSH_CTLr,&(r._led_reflsh_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LED_REFLSH_CTLr BCM53101_A0_LED_REFLSH_CTLr
#define LED_REFLSH_CTLr_SIZE BCM53101_A0_LED_REFLSH_CTLr_SIZE
typedef BCM53101_A0_LED_REFLSH_CTLr_t LED_REFLSH_CTLr_t;
#define LED_REFLSH_CTLr_CLR BCM53101_A0_LED_REFLSH_CTLr_CLR
#define LED_REFLSH_CTLr_SET BCM53101_A0_LED_REFLSH_CTLr_SET
#define LED_REFLSH_CTLr_GET BCM53101_A0_LED_REFLSH_CTLr_GET
#define LED_REFLSH_CTLr_LED_RFS_STOPf_GET BCM53101_A0_LED_REFLSH_CTLr_LED_RFS_STOPf_GET
#define LED_REFLSH_CTLr_LED_RFS_STOPf_SET BCM53101_A0_LED_REFLSH_CTLr_LED_RFS_STOPf_SET
#define LED_REFLSH_CTLr_LED_NORM_CD_ENf_GET BCM53101_A0_LED_REFLSH_CTLr_LED_NORM_CD_ENf_GET
#define LED_REFLSH_CTLr_LED_NORM_CD_ENf_SET BCM53101_A0_LED_REFLSH_CTLr_LED_NORM_CD_ENf_SET
#define LED_REFLSH_CTLr_LED_POST_CD_ENf_GET BCM53101_A0_LED_REFLSH_CTLr_LED_POST_CD_ENf_GET
#define LED_REFLSH_CTLr_LED_POST_CD_ENf_SET BCM53101_A0_LED_REFLSH_CTLr_LED_POST_CD_ENf_SET
#define LED_REFLSH_CTLr_LED_PSCAN_ENf_GET BCM53101_A0_LED_REFLSH_CTLr_LED_PSCAN_ENf_GET
#define LED_REFLSH_CTLr_LED_PSCAN_ENf_SET BCM53101_A0_LED_REFLSH_CTLr_LED_PSCAN_ENf_SET
#define LED_REFLSH_CTLr_LED_POST_EXECf_GET BCM53101_A0_LED_REFLSH_CTLr_LED_POST_EXECf_GET
#define LED_REFLSH_CTLr_LED_POST_EXECf_SET BCM53101_A0_LED_REFLSH_CTLr_LED_POST_EXECf_SET
#define LED_REFLSH_CTLr_LED_ENf_GET BCM53101_A0_LED_REFLSH_CTLr_LED_ENf_GET
#define LED_REFLSH_CTLr_LED_ENf_SET BCM53101_A0_LED_REFLSH_CTLr_LED_ENf_SET
#define READ_LED_REFLSH_CTLr BCM53101_A0_READ_LED_REFLSH_CTLr
#define WRITE_LED_REFLSH_CTLr BCM53101_A0_WRITE_LED_REFLSH_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_LED_REFLSH_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  LNKSTS
 * BLOCKS:   SYS
 * DESC:     LinkStatus Summary Register
 * SIZE:     16
 * FIELDS:
 *     LNK_STS          Link Status.9bit field indicating the Link Status for each 10/100/1000 BASE-T port, (bits 0-7 = 10/100/1000 BASE-T, bit 8 IMP port ).0 = Link Fail1 = Link Pass
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_LNKSTSr 0x00000100

#define BCM53101_A0_LNKSTSr_SIZE 2

/*
 * This structure should be used to declare and program LNKSTS.
 *
 */
typedef union BCM53101_A0_LNKSTSr_s {
	uint32_t v[1];
	uint32_t lnksts[1];
	uint32_t _lnksts;
} BCM53101_A0_LNKSTSr_t;

#define BCM53101_A0_LNKSTSr_CLR(r) (r).lnksts[0] = 0
#define BCM53101_A0_LNKSTSr_SET(r,d) (r).lnksts[0] = d
#define BCM53101_A0_LNKSTSr_GET(r) (r).lnksts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_LNKSTSr_LNK_STSf_GET(r) (((r).lnksts[0]) & 0x1ff)
#define BCM53101_A0_LNKSTSr_LNK_STSf_SET(r,f) (r).lnksts[0]=(((r).lnksts[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_LNKSTSr_RESERVEDf_GET(r) ((((r).lnksts[0]) >> 9) & 0x7f)
#define BCM53101_A0_LNKSTSr_RESERVEDf_SET(r,f) (r).lnksts[0]=(((r).lnksts[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access LNKSTS.
 *
 */
#define BCM53101_A0_READ_LNKSTSr(u,r) cdk_robo_reg_read(u,BCM53101_A0_LNKSTSr,(r._lnksts),2)
#define BCM53101_A0_WRITE_LNKSTSr(u,r) cdk_robo_reg_write(u,BCM53101_A0_LNKSTSr,&(r._lnksts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LNKSTSr BCM53101_A0_LNKSTSr
#define LNKSTSr_SIZE BCM53101_A0_LNKSTSr_SIZE
typedef BCM53101_A0_LNKSTSr_t LNKSTSr_t;
#define LNKSTSr_CLR BCM53101_A0_LNKSTSr_CLR
#define LNKSTSr_SET BCM53101_A0_LNKSTSr_SET
#define LNKSTSr_GET BCM53101_A0_LNKSTSr_GET
#define LNKSTSr_LNK_STSf_GET BCM53101_A0_LNKSTSr_LNK_STSf_GET
#define LNKSTSr_LNK_STSf_SET BCM53101_A0_LNKSTSr_LNK_STSf_SET
#define LNKSTSr_RESERVEDf_GET BCM53101_A0_LNKSTSr_RESERVEDf_GET
#define LNKSTSr_RESERVEDf_SET BCM53101_A0_LNKSTSr_RESERVEDf_SET
#define READ_LNKSTSr BCM53101_A0_READ_LNKSTSr
#define WRITE_LNKSTSr BCM53101_A0_WRITE_LNKSTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_LNKSTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  LNKSTSCHG
 * BLOCKS:   SYS
 * DESC:     Link Status Change Register
 * SIZE:     16
 * FIELDS:
 *     LNK_STS_CHG      Link Status Change.9 bit field indicating that the Link Status for an individual 10/100/1000BASE-T port had changed since the last read operation (bits 0-23 = 10/100/1000BASE- T ports, bit 8 = IMP port). Upon change of link status, a bit remains set until cleared by a read operation.0 = Link Status Constant,1 = Link Status Change.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_LNKSTSCHGr 0x00000102

#define BCM53101_A0_LNKSTSCHGr_SIZE 2

/*
 * This structure should be used to declare and program LNKSTSCHG.
 *
 */
typedef union BCM53101_A0_LNKSTSCHGr_s {
	uint32_t v[1];
	uint32_t lnkstschg[1];
	uint32_t _lnkstschg;
} BCM53101_A0_LNKSTSCHGr_t;

#define BCM53101_A0_LNKSTSCHGr_CLR(r) (r).lnkstschg[0] = 0
#define BCM53101_A0_LNKSTSCHGr_SET(r,d) (r).lnkstschg[0] = d
#define BCM53101_A0_LNKSTSCHGr_GET(r) (r).lnkstschg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_LNKSTSCHGr_LNK_STS_CHGf_GET(r) (((r).lnkstschg[0]) & 0x1ff)
#define BCM53101_A0_LNKSTSCHGr_LNK_STS_CHGf_SET(r,f) (r).lnkstschg[0]=(((r).lnkstschg[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_LNKSTSCHGr_RESERVEDf_GET(r) ((((r).lnkstschg[0]) >> 9) & 0x7f)
#define BCM53101_A0_LNKSTSCHGr_RESERVEDf_SET(r,f) (r).lnkstschg[0]=(((r).lnkstschg[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access LNKSTSCHG.
 *
 */
#define BCM53101_A0_READ_LNKSTSCHGr(u,r) cdk_robo_reg_read(u,BCM53101_A0_LNKSTSCHGr,(r._lnkstschg),2)
#define BCM53101_A0_WRITE_LNKSTSCHGr(u,r) cdk_robo_reg_write(u,BCM53101_A0_LNKSTSCHGr,&(r._lnkstschg),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LNKSTSCHGr BCM53101_A0_LNKSTSCHGr
#define LNKSTSCHGr_SIZE BCM53101_A0_LNKSTSCHGr_SIZE
typedef BCM53101_A0_LNKSTSCHGr_t LNKSTSCHGr_t;
#define LNKSTSCHGr_CLR BCM53101_A0_LNKSTSCHGr_CLR
#define LNKSTSCHGr_SET BCM53101_A0_LNKSTSCHGr_SET
#define LNKSTSCHGr_GET BCM53101_A0_LNKSTSCHGr_GET
#define LNKSTSCHGr_LNK_STS_CHGf_GET BCM53101_A0_LNKSTSCHGr_LNK_STS_CHGf_GET
#define LNKSTSCHGr_LNK_STS_CHGf_SET BCM53101_A0_LNKSTSCHGr_LNK_STS_CHGf_SET
#define LNKSTSCHGr_RESERVEDf_GET BCM53101_A0_LNKSTSCHGr_RESERVEDf_GET
#define LNKSTSCHGr_RESERVEDf_SET BCM53101_A0_LNKSTSCHGr_RESERVEDf_SET
#define READ_LNKSTSCHGr BCM53101_A0_READ_LNKSTSCHGr
#define WRITE_LNKSTSCHGr BCM53101_A0_WRITE_LNKSTSCHGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_LNKSTSCHGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  LOW_POWER_CTRL
 * BLOCKS:   SYS
 * DESC:     LOW Power Control Register(Engineering Use Only)
 * SIZE:     8
 * FIELDS:
 *     LOW_POWER_CLK_DIVIDER When bit[7] is 1'b1, this field indicates the divider of the low power clock. If this field is 0, the system clock=CK25/2, otherwise=CK25/(low_power_divider*4).5'h01: 6.25Mhz5'h02: 3.125Mhz5'h03: 2.083Mhz5'h04: 1.5625Mhz5'h05: 1.25Mhz5'h06: 1.041Mhz....5'h1f: 201.612Khz
 *     SLEEP_MAC        Writing 1'b1 to this bit will stop MAC source clocks for P5 and P8(IMP).
 *     SLEEP_SYS        Writing 1'b1 to this bit will stop system clock.
 *     SYS_LOW_POWER_EN When enabled, system clock will be switched to low power clock source. The system clock = CK25/(low_power_divider+1)*2)
 *
 ******************************************************************************/
#define BCM53101_A0_LOW_POWER_CTRLr 0x000000df

#define BCM53101_A0_LOW_POWER_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program LOW_POWER_CTRL.
 *
 */
typedef union BCM53101_A0_LOW_POWER_CTRLr_s {
	uint32_t v[1];
	uint32_t low_power_ctrl[1];
	uint32_t _low_power_ctrl;
} BCM53101_A0_LOW_POWER_CTRLr_t;

#define BCM53101_A0_LOW_POWER_CTRLr_CLR(r) (r).low_power_ctrl[0] = 0
#define BCM53101_A0_LOW_POWER_CTRLr_SET(r,d) (r).low_power_ctrl[0] = d
#define BCM53101_A0_LOW_POWER_CTRLr_GET(r) (r).low_power_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_LOW_POWER_CTRLr_LOW_POWER_CLK_DIVIDERf_GET(r) (((r).low_power_ctrl[0]) & 0x1f)
#define BCM53101_A0_LOW_POWER_CTRLr_LOW_POWER_CLK_DIVIDERf_SET(r,f) (r).low_power_ctrl[0]=(((r).low_power_ctrl[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53101_A0_LOW_POWER_CTRLr_SLEEP_MACf_GET(r) ((((r).low_power_ctrl[0]) >> 5) & 0x1)
#define BCM53101_A0_LOW_POWER_CTRLr_SLEEP_MACf_SET(r,f) (r).low_power_ctrl[0]=(((r).low_power_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_LOW_POWER_CTRLr_SLEEP_SYSf_GET(r) ((((r).low_power_ctrl[0]) >> 6) & 0x1)
#define BCM53101_A0_LOW_POWER_CTRLr_SLEEP_SYSf_SET(r,f) (r).low_power_ctrl[0]=(((r).low_power_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_LOW_POWER_CTRLr_SYS_LOW_POWER_ENf_GET(r) ((((r).low_power_ctrl[0]) >> 7) & 0x1)
#define BCM53101_A0_LOW_POWER_CTRLr_SYS_LOW_POWER_ENf_SET(r,f) (r).low_power_ctrl[0]=(((r).low_power_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access LOW_POWER_CTRL.
 *
 */
#define BCM53101_A0_READ_LOW_POWER_CTRLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_LOW_POWER_CTRLr,(r._low_power_ctrl),1)
#define BCM53101_A0_WRITE_LOW_POWER_CTRLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_LOW_POWER_CTRLr,&(r._low_power_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LOW_POWER_CTRLr BCM53101_A0_LOW_POWER_CTRLr
#define LOW_POWER_CTRLr_SIZE BCM53101_A0_LOW_POWER_CTRLr_SIZE
typedef BCM53101_A0_LOW_POWER_CTRLr_t LOW_POWER_CTRLr_t;
#define LOW_POWER_CTRLr_CLR BCM53101_A0_LOW_POWER_CTRLr_CLR
#define LOW_POWER_CTRLr_SET BCM53101_A0_LOW_POWER_CTRLr_SET
#define LOW_POWER_CTRLr_GET BCM53101_A0_LOW_POWER_CTRLr_GET
#define LOW_POWER_CTRLr_LOW_POWER_CLK_DIVIDERf_GET BCM53101_A0_LOW_POWER_CTRLr_LOW_POWER_CLK_DIVIDERf_GET
#define LOW_POWER_CTRLr_LOW_POWER_CLK_DIVIDERf_SET BCM53101_A0_LOW_POWER_CTRLr_LOW_POWER_CLK_DIVIDERf_SET
#define LOW_POWER_CTRLr_SLEEP_MACf_GET BCM53101_A0_LOW_POWER_CTRLr_SLEEP_MACf_GET
#define LOW_POWER_CTRLr_SLEEP_MACf_SET BCM53101_A0_LOW_POWER_CTRLr_SLEEP_MACf_SET
#define LOW_POWER_CTRLr_SLEEP_SYSf_GET BCM53101_A0_LOW_POWER_CTRLr_SLEEP_SYSf_GET
#define LOW_POWER_CTRLr_SLEEP_SYSf_SET BCM53101_A0_LOW_POWER_CTRLr_SLEEP_SYSf_SET
#define LOW_POWER_CTRLr_SYS_LOW_POWER_ENf_GET BCM53101_A0_LOW_POWER_CTRLr_SYS_LOW_POWER_ENf_GET
#define LOW_POWER_CTRLr_SYS_LOW_POWER_ENf_SET BCM53101_A0_LOW_POWER_CTRLr_SYS_LOW_POWER_ENf_SET
#define READ_LOW_POWER_CTRLr BCM53101_A0_READ_LOW_POWER_CTRLr
#define WRITE_LOW_POWER_CTRLr BCM53101_A0_WRITE_LOW_POWER_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_LOW_POWER_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  LPNXP
 * BLOCKS:   EPIC0
 * DESC:     Link Partner next Page Register
 * SIZE:     16
 * FIELDS:
 *     LP_CODE_FIELD    Message/Unformatted Code Field.
 *     LP_TOGGLE        1 = Previous value of the transmitted link code word equaled logic 0.0 = Previous value of the transmitted link code word equaled logic 1.
 *     LP_ACK_2         1 = Will comply with message.0 = Can not comply with message.
 *     LP_MESSAGE_PAGE  1 = Message page.0 = Unformatted page.
 *     RESERVED         Reserved
 *     LP_NEXT_PAGE     1 = Addition next page(s) follows.0 = Last page.
 *
 ******************************************************************************/
#define BCM53101_A0_LPNXPr 0x00001010

#define BCM53101_A0_LPNXPr_SIZE 2

/*
 * This structure should be used to declare and program LPNXP.
 *
 */
typedef union BCM53101_A0_LPNXPr_s {
	uint32_t v[1];
	uint32_t lpnxp[1];
	uint32_t _lpnxp;
} BCM53101_A0_LPNXPr_t;

#define BCM53101_A0_LPNXPr_CLR(r) (r).lpnxp[0] = 0
#define BCM53101_A0_LPNXPr_SET(r,d) (r).lpnxp[0] = d
#define BCM53101_A0_LPNXPr_GET(r) (r).lpnxp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_LPNXPr_LP_CODE_FIELDf_GET(r) (((r).lpnxp[0]) & 0x7ff)
#define BCM53101_A0_LPNXPr_LP_CODE_FIELDf_SET(r,f) (r).lpnxp[0]=(((r).lpnxp[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53101_A0_LPNXPr_LP_TOGGLEf_GET(r) ((((r).lpnxp[0]) >> 11) & 0x1)
#define BCM53101_A0_LPNXPr_LP_TOGGLEf_SET(r,f) (r).lpnxp[0]=(((r).lpnxp[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53101_A0_LPNXPr_LP_ACK_2f_GET(r) ((((r).lpnxp[0]) >> 12) & 0x1)
#define BCM53101_A0_LPNXPr_LP_ACK_2f_SET(r,f) (r).lpnxp[0]=(((r).lpnxp[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53101_A0_LPNXPr_LP_MESSAGE_PAGEf_GET(r) ((((r).lpnxp[0]) >> 13) & 0x1)
#define BCM53101_A0_LPNXPr_LP_MESSAGE_PAGEf_SET(r,f) (r).lpnxp[0]=(((r).lpnxp[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53101_A0_LPNXPr_RESERVEDf_GET(r) ((((r).lpnxp[0]) >> 14) & 0x1)
#define BCM53101_A0_LPNXPr_RESERVEDf_SET(r,f) (r).lpnxp[0]=(((r).lpnxp[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_LPNXPr_LP_NEXT_PAGEf_GET(r) ((((r).lpnxp[0]) >> 15) & 0x1)
#define BCM53101_A0_LPNXPr_LP_NEXT_PAGEf_SET(r,f) (r).lpnxp[0]=(((r).lpnxp[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access LPNXP.
 *
 */
#define BCM53101_A0_READ_LPNXPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_LPNXPr,(r._lpnxp),2)
#define BCM53101_A0_WRITE_LPNXPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_LPNXPr,&(r._lpnxp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LPNXPr BCM53101_A0_LPNXPr
#define LPNXPr_SIZE BCM53101_A0_LPNXPr_SIZE
typedef BCM53101_A0_LPNXPr_t LPNXPr_t;
#define LPNXPr_CLR BCM53101_A0_LPNXPr_CLR
#define LPNXPr_SET BCM53101_A0_LPNXPr_SET
#define LPNXPr_GET BCM53101_A0_LPNXPr_GET
#define LPNXPr_LP_CODE_FIELDf_GET BCM53101_A0_LPNXPr_LP_CODE_FIELDf_GET
#define LPNXPr_LP_CODE_FIELDf_SET BCM53101_A0_LPNXPr_LP_CODE_FIELDf_SET
#define LPNXPr_LP_TOGGLEf_GET BCM53101_A0_LPNXPr_LP_TOGGLEf_GET
#define LPNXPr_LP_TOGGLEf_SET BCM53101_A0_LPNXPr_LP_TOGGLEf_SET
#define LPNXPr_LP_ACK_2f_GET BCM53101_A0_LPNXPr_LP_ACK_2f_GET
#define LPNXPr_LP_ACK_2f_SET BCM53101_A0_LPNXPr_LP_ACK_2f_SET
#define LPNXPr_LP_MESSAGE_PAGEf_GET BCM53101_A0_LPNXPr_LP_MESSAGE_PAGEf_GET
#define LPNXPr_LP_MESSAGE_PAGEf_SET BCM53101_A0_LPNXPr_LP_MESSAGE_PAGEf_SET
#define LPNXPr_RESERVEDf_GET BCM53101_A0_LPNXPr_RESERVEDf_GET
#define LPNXPr_RESERVEDf_SET BCM53101_A0_LPNXPr_RESERVEDf_SET
#define LPNXPr_LP_NEXT_PAGEf_GET BCM53101_A0_LPNXPr_LP_NEXT_PAGEf_GET
#define LPNXPr_LP_NEXT_PAGEf_SET BCM53101_A0_LPNXPr_LP_NEXT_PAGEf_SET
#define READ_LPNXPr BCM53101_A0_READ_LPNXPr
#define WRITE_LPNXPr BCM53101_A0_WRITE_LPNXPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_LPNXPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  LPNXP_EXT_P5
 * BLOCKS:   SYS
 * DESC:     Link Partner next Page Register
 * SIZE:     16
 * FIELDS:
 *     LP_CODE_FIELD    Message/Unformatted Code Field.
 *     LP_TOGGLE        1 = Previous value of the transmitted link code word equaled logic 0.0 = Previous value of the transmitted link code word equaled logic 1.
 *     LP_ACK_2         1 = Will comply with message.0 = Can not comply with message.
 *     LP_NEXT_PAGE     1 = Addition next page(s) follows.0 = Last page.EOT             },            RESERVED     => {                MAXBIT      => 14,   MINBIT => 14,    RESETVAL => 0x0,                READONLY    => 1,                DESC        => 'Reserved'            },           LP_MESSAGE_PAGE => {                MAXBIT      => 13,   MINBIT => 13,    RESETVAL => 0x0,                READONLY    => 1,                DESC        => <<'EOT'1 = Message page.0 = Unformatted page.
 *
 ******************************************************************************/
#define BCM53101_A0_LPNXP_EXT_P5r 0x00008510

#define BCM53101_A0_LPNXP_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program LPNXP_EXT_P5.
 *
 */
typedef union BCM53101_A0_LPNXP_EXT_P5r_s {
	uint32_t v[1];
	uint32_t lpnxp_ext_p5[1];
	uint32_t _lpnxp_ext_p5;
} BCM53101_A0_LPNXP_EXT_P5r_t;

#define BCM53101_A0_LPNXP_EXT_P5r_CLR(r) (r).lpnxp_ext_p5[0] = 0
#define BCM53101_A0_LPNXP_EXT_P5r_SET(r,d) (r).lpnxp_ext_p5[0] = d
#define BCM53101_A0_LPNXP_EXT_P5r_GET(r) (r).lpnxp_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_LPNXP_EXT_P5r_LP_CODE_FIELDf_GET(r) (((r).lpnxp_ext_p5[0]) & 0x7ff)
#define BCM53101_A0_LPNXP_EXT_P5r_LP_CODE_FIELDf_SET(r,f) (r).lpnxp_ext_p5[0]=(((r).lpnxp_ext_p5[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff))
#define BCM53101_A0_LPNXP_EXT_P5r_LP_TOGGLEf_GET(r) ((((r).lpnxp_ext_p5[0]) >> 11) & 0x1)
#define BCM53101_A0_LPNXP_EXT_P5r_LP_TOGGLEf_SET(r,f) (r).lpnxp_ext_p5[0]=(((r).lpnxp_ext_p5[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53101_A0_LPNXP_EXT_P5r_LP_ACK_2f_GET(r) ((((r).lpnxp_ext_p5[0]) >> 12) & 0x1)
#define BCM53101_A0_LPNXP_EXT_P5r_LP_ACK_2f_SET(r,f) (r).lpnxp_ext_p5[0]=(((r).lpnxp_ext_p5[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53101_A0_LPNXP_EXT_P5r_LP_NEXT_PAGEf_GET(r) ((((r).lpnxp_ext_p5[0]) >> 15) & 0x1)
#define BCM53101_A0_LPNXP_EXT_P5r_LP_NEXT_PAGEf_SET(r,f) (r).lpnxp_ext_p5[0]=(((r).lpnxp_ext_p5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access LPNXP_EXT_P5.
 *
 */
#define BCM53101_A0_READ_LPNXP_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53101_A0_LPNXP_EXT_P5r,(r._lpnxp_ext_p5),2)
#define BCM53101_A0_WRITE_LPNXP_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53101_A0_LPNXP_EXT_P5r,&(r._lpnxp_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LPNXP_EXT_P5r BCM53101_A0_LPNXP_EXT_P5r
#define LPNXP_EXT_P5r_SIZE BCM53101_A0_LPNXP_EXT_P5r_SIZE
typedef BCM53101_A0_LPNXP_EXT_P5r_t LPNXP_EXT_P5r_t;
#define LPNXP_EXT_P5r_CLR BCM53101_A0_LPNXP_EXT_P5r_CLR
#define LPNXP_EXT_P5r_SET BCM53101_A0_LPNXP_EXT_P5r_SET
#define LPNXP_EXT_P5r_GET BCM53101_A0_LPNXP_EXT_P5r_GET
#define LPNXP_EXT_P5r_LP_CODE_FIELDf_GET BCM53101_A0_LPNXP_EXT_P5r_LP_CODE_FIELDf_GET
#define LPNXP_EXT_P5r_LP_CODE_FIELDf_SET BCM53101_A0_LPNXP_EXT_P5r_LP_CODE_FIELDf_SET
#define LPNXP_EXT_P5r_LP_TOGGLEf_GET BCM53101_A0_LPNXP_EXT_P5r_LP_TOGGLEf_GET
#define LPNXP_EXT_P5r_LP_TOGGLEf_SET BCM53101_A0_LPNXP_EXT_P5r_LP_TOGGLEf_SET
#define LPNXP_EXT_P5r_LP_ACK_2f_GET BCM53101_A0_LPNXP_EXT_P5r_LP_ACK_2f_GET
#define LPNXP_EXT_P5r_LP_ACK_2f_SET BCM53101_A0_LPNXP_EXT_P5r_LP_ACK_2f_SET
#define LPNXP_EXT_P5r_LP_NEXT_PAGEf_GET BCM53101_A0_LPNXP_EXT_P5r_LP_NEXT_PAGEf_GET
#define LPNXP_EXT_P5r_LP_NEXT_PAGEf_SET BCM53101_A0_LPNXP_EXT_P5r_LP_NEXT_PAGEf_SET
#define READ_LPNXP_EXT_P5r BCM53101_A0_READ_LPNXP_EXT_P5r
#define WRITE_LPNXP_EXT_P5r BCM53101_A0_WRITE_LPNXP_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_LPNXP_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  LSA_MII_PORT
 * BLOCKS:   SYS
 * DESC:     Last Source Address MII Port
 * SIZE:     48
 * FIELDS:
 *     LST_ADDR         Last Source Address Port nWhere :n=0-8 for 0-8 port.
 *
 ******************************************************************************/
#define BCM53101_A0_LSA_MII_PORTr 0x00000140

#define BCM53101_A0_LSA_MII_PORTr_SIZE 6

/*
 * This structure should be used to declare and program LSA_MII_PORT.
 *
 */
typedef union BCM53101_A0_LSA_MII_PORTr_s {
	uint32_t v[2];
	uint32_t lsa_mii_port[2];
	uint32_t _lsa_mii_port;
} BCM53101_A0_LSA_MII_PORTr_t;

#define BCM53101_A0_LSA_MII_PORTr_CLR(r) CDK_MEMSET(&((r)._lsa_mii_port), 0, sizeof(BCM53101_A0_LSA_MII_PORTr_t))
#define BCM53101_A0_LSA_MII_PORTr_SET(r,i,d) (r).lsa_mii_port[i] = d
#define BCM53101_A0_LSA_MII_PORTr_GET(r,i) (r).lsa_mii_port[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_LSA_MII_PORTr_LST_ADDRf_GET(r,a) cdk_field_get((r).lsa_mii_port,0,47,a)
#define BCM53101_A0_LSA_MII_PORTr_LST_ADDRf_SET(r,a) cdk_field_set((r).lsa_mii_port,0,47,a)

/*
 * These macros can be used to access LSA_MII_PORT.
 *
 */
#define BCM53101_A0_READ_LSA_MII_PORTr(u,r) cdk_robo_reg_read(u,BCM53101_A0_LSA_MII_PORTr,(r._lsa_mii_port),6)
#define BCM53101_A0_WRITE_LSA_MII_PORTr(u,r) cdk_robo_reg_write(u,BCM53101_A0_LSA_MII_PORTr,&(r._lsa_mii_port),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LSA_MII_PORTr BCM53101_A0_LSA_MII_PORTr
#define LSA_MII_PORTr_SIZE BCM53101_A0_LSA_MII_PORTr_SIZE
typedef BCM53101_A0_LSA_MII_PORTr_t LSA_MII_PORTr_t;
#define LSA_MII_PORTr_CLR BCM53101_A0_LSA_MII_PORTr_CLR
#define LSA_MII_PORTr_SET BCM53101_A0_LSA_MII_PORTr_SET
#define LSA_MII_PORTr_GET BCM53101_A0_LSA_MII_PORTr_GET
#define LSA_MII_PORTr_LST_ADDRf_GET BCM53101_A0_LSA_MII_PORTr_LST_ADDRf_GET
#define LSA_MII_PORTr_LST_ADDRf_SET BCM53101_A0_LSA_MII_PORTr_LST_ADDRf_SET
#define READ_LSA_MII_PORTr BCM53101_A0_READ_LSA_MII_PORTr
#define WRITE_LSA_MII_PORTr BCM53101_A0_WRITE_LSA_MII_PORTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_LSA_MII_PORTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  LSA_PORT
 * BLOCKS:   CPIC EPIC0
 * DESC:     Last Source Address Port X
 * SIZE:     48
 * FIELDS:
 *     LST_ADDR         Last Source Address Port nWhere :n=0-5 for 0-5 Port.n=8 for IMP Port
 *
 ******************************************************************************/
#define BCM53101_A0_LSA_PORTr 0x00000110

#define BCM53101_A0_LSA_PORTr_SIZE 6

/*
 * This structure should be used to declare and program LSA_PORT.
 *
 */
typedef union BCM53101_A0_LSA_PORTr_s {
	uint32_t v[2];
	uint32_t lsa_port[2];
	uint32_t _lsa_port;
} BCM53101_A0_LSA_PORTr_t;

#define BCM53101_A0_LSA_PORTr_CLR(r) CDK_MEMSET(&((r)._lsa_port), 0, sizeof(BCM53101_A0_LSA_PORTr_t))
#define BCM53101_A0_LSA_PORTr_SET(r,i,d) (r).lsa_port[i] = d
#define BCM53101_A0_LSA_PORTr_GET(r,i) (r).lsa_port[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_LSA_PORTr_LST_ADDRf_GET(r,a) cdk_field_get((r).lsa_port,0,47,a)
#define BCM53101_A0_LSA_PORTr_LST_ADDRf_SET(r,a) cdk_field_set((r).lsa_port,0,47,a)

/*
 * These macros can be used to access LSA_PORT.
 *
 */
#define BCM53101_A0_READ_LSA_PORTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_LSA_PORTr,(r._lsa_port),6)
#define BCM53101_A0_WRITE_LSA_PORTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_LSA_PORTr,&(r._lsa_port),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define LSA_PORTr BCM53101_A0_LSA_PORTr
#define LSA_PORTr_SIZE BCM53101_A0_LSA_PORTr_SIZE
typedef BCM53101_A0_LSA_PORTr_t LSA_PORTr_t;
#define LSA_PORTr_CLR BCM53101_A0_LSA_PORTr_CLR
#define LSA_PORTr_SET BCM53101_A0_LSA_PORTr_SET
#define LSA_PORTr_GET BCM53101_A0_LSA_PORTr_GET
#define LSA_PORTr_LST_ADDRf_GET BCM53101_A0_LSA_PORTr_LST_ADDRf_GET
#define LSA_PORTr_LST_ADDRf_SET BCM53101_A0_LSA_PORTr_LST_ADDRf_SET
#define READ_LSA_PORTr BCM53101_A0_READ_LSA_PORTr
#define WRITE_LSA_PORTr BCM53101_A0_WRITE_LSA_PORTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_LSA_PORTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MAC_TRUNK_CTL
 * BLOCKS:   SYS
 * DESC:     MAC Trunk Control Register
 * SIZE:     8
 * FIELDS:
 *     HASH_SEL         index selection00 : use hash DA ^ SA) to generate index. ( default=0 )01 : use hash(DA) to generate index.10 : Use hash (SA) to generate index.
 *     SERVER_0         Reserved
 *     EN_TRUNK_LOCAL   Enable Mac trunking .Lotus  support 4 trunking groups. The trunking group can support up to 2 ports as defined trunking group register.
 *     SERVER_1         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_MAC_TRUNK_CTLr 0x00003200

#define BCM53101_A0_MAC_TRUNK_CTLr_SIZE 1

/*
 * This structure should be used to declare and program MAC_TRUNK_CTL.
 *
 */
typedef union BCM53101_A0_MAC_TRUNK_CTLr_s {
	uint32_t v[1];
	uint32_t mac_trunk_ctl[1];
	uint32_t _mac_trunk_ctl;
} BCM53101_A0_MAC_TRUNK_CTLr_t;

#define BCM53101_A0_MAC_TRUNK_CTLr_CLR(r) (r).mac_trunk_ctl[0] = 0
#define BCM53101_A0_MAC_TRUNK_CTLr_SET(r,d) (r).mac_trunk_ctl[0] = d
#define BCM53101_A0_MAC_TRUNK_CTLr_GET(r) (r).mac_trunk_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MAC_TRUNK_CTLr_HASH_SELf_GET(r) (((r).mac_trunk_ctl[0]) & 0x3)
#define BCM53101_A0_MAC_TRUNK_CTLr_HASH_SELf_SET(r,f) (r).mac_trunk_ctl[0]=(((r).mac_trunk_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53101_A0_MAC_TRUNK_CTLr_SERVER_0f_GET(r) ((((r).mac_trunk_ctl[0]) >> 2) & 0x1)
#define BCM53101_A0_MAC_TRUNK_CTLr_SERVER_0f_SET(r,f) (r).mac_trunk_ctl[0]=(((r).mac_trunk_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_MAC_TRUNK_CTLr_EN_TRUNK_LOCALf_GET(r) ((((r).mac_trunk_ctl[0]) >> 3) & 0x1)
#define BCM53101_A0_MAC_TRUNK_CTLr_EN_TRUNK_LOCALf_SET(r,f) (r).mac_trunk_ctl[0]=(((r).mac_trunk_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_MAC_TRUNK_CTLr_SERVER_1f_GET(r) ((((r).mac_trunk_ctl[0]) >> 4) & 0xf)
#define BCM53101_A0_MAC_TRUNK_CTLr_SERVER_1f_SET(r,f) (r).mac_trunk_ctl[0]=(((r).mac_trunk_ctl[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access MAC_TRUNK_CTL.
 *
 */
#define BCM53101_A0_READ_MAC_TRUNK_CTLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_MAC_TRUNK_CTLr,(r._mac_trunk_ctl),1)
#define BCM53101_A0_WRITE_MAC_TRUNK_CTLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_MAC_TRUNK_CTLr,&(r._mac_trunk_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAC_TRUNK_CTLr BCM53101_A0_MAC_TRUNK_CTLr
#define MAC_TRUNK_CTLr_SIZE BCM53101_A0_MAC_TRUNK_CTLr_SIZE
typedef BCM53101_A0_MAC_TRUNK_CTLr_t MAC_TRUNK_CTLr_t;
#define MAC_TRUNK_CTLr_CLR BCM53101_A0_MAC_TRUNK_CTLr_CLR
#define MAC_TRUNK_CTLr_SET BCM53101_A0_MAC_TRUNK_CTLr_SET
#define MAC_TRUNK_CTLr_GET BCM53101_A0_MAC_TRUNK_CTLr_GET
#define MAC_TRUNK_CTLr_HASH_SELf_GET BCM53101_A0_MAC_TRUNK_CTLr_HASH_SELf_GET
#define MAC_TRUNK_CTLr_HASH_SELf_SET BCM53101_A0_MAC_TRUNK_CTLr_HASH_SELf_SET
#define MAC_TRUNK_CTLr_SERVER_0f_GET BCM53101_A0_MAC_TRUNK_CTLr_SERVER_0f_GET
#define MAC_TRUNK_CTLr_SERVER_0f_SET BCM53101_A0_MAC_TRUNK_CTLr_SERVER_0f_SET
#define MAC_TRUNK_CTLr_EN_TRUNK_LOCALf_GET BCM53101_A0_MAC_TRUNK_CTLr_EN_TRUNK_LOCALf_GET
#define MAC_TRUNK_CTLr_EN_TRUNK_LOCALf_SET BCM53101_A0_MAC_TRUNK_CTLr_EN_TRUNK_LOCALf_SET
#define MAC_TRUNK_CTLr_SERVER_1f_GET BCM53101_A0_MAC_TRUNK_CTLr_SERVER_1f_GET
#define MAC_TRUNK_CTLr_SERVER_1f_SET BCM53101_A0_MAC_TRUNK_CTLr_SERVER_1f_SET
#define READ_MAC_TRUNK_CTLr BCM53101_A0_READ_MAC_TRUNK_CTLr
#define WRITE_MAC_TRUNK_CTLr BCM53101_A0_WRITE_MAC_TRUNK_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MAC_TRUNK_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * MEMORY:  MARL_PBMP
 * BLOCKS:   SYS
 * DESC:     Multicast Table
 * SIZE:     29
 * FIELDS:
 *     PBMP             Multicast forwarding vector
 *
 ******************************************************************************/
#define BCM53101_A0_MARL_PBMPm 0x00000000

#define BCM53101_A0_MARL_PBMPm_MIN 0
#define BCM53101_A0_MARL_PBMPm_MAX 4095
#define BCM53101_A0_MARL_PBMPm_CMAX(u) 4095
#define BCM53101_A0_MARL_PBMPm_SIZE 4

/*
 * This structure should be used to declare and program MARL_PBMP.
 *
 */
typedef union BCM53101_A0_MARL_PBMPm_s {
	uint32_t v[1];
	uint32_t marl_pbmp[1];
	uint32_t _marl_pbmp;
} BCM53101_A0_MARL_PBMPm_t;

#define BCM53101_A0_MARL_PBMPm_CLR(r) (r).marl_pbmp[0] = 0
#define BCM53101_A0_MARL_PBMPm_SET(r,d) (r).marl_pbmp[0] = d
#define BCM53101_A0_MARL_PBMPm_GET(r) (r).marl_pbmp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MARL_PBMPm_PBMPf_GET(r) (((r).marl_pbmp[0]) & 0x1fffffff)
#define BCM53101_A0_MARL_PBMPm_PBMPf_SET(r,f) (r).marl_pbmp[0]=(((r).marl_pbmp[0] & ~((uint32_t)0x1fffffff)) | (((uint32_t)f) & 0x1fffffff))

/*
 * These macros can be used to access MARL_PBMP.
 *
 */
#define BCM53101_A0_READ_MARL_PBMPm(u,i,m) cdk_robo_mem_read(u,BCM53101_A0_MARL_PBMPm,i,(m),4)
#define BCM53101_A0_WRITE_MARL_PBMPm(u,i,m) cdk_robo_mem_write(u,BCM53101_A0_MARL_PBMPm,i,&(m),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MARL_PBMPm BCM53101_A0_MARL_PBMPm
#define MARL_PBMPm_MIN BCM53101_A0_MARL_PBMPm_MIN
#define MARL_PBMPm_MAX BCM53101_A0_MARL_PBMPm_MAX
#define MARL_PBMPm_CMAX(u) BCM53101_A0_MARL_PBMPm_CMAX(u)
#define MARL_PBMPm_SIZE BCM53101_A0_MARL_PBMPm_SIZE
typedef BCM53101_A0_MARL_PBMPm_t MARL_PBMPm_t;
#define MARL_PBMPm_CLR BCM53101_A0_MARL_PBMPm_CLR
#define MARL_PBMPm_SET BCM53101_A0_MARL_PBMPm_SET
#define MARL_PBMPm_GET BCM53101_A0_MARL_PBMPm_GET
#define MARL_PBMPm_PBMPf_GET BCM53101_A0_MARL_PBMPm_PBMPf_GET
#define MARL_PBMPm_PBMPf_SET BCM53101_A0_MARL_PBMPm_PBMPf_SET
#define READ_MARL_PBMPm BCM53101_A0_READ_MARL_PBMPm
#define WRITE_MARL_PBMPm BCM53101_A0_WRITE_MARL_PBMPm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MARL_PBMPm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MAX_ICMPV4_SIZE_REG
 * BLOCKS:   SYS
 * DESC:     Maximum ICMPv4 Size Register
 * SIZE:     32
 * FIELDS:
 *     MAX_ICMPV4_SIZE  MAX_ICMPv4_Size is programable between 0 and 9.6K bytes, inclusive. The default value is set to 512 bytes.
 *
 ******************************************************************************/
#define BCM53101_A0_MAX_ICMPV4_SIZE_REGr 0x00003608

#define BCM53101_A0_MAX_ICMPV4_SIZE_REGr_SIZE 4

/*
 * This structure should be used to declare and program MAX_ICMPV4_SIZE_REG.
 *
 */
typedef union BCM53101_A0_MAX_ICMPV4_SIZE_REGr_s {
	uint32_t v[1];
	uint32_t max_icmpv4_size_reg[1];
	uint32_t _max_icmpv4_size_reg;
} BCM53101_A0_MAX_ICMPV4_SIZE_REGr_t;

#define BCM53101_A0_MAX_ICMPV4_SIZE_REGr_CLR(r) (r).max_icmpv4_size_reg[0] = 0
#define BCM53101_A0_MAX_ICMPV4_SIZE_REGr_SET(r,d) (r).max_icmpv4_size_reg[0] = d
#define BCM53101_A0_MAX_ICMPV4_SIZE_REGr_GET(r) (r).max_icmpv4_size_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MAX_ICMPV4_SIZE_REGr_MAX_ICMPV4_SIZEf_GET(r) ((r).max_icmpv4_size_reg[0])
#define BCM53101_A0_MAX_ICMPV4_SIZE_REGr_MAX_ICMPV4_SIZEf_SET(r,f) (r).max_icmpv4_size_reg[0]=((uint32_t)f)

/*
 * These macros can be used to access MAX_ICMPV4_SIZE_REG.
 *
 */
#define BCM53101_A0_READ_MAX_ICMPV4_SIZE_REGr(u,r) cdk_robo_reg_read(u,BCM53101_A0_MAX_ICMPV4_SIZE_REGr,(r._max_icmpv4_size_reg),4)
#define BCM53101_A0_WRITE_MAX_ICMPV4_SIZE_REGr(u,r) cdk_robo_reg_write(u,BCM53101_A0_MAX_ICMPV4_SIZE_REGr,&(r._max_icmpv4_size_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAX_ICMPV4_SIZE_REGr BCM53101_A0_MAX_ICMPV4_SIZE_REGr
#define MAX_ICMPV4_SIZE_REGr_SIZE BCM53101_A0_MAX_ICMPV4_SIZE_REGr_SIZE
typedef BCM53101_A0_MAX_ICMPV4_SIZE_REGr_t MAX_ICMPV4_SIZE_REGr_t;
#define MAX_ICMPV4_SIZE_REGr_CLR BCM53101_A0_MAX_ICMPV4_SIZE_REGr_CLR
#define MAX_ICMPV4_SIZE_REGr_SET BCM53101_A0_MAX_ICMPV4_SIZE_REGr_SET
#define MAX_ICMPV4_SIZE_REGr_GET BCM53101_A0_MAX_ICMPV4_SIZE_REGr_GET
#define MAX_ICMPV4_SIZE_REGr_MAX_ICMPV4_SIZEf_GET BCM53101_A0_MAX_ICMPV4_SIZE_REGr_MAX_ICMPV4_SIZEf_GET
#define MAX_ICMPV4_SIZE_REGr_MAX_ICMPV4_SIZEf_SET BCM53101_A0_MAX_ICMPV4_SIZE_REGr_MAX_ICMPV4_SIZEf_SET
#define READ_MAX_ICMPV4_SIZE_REGr BCM53101_A0_READ_MAX_ICMPV4_SIZE_REGr
#define WRITE_MAX_ICMPV4_SIZE_REGr BCM53101_A0_WRITE_MAX_ICMPV4_SIZE_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MAX_ICMPV4_SIZE_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MAX_ICMPV6_SIZE_REG
 * BLOCKS:   SYS
 * DESC:     Maximum ICMPv6 Size Register
 * SIZE:     32
 * FIELDS:
 *     MAX_ICMPV6_SIZE  MAX_ICMPv6_Size is programable between 0 and 9.6K bytes, inclusive. The default value is set to 512 bytes.
 *
 ******************************************************************************/
#define BCM53101_A0_MAX_ICMPV6_SIZE_REGr 0x0000360c

#define BCM53101_A0_MAX_ICMPV6_SIZE_REGr_SIZE 4

/*
 * This structure should be used to declare and program MAX_ICMPV6_SIZE_REG.
 *
 */
typedef union BCM53101_A0_MAX_ICMPV6_SIZE_REGr_s {
	uint32_t v[1];
	uint32_t max_icmpv6_size_reg[1];
	uint32_t _max_icmpv6_size_reg;
} BCM53101_A0_MAX_ICMPV6_SIZE_REGr_t;

#define BCM53101_A0_MAX_ICMPV6_SIZE_REGr_CLR(r) (r).max_icmpv6_size_reg[0] = 0
#define BCM53101_A0_MAX_ICMPV6_SIZE_REGr_SET(r,d) (r).max_icmpv6_size_reg[0] = d
#define BCM53101_A0_MAX_ICMPV6_SIZE_REGr_GET(r) (r).max_icmpv6_size_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MAX_ICMPV6_SIZE_REGr_MAX_ICMPV6_SIZEf_GET(r) ((r).max_icmpv6_size_reg[0])
#define BCM53101_A0_MAX_ICMPV6_SIZE_REGr_MAX_ICMPV6_SIZEf_SET(r,f) (r).max_icmpv6_size_reg[0]=((uint32_t)f)

/*
 * These macros can be used to access MAX_ICMPV6_SIZE_REG.
 *
 */
#define BCM53101_A0_READ_MAX_ICMPV6_SIZE_REGr(u,r) cdk_robo_reg_read(u,BCM53101_A0_MAX_ICMPV6_SIZE_REGr,(r._max_icmpv6_size_reg),4)
#define BCM53101_A0_WRITE_MAX_ICMPV6_SIZE_REGr(u,r) cdk_robo_reg_write(u,BCM53101_A0_MAX_ICMPV6_SIZE_REGr,&(r._max_icmpv6_size_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MAX_ICMPV6_SIZE_REGr BCM53101_A0_MAX_ICMPV6_SIZE_REGr
#define MAX_ICMPV6_SIZE_REGr_SIZE BCM53101_A0_MAX_ICMPV6_SIZE_REGr_SIZE
typedef BCM53101_A0_MAX_ICMPV6_SIZE_REGr_t MAX_ICMPV6_SIZE_REGr_t;
#define MAX_ICMPV6_SIZE_REGr_CLR BCM53101_A0_MAX_ICMPV6_SIZE_REGr_CLR
#define MAX_ICMPV6_SIZE_REGr_SET BCM53101_A0_MAX_ICMPV6_SIZE_REGr_SET
#define MAX_ICMPV6_SIZE_REGr_GET BCM53101_A0_MAX_ICMPV6_SIZE_REGr_GET
#define MAX_ICMPV6_SIZE_REGr_MAX_ICMPV6_SIZEf_GET BCM53101_A0_MAX_ICMPV6_SIZE_REGr_MAX_ICMPV6_SIZEf_GET
#define MAX_ICMPV6_SIZE_REGr_MAX_ICMPV6_SIZEf_SET BCM53101_A0_MAX_ICMPV6_SIZE_REGr_MAX_ICMPV6_SIZEf_SET
#define READ_MAX_ICMPV6_SIZE_REGr BCM53101_A0_READ_MAX_ICMPV6_SIZE_REGr
#define WRITE_MAX_ICMPV6_SIZE_REGr BCM53101_A0_WRITE_MAX_ICMPV6_SIZE_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MAX_ICMPV6_SIZE_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MDIO_IMP_ADDR
 * BLOCKS:   SYS
 * DESC:     MDIO Port IMP Address Registrer
 * SIZE:     8
 * FIELDS:
 *     ADDR_IMP         Port IMP MDIO Scan ADDRESS.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_MDIO_IMP_ADDRr 0x00000078

#define BCM53101_A0_MDIO_IMP_ADDRr_SIZE 1

/*
 * This structure should be used to declare and program MDIO_IMP_ADDR.
 *
 */
typedef union BCM53101_A0_MDIO_IMP_ADDRr_s {
	uint32_t v[1];
	uint32_t mdio_imp_addr[1];
	uint32_t _mdio_imp_addr;
} BCM53101_A0_MDIO_IMP_ADDRr_t;

#define BCM53101_A0_MDIO_IMP_ADDRr_CLR(r) (r).mdio_imp_addr[0] = 0
#define BCM53101_A0_MDIO_IMP_ADDRr_SET(r,d) (r).mdio_imp_addr[0] = d
#define BCM53101_A0_MDIO_IMP_ADDRr_GET(r) (r).mdio_imp_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MDIO_IMP_ADDRr_ADDR_IMPf_GET(r) (((r).mdio_imp_addr[0]) & 0x1f)
#define BCM53101_A0_MDIO_IMP_ADDRr_ADDR_IMPf_SET(r,f) (r).mdio_imp_addr[0]=(((r).mdio_imp_addr[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53101_A0_MDIO_IMP_ADDRr_RESERVEDf_GET(r) ((((r).mdio_imp_addr[0]) >> 5) & 0x7)
#define BCM53101_A0_MDIO_IMP_ADDRr_RESERVEDf_SET(r,f) (r).mdio_imp_addr[0]=(((r).mdio_imp_addr[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access MDIO_IMP_ADDR.
 *
 */
#define BCM53101_A0_READ_MDIO_IMP_ADDRr(u,r) cdk_robo_reg_read(u,BCM53101_A0_MDIO_IMP_ADDRr,(r._mdio_imp_addr),1)
#define BCM53101_A0_WRITE_MDIO_IMP_ADDRr(u,r) cdk_robo_reg_write(u,BCM53101_A0_MDIO_IMP_ADDRr,&(r._mdio_imp_addr),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MDIO_IMP_ADDRr BCM53101_A0_MDIO_IMP_ADDRr
#define MDIO_IMP_ADDRr_SIZE BCM53101_A0_MDIO_IMP_ADDRr_SIZE
typedef BCM53101_A0_MDIO_IMP_ADDRr_t MDIO_IMP_ADDRr_t;
#define MDIO_IMP_ADDRr_CLR BCM53101_A0_MDIO_IMP_ADDRr_CLR
#define MDIO_IMP_ADDRr_SET BCM53101_A0_MDIO_IMP_ADDRr_SET
#define MDIO_IMP_ADDRr_GET BCM53101_A0_MDIO_IMP_ADDRr_GET
#define MDIO_IMP_ADDRr_ADDR_IMPf_GET BCM53101_A0_MDIO_IMP_ADDRr_ADDR_IMPf_GET
#define MDIO_IMP_ADDRr_ADDR_IMPf_SET BCM53101_A0_MDIO_IMP_ADDRr_ADDR_IMPf_SET
#define MDIO_IMP_ADDRr_RESERVEDf_GET BCM53101_A0_MDIO_IMP_ADDRr_RESERVEDf_GET
#define MDIO_IMP_ADDRr_RESERVEDf_SET BCM53101_A0_MDIO_IMP_ADDRr_RESERVEDf_SET
#define READ_MDIO_IMP_ADDRr BCM53101_A0_READ_MDIO_IMP_ADDRr
#define WRITE_MDIO_IMP_ADDRr BCM53101_A0_WRITE_MDIO_IMP_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MDIO_IMP_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MDIO_WAN_ADDR
 * BLOCKS:   SYS
 * DESC:     MDIO WAN Port Address Registrer
 * SIZE:     8
 * FIELDS:
 *     ADDR_WAN         Wan-Port MDIO Scan ADDRESS.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_MDIO_WAN_ADDRr 0x00000075

#define BCM53101_A0_MDIO_WAN_ADDRr_SIZE 1

/*
 * This structure should be used to declare and program MDIO_WAN_ADDR.
 *
 */
typedef union BCM53101_A0_MDIO_WAN_ADDRr_s {
	uint32_t v[1];
	uint32_t mdio_wan_addr[1];
	uint32_t _mdio_wan_addr;
} BCM53101_A0_MDIO_WAN_ADDRr_t;

#define BCM53101_A0_MDIO_WAN_ADDRr_CLR(r) (r).mdio_wan_addr[0] = 0
#define BCM53101_A0_MDIO_WAN_ADDRr_SET(r,d) (r).mdio_wan_addr[0] = d
#define BCM53101_A0_MDIO_WAN_ADDRr_GET(r) (r).mdio_wan_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MDIO_WAN_ADDRr_ADDR_WANf_GET(r) (((r).mdio_wan_addr[0]) & 0x1f)
#define BCM53101_A0_MDIO_WAN_ADDRr_ADDR_WANf_SET(r,f) (r).mdio_wan_addr[0]=(((r).mdio_wan_addr[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53101_A0_MDIO_WAN_ADDRr_RESERVEDf_GET(r) ((((r).mdio_wan_addr[0]) >> 5) & 0x7)
#define BCM53101_A0_MDIO_WAN_ADDRr_RESERVEDf_SET(r,f) (r).mdio_wan_addr[0]=(((r).mdio_wan_addr[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access MDIO_WAN_ADDR.
 *
 */
#define BCM53101_A0_READ_MDIO_WAN_ADDRr(u,r) cdk_robo_reg_read(u,BCM53101_A0_MDIO_WAN_ADDRr,(r._mdio_wan_addr),1)
#define BCM53101_A0_WRITE_MDIO_WAN_ADDRr(u,r) cdk_robo_reg_write(u,BCM53101_A0_MDIO_WAN_ADDRr,&(r._mdio_wan_addr),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MDIO_WAN_ADDRr BCM53101_A0_MDIO_WAN_ADDRr
#define MDIO_WAN_ADDRr_SIZE BCM53101_A0_MDIO_WAN_ADDRr_SIZE
typedef BCM53101_A0_MDIO_WAN_ADDRr_t MDIO_WAN_ADDRr_t;
#define MDIO_WAN_ADDRr_CLR BCM53101_A0_MDIO_WAN_ADDRr_CLR
#define MDIO_WAN_ADDRr_SET BCM53101_A0_MDIO_WAN_ADDRr_SET
#define MDIO_WAN_ADDRr_GET BCM53101_A0_MDIO_WAN_ADDRr_GET
#define MDIO_WAN_ADDRr_ADDR_WANf_GET BCM53101_A0_MDIO_WAN_ADDRr_ADDR_WANf_GET
#define MDIO_WAN_ADDRr_ADDR_WANf_SET BCM53101_A0_MDIO_WAN_ADDRr_ADDR_WANf_SET
#define MDIO_WAN_ADDRr_RESERVEDf_GET BCM53101_A0_MDIO_WAN_ADDRr_RESERVEDf_GET
#define MDIO_WAN_ADDRr_RESERVEDf_SET BCM53101_A0_MDIO_WAN_ADDRr_RESERVEDf_SET
#define READ_MDIO_WAN_ADDRr BCM53101_A0_READ_MDIO_WAN_ADDRr
#define WRITE_MDIO_WAN_ADDRr BCM53101_A0_WRITE_MDIO_WAN_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MDIO_WAN_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MEMORY_TEST_CTRL
 * BLOCKS:   SYS
 * DESC:     Memory Test Control Register(Engineering Use Only)
 * SIZE:     64
 * FIELDS:
 *     ARL_TM           TM control[7:0] for ARL Table, AT0 and AT1
 *     BT_TM            TM control[7:0] for Buffer Tag, BT
 *     PB_TM            TM control[7:0] for Packet Buffer, PB
 *     TXQ_TM           TM control[7:0] for Transmit Queue, TXQ
 *     RESERVED_0       Reserved
 *     VL_TM            TM control[3:0] for VLAN Table, VT
 *     RESERVED_1       Reserved
 *     OTP_CPU_IF_EN    Enable OTP CPU Interface
 *
 ******************************************************************************/
#define BCM53101_A0_MEMORY_TEST_CTRLr 0x000000e0

#define BCM53101_A0_MEMORY_TEST_CTRLr_SIZE 8

/*
 * This structure should be used to declare and program MEMORY_TEST_CTRL.
 *
 */
typedef union BCM53101_A0_MEMORY_TEST_CTRLr_s {
	uint32_t v[2];
	uint32_t memory_test_ctrl[2];
	uint32_t _memory_test_ctrl;
} BCM53101_A0_MEMORY_TEST_CTRLr_t;

#define BCM53101_A0_MEMORY_TEST_CTRLr_CLR(r) CDK_MEMSET(&((r)._memory_test_ctrl), 0, sizeof(BCM53101_A0_MEMORY_TEST_CTRLr_t))
#define BCM53101_A0_MEMORY_TEST_CTRLr_SET(r,i,d) (r).memory_test_ctrl[i] = d
#define BCM53101_A0_MEMORY_TEST_CTRLr_GET(r,i) (r).memory_test_ctrl[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MEMORY_TEST_CTRLr_ARL_TMf_GET(r) (((r).memory_test_ctrl[0]) & 0xff)
#define BCM53101_A0_MEMORY_TEST_CTRLr_ARL_TMf_SET(r,f) (r).memory_test_ctrl[0]=(((r).memory_test_ctrl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53101_A0_MEMORY_TEST_CTRLr_BT_TMf_GET(r) ((((r).memory_test_ctrl[0]) >> 8) & 0xff)
#define BCM53101_A0_MEMORY_TEST_CTRLr_BT_TMf_SET(r,f) (r).memory_test_ctrl[0]=(((r).memory_test_ctrl[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM53101_A0_MEMORY_TEST_CTRLr_PB_TMf_GET(r) ((((r).memory_test_ctrl[0]) >> 16) & 0xff)
#define BCM53101_A0_MEMORY_TEST_CTRLr_PB_TMf_SET(r,f) (r).memory_test_ctrl[0]=(((r).memory_test_ctrl[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM53101_A0_MEMORY_TEST_CTRLr_TXQ_TMf_GET(r) ((((r).memory_test_ctrl[0]) >> 24) & 0xff)
#define BCM53101_A0_MEMORY_TEST_CTRLr_TXQ_TMf_SET(r,f) (r).memory_test_ctrl[0]=(((r).memory_test_ctrl[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))
#define BCM53101_A0_MEMORY_TEST_CTRLr_RESERVED_0f_GET(r) (((r).memory_test_ctrl[1]) & 0xfff)
#define BCM53101_A0_MEMORY_TEST_CTRLr_RESERVED_0f_SET(r,f) (r).memory_test_ctrl[1]=(((r).memory_test_ctrl[1] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53101_A0_MEMORY_TEST_CTRLr_VL_TMf_GET(r) ((((r).memory_test_ctrl[1]) >> 12) & 0xf)
#define BCM53101_A0_MEMORY_TEST_CTRLr_VL_TMf_SET(r,f) (r).memory_test_ctrl[1]=(((r).memory_test_ctrl[1] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM53101_A0_MEMORY_TEST_CTRLr_RESERVED_1f_GET(r) ((((r).memory_test_ctrl[1]) >> 16) & 0x7fff)
#define BCM53101_A0_MEMORY_TEST_CTRLr_RESERVED_1f_SET(r,f) (r).memory_test_ctrl[1]=(((r).memory_test_ctrl[1] & ~((uint32_t)0x7fff << 16)) | ((((uint32_t)f) & 0x7fff) << 16))
#define BCM53101_A0_MEMORY_TEST_CTRLr_OTP_CPU_IF_ENf_GET(r) ((((r).memory_test_ctrl[1]) >> 31) & 0x1)
#define BCM53101_A0_MEMORY_TEST_CTRLr_OTP_CPU_IF_ENf_SET(r,f) (r).memory_test_ctrl[1]=(((r).memory_test_ctrl[1] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access MEMORY_TEST_CTRL.
 *
 */
#define BCM53101_A0_READ_MEMORY_TEST_CTRLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_MEMORY_TEST_CTRLr,(r._memory_test_ctrl),8)
#define BCM53101_A0_WRITE_MEMORY_TEST_CTRLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_MEMORY_TEST_CTRLr,&(r._memory_test_ctrl),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEMORY_TEST_CTRLr BCM53101_A0_MEMORY_TEST_CTRLr
#define MEMORY_TEST_CTRLr_SIZE BCM53101_A0_MEMORY_TEST_CTRLr_SIZE
typedef BCM53101_A0_MEMORY_TEST_CTRLr_t MEMORY_TEST_CTRLr_t;
#define MEMORY_TEST_CTRLr_CLR BCM53101_A0_MEMORY_TEST_CTRLr_CLR
#define MEMORY_TEST_CTRLr_SET BCM53101_A0_MEMORY_TEST_CTRLr_SET
#define MEMORY_TEST_CTRLr_GET BCM53101_A0_MEMORY_TEST_CTRLr_GET
#define MEMORY_TEST_CTRLr_ARL_TMf_GET BCM53101_A0_MEMORY_TEST_CTRLr_ARL_TMf_GET
#define MEMORY_TEST_CTRLr_ARL_TMf_SET BCM53101_A0_MEMORY_TEST_CTRLr_ARL_TMf_SET
#define MEMORY_TEST_CTRLr_BT_TMf_GET BCM53101_A0_MEMORY_TEST_CTRLr_BT_TMf_GET
#define MEMORY_TEST_CTRLr_BT_TMf_SET BCM53101_A0_MEMORY_TEST_CTRLr_BT_TMf_SET
#define MEMORY_TEST_CTRLr_PB_TMf_GET BCM53101_A0_MEMORY_TEST_CTRLr_PB_TMf_GET
#define MEMORY_TEST_CTRLr_PB_TMf_SET BCM53101_A0_MEMORY_TEST_CTRLr_PB_TMf_SET
#define MEMORY_TEST_CTRLr_TXQ_TMf_GET BCM53101_A0_MEMORY_TEST_CTRLr_TXQ_TMf_GET
#define MEMORY_TEST_CTRLr_TXQ_TMf_SET BCM53101_A0_MEMORY_TEST_CTRLr_TXQ_TMf_SET
#define MEMORY_TEST_CTRLr_RESERVED_0f_GET BCM53101_A0_MEMORY_TEST_CTRLr_RESERVED_0f_GET
#define MEMORY_TEST_CTRLr_RESERVED_0f_SET BCM53101_A0_MEMORY_TEST_CTRLr_RESERVED_0f_SET
#define MEMORY_TEST_CTRLr_VL_TMf_GET BCM53101_A0_MEMORY_TEST_CTRLr_VL_TMf_GET
#define MEMORY_TEST_CTRLr_VL_TMf_SET BCM53101_A0_MEMORY_TEST_CTRLr_VL_TMf_SET
#define MEMORY_TEST_CTRLr_RESERVED_1f_GET BCM53101_A0_MEMORY_TEST_CTRLr_RESERVED_1f_GET
#define MEMORY_TEST_CTRLr_RESERVED_1f_SET BCM53101_A0_MEMORY_TEST_CTRLr_RESERVED_1f_SET
#define MEMORY_TEST_CTRLr_OTP_CPU_IF_ENf_GET BCM53101_A0_MEMORY_TEST_CTRLr_OTP_CPU_IF_ENf_GET
#define MEMORY_TEST_CTRLr_OTP_CPU_IF_ENf_SET BCM53101_A0_MEMORY_TEST_CTRLr_OTP_CPU_IF_ENf_SET
#define READ_MEMORY_TEST_CTRLr BCM53101_A0_READ_MEMORY_TEST_CTRLr
#define WRITE_MEMORY_TEST_CTRLr BCM53101_A0_WRITE_MEMORY_TEST_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MEMORY_TEST_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MEM_ADDR
 * BLOCKS:   SYS
 * DESC:     Memory Debug Address Register
 * SIZE:     16
 * FIELDS:
 *     MEM_ADR          Specifies the next memory address to read or write.
 *     MEM_RW           '1' causes a read operation while '0' is for a write operation.
 *     MEM_STDN         Initiates the read/write operation for the Debugged memory.The bit will be clear once the Read/Write Operation is completed.
 *
 ******************************************************************************/
#define BCM53101_A0_MEM_ADDRr 0x00000801

#define BCM53101_A0_MEM_ADDRr_SIZE 2

/*
 * This structure should be used to declare and program MEM_ADDR.
 *
 */
typedef union BCM53101_A0_MEM_ADDRr_s {
	uint32_t v[1];
	uint32_t mem_addr[1];
	uint32_t _mem_addr;
} BCM53101_A0_MEM_ADDRr_t;

#define BCM53101_A0_MEM_ADDRr_CLR(r) (r).mem_addr[0] = 0
#define BCM53101_A0_MEM_ADDRr_SET(r,d) (r).mem_addr[0] = d
#define BCM53101_A0_MEM_ADDRr_GET(r) (r).mem_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MEM_ADDRr_MEM_ADRf_GET(r) (((r).mem_addr[0]) & 0x3fff)
#define BCM53101_A0_MEM_ADDRr_MEM_ADRf_SET(r,f) (r).mem_addr[0]=(((r).mem_addr[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM53101_A0_MEM_ADDRr_MEM_RWf_GET(r) ((((r).mem_addr[0]) >> 14) & 0x1)
#define BCM53101_A0_MEM_ADDRr_MEM_RWf_SET(r,f) (r).mem_addr[0]=(((r).mem_addr[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_MEM_ADDRr_MEM_STDNf_GET(r) ((((r).mem_addr[0]) >> 15) & 0x1)
#define BCM53101_A0_MEM_ADDRr_MEM_STDNf_SET(r,f) (r).mem_addr[0]=(((r).mem_addr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MEM_ADDR.
 *
 */
#define BCM53101_A0_READ_MEM_ADDRr(u,r) cdk_robo_reg_read(u,BCM53101_A0_MEM_ADDRr,(r._mem_addr),2)
#define BCM53101_A0_WRITE_MEM_ADDRr(u,r) cdk_robo_reg_write(u,BCM53101_A0_MEM_ADDRr,&(r._mem_addr),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_ADDRr BCM53101_A0_MEM_ADDRr
#define MEM_ADDRr_SIZE BCM53101_A0_MEM_ADDRr_SIZE
typedef BCM53101_A0_MEM_ADDRr_t MEM_ADDRr_t;
#define MEM_ADDRr_CLR BCM53101_A0_MEM_ADDRr_CLR
#define MEM_ADDRr_SET BCM53101_A0_MEM_ADDRr_SET
#define MEM_ADDRr_GET BCM53101_A0_MEM_ADDRr_GET
#define MEM_ADDRr_MEM_ADRf_GET BCM53101_A0_MEM_ADDRr_MEM_ADRf_GET
#define MEM_ADDRr_MEM_ADRf_SET BCM53101_A0_MEM_ADDRr_MEM_ADRf_SET
#define MEM_ADDRr_MEM_RWf_GET BCM53101_A0_MEM_ADDRr_MEM_RWf_GET
#define MEM_ADDRr_MEM_RWf_SET BCM53101_A0_MEM_ADDRr_MEM_RWf_SET
#define MEM_ADDRr_MEM_STDNf_GET BCM53101_A0_MEM_ADDRr_MEM_STDNf_GET
#define MEM_ADDRr_MEM_STDNf_SET BCM53101_A0_MEM_ADDRr_MEM_STDNf_SET
#define READ_MEM_ADDRr BCM53101_A0_READ_MEM_ADDRr
#define WRITE_MEM_ADDRr BCM53101_A0_WRITE_MEM_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MEM_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MEM_BFC_ADDR
 * BLOCKS:   SYS
 * DESC:     Buffer Control Memory Address Register
 * SIZE:     16
 * FIELDS:
 *     BFC_ADDR         Specifies the next memmory address to read or write.
 *     RW_CTRL          '1' causes read operation while '0' is for write operation.
 *     MEM_REQ          Initiates the read/write operation for the Buffer Control memmory.The bit will clear one the Read/write Operation is completed.
 *
 ******************************************************************************/
#define BCM53101_A0_MEM_BFC_ADDRr 0x00000860

#define BCM53101_A0_MEM_BFC_ADDRr_SIZE 2

/*
 * This structure should be used to declare and program MEM_BFC_ADDR.
 *
 */
typedef union BCM53101_A0_MEM_BFC_ADDRr_s {
	uint32_t v[1];
	uint32_t mem_bfc_addr[1];
	uint32_t _mem_bfc_addr;
} BCM53101_A0_MEM_BFC_ADDRr_t;

#define BCM53101_A0_MEM_BFC_ADDRr_CLR(r) (r).mem_bfc_addr[0] = 0
#define BCM53101_A0_MEM_BFC_ADDRr_SET(r,d) (r).mem_bfc_addr[0] = d
#define BCM53101_A0_MEM_BFC_ADDRr_GET(r) (r).mem_bfc_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MEM_BFC_ADDRr_BFC_ADDRf_GET(r) (((r).mem_bfc_addr[0]) & 0x3fff)
#define BCM53101_A0_MEM_BFC_ADDRr_BFC_ADDRf_SET(r,f) (r).mem_bfc_addr[0]=(((r).mem_bfc_addr[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM53101_A0_MEM_BFC_ADDRr_RW_CTRLf_GET(r) ((((r).mem_bfc_addr[0]) >> 14) & 0x1)
#define BCM53101_A0_MEM_BFC_ADDRr_RW_CTRLf_SET(r,f) (r).mem_bfc_addr[0]=(((r).mem_bfc_addr[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_MEM_BFC_ADDRr_MEM_REQf_GET(r) ((((r).mem_bfc_addr[0]) >> 15) & 0x1)
#define BCM53101_A0_MEM_BFC_ADDRr_MEM_REQf_SET(r,f) (r).mem_bfc_addr[0]=(((r).mem_bfc_addr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MEM_BFC_ADDR.
 *
 */
#define BCM53101_A0_READ_MEM_BFC_ADDRr(u,r) cdk_robo_reg_read(u,BCM53101_A0_MEM_BFC_ADDRr,(r._mem_bfc_addr),2)
#define BCM53101_A0_WRITE_MEM_BFC_ADDRr(u,r) cdk_robo_reg_write(u,BCM53101_A0_MEM_BFC_ADDRr,&(r._mem_bfc_addr),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_BFC_ADDRr BCM53101_A0_MEM_BFC_ADDRr
#define MEM_BFC_ADDRr_SIZE BCM53101_A0_MEM_BFC_ADDRr_SIZE
typedef BCM53101_A0_MEM_BFC_ADDRr_t MEM_BFC_ADDRr_t;
#define MEM_BFC_ADDRr_CLR BCM53101_A0_MEM_BFC_ADDRr_CLR
#define MEM_BFC_ADDRr_SET BCM53101_A0_MEM_BFC_ADDRr_SET
#define MEM_BFC_ADDRr_GET BCM53101_A0_MEM_BFC_ADDRr_GET
#define MEM_BFC_ADDRr_BFC_ADDRf_GET BCM53101_A0_MEM_BFC_ADDRr_BFC_ADDRf_GET
#define MEM_BFC_ADDRr_BFC_ADDRf_SET BCM53101_A0_MEM_BFC_ADDRr_BFC_ADDRf_SET
#define MEM_BFC_ADDRr_RW_CTRLf_GET BCM53101_A0_MEM_BFC_ADDRr_RW_CTRLf_GET
#define MEM_BFC_ADDRr_RW_CTRLf_SET BCM53101_A0_MEM_BFC_ADDRr_RW_CTRLf_SET
#define MEM_BFC_ADDRr_MEM_REQf_GET BCM53101_A0_MEM_BFC_ADDRr_MEM_REQf_GET
#define MEM_BFC_ADDRr_MEM_REQf_SET BCM53101_A0_MEM_BFC_ADDRr_MEM_REQf_SET
#define READ_MEM_BFC_ADDRr BCM53101_A0_READ_MEM_BFC_ADDRr
#define WRITE_MEM_BFC_ADDRr BCM53101_A0_WRITE_MEM_BFC_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MEM_BFC_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MEM_BFC_DATA
 * BLOCKS:   SYS
 * DESC:     Buffer Control Memory Data Register
 * SIZE:     64
 * FIELDS:
 *     BFC_DATA         Privides the read from the Buffer Control memmory[63:0].
 *
 ******************************************************************************/
#define BCM53101_A0_MEM_BFC_DATAr 0x00000862

#define BCM53101_A0_MEM_BFC_DATAr_SIZE 8

/*
 * This structure should be used to declare and program MEM_BFC_DATA.
 *
 */
typedef union BCM53101_A0_MEM_BFC_DATAr_s {
	uint32_t v[2];
	uint32_t mem_bfc_data[2];
	uint32_t _mem_bfc_data;
} BCM53101_A0_MEM_BFC_DATAr_t;

#define BCM53101_A0_MEM_BFC_DATAr_CLR(r) CDK_MEMSET(&((r)._mem_bfc_data), 0, sizeof(BCM53101_A0_MEM_BFC_DATAr_t))
#define BCM53101_A0_MEM_BFC_DATAr_SET(r,i,d) (r).mem_bfc_data[i] = d
#define BCM53101_A0_MEM_BFC_DATAr_GET(r,i) (r).mem_bfc_data[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MEM_BFC_DATAr_BFC_DATAf_GET(r,a) cdk_field_get((r).mem_bfc_data,0,63,a)
#define BCM53101_A0_MEM_BFC_DATAr_BFC_DATAf_SET(r,a) cdk_field_set((r).mem_bfc_data,0,63,a)

/*
 * These macros can be used to access MEM_BFC_DATA.
 *
 */
#define BCM53101_A0_READ_MEM_BFC_DATAr(u,r) cdk_robo_reg_read(u,BCM53101_A0_MEM_BFC_DATAr,(r._mem_bfc_data),8)
#define BCM53101_A0_WRITE_MEM_BFC_DATAr(u,r) cdk_robo_reg_write(u,BCM53101_A0_MEM_BFC_DATAr,&(r._mem_bfc_data),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_BFC_DATAr BCM53101_A0_MEM_BFC_DATAr
#define MEM_BFC_DATAr_SIZE BCM53101_A0_MEM_BFC_DATAr_SIZE
typedef BCM53101_A0_MEM_BFC_DATAr_t MEM_BFC_DATAr_t;
#define MEM_BFC_DATAr_CLR BCM53101_A0_MEM_BFC_DATAr_CLR
#define MEM_BFC_DATAr_SET BCM53101_A0_MEM_BFC_DATAr_SET
#define MEM_BFC_DATAr_GET BCM53101_A0_MEM_BFC_DATAr_GET
#define MEM_BFC_DATAr_BFC_DATAf_GET BCM53101_A0_MEM_BFC_DATAr_BFC_DATAf_GET
#define MEM_BFC_DATAr_BFC_DATAf_SET BCM53101_A0_MEM_BFC_DATAr_BFC_DATAf_SET
#define READ_MEM_BFC_DATAr BCM53101_A0_READ_MEM_BFC_DATAr
#define WRITE_MEM_BFC_DATAr BCM53101_A0_WRITE_MEM_BFC_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MEM_BFC_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MEM_BTM_DATA0
 * BLOCKS:   SYS
 * DESC:     Buffer Tag Memory Register 0
 * SIZE:     64
 * FIELDS:
 *     MEM_DATA         Specifies the data to read data from buffer Tag memory[63:0]Note: Buffer Tag Memory Register Only For Read.
 *
 ******************************************************************************/
#define BCM53101_A0_MEM_BTM_DATA0r 0x00000850

#define BCM53101_A0_MEM_BTM_DATA0r_SIZE 8

/*
 * This structure should be used to declare and program MEM_BTM_DATA0.
 *
 */
typedef union BCM53101_A0_MEM_BTM_DATA0r_s {
	uint32_t v[2];
	uint32_t mem_btm_data0[2];
	uint32_t _mem_btm_data0;
} BCM53101_A0_MEM_BTM_DATA0r_t;

#define BCM53101_A0_MEM_BTM_DATA0r_CLR(r) CDK_MEMSET(&((r)._mem_btm_data0), 0, sizeof(BCM53101_A0_MEM_BTM_DATA0r_t))
#define BCM53101_A0_MEM_BTM_DATA0r_SET(r,i,d) (r).mem_btm_data0[i] = d
#define BCM53101_A0_MEM_BTM_DATA0r_GET(r,i) (r).mem_btm_data0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MEM_BTM_DATA0r_MEM_DATAf_GET(r,a) cdk_field_get((r).mem_btm_data0,0,63,a)
#define BCM53101_A0_MEM_BTM_DATA0r_MEM_DATAf_SET(r,a) cdk_field_set((r).mem_btm_data0,0,63,a)

/*
 * These macros can be used to access MEM_BTM_DATA0.
 *
 */
#define BCM53101_A0_READ_MEM_BTM_DATA0r(u,r) cdk_robo_reg_read(u,BCM53101_A0_MEM_BTM_DATA0r,(r._mem_btm_data0),8)
#define BCM53101_A0_WRITE_MEM_BTM_DATA0r(u,r) cdk_robo_reg_write(u,BCM53101_A0_MEM_BTM_DATA0r,&(r._mem_btm_data0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_BTM_DATA0r BCM53101_A0_MEM_BTM_DATA0r
#define MEM_BTM_DATA0r_SIZE BCM53101_A0_MEM_BTM_DATA0r_SIZE
typedef BCM53101_A0_MEM_BTM_DATA0r_t MEM_BTM_DATA0r_t;
#define MEM_BTM_DATA0r_CLR BCM53101_A0_MEM_BTM_DATA0r_CLR
#define MEM_BTM_DATA0r_SET BCM53101_A0_MEM_BTM_DATA0r_SET
#define MEM_BTM_DATA0r_GET BCM53101_A0_MEM_BTM_DATA0r_GET
#define MEM_BTM_DATA0r_MEM_DATAf_GET BCM53101_A0_MEM_BTM_DATA0r_MEM_DATAf_GET
#define MEM_BTM_DATA0r_MEM_DATAf_SET BCM53101_A0_MEM_BTM_DATA0r_MEM_DATAf_SET
#define READ_MEM_BTM_DATA0r BCM53101_A0_READ_MEM_BTM_DATA0r
#define WRITE_MEM_BTM_DATA0r BCM53101_A0_WRITE_MEM_BTM_DATA0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MEM_BTM_DATA0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MEM_BTM_DATA1
 * BLOCKS:   SYS
 * DESC:     Buffer Tag Memory Register 1
 * SIZE:     16
 * FIELDS:
 *     MEM_DATA         Specifies the data to read data from buffer Tag memory[72:64]Note: Buffer Tag Memory Register Only For Read.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_MEM_BTM_DATA1r 0x00000858

#define BCM53101_A0_MEM_BTM_DATA1r_SIZE 2

/*
 * This structure should be used to declare and program MEM_BTM_DATA1.
 *
 */
typedef union BCM53101_A0_MEM_BTM_DATA1r_s {
	uint32_t v[1];
	uint32_t mem_btm_data1[1];
	uint32_t _mem_btm_data1;
} BCM53101_A0_MEM_BTM_DATA1r_t;

#define BCM53101_A0_MEM_BTM_DATA1r_CLR(r) (r).mem_btm_data1[0] = 0
#define BCM53101_A0_MEM_BTM_DATA1r_SET(r,d) (r).mem_btm_data1[0] = d
#define BCM53101_A0_MEM_BTM_DATA1r_GET(r) (r).mem_btm_data1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MEM_BTM_DATA1r_MEM_DATAf_GET(r) (((r).mem_btm_data1[0]) & 0x1ff)
#define BCM53101_A0_MEM_BTM_DATA1r_MEM_DATAf_SET(r,f) (r).mem_btm_data1[0]=(((r).mem_btm_data1[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_MEM_BTM_DATA1r_RESERVEDf_GET(r) ((((r).mem_btm_data1[0]) >> 9) & 0x7f)
#define BCM53101_A0_MEM_BTM_DATA1r_RESERVEDf_SET(r,f) (r).mem_btm_data1[0]=(((r).mem_btm_data1[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access MEM_BTM_DATA1.
 *
 */
#define BCM53101_A0_READ_MEM_BTM_DATA1r(u,r) cdk_robo_reg_read(u,BCM53101_A0_MEM_BTM_DATA1r,(r._mem_btm_data1),2)
#define BCM53101_A0_WRITE_MEM_BTM_DATA1r(u,r) cdk_robo_reg_write(u,BCM53101_A0_MEM_BTM_DATA1r,&(r._mem_btm_data1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_BTM_DATA1r BCM53101_A0_MEM_BTM_DATA1r
#define MEM_BTM_DATA1r_SIZE BCM53101_A0_MEM_BTM_DATA1r_SIZE
typedef BCM53101_A0_MEM_BTM_DATA1r_t MEM_BTM_DATA1r_t;
#define MEM_BTM_DATA1r_CLR BCM53101_A0_MEM_BTM_DATA1r_CLR
#define MEM_BTM_DATA1r_SET BCM53101_A0_MEM_BTM_DATA1r_SET
#define MEM_BTM_DATA1r_GET BCM53101_A0_MEM_BTM_DATA1r_GET
#define MEM_BTM_DATA1r_MEM_DATAf_GET BCM53101_A0_MEM_BTM_DATA1r_MEM_DATAf_GET
#define MEM_BTM_DATA1r_MEM_DATAf_SET BCM53101_A0_MEM_BTM_DATA1r_MEM_DATAf_SET
#define MEM_BTM_DATA1r_RESERVEDf_GET BCM53101_A0_MEM_BTM_DATA1r_RESERVEDf_GET
#define MEM_BTM_DATA1r_RESERVEDf_SET BCM53101_A0_MEM_BTM_DATA1r_RESERVEDf_SET
#define READ_MEM_BTM_DATA1r BCM53101_A0_READ_MEM_BTM_DATA1r
#define WRITE_MEM_BTM_DATA1r BCM53101_A0_WRITE_MEM_BTM_DATA1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MEM_BTM_DATA1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MEM_CTRL
 * BLOCKS:   SYS
 * DESC:     Memory Debug Control Register
 * SIZE:     8
 * FIELDS:
 *     RESERVED_0       Reserved
 *     RESERVED_1       Reserved
 *     MEM_TYPE         Indicate the memory for the Debugged memory.10 : 1Q-VLAN Memory,11 : ARL Memory.
 *
 ******************************************************************************/
#define BCM53101_A0_MEM_CTRLr 0x00000800

#define BCM53101_A0_MEM_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program MEM_CTRL.
 *
 */
typedef union BCM53101_A0_MEM_CTRLr_s {
	uint32_t v[1];
	uint32_t mem_ctrl[1];
	uint32_t _mem_ctrl;
} BCM53101_A0_MEM_CTRLr_t;

#define BCM53101_A0_MEM_CTRLr_CLR(r) (r).mem_ctrl[0] = 0
#define BCM53101_A0_MEM_CTRLr_SET(r,d) (r).mem_ctrl[0] = d
#define BCM53101_A0_MEM_CTRLr_GET(r) (r).mem_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MEM_CTRLr_RESERVED_0f_GET(r) (((r).mem_ctrl[0]) & 0xf)
#define BCM53101_A0_MEM_CTRLr_RESERVED_0f_SET(r,f) (r).mem_ctrl[0]=(((r).mem_ctrl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53101_A0_MEM_CTRLr_RESERVED_1f_GET(r) ((((r).mem_ctrl[0]) >> 4) & 0x3)
#define BCM53101_A0_MEM_CTRLr_RESERVED_1f_SET(r,f) (r).mem_ctrl[0]=(((r).mem_ctrl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53101_A0_MEM_CTRLr_MEM_TYPEf_GET(r) ((((r).mem_ctrl[0]) >> 6) & 0x3)
#define BCM53101_A0_MEM_CTRLr_MEM_TYPEf_SET(r,f) (r).mem_ctrl[0]=(((r).mem_ctrl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access MEM_CTRL.
 *
 */
#define BCM53101_A0_READ_MEM_CTRLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_MEM_CTRLr,(r._mem_ctrl),1)
#define BCM53101_A0_WRITE_MEM_CTRLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_MEM_CTRLr,&(r._mem_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_CTRLr BCM53101_A0_MEM_CTRLr
#define MEM_CTRLr_SIZE BCM53101_A0_MEM_CTRLr_SIZE
typedef BCM53101_A0_MEM_CTRLr_t MEM_CTRLr_t;
#define MEM_CTRLr_CLR BCM53101_A0_MEM_CTRLr_CLR
#define MEM_CTRLr_SET BCM53101_A0_MEM_CTRLr_SET
#define MEM_CTRLr_GET BCM53101_A0_MEM_CTRLr_GET
#define MEM_CTRLr_RESERVED_0f_GET BCM53101_A0_MEM_CTRLr_RESERVED_0f_GET
#define MEM_CTRLr_RESERVED_0f_SET BCM53101_A0_MEM_CTRLr_RESERVED_0f_SET
#define MEM_CTRLr_RESERVED_1f_GET BCM53101_A0_MEM_CTRLr_RESERVED_1f_GET
#define MEM_CTRLr_RESERVED_1f_SET BCM53101_A0_MEM_CTRLr_RESERVED_1f_SET
#define MEM_CTRLr_MEM_TYPEf_GET BCM53101_A0_MEM_CTRLr_MEM_TYPEf_GET
#define MEM_CTRLr_MEM_TYPEf_SET BCM53101_A0_MEM_CTRLr_MEM_TYPEf_SET
#define READ_MEM_CTRLr BCM53101_A0_READ_MEM_CTRLr
#define WRITE_MEM_CTRLr BCM53101_A0_WRITE_MEM_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MEM_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MEM_DEBUG_DATA_0_0
 * BLOCKS:   SYS
 * DESC:     Memory Debug Data 0_0 Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DAT          Specifies the data to write or provides the read data from the debugged memory [63:0].For ARL, this field specifies the entry 0 bit[63:0].For VLAN, this field specifies the VLAN entry [11:0].Valid bits of the registers depends on the type of memory.
 *
 ******************************************************************************/
#define BCM53101_A0_MEM_DEBUG_DATA_0_0r 0x00000808

#define BCM53101_A0_MEM_DEBUG_DATA_0_0r_SIZE 8

/*
 * This structure should be used to declare and program MEM_DEBUG_DATA_0_0.
 *
 */
typedef union BCM53101_A0_MEM_DEBUG_DATA_0_0r_s {
	uint32_t v[2];
	uint32_t mem_debug_data_0_0[2];
	uint32_t _mem_debug_data_0_0;
} BCM53101_A0_MEM_DEBUG_DATA_0_0r_t;

#define BCM53101_A0_MEM_DEBUG_DATA_0_0r_CLR(r) CDK_MEMSET(&((r)._mem_debug_data_0_0), 0, sizeof(BCM53101_A0_MEM_DEBUG_DATA_0_0r_t))
#define BCM53101_A0_MEM_DEBUG_DATA_0_0r_SET(r,i,d) (r).mem_debug_data_0_0[i] = d
#define BCM53101_A0_MEM_DEBUG_DATA_0_0r_GET(r,i) (r).mem_debug_data_0_0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MEM_DEBUG_DATA_0_0r_MEM_DATf_GET(r,a) cdk_field_get((r).mem_debug_data_0_0,0,63,a)
#define BCM53101_A0_MEM_DEBUG_DATA_0_0r_MEM_DATf_SET(r,a) cdk_field_set((r).mem_debug_data_0_0,0,63,a)

/*
 * These macros can be used to access MEM_DEBUG_DATA_0_0.
 *
 */
#define BCM53101_A0_READ_MEM_DEBUG_DATA_0_0r(u,r) cdk_robo_reg_read(u,BCM53101_A0_MEM_DEBUG_DATA_0_0r,(r._mem_debug_data_0_0),8)
#define BCM53101_A0_WRITE_MEM_DEBUG_DATA_0_0r(u,r) cdk_robo_reg_write(u,BCM53101_A0_MEM_DEBUG_DATA_0_0r,&(r._mem_debug_data_0_0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_DEBUG_DATA_0_0r BCM53101_A0_MEM_DEBUG_DATA_0_0r
#define MEM_DEBUG_DATA_0_0r_SIZE BCM53101_A0_MEM_DEBUG_DATA_0_0r_SIZE
typedef BCM53101_A0_MEM_DEBUG_DATA_0_0r_t MEM_DEBUG_DATA_0_0r_t;
#define MEM_DEBUG_DATA_0_0r_CLR BCM53101_A0_MEM_DEBUG_DATA_0_0r_CLR
#define MEM_DEBUG_DATA_0_0r_SET BCM53101_A0_MEM_DEBUG_DATA_0_0r_SET
#define MEM_DEBUG_DATA_0_0r_GET BCM53101_A0_MEM_DEBUG_DATA_0_0r_GET
#define MEM_DEBUG_DATA_0_0r_MEM_DATf_GET BCM53101_A0_MEM_DEBUG_DATA_0_0r_MEM_DATf_GET
#define MEM_DEBUG_DATA_0_0r_MEM_DATf_SET BCM53101_A0_MEM_DEBUG_DATA_0_0r_MEM_DATf_SET
#define READ_MEM_DEBUG_DATA_0_0r BCM53101_A0_READ_MEM_DEBUG_DATA_0_0r
#define WRITE_MEM_DEBUG_DATA_0_0r BCM53101_A0_WRITE_MEM_DEBUG_DATA_0_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MEM_DEBUG_DATA_0_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MEM_DEBUG_DATA_0_1
 * BLOCKS:   SYS
 * DESC:     Memory Debug Data 0_1 Register
 * SIZE:     16
 * FIELDS:
 *     MEM_DAT          Specifies the data to write or provides the read data from the debugged memory[75:64].For ARL, this field specifies the entry 0 bit[65:64].Valid bits of the registers depends on the type of memory.
 *
 ******************************************************************************/
#define BCM53101_A0_MEM_DEBUG_DATA_0_1r 0x00000810

#define BCM53101_A0_MEM_DEBUG_DATA_0_1r_SIZE 2

/*
 * This structure should be used to declare and program MEM_DEBUG_DATA_0_1.
 *
 */
typedef union BCM53101_A0_MEM_DEBUG_DATA_0_1r_s {
	uint32_t v[1];
	uint32_t mem_debug_data_0_1[1];
	uint32_t _mem_debug_data_0_1;
} BCM53101_A0_MEM_DEBUG_DATA_0_1r_t;

#define BCM53101_A0_MEM_DEBUG_DATA_0_1r_CLR(r) (r).mem_debug_data_0_1[0] = 0
#define BCM53101_A0_MEM_DEBUG_DATA_0_1r_SET(r,d) (r).mem_debug_data_0_1[0] = d
#define BCM53101_A0_MEM_DEBUG_DATA_0_1r_GET(r) (r).mem_debug_data_0_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MEM_DEBUG_DATA_0_1r_MEM_DATf_GET(r) (((r).mem_debug_data_0_1[0]) & 0xffff)
#define BCM53101_A0_MEM_DEBUG_DATA_0_1r_MEM_DATf_SET(r,f) (r).mem_debug_data_0_1[0]=(((r).mem_debug_data_0_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MEM_DEBUG_DATA_0_1.
 *
 */
#define BCM53101_A0_READ_MEM_DEBUG_DATA_0_1r(u,r) cdk_robo_reg_read(u,BCM53101_A0_MEM_DEBUG_DATA_0_1r,(r._mem_debug_data_0_1),2)
#define BCM53101_A0_WRITE_MEM_DEBUG_DATA_0_1r(u,r) cdk_robo_reg_write(u,BCM53101_A0_MEM_DEBUG_DATA_0_1r,&(r._mem_debug_data_0_1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_DEBUG_DATA_0_1r BCM53101_A0_MEM_DEBUG_DATA_0_1r
#define MEM_DEBUG_DATA_0_1r_SIZE BCM53101_A0_MEM_DEBUG_DATA_0_1r_SIZE
typedef BCM53101_A0_MEM_DEBUG_DATA_0_1r_t MEM_DEBUG_DATA_0_1r_t;
#define MEM_DEBUG_DATA_0_1r_CLR BCM53101_A0_MEM_DEBUG_DATA_0_1r_CLR
#define MEM_DEBUG_DATA_0_1r_SET BCM53101_A0_MEM_DEBUG_DATA_0_1r_SET
#define MEM_DEBUG_DATA_0_1r_GET BCM53101_A0_MEM_DEBUG_DATA_0_1r_GET
#define MEM_DEBUG_DATA_0_1r_MEM_DATf_GET BCM53101_A0_MEM_DEBUG_DATA_0_1r_MEM_DATf_GET
#define MEM_DEBUG_DATA_0_1r_MEM_DATf_SET BCM53101_A0_MEM_DEBUG_DATA_0_1r_MEM_DATf_SET
#define READ_MEM_DEBUG_DATA_0_1r BCM53101_A0_READ_MEM_DEBUG_DATA_0_1r
#define WRITE_MEM_DEBUG_DATA_0_1r BCM53101_A0_WRITE_MEM_DEBUG_DATA_0_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MEM_DEBUG_DATA_0_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MEM_DEBUG_DATA_1_0
 * BLOCKS:   SYS
 * DESC:     Memory Debug Data 1_0 Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DAT          Specifies the data to write or provides the read data from the debugged memory [63:0].For ARL, this field specifies the entry 1 bit[63:0].Valid bits of the registers depends on the type of memory.
 *
 ******************************************************************************/
#define BCM53101_A0_MEM_DEBUG_DATA_1_0r 0x00000812

#define BCM53101_A0_MEM_DEBUG_DATA_1_0r_SIZE 8

/*
 * This structure should be used to declare and program MEM_DEBUG_DATA_1_0.
 *
 */
typedef union BCM53101_A0_MEM_DEBUG_DATA_1_0r_s {
	uint32_t v[2];
	uint32_t mem_debug_data_1_0[2];
	uint32_t _mem_debug_data_1_0;
} BCM53101_A0_MEM_DEBUG_DATA_1_0r_t;

#define BCM53101_A0_MEM_DEBUG_DATA_1_0r_CLR(r) CDK_MEMSET(&((r)._mem_debug_data_1_0), 0, sizeof(BCM53101_A0_MEM_DEBUG_DATA_1_0r_t))
#define BCM53101_A0_MEM_DEBUG_DATA_1_0r_SET(r,i,d) (r).mem_debug_data_1_0[i] = d
#define BCM53101_A0_MEM_DEBUG_DATA_1_0r_GET(r,i) (r).mem_debug_data_1_0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MEM_DEBUG_DATA_1_0r_MEM_DATf_GET(r,a) cdk_field_get((r).mem_debug_data_1_0,0,63,a)
#define BCM53101_A0_MEM_DEBUG_DATA_1_0r_MEM_DATf_SET(r,a) cdk_field_set((r).mem_debug_data_1_0,0,63,a)

/*
 * These macros can be used to access MEM_DEBUG_DATA_1_0.
 *
 */
#define BCM53101_A0_READ_MEM_DEBUG_DATA_1_0r(u,r) cdk_robo_reg_read(u,BCM53101_A0_MEM_DEBUG_DATA_1_0r,(r._mem_debug_data_1_0),8)
#define BCM53101_A0_WRITE_MEM_DEBUG_DATA_1_0r(u,r) cdk_robo_reg_write(u,BCM53101_A0_MEM_DEBUG_DATA_1_0r,&(r._mem_debug_data_1_0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_DEBUG_DATA_1_0r BCM53101_A0_MEM_DEBUG_DATA_1_0r
#define MEM_DEBUG_DATA_1_0r_SIZE BCM53101_A0_MEM_DEBUG_DATA_1_0r_SIZE
typedef BCM53101_A0_MEM_DEBUG_DATA_1_0r_t MEM_DEBUG_DATA_1_0r_t;
#define MEM_DEBUG_DATA_1_0r_CLR BCM53101_A0_MEM_DEBUG_DATA_1_0r_CLR
#define MEM_DEBUG_DATA_1_0r_SET BCM53101_A0_MEM_DEBUG_DATA_1_0r_SET
#define MEM_DEBUG_DATA_1_0r_GET BCM53101_A0_MEM_DEBUG_DATA_1_0r_GET
#define MEM_DEBUG_DATA_1_0r_MEM_DATf_GET BCM53101_A0_MEM_DEBUG_DATA_1_0r_MEM_DATf_GET
#define MEM_DEBUG_DATA_1_0r_MEM_DATf_SET BCM53101_A0_MEM_DEBUG_DATA_1_0r_MEM_DATf_SET
#define READ_MEM_DEBUG_DATA_1_0r BCM53101_A0_READ_MEM_DEBUG_DATA_1_0r
#define WRITE_MEM_DEBUG_DATA_1_0r BCM53101_A0_WRITE_MEM_DEBUG_DATA_1_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MEM_DEBUG_DATA_1_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MEM_DEBUG_DATA_1_1
 * BLOCKS:   SYS
 * DESC:     Memory Debug Data 1_1 Register
 * SIZE:     16
 * FIELDS:
 *     MEM_DAT          Specifies the data to write or provides the read data from the debugged memory[75:64].For ARL, this field specifies the entry 1 bit[65:64].Valid bits of the registers depends on the type of memory.
 *
 ******************************************************************************/
#define BCM53101_A0_MEM_DEBUG_DATA_1_1r 0x0000081a

#define BCM53101_A0_MEM_DEBUG_DATA_1_1r_SIZE 2

/*
 * This structure should be used to declare and program MEM_DEBUG_DATA_1_1.
 *
 */
typedef union BCM53101_A0_MEM_DEBUG_DATA_1_1r_s {
	uint32_t v[1];
	uint32_t mem_debug_data_1_1[1];
	uint32_t _mem_debug_data_1_1;
} BCM53101_A0_MEM_DEBUG_DATA_1_1r_t;

#define BCM53101_A0_MEM_DEBUG_DATA_1_1r_CLR(r) (r).mem_debug_data_1_1[0] = 0
#define BCM53101_A0_MEM_DEBUG_DATA_1_1r_SET(r,d) (r).mem_debug_data_1_1[0] = d
#define BCM53101_A0_MEM_DEBUG_DATA_1_1r_GET(r) (r).mem_debug_data_1_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MEM_DEBUG_DATA_1_1r_MEM_DATf_GET(r) (((r).mem_debug_data_1_1[0]) & 0xffff)
#define BCM53101_A0_MEM_DEBUG_DATA_1_1r_MEM_DATf_SET(r,f) (r).mem_debug_data_1_1[0]=(((r).mem_debug_data_1_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access MEM_DEBUG_DATA_1_1.
 *
 */
#define BCM53101_A0_READ_MEM_DEBUG_DATA_1_1r(u,r) cdk_robo_reg_read(u,BCM53101_A0_MEM_DEBUG_DATA_1_1r,(r._mem_debug_data_1_1),2)
#define BCM53101_A0_WRITE_MEM_DEBUG_DATA_1_1r(u,r) cdk_robo_reg_write(u,BCM53101_A0_MEM_DEBUG_DATA_1_1r,&(r._mem_debug_data_1_1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_DEBUG_DATA_1_1r BCM53101_A0_MEM_DEBUG_DATA_1_1r
#define MEM_DEBUG_DATA_1_1r_SIZE BCM53101_A0_MEM_DEBUG_DATA_1_1r_SIZE
typedef BCM53101_A0_MEM_DEBUG_DATA_1_1r_t MEM_DEBUG_DATA_1_1r_t;
#define MEM_DEBUG_DATA_1_1r_CLR BCM53101_A0_MEM_DEBUG_DATA_1_1r_CLR
#define MEM_DEBUG_DATA_1_1r_SET BCM53101_A0_MEM_DEBUG_DATA_1_1r_SET
#define MEM_DEBUG_DATA_1_1r_GET BCM53101_A0_MEM_DEBUG_DATA_1_1r_GET
#define MEM_DEBUG_DATA_1_1r_MEM_DATf_GET BCM53101_A0_MEM_DEBUG_DATA_1_1r_MEM_DATf_GET
#define MEM_DEBUG_DATA_1_1r_MEM_DATf_SET BCM53101_A0_MEM_DEBUG_DATA_1_1r_MEM_DATf_SET
#define READ_MEM_DEBUG_DATA_1_1r BCM53101_A0_READ_MEM_DEBUG_DATA_1_1r
#define WRITE_MEM_DEBUG_DATA_1_1r BCM53101_A0_WRITE_MEM_DEBUG_DATA_1_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MEM_DEBUG_DATA_1_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MEM_FRM_ADDR
 * BLOCKS:   SYS
 * DESC:     Frame Memory Address Register
 * SIZE:     16
 * FIELDS:
 *     MEM_ADR          Specifies the next memory address to read or write.
 *     RESERVED         Reserved
 *     MEM_RW           '1' causes a read operation while '0' is for a write operation.
 *     MEM_STDN         Initiates the read/write operation for the FM memory.The bit will be clear once the Read/Write Operation is completed.
 *
 ******************************************************************************/
#define BCM53101_A0_MEM_FRM_ADDRr 0x00000820

#define BCM53101_A0_MEM_FRM_ADDRr_SIZE 2

/*
 * This structure should be used to declare and program MEM_FRM_ADDR.
 *
 */
typedef union BCM53101_A0_MEM_FRM_ADDRr_s {
	uint32_t v[1];
	uint32_t mem_frm_addr[1];
	uint32_t _mem_frm_addr;
} BCM53101_A0_MEM_FRM_ADDRr_t;

#define BCM53101_A0_MEM_FRM_ADDRr_CLR(r) (r).mem_frm_addr[0] = 0
#define BCM53101_A0_MEM_FRM_ADDRr_SET(r,d) (r).mem_frm_addr[0] = d
#define BCM53101_A0_MEM_FRM_ADDRr_GET(r) (r).mem_frm_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MEM_FRM_ADDRr_MEM_ADRf_GET(r) (((r).mem_frm_addr[0]) & 0xfff)
#define BCM53101_A0_MEM_FRM_ADDRr_MEM_ADRf_SET(r,f) (r).mem_frm_addr[0]=(((r).mem_frm_addr[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53101_A0_MEM_FRM_ADDRr_RESERVEDf_GET(r) ((((r).mem_frm_addr[0]) >> 12) & 0x3)
#define BCM53101_A0_MEM_FRM_ADDRr_RESERVEDf_SET(r,f) (r).mem_frm_addr[0]=(((r).mem_frm_addr[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM53101_A0_MEM_FRM_ADDRr_MEM_RWf_GET(r) ((((r).mem_frm_addr[0]) >> 14) & 0x1)
#define BCM53101_A0_MEM_FRM_ADDRr_MEM_RWf_SET(r,f) (r).mem_frm_addr[0]=(((r).mem_frm_addr[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_MEM_FRM_ADDRr_MEM_STDNf_GET(r) ((((r).mem_frm_addr[0]) >> 15) & 0x1)
#define BCM53101_A0_MEM_FRM_ADDRr_MEM_STDNf_SET(r,f) (r).mem_frm_addr[0]=(((r).mem_frm_addr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MEM_FRM_ADDR.
 *
 */
#define BCM53101_A0_READ_MEM_FRM_ADDRr(u,r) cdk_robo_reg_read(u,BCM53101_A0_MEM_FRM_ADDRr,(r._mem_frm_addr),2)
#define BCM53101_A0_WRITE_MEM_FRM_ADDRr(u,r) cdk_robo_reg_write(u,BCM53101_A0_MEM_FRM_ADDRr,&(r._mem_frm_addr),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_FRM_ADDRr BCM53101_A0_MEM_FRM_ADDRr
#define MEM_FRM_ADDRr_SIZE BCM53101_A0_MEM_FRM_ADDRr_SIZE
typedef BCM53101_A0_MEM_FRM_ADDRr_t MEM_FRM_ADDRr_t;
#define MEM_FRM_ADDRr_CLR BCM53101_A0_MEM_FRM_ADDRr_CLR
#define MEM_FRM_ADDRr_SET BCM53101_A0_MEM_FRM_ADDRr_SET
#define MEM_FRM_ADDRr_GET BCM53101_A0_MEM_FRM_ADDRr_GET
#define MEM_FRM_ADDRr_MEM_ADRf_GET BCM53101_A0_MEM_FRM_ADDRr_MEM_ADRf_GET
#define MEM_FRM_ADDRr_MEM_ADRf_SET BCM53101_A0_MEM_FRM_ADDRr_MEM_ADRf_SET
#define MEM_FRM_ADDRr_RESERVEDf_GET BCM53101_A0_MEM_FRM_ADDRr_RESERVEDf_GET
#define MEM_FRM_ADDRr_RESERVEDf_SET BCM53101_A0_MEM_FRM_ADDRr_RESERVEDf_SET
#define MEM_FRM_ADDRr_MEM_RWf_GET BCM53101_A0_MEM_FRM_ADDRr_MEM_RWf_GET
#define MEM_FRM_ADDRr_MEM_RWf_SET BCM53101_A0_MEM_FRM_ADDRr_MEM_RWf_SET
#define MEM_FRM_ADDRr_MEM_STDNf_GET BCM53101_A0_MEM_FRM_ADDRr_MEM_STDNf_GET
#define MEM_FRM_ADDRr_MEM_STDNf_SET BCM53101_A0_MEM_FRM_ADDRr_MEM_STDNf_SET
#define READ_MEM_FRM_ADDRr BCM53101_A0_READ_MEM_FRM_ADDRr
#define WRITE_MEM_FRM_ADDRr BCM53101_A0_WRITE_MEM_FRM_ADDRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MEM_FRM_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MEM_FRM_DATA0
 * BLOCKS:   SYS
 * DESC:     Frame Memory Data 1st Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DATA         Specifies the data to write or provides the read data from the Frame memory[63:0].
 *
 ******************************************************************************/
#define BCM53101_A0_MEM_FRM_DATA0r 0x00000830

#define BCM53101_A0_MEM_FRM_DATA0r_SIZE 8

/*
 * This structure should be used to declare and program MEM_FRM_DATA0.
 *
 */
typedef union BCM53101_A0_MEM_FRM_DATA0r_s {
	uint32_t v[2];
	uint32_t mem_frm_data0[2];
	uint32_t _mem_frm_data0;
} BCM53101_A0_MEM_FRM_DATA0r_t;

#define BCM53101_A0_MEM_FRM_DATA0r_CLR(r) CDK_MEMSET(&((r)._mem_frm_data0), 0, sizeof(BCM53101_A0_MEM_FRM_DATA0r_t))
#define BCM53101_A0_MEM_FRM_DATA0r_SET(r,i,d) (r).mem_frm_data0[i] = d
#define BCM53101_A0_MEM_FRM_DATA0r_GET(r,i) (r).mem_frm_data0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MEM_FRM_DATA0r_MEM_DATAf_GET(r,a) cdk_field_get((r).mem_frm_data0,0,63,a)
#define BCM53101_A0_MEM_FRM_DATA0r_MEM_DATAf_SET(r,a) cdk_field_set((r).mem_frm_data0,0,63,a)

/*
 * These macros can be used to access MEM_FRM_DATA0.
 *
 */
#define BCM53101_A0_READ_MEM_FRM_DATA0r(u,r) cdk_robo_reg_read(u,BCM53101_A0_MEM_FRM_DATA0r,(r._mem_frm_data0),8)
#define BCM53101_A0_WRITE_MEM_FRM_DATA0r(u,r) cdk_robo_reg_write(u,BCM53101_A0_MEM_FRM_DATA0r,&(r._mem_frm_data0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_FRM_DATA0r BCM53101_A0_MEM_FRM_DATA0r
#define MEM_FRM_DATA0r_SIZE BCM53101_A0_MEM_FRM_DATA0r_SIZE
typedef BCM53101_A0_MEM_FRM_DATA0r_t MEM_FRM_DATA0r_t;
#define MEM_FRM_DATA0r_CLR BCM53101_A0_MEM_FRM_DATA0r_CLR
#define MEM_FRM_DATA0r_SET BCM53101_A0_MEM_FRM_DATA0r_SET
#define MEM_FRM_DATA0r_GET BCM53101_A0_MEM_FRM_DATA0r_GET
#define MEM_FRM_DATA0r_MEM_DATAf_GET BCM53101_A0_MEM_FRM_DATA0r_MEM_DATAf_GET
#define MEM_FRM_DATA0r_MEM_DATAf_SET BCM53101_A0_MEM_FRM_DATA0r_MEM_DATAf_SET
#define READ_MEM_FRM_DATA0r BCM53101_A0_READ_MEM_FRM_DATA0r
#define WRITE_MEM_FRM_DATA0r BCM53101_A0_WRITE_MEM_FRM_DATA0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MEM_FRM_DATA0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MEM_FRM_DATA1
 * BLOCKS:   SYS
 * DESC:     Frame Memory Data 2st Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DATA         Specifies the data to write or provides the read data from the Frame memory[127:64].
 *
 ******************************************************************************/
#define BCM53101_A0_MEM_FRM_DATA1r 0x00000838

#define BCM53101_A0_MEM_FRM_DATA1r_SIZE 8

/*
 * This structure should be used to declare and program MEM_FRM_DATA1.
 *
 */
typedef union BCM53101_A0_MEM_FRM_DATA1r_s {
	uint32_t v[2];
	uint32_t mem_frm_data1[2];
	uint32_t _mem_frm_data1;
} BCM53101_A0_MEM_FRM_DATA1r_t;

#define BCM53101_A0_MEM_FRM_DATA1r_CLR(r) CDK_MEMSET(&((r)._mem_frm_data1), 0, sizeof(BCM53101_A0_MEM_FRM_DATA1r_t))
#define BCM53101_A0_MEM_FRM_DATA1r_SET(r,i,d) (r).mem_frm_data1[i] = d
#define BCM53101_A0_MEM_FRM_DATA1r_GET(r,i) (r).mem_frm_data1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MEM_FRM_DATA1r_MEM_DATAf_GET(r,a) cdk_field_get((r).mem_frm_data1,0,63,a)
#define BCM53101_A0_MEM_FRM_DATA1r_MEM_DATAf_SET(r,a) cdk_field_set((r).mem_frm_data1,0,63,a)

/*
 * These macros can be used to access MEM_FRM_DATA1.
 *
 */
#define BCM53101_A0_READ_MEM_FRM_DATA1r(u,r) cdk_robo_reg_read(u,BCM53101_A0_MEM_FRM_DATA1r,(r._mem_frm_data1),8)
#define BCM53101_A0_WRITE_MEM_FRM_DATA1r(u,r) cdk_robo_reg_write(u,BCM53101_A0_MEM_FRM_DATA1r,&(r._mem_frm_data1),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_FRM_DATA1r BCM53101_A0_MEM_FRM_DATA1r
#define MEM_FRM_DATA1r_SIZE BCM53101_A0_MEM_FRM_DATA1r_SIZE
typedef BCM53101_A0_MEM_FRM_DATA1r_t MEM_FRM_DATA1r_t;
#define MEM_FRM_DATA1r_CLR BCM53101_A0_MEM_FRM_DATA1r_CLR
#define MEM_FRM_DATA1r_SET BCM53101_A0_MEM_FRM_DATA1r_SET
#define MEM_FRM_DATA1r_GET BCM53101_A0_MEM_FRM_DATA1r_GET
#define MEM_FRM_DATA1r_MEM_DATAf_GET BCM53101_A0_MEM_FRM_DATA1r_MEM_DATAf_GET
#define MEM_FRM_DATA1r_MEM_DATAf_SET BCM53101_A0_MEM_FRM_DATA1r_MEM_DATAf_SET
#define READ_MEM_FRM_DATA1r BCM53101_A0_READ_MEM_FRM_DATA1r
#define WRITE_MEM_FRM_DATA1r BCM53101_A0_WRITE_MEM_FRM_DATA1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MEM_FRM_DATA1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MEM_FRM_DATA2
 * BLOCKS:   SYS
 * DESC:     Frame Memory Data 3st Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DATA         Specifies the data to write or provides the read data from the Frame memory[191:128].
 *
 ******************************************************************************/
#define BCM53101_A0_MEM_FRM_DATA2r 0x00000840

#define BCM53101_A0_MEM_FRM_DATA2r_SIZE 8

/*
 * This structure should be used to declare and program MEM_FRM_DATA2.
 *
 */
typedef union BCM53101_A0_MEM_FRM_DATA2r_s {
	uint32_t v[2];
	uint32_t mem_frm_data2[2];
	uint32_t _mem_frm_data2;
} BCM53101_A0_MEM_FRM_DATA2r_t;

#define BCM53101_A0_MEM_FRM_DATA2r_CLR(r) CDK_MEMSET(&((r)._mem_frm_data2), 0, sizeof(BCM53101_A0_MEM_FRM_DATA2r_t))
#define BCM53101_A0_MEM_FRM_DATA2r_SET(r,i,d) (r).mem_frm_data2[i] = d
#define BCM53101_A0_MEM_FRM_DATA2r_GET(r,i) (r).mem_frm_data2[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MEM_FRM_DATA2r_MEM_DATAf_GET(r,a) cdk_field_get((r).mem_frm_data2,0,63,a)
#define BCM53101_A0_MEM_FRM_DATA2r_MEM_DATAf_SET(r,a) cdk_field_set((r).mem_frm_data2,0,63,a)

/*
 * These macros can be used to access MEM_FRM_DATA2.
 *
 */
#define BCM53101_A0_READ_MEM_FRM_DATA2r(u,r) cdk_robo_reg_read(u,BCM53101_A0_MEM_FRM_DATA2r,(r._mem_frm_data2),8)
#define BCM53101_A0_WRITE_MEM_FRM_DATA2r(u,r) cdk_robo_reg_write(u,BCM53101_A0_MEM_FRM_DATA2r,&(r._mem_frm_data2),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_FRM_DATA2r BCM53101_A0_MEM_FRM_DATA2r
#define MEM_FRM_DATA2r_SIZE BCM53101_A0_MEM_FRM_DATA2r_SIZE
typedef BCM53101_A0_MEM_FRM_DATA2r_t MEM_FRM_DATA2r_t;
#define MEM_FRM_DATA2r_CLR BCM53101_A0_MEM_FRM_DATA2r_CLR
#define MEM_FRM_DATA2r_SET BCM53101_A0_MEM_FRM_DATA2r_SET
#define MEM_FRM_DATA2r_GET BCM53101_A0_MEM_FRM_DATA2r_GET
#define MEM_FRM_DATA2r_MEM_DATAf_GET BCM53101_A0_MEM_FRM_DATA2r_MEM_DATAf_GET
#define MEM_FRM_DATA2r_MEM_DATAf_SET BCM53101_A0_MEM_FRM_DATA2r_MEM_DATAf_SET
#define READ_MEM_FRM_DATA2r BCM53101_A0_READ_MEM_FRM_DATA2r
#define WRITE_MEM_FRM_DATA2r BCM53101_A0_WRITE_MEM_FRM_DATA2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MEM_FRM_DATA2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MEM_FRM_DATA3
 * BLOCKS:   SYS
 * DESC:     Frame Memory Data 4th Register
 * SIZE:     64
 * FIELDS:
 *     MEM_DATA         Specifies the data to write or provides the read data from the Frame memory[255:192].
 *
 ******************************************************************************/
#define BCM53101_A0_MEM_FRM_DATA3r 0x00000848

#define BCM53101_A0_MEM_FRM_DATA3r_SIZE 8

/*
 * This structure should be used to declare and program MEM_FRM_DATA3.
 *
 */
typedef union BCM53101_A0_MEM_FRM_DATA3r_s {
	uint32_t v[2];
	uint32_t mem_frm_data3[2];
	uint32_t _mem_frm_data3;
} BCM53101_A0_MEM_FRM_DATA3r_t;

#define BCM53101_A0_MEM_FRM_DATA3r_CLR(r) CDK_MEMSET(&((r)._mem_frm_data3), 0, sizeof(BCM53101_A0_MEM_FRM_DATA3r_t))
#define BCM53101_A0_MEM_FRM_DATA3r_SET(r,i,d) (r).mem_frm_data3[i] = d
#define BCM53101_A0_MEM_FRM_DATA3r_GET(r,i) (r).mem_frm_data3[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MEM_FRM_DATA3r_MEM_DATAf_GET(r,a) cdk_field_get((r).mem_frm_data3,0,63,a)
#define BCM53101_A0_MEM_FRM_DATA3r_MEM_DATAf_SET(r,a) cdk_field_set((r).mem_frm_data3,0,63,a)

/*
 * These macros can be used to access MEM_FRM_DATA3.
 *
 */
#define BCM53101_A0_READ_MEM_FRM_DATA3r(u,r) cdk_robo_reg_read(u,BCM53101_A0_MEM_FRM_DATA3r,(r._mem_frm_data3),8)
#define BCM53101_A0_WRITE_MEM_FRM_DATA3r(u,r) cdk_robo_reg_write(u,BCM53101_A0_MEM_FRM_DATA3r,&(r._mem_frm_data3),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MEM_FRM_DATA3r BCM53101_A0_MEM_FRM_DATA3r
#define MEM_FRM_DATA3r_SIZE BCM53101_A0_MEM_FRM_DATA3r_SIZE
typedef BCM53101_A0_MEM_FRM_DATA3r_t MEM_FRM_DATA3r_t;
#define MEM_FRM_DATA3r_CLR BCM53101_A0_MEM_FRM_DATA3r_CLR
#define MEM_FRM_DATA3r_SET BCM53101_A0_MEM_FRM_DATA3r_SET
#define MEM_FRM_DATA3r_GET BCM53101_A0_MEM_FRM_DATA3r_GET
#define MEM_FRM_DATA3r_MEM_DATAf_GET BCM53101_A0_MEM_FRM_DATA3r_MEM_DATAf_GET
#define MEM_FRM_DATA3r_MEM_DATAf_SET BCM53101_A0_MEM_FRM_DATA3r_MEM_DATAf_SET
#define READ_MEM_FRM_DATA3r BCM53101_A0_READ_MEM_FRM_DATA3r
#define WRITE_MEM_FRM_DATA3r BCM53101_A0_WRITE_MEM_FRM_DATA3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MEM_FRM_DATA3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MIB_GD_FM_MAX_SIZE
 * BLOCKS:   SYS
 * DESC:     Jumbo MIB Good Frame Max Size Registers
 * SIZE:     16
 * FIELDS:
 *     MAX_SIZE         Standard Max. Frame Size.The Register defines the Standard MAX. Frame Size for MAC and MIB counter.When jumbo is disable, the MAC and MIB counter use this field to check for good frame size.This register defines the max, ingress packet size including all the tags. The max value of this register is 2048, (Lotus)This register defines the max, ingress packet size including all the tags. The max value of this register is 2048.(Lotus doesn't support Jumbo enable)when jumbo is enable, all the frames will be dropped if the frame size is larger than 9720B.The Register setting will affect those MIB counting includingin RxSAChangeRxgoodOctetsRxUnicastPktsRxMulticastPktsRxBroadcastPktsRxOverSizePkts
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_MIB_GD_FM_MAX_SIZEr 0x00004005

#define BCM53101_A0_MIB_GD_FM_MAX_SIZEr_SIZE 2

/*
 * This structure should be used to declare and program MIB_GD_FM_MAX_SIZE.
 *
 */
typedef union BCM53101_A0_MIB_GD_FM_MAX_SIZEr_s {
	uint32_t v[1];
	uint32_t mib_gd_fm_max_size[1];
	uint32_t _mib_gd_fm_max_size;
} BCM53101_A0_MIB_GD_FM_MAX_SIZEr_t;

#define BCM53101_A0_MIB_GD_FM_MAX_SIZEr_CLR(r) (r).mib_gd_fm_max_size[0] = 0
#define BCM53101_A0_MIB_GD_FM_MAX_SIZEr_SET(r,d) (r).mib_gd_fm_max_size[0] = d
#define BCM53101_A0_MIB_GD_FM_MAX_SIZEr_GET(r) (r).mib_gd_fm_max_size[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MIB_GD_FM_MAX_SIZEr_MAX_SIZEf_GET(r) (((r).mib_gd_fm_max_size[0]) & 0x3fff)
#define BCM53101_A0_MIB_GD_FM_MAX_SIZEr_MAX_SIZEf_SET(r,f) (r).mib_gd_fm_max_size[0]=(((r).mib_gd_fm_max_size[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM53101_A0_MIB_GD_FM_MAX_SIZEr_RESERVEDf_GET(r) ((((r).mib_gd_fm_max_size[0]) >> 14) & 0x3)
#define BCM53101_A0_MIB_GD_FM_MAX_SIZEr_RESERVEDf_SET(r,f) (r).mib_gd_fm_max_size[0]=(((r).mib_gd_fm_max_size[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access MIB_GD_FM_MAX_SIZE.
 *
 */
#define BCM53101_A0_READ_MIB_GD_FM_MAX_SIZEr(u,r) cdk_robo_reg_read(u,BCM53101_A0_MIB_GD_FM_MAX_SIZEr,(r._mib_gd_fm_max_size),2)
#define BCM53101_A0_WRITE_MIB_GD_FM_MAX_SIZEr(u,r) cdk_robo_reg_write(u,BCM53101_A0_MIB_GD_FM_MAX_SIZEr,&(r._mib_gd_fm_max_size),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIB_GD_FM_MAX_SIZEr BCM53101_A0_MIB_GD_FM_MAX_SIZEr
#define MIB_GD_FM_MAX_SIZEr_SIZE BCM53101_A0_MIB_GD_FM_MAX_SIZEr_SIZE
typedef BCM53101_A0_MIB_GD_FM_MAX_SIZEr_t MIB_GD_FM_MAX_SIZEr_t;
#define MIB_GD_FM_MAX_SIZEr_CLR BCM53101_A0_MIB_GD_FM_MAX_SIZEr_CLR
#define MIB_GD_FM_MAX_SIZEr_SET BCM53101_A0_MIB_GD_FM_MAX_SIZEr_SET
#define MIB_GD_FM_MAX_SIZEr_GET BCM53101_A0_MIB_GD_FM_MAX_SIZEr_GET
#define MIB_GD_FM_MAX_SIZEr_MAX_SIZEf_GET BCM53101_A0_MIB_GD_FM_MAX_SIZEr_MAX_SIZEf_GET
#define MIB_GD_FM_MAX_SIZEr_MAX_SIZEf_SET BCM53101_A0_MIB_GD_FM_MAX_SIZEr_MAX_SIZEf_SET
#define MIB_GD_FM_MAX_SIZEr_RESERVEDf_GET BCM53101_A0_MIB_GD_FM_MAX_SIZEr_RESERVEDf_GET
#define MIB_GD_FM_MAX_SIZEr_RESERVEDf_SET BCM53101_A0_MIB_GD_FM_MAX_SIZEr_RESERVEDf_SET
#define READ_MIB_GD_FM_MAX_SIZEr BCM53101_A0_READ_MIB_GD_FM_MAX_SIZEr
#define WRITE_MIB_GD_FM_MAX_SIZEr BCM53101_A0_WRITE_MIB_GD_FM_MAX_SIZEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MIB_GD_FM_MAX_SIZEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MIB_SNAPSHOT_CTL
 * BLOCKS:   SYS
 * DESC:     MIB Snapshot Control Register
 * SIZE:     8
 * FIELDS:
 *     SNAPSHOT_PORT    Port munber for MIB snapshot function.
 *     RESERVED         
 *     SNAPSHOT_MIRROR  1'b1 : enable read address to port MIB, but from MIB snapshot memory.1'b0 : enable to read from port MIB memory.
 *     SNAPSHOT_STDONE  Write 1'b1 to initiate MIB snapshot access clear to 1'b0 when MIB snapshot access is done.
 *
 ******************************************************************************/
#define BCM53101_A0_MIB_SNAPSHOT_CTLr 0x00007000

#define BCM53101_A0_MIB_SNAPSHOT_CTLr_SIZE 1

/*
 * This structure should be used to declare and program MIB_SNAPSHOT_CTL.
 *
 */
typedef union BCM53101_A0_MIB_SNAPSHOT_CTLr_s {
	uint32_t v[1];
	uint32_t mib_snapshot_ctl[1];
	uint32_t _mib_snapshot_ctl;
} BCM53101_A0_MIB_SNAPSHOT_CTLr_t;

#define BCM53101_A0_MIB_SNAPSHOT_CTLr_CLR(r) (r).mib_snapshot_ctl[0] = 0
#define BCM53101_A0_MIB_SNAPSHOT_CTLr_SET(r,d) (r).mib_snapshot_ctl[0] = d
#define BCM53101_A0_MIB_SNAPSHOT_CTLr_GET(r) (r).mib_snapshot_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_GET(r) (((r).mib_snapshot_ctl[0]) & 0xf)
#define BCM53101_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_SET(r,f) (r).mib_snapshot_ctl[0]=(((r).mib_snapshot_ctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53101_A0_MIB_SNAPSHOT_CTLr_RESERVEDf_GET(r) ((((r).mib_snapshot_ctl[0]) >> 4) & 0x3)
#define BCM53101_A0_MIB_SNAPSHOT_CTLr_RESERVEDf_SET(r,f) (r).mib_snapshot_ctl[0]=(((r).mib_snapshot_ctl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53101_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_GET(r) ((((r).mib_snapshot_ctl[0]) >> 6) & 0x1)
#define BCM53101_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_SET(r,f) (r).mib_snapshot_ctl[0]=(((r).mib_snapshot_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_STDONEf_GET(r) ((((r).mib_snapshot_ctl[0]) >> 7) & 0x1)
#define BCM53101_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_STDONEf_SET(r,f) (r).mib_snapshot_ctl[0]=(((r).mib_snapshot_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access MIB_SNAPSHOT_CTL.
 *
 */
#define BCM53101_A0_READ_MIB_SNAPSHOT_CTLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_MIB_SNAPSHOT_CTLr,(r._mib_snapshot_ctl),1)
#define BCM53101_A0_WRITE_MIB_SNAPSHOT_CTLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_MIB_SNAPSHOT_CTLr,&(r._mib_snapshot_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIB_SNAPSHOT_CTLr BCM53101_A0_MIB_SNAPSHOT_CTLr
#define MIB_SNAPSHOT_CTLr_SIZE BCM53101_A0_MIB_SNAPSHOT_CTLr_SIZE
typedef BCM53101_A0_MIB_SNAPSHOT_CTLr_t MIB_SNAPSHOT_CTLr_t;
#define MIB_SNAPSHOT_CTLr_CLR BCM53101_A0_MIB_SNAPSHOT_CTLr_CLR
#define MIB_SNAPSHOT_CTLr_SET BCM53101_A0_MIB_SNAPSHOT_CTLr_SET
#define MIB_SNAPSHOT_CTLr_GET BCM53101_A0_MIB_SNAPSHOT_CTLr_GET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_GET BCM53101_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_GET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_SET BCM53101_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_PORTf_SET
#define MIB_SNAPSHOT_CTLr_RESERVEDf_GET BCM53101_A0_MIB_SNAPSHOT_CTLr_RESERVEDf_GET
#define MIB_SNAPSHOT_CTLr_RESERVEDf_SET BCM53101_A0_MIB_SNAPSHOT_CTLr_RESERVEDf_SET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_GET BCM53101_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_GET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_SET BCM53101_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_MIRRORf_SET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_STDONEf_GET BCM53101_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_STDONEf_GET
#define MIB_SNAPSHOT_CTLr_SNAPSHOT_STDONEf_SET BCM53101_A0_MIB_SNAPSHOT_CTLr_SNAPSHOT_STDONEf_SET
#define READ_MIB_SNAPSHOT_CTLr BCM53101_A0_READ_MIB_SNAPSHOT_CTLr
#define WRITE_MIB_SNAPSHOT_CTLr BCM53101_A0_WRITE_MIB_SNAPSHOT_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MIB_SNAPSHOT_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MIICTL
 * BLOCKS:   EPIC0
 * DESC:     MII Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         Ignore when read.
 *     DUPLEX_MOD       1'b1: Full Duplex.1'b0: Half Duplex.
 *     RE_AN            1'b1: Restart Auto-Negotiation process.1'b0: Normal operation.
 *     ISOLATE          1'b1: Electrically isolate PHY from MII 0.1'b0: Normal operation.
 *     RESERVED_1       Ignore when read.
 *     AN_EN            1'b1: Auto-Negotiation Enable.1'b0: Auto-Negotiation disable.
 *     F_SPD_SEL        1'b1: 100 Mbps1'b0: 10 Mbps.
 *     LOOPBACK         1'b1: Loopback mode.1'b0: Normal operation.
 *     SOFT_RESET       1'b1: PHY reset.1'b0: Normal operation.
 *
 ******************************************************************************/
#define BCM53101_A0_MIICTLr 0x00001000

#define BCM53101_A0_MIICTLr_SIZE 2

/*
 * This structure should be used to declare and program MIICTL.
 *
 */
typedef union BCM53101_A0_MIICTLr_s {
	uint32_t v[1];
	uint32_t miictl[1];
	uint32_t _miictl;
} BCM53101_A0_MIICTLr_t;

#define BCM53101_A0_MIICTLr_CLR(r) (r).miictl[0] = 0
#define BCM53101_A0_MIICTLr_SET(r,d) (r).miictl[0] = d
#define BCM53101_A0_MIICTLr_GET(r) (r).miictl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MIICTLr_RESERVEDf_GET(r) (((r).miictl[0]) & 0xff)
#define BCM53101_A0_MIICTLr_RESERVEDf_SET(r,f) (r).miictl[0]=(((r).miictl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53101_A0_MIICTLr_DUPLEX_MODf_GET(r) ((((r).miictl[0]) >> 8) & 0x1)
#define BCM53101_A0_MIICTLr_DUPLEX_MODf_SET(r,f) (r).miictl[0]=(((r).miictl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53101_A0_MIICTLr_RE_ANf_GET(r) ((((r).miictl[0]) >> 9) & 0x1)
#define BCM53101_A0_MIICTLr_RE_ANf_SET(r,f) (r).miictl[0]=(((r).miictl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53101_A0_MIICTLr_ISOLATEf_GET(r) ((((r).miictl[0]) >> 10) & 0x1)
#define BCM53101_A0_MIICTLr_ISOLATEf_SET(r,f) (r).miictl[0]=(((r).miictl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53101_A0_MIICTLr_RESERVED_1f_GET(r) ((((r).miictl[0]) >> 11) & 0x1)
#define BCM53101_A0_MIICTLr_RESERVED_1f_SET(r,f) (r).miictl[0]=(((r).miictl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53101_A0_MIICTLr_AN_ENf_GET(r) ((((r).miictl[0]) >> 12) & 0x1)
#define BCM53101_A0_MIICTLr_AN_ENf_SET(r,f) (r).miictl[0]=(((r).miictl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53101_A0_MIICTLr_F_SPD_SELf_GET(r) ((((r).miictl[0]) >> 13) & 0x1)
#define BCM53101_A0_MIICTLr_F_SPD_SELf_SET(r,f) (r).miictl[0]=(((r).miictl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53101_A0_MIICTLr_LOOPBACKf_GET(r) ((((r).miictl[0]) >> 14) & 0x1)
#define BCM53101_A0_MIICTLr_LOOPBACKf_SET(r,f) (r).miictl[0]=(((r).miictl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_MIICTLr_SOFT_RESETf_GET(r) ((((r).miictl[0]) >> 15) & 0x1)
#define BCM53101_A0_MIICTLr_SOFT_RESETf_SET(r,f) (r).miictl[0]=(((r).miictl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MIICTL.
 *
 */
#define BCM53101_A0_READ_MIICTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_MIICTLr,(r._miictl),2)
#define BCM53101_A0_WRITE_MIICTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_MIICTLr,&(r._miictl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIICTLr BCM53101_A0_MIICTLr
#define MIICTLr_SIZE BCM53101_A0_MIICTLr_SIZE
typedef BCM53101_A0_MIICTLr_t MIICTLr_t;
#define MIICTLr_CLR BCM53101_A0_MIICTLr_CLR
#define MIICTLr_SET BCM53101_A0_MIICTLr_SET
#define MIICTLr_GET BCM53101_A0_MIICTLr_GET
#define MIICTLr_RESERVEDf_GET BCM53101_A0_MIICTLr_RESERVEDf_GET
#define MIICTLr_RESERVEDf_SET BCM53101_A0_MIICTLr_RESERVEDf_SET
#define MIICTLr_DUPLEX_MODf_GET BCM53101_A0_MIICTLr_DUPLEX_MODf_GET
#define MIICTLr_DUPLEX_MODf_SET BCM53101_A0_MIICTLr_DUPLEX_MODf_SET
#define MIICTLr_RE_ANf_GET BCM53101_A0_MIICTLr_RE_ANf_GET
#define MIICTLr_RE_ANf_SET BCM53101_A0_MIICTLr_RE_ANf_SET
#define MIICTLr_ISOLATEf_GET BCM53101_A0_MIICTLr_ISOLATEf_GET
#define MIICTLr_ISOLATEf_SET BCM53101_A0_MIICTLr_ISOLATEf_SET
#define MIICTLr_RESERVED_1f_GET BCM53101_A0_MIICTLr_RESERVED_1f_GET
#define MIICTLr_RESERVED_1f_SET BCM53101_A0_MIICTLr_RESERVED_1f_SET
#define MIICTLr_AN_ENf_GET BCM53101_A0_MIICTLr_AN_ENf_GET
#define MIICTLr_AN_ENf_SET BCM53101_A0_MIICTLr_AN_ENf_SET
#define MIICTLr_F_SPD_SELf_GET BCM53101_A0_MIICTLr_F_SPD_SELf_GET
#define MIICTLr_F_SPD_SELf_SET BCM53101_A0_MIICTLr_F_SPD_SELf_SET
#define MIICTLr_LOOPBACKf_GET BCM53101_A0_MIICTLr_LOOPBACKf_GET
#define MIICTLr_LOOPBACKf_SET BCM53101_A0_MIICTLr_LOOPBACKf_SET
#define MIICTLr_SOFT_RESETf_GET BCM53101_A0_MIICTLr_SOFT_RESETf_GET
#define MIICTLr_SOFT_RESETf_SET BCM53101_A0_MIICTLr_SOFT_RESETf_SET
#define READ_MIICTLr BCM53101_A0_READ_MIICTLr
#define WRITE_MIICTLr BCM53101_A0_WRITE_MIICTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MIICTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MIICTL_EXT_P5
 * BLOCKS:   SYS
 * DESC:     MII Control Register
 * SIZE:     16
 * FIELDS:
 *     RESERVED         Ignore when read.
 *     DUPLEX_MOD       1'b1: Full Duplex.1'b0: Half Duplex.
 *     RE_AN            1'b1: Restart Auto-Negotiation process.1'b0: Normal operation.
 *     ISOLATE          1'b1: Electrically isolate PHY from MII 0.1'b0: Normal operation.
 *     RESERVED_1       Ignore when read.
 *     AN_EN            1'b1: Auto-Negotiation Enable.1'b0: Auto-Negotiation disable.
 *     F_SPD_SEL        1'b1: 100 Mbps1'b0: 10 Mbps.
 *     LOOPBACK         1'b1: Loopback mode.1'b0: Normal operation.
 *     RESET            1'b1: PHY reset.1'b0: Normal operation.
 *
 ******************************************************************************/
#define BCM53101_A0_MIICTL_EXT_P5r 0x00008500

#define BCM53101_A0_MIICTL_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program MIICTL_EXT_P5.
 *
 */
typedef union BCM53101_A0_MIICTL_EXT_P5r_s {
	uint32_t v[1];
	uint32_t miictl_ext_p5[1];
	uint32_t _miictl_ext_p5;
} BCM53101_A0_MIICTL_EXT_P5r_t;

#define BCM53101_A0_MIICTL_EXT_P5r_CLR(r) (r).miictl_ext_p5[0] = 0
#define BCM53101_A0_MIICTL_EXT_P5r_SET(r,d) (r).miictl_ext_p5[0] = d
#define BCM53101_A0_MIICTL_EXT_P5r_GET(r) (r).miictl_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MIICTL_EXT_P5r_RESERVEDf_GET(r) (((r).miictl_ext_p5[0]) & 0xff)
#define BCM53101_A0_MIICTL_EXT_P5r_RESERVEDf_SET(r,f) (r).miictl_ext_p5[0]=(((r).miictl_ext_p5[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53101_A0_MIICTL_EXT_P5r_DUPLEX_MODf_GET(r) ((((r).miictl_ext_p5[0]) >> 8) & 0x1)
#define BCM53101_A0_MIICTL_EXT_P5r_DUPLEX_MODf_SET(r,f) (r).miictl_ext_p5[0]=(((r).miictl_ext_p5[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53101_A0_MIICTL_EXT_P5r_RE_ANf_GET(r) ((((r).miictl_ext_p5[0]) >> 9) & 0x1)
#define BCM53101_A0_MIICTL_EXT_P5r_RE_ANf_SET(r,f) (r).miictl_ext_p5[0]=(((r).miictl_ext_p5[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53101_A0_MIICTL_EXT_P5r_ISOLATEf_GET(r) ((((r).miictl_ext_p5[0]) >> 10) & 0x1)
#define BCM53101_A0_MIICTL_EXT_P5r_ISOLATEf_SET(r,f) (r).miictl_ext_p5[0]=(((r).miictl_ext_p5[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53101_A0_MIICTL_EXT_P5r_RESERVED_1f_GET(r) ((((r).miictl_ext_p5[0]) >> 11) & 0x1)
#define BCM53101_A0_MIICTL_EXT_P5r_RESERVED_1f_SET(r,f) (r).miictl_ext_p5[0]=(((r).miictl_ext_p5[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53101_A0_MIICTL_EXT_P5r_AN_ENf_GET(r) ((((r).miictl_ext_p5[0]) >> 12) & 0x1)
#define BCM53101_A0_MIICTL_EXT_P5r_AN_ENf_SET(r,f) (r).miictl_ext_p5[0]=(((r).miictl_ext_p5[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53101_A0_MIICTL_EXT_P5r_F_SPD_SELf_GET(r) ((((r).miictl_ext_p5[0]) >> 13) & 0x1)
#define BCM53101_A0_MIICTL_EXT_P5r_F_SPD_SELf_SET(r,f) (r).miictl_ext_p5[0]=(((r).miictl_ext_p5[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53101_A0_MIICTL_EXT_P5r_LOOPBACKf_GET(r) ((((r).miictl_ext_p5[0]) >> 14) & 0x1)
#define BCM53101_A0_MIICTL_EXT_P5r_LOOPBACKf_SET(r,f) (r).miictl_ext_p5[0]=(((r).miictl_ext_p5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_MIICTL_EXT_P5r_RESETf_GET(r) ((((r).miictl_ext_p5[0]) >> 15) & 0x1)
#define BCM53101_A0_MIICTL_EXT_P5r_RESETf_SET(r,f) (r).miictl_ext_p5[0]=(((r).miictl_ext_p5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MIICTL_EXT_P5.
 *
 */
#define BCM53101_A0_READ_MIICTL_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53101_A0_MIICTL_EXT_P5r,(r._miictl_ext_p5),2)
#define BCM53101_A0_WRITE_MIICTL_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53101_A0_MIICTL_EXT_P5r,&(r._miictl_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIICTL_EXT_P5r BCM53101_A0_MIICTL_EXT_P5r
#define MIICTL_EXT_P5r_SIZE BCM53101_A0_MIICTL_EXT_P5r_SIZE
typedef BCM53101_A0_MIICTL_EXT_P5r_t MIICTL_EXT_P5r_t;
#define MIICTL_EXT_P5r_CLR BCM53101_A0_MIICTL_EXT_P5r_CLR
#define MIICTL_EXT_P5r_SET BCM53101_A0_MIICTL_EXT_P5r_SET
#define MIICTL_EXT_P5r_GET BCM53101_A0_MIICTL_EXT_P5r_GET
#define MIICTL_EXT_P5r_RESERVEDf_GET BCM53101_A0_MIICTL_EXT_P5r_RESERVEDf_GET
#define MIICTL_EXT_P5r_RESERVEDf_SET BCM53101_A0_MIICTL_EXT_P5r_RESERVEDf_SET
#define MIICTL_EXT_P5r_DUPLEX_MODf_GET BCM53101_A0_MIICTL_EXT_P5r_DUPLEX_MODf_GET
#define MIICTL_EXT_P5r_DUPLEX_MODf_SET BCM53101_A0_MIICTL_EXT_P5r_DUPLEX_MODf_SET
#define MIICTL_EXT_P5r_RE_ANf_GET BCM53101_A0_MIICTL_EXT_P5r_RE_ANf_GET
#define MIICTL_EXT_P5r_RE_ANf_SET BCM53101_A0_MIICTL_EXT_P5r_RE_ANf_SET
#define MIICTL_EXT_P5r_ISOLATEf_GET BCM53101_A0_MIICTL_EXT_P5r_ISOLATEf_GET
#define MIICTL_EXT_P5r_ISOLATEf_SET BCM53101_A0_MIICTL_EXT_P5r_ISOLATEf_SET
#define MIICTL_EXT_P5r_RESERVED_1f_GET BCM53101_A0_MIICTL_EXT_P5r_RESERVED_1f_GET
#define MIICTL_EXT_P5r_RESERVED_1f_SET BCM53101_A0_MIICTL_EXT_P5r_RESERVED_1f_SET
#define MIICTL_EXT_P5r_AN_ENf_GET BCM53101_A0_MIICTL_EXT_P5r_AN_ENf_GET
#define MIICTL_EXT_P5r_AN_ENf_SET BCM53101_A0_MIICTL_EXT_P5r_AN_ENf_SET
#define MIICTL_EXT_P5r_F_SPD_SELf_GET BCM53101_A0_MIICTL_EXT_P5r_F_SPD_SELf_GET
#define MIICTL_EXT_P5r_F_SPD_SELf_SET BCM53101_A0_MIICTL_EXT_P5r_F_SPD_SELf_SET
#define MIICTL_EXT_P5r_LOOPBACKf_GET BCM53101_A0_MIICTL_EXT_P5r_LOOPBACKf_GET
#define MIICTL_EXT_P5r_LOOPBACKf_SET BCM53101_A0_MIICTL_EXT_P5r_LOOPBACKf_SET
#define MIICTL_EXT_P5r_RESETf_GET BCM53101_A0_MIICTL_EXT_P5r_RESETf_GET
#define MIICTL_EXT_P5r_RESETf_SET BCM53101_A0_MIICTL_EXT_P5r_RESETf_SET
#define READ_MIICTL_EXT_P5r BCM53101_A0_READ_MIICTL_EXT_P5r
#define WRITE_MIICTL_EXT_P5r BCM53101_A0_WRITE_MIICTL_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MIICTL_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MIISTS
 * BLOCKS:   EPIC0
 * DESC:     MII Status Register
 * SIZE:     16
 * FIELDS:
 *     EXT_CAP          1 = Extended register capabe.
 *     JABBER_DET       1 = jabber condition detected.0 = no jabber condition detected.   
 *     LINK_STA         1 = link is up(link pass state).0 = link is down(link fail state).
 *     RESERVED_1       Ignore when read.EOT             },            AUTO_NEGO_CAP => {                MAXBIT      => 3,   MINBIT => 3,    RESETVAL => 0x1,                READONLY    => 1,                DESC        => <<'EOT'1 = Auto-negotiation capable.0 = not auto-negotiation capable.
 *     AUTO_NEGO_COMP   1 = Auto-negotiation process completed.0 = Auto-negotiation process not completed.
 *     MF_PRE_SUP       1 = Preamble may be suppressed.0 = Preamble always required.
 *     RESERVED         Reserved
 *     B10T_CAP         1 = 10BASE-T half-duplex capable.
 *     B10T_FDX_CAP     1 = 10BASE-T full-duplex capable.
 *     B100TX_CAP       1 = 100BASE-TX half-duplex capable.
 *     B100TX_FDX_CAP   1 = 100BASE-TX full-duplex capable.
 *     B100T4_CAP       0 = Not 100BASE-T4 capable.
 *
 ******************************************************************************/
#define BCM53101_A0_MIISTSr 0x00001002

#define BCM53101_A0_MIISTSr_SIZE 2

/*
 * This structure should be used to declare and program MIISTS.
 *
 */
typedef union BCM53101_A0_MIISTSr_s {
	uint32_t v[1];
	uint32_t miists[1];
	uint32_t _miists;
} BCM53101_A0_MIISTSr_t;

#define BCM53101_A0_MIISTSr_CLR(r) (r).miists[0] = 0
#define BCM53101_A0_MIISTSr_SET(r,d) (r).miists[0] = d
#define BCM53101_A0_MIISTSr_GET(r) (r).miists[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MIISTSr_EXT_CAPf_GET(r) (((r).miists[0]) & 0x1)
#define BCM53101_A0_MIISTSr_EXT_CAPf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_MIISTSr_JABBER_DETf_GET(r) ((((r).miists[0]) >> 1) & 0x1)
#define BCM53101_A0_MIISTSr_JABBER_DETf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_MIISTSr_LINK_STAf_GET(r) ((((r).miists[0]) >> 2) & 0x1)
#define BCM53101_A0_MIISTSr_LINK_STAf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_MIISTSr_RESERVED_1f_GET(r) ((((r).miists[0]) >> 4) & 0x1)
#define BCM53101_A0_MIISTSr_RESERVED_1f_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_MIISTSr_AUTO_NEGO_COMPf_GET(r) ((((r).miists[0]) >> 5) & 0x1)
#define BCM53101_A0_MIISTSr_AUTO_NEGO_COMPf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_MIISTSr_MF_PRE_SUPf_GET(r) ((((r).miists[0]) >> 6) & 0x1)
#define BCM53101_A0_MIISTSr_MF_PRE_SUPf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_MIISTSr_RESERVEDf_GET(r) ((((r).miists[0]) >> 7) & 0xf)
#define BCM53101_A0_MIISTSr_RESERVEDf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0xf << 7)) | ((((uint32_t)f) & 0xf) << 7))
#define BCM53101_A0_MIISTSr_B10T_CAPf_GET(r) ((((r).miists[0]) >> 11) & 0x1)
#define BCM53101_A0_MIISTSr_B10T_CAPf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53101_A0_MIISTSr_B10T_FDX_CAPf_GET(r) ((((r).miists[0]) >> 12) & 0x1)
#define BCM53101_A0_MIISTSr_B10T_FDX_CAPf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53101_A0_MIISTSr_B100TX_CAPf_GET(r) ((((r).miists[0]) >> 13) & 0x1)
#define BCM53101_A0_MIISTSr_B100TX_CAPf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53101_A0_MIISTSr_B100TX_FDX_CAPf_GET(r) ((((r).miists[0]) >> 14) & 0x1)
#define BCM53101_A0_MIISTSr_B100TX_FDX_CAPf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_MIISTSr_B100T4_CAPf_GET(r) ((((r).miists[0]) >> 15) & 0x1)
#define BCM53101_A0_MIISTSr_B100T4_CAPf_SET(r,f) (r).miists[0]=(((r).miists[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MIISTS.
 *
 */
#define BCM53101_A0_READ_MIISTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_MIISTSr,(r._miists),2)
#define BCM53101_A0_WRITE_MIISTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_MIISTSr,&(r._miists),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIISTSr BCM53101_A0_MIISTSr
#define MIISTSr_SIZE BCM53101_A0_MIISTSr_SIZE
typedef BCM53101_A0_MIISTSr_t MIISTSr_t;
#define MIISTSr_CLR BCM53101_A0_MIISTSr_CLR
#define MIISTSr_SET BCM53101_A0_MIISTSr_SET
#define MIISTSr_GET BCM53101_A0_MIISTSr_GET
#define MIISTSr_EXT_CAPf_GET BCM53101_A0_MIISTSr_EXT_CAPf_GET
#define MIISTSr_EXT_CAPf_SET BCM53101_A0_MIISTSr_EXT_CAPf_SET
#define MIISTSr_JABBER_DETf_GET BCM53101_A0_MIISTSr_JABBER_DETf_GET
#define MIISTSr_JABBER_DETf_SET BCM53101_A0_MIISTSr_JABBER_DETf_SET
#define MIISTSr_LINK_STAf_GET BCM53101_A0_MIISTSr_LINK_STAf_GET
#define MIISTSr_LINK_STAf_SET BCM53101_A0_MIISTSr_LINK_STAf_SET
#define MIISTSr_RESERVED_1f_GET BCM53101_A0_MIISTSr_RESERVED_1f_GET
#define MIISTSr_RESERVED_1f_SET BCM53101_A0_MIISTSr_RESERVED_1f_SET
#define MIISTSr_AUTO_NEGO_COMPf_GET BCM53101_A0_MIISTSr_AUTO_NEGO_COMPf_GET
#define MIISTSr_AUTO_NEGO_COMPf_SET BCM53101_A0_MIISTSr_AUTO_NEGO_COMPf_SET
#define MIISTSr_MF_PRE_SUPf_GET BCM53101_A0_MIISTSr_MF_PRE_SUPf_GET
#define MIISTSr_MF_PRE_SUPf_SET BCM53101_A0_MIISTSr_MF_PRE_SUPf_SET
#define MIISTSr_RESERVEDf_GET BCM53101_A0_MIISTSr_RESERVEDf_GET
#define MIISTSr_RESERVEDf_SET BCM53101_A0_MIISTSr_RESERVEDf_SET
#define MIISTSr_B10T_CAPf_GET BCM53101_A0_MIISTSr_B10T_CAPf_GET
#define MIISTSr_B10T_CAPf_SET BCM53101_A0_MIISTSr_B10T_CAPf_SET
#define MIISTSr_B10T_FDX_CAPf_GET BCM53101_A0_MIISTSr_B10T_FDX_CAPf_GET
#define MIISTSr_B10T_FDX_CAPf_SET BCM53101_A0_MIISTSr_B10T_FDX_CAPf_SET
#define MIISTSr_B100TX_CAPf_GET BCM53101_A0_MIISTSr_B100TX_CAPf_GET
#define MIISTSr_B100TX_CAPf_SET BCM53101_A0_MIISTSr_B100TX_CAPf_SET
#define MIISTSr_B100TX_FDX_CAPf_GET BCM53101_A0_MIISTSr_B100TX_FDX_CAPf_GET
#define MIISTSr_B100TX_FDX_CAPf_SET BCM53101_A0_MIISTSr_B100TX_FDX_CAPf_SET
#define MIISTSr_B100T4_CAPf_GET BCM53101_A0_MIISTSr_B100T4_CAPf_GET
#define MIISTSr_B100T4_CAPf_SET BCM53101_A0_MIISTSr_B100T4_CAPf_SET
#define READ_MIISTSr BCM53101_A0_READ_MIISTSr
#define WRITE_MIISTSr BCM53101_A0_WRITE_MIISTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MIISTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MIISTS_EXT_P5
 * BLOCKS:   SYS
 * DESC:     MII Status Register
 * SIZE:     16
 * FIELDS:
 *     EXT_CAP          1 = Extended register capabe.EOT             }        } # fields    },  # reg MIISTS##################################################### REGISTER  PHYIDH# PAGE      0x85 # BLOCKS    EPIC####################################################    PHYIDH_EXT_P5 => {        PAGE        => 'PORT5_EXT',        OFFSET      => 0x04,        BLOCKS      => [SYS],        DESC        => 'PHY ID High Register',        DATAWID     => 16,  #        ISPHY       => 1,   #        VENDOR      => 'INTERNAL',#        PORT        => 1,        NUMELS      => 1,          # *** should be 24!        EXTERNAL    => 5,        FIELDS      => {            MII_ADDR => {                MAXBIT      => 15,   MINBIT => 0,    RESETVAL => 0x0362,                READONLY    => 1,                   DESC        => <<'EOT'Device ID.EOT             }        } # fields    },  # reg PHYIDH#################################################### # REGISTER  PHYIDL# PAGE      0x85 # BLOCKS    EPIC####################################################    PHYIDL_EXT_P5 => {        PAGE        => 'PORT5_EXT',        OFFSET      => 0x06,        BLOCKS      => [SYS],        DESC        => 'PHY ID Low Register',        DATAWID     => 16,#        ISPHY       => 1,#        VENDOR      => 'INTERNAL',#        PORT        => 1,        NUMELS      => 1,          # *** should be 24!        EXTERNAL    => 5,        FIELDS      => {            MII_ADDR => {                MAXBIT      => 15,   MINBIT => 0,    RESETVAL => 0x5e90,                READONLY    => 1,                DESC        => <<'EOT'Device ID.
 *     JABBER_DET       1 = jabber condition detected.0 = no jabber condition detected.
 *     LINK_STA         1 = link is up(link pass state).0 = link is down(link fail state).
 *     AUTO_NEGO_CAP    1 = Auto-negotiation capable.0 = not auto-negotiation capable.
 *     RESERVED_1       Ignore when read.
 *     AUTO_NEGO_COMP   1 = Auto-negotiation process completed.0 = Auto-negotiation process not completed.
 *     MF_PRE_SUP       1 = Preamble may be suppressed.0 = Preamble always required.
 *     RESERVED         Reserved
 *     B10T_CAP         1 = 10BASE-T half-duplex capable.
 *     B10T_FDX_CAP     1 = 10BASE-T full-duplex capable.
 *     B100TX_CAP       1 = 100BASE-TX half-duplex capable.
 *     B100TX_FDX_CAP   1 = 100BASE-TX full-duplex capable.
 *     B100T4_CAP       0 = Not 100BASE-T4 capable.
 *
 ******************************************************************************/
#define BCM53101_A0_MIISTS_EXT_P5r 0x00008502

#define BCM53101_A0_MIISTS_EXT_P5r_SIZE 2

/*
 * This structure should be used to declare and program MIISTS_EXT_P5.
 *
 */
typedef union BCM53101_A0_MIISTS_EXT_P5r_s {
	uint32_t v[1];
	uint32_t miists_ext_p5[1];
	uint32_t _miists_ext_p5;
} BCM53101_A0_MIISTS_EXT_P5r_t;

#define BCM53101_A0_MIISTS_EXT_P5r_CLR(r) (r).miists_ext_p5[0] = 0
#define BCM53101_A0_MIISTS_EXT_P5r_SET(r,d) (r).miists_ext_p5[0] = d
#define BCM53101_A0_MIISTS_EXT_P5r_GET(r) (r).miists_ext_p5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MIISTS_EXT_P5r_EXT_CAPf_GET(r) (((r).miists_ext_p5[0]) & 0x1)
#define BCM53101_A0_MIISTS_EXT_P5r_EXT_CAPf_SET(r,f) (r).miists_ext_p5[0]=(((r).miists_ext_p5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_MIISTS_EXT_P5r_JABBER_DETf_GET(r) ((((r).miists_ext_p5[0]) >> 1) & 0x1)
#define BCM53101_A0_MIISTS_EXT_P5r_JABBER_DETf_SET(r,f) (r).miists_ext_p5[0]=(((r).miists_ext_p5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_MIISTS_EXT_P5r_LINK_STAf_GET(r) ((((r).miists_ext_p5[0]) >> 2) & 0x1)
#define BCM53101_A0_MIISTS_EXT_P5r_LINK_STAf_SET(r,f) (r).miists_ext_p5[0]=(((r).miists_ext_p5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_MIISTS_EXT_P5r_AUTO_NEGO_CAPf_GET(r) ((((r).miists_ext_p5[0]) >> 3) & 0x1)
#define BCM53101_A0_MIISTS_EXT_P5r_AUTO_NEGO_CAPf_SET(r,f) (r).miists_ext_p5[0]=(((r).miists_ext_p5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_MIISTS_EXT_P5r_RESERVED_1f_GET(r) ((((r).miists_ext_p5[0]) >> 4) & 0x1)
#define BCM53101_A0_MIISTS_EXT_P5r_RESERVED_1f_SET(r,f) (r).miists_ext_p5[0]=(((r).miists_ext_p5[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_MIISTS_EXT_P5r_AUTO_NEGO_COMPf_GET(r) ((((r).miists_ext_p5[0]) >> 5) & 0x1)
#define BCM53101_A0_MIISTS_EXT_P5r_AUTO_NEGO_COMPf_SET(r,f) (r).miists_ext_p5[0]=(((r).miists_ext_p5[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_MIISTS_EXT_P5r_MF_PRE_SUPf_GET(r) ((((r).miists_ext_p5[0]) >> 6) & 0x1)
#define BCM53101_A0_MIISTS_EXT_P5r_MF_PRE_SUPf_SET(r,f) (r).miists_ext_p5[0]=(((r).miists_ext_p5[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_MIISTS_EXT_P5r_RESERVEDf_GET(r) ((((r).miists_ext_p5[0]) >> 7) & 0xf)
#define BCM53101_A0_MIISTS_EXT_P5r_RESERVEDf_SET(r,f) (r).miists_ext_p5[0]=(((r).miists_ext_p5[0] & ~((uint32_t)0xf << 7)) | ((((uint32_t)f) & 0xf) << 7))
#define BCM53101_A0_MIISTS_EXT_P5r_B10T_CAPf_GET(r) ((((r).miists_ext_p5[0]) >> 11) & 0x1)
#define BCM53101_A0_MIISTS_EXT_P5r_B10T_CAPf_SET(r,f) (r).miists_ext_p5[0]=(((r).miists_ext_p5[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53101_A0_MIISTS_EXT_P5r_B10T_FDX_CAPf_GET(r) ((((r).miists_ext_p5[0]) >> 12) & 0x1)
#define BCM53101_A0_MIISTS_EXT_P5r_B10T_FDX_CAPf_SET(r,f) (r).miists_ext_p5[0]=(((r).miists_ext_p5[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53101_A0_MIISTS_EXT_P5r_B100TX_CAPf_GET(r) ((((r).miists_ext_p5[0]) >> 13) & 0x1)
#define BCM53101_A0_MIISTS_EXT_P5r_B100TX_CAPf_SET(r,f) (r).miists_ext_p5[0]=(((r).miists_ext_p5[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13))
#define BCM53101_A0_MIISTS_EXT_P5r_B100TX_FDX_CAPf_GET(r) ((((r).miists_ext_p5[0]) >> 14) & 0x1)
#define BCM53101_A0_MIISTS_EXT_P5r_B100TX_FDX_CAPf_SET(r,f) (r).miists_ext_p5[0]=(((r).miists_ext_p5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_MIISTS_EXT_P5r_B100T4_CAPf_GET(r) ((((r).miists_ext_p5[0]) >> 15) & 0x1)
#define BCM53101_A0_MIISTS_EXT_P5r_B100T4_CAPf_SET(r,f) (r).miists_ext_p5[0]=(((r).miists_ext_p5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MIISTS_EXT_P5.
 *
 */
#define BCM53101_A0_READ_MIISTS_EXT_P5r(u,r) cdk_robo_reg_read(u,BCM53101_A0_MIISTS_EXT_P5r,(r._miists_ext_p5),2)
#define BCM53101_A0_WRITE_MIISTS_EXT_P5r(u,r) cdk_robo_reg_write(u,BCM53101_A0_MIISTS_EXT_P5r,&(r._miists_ext_p5),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIISTS_EXT_P5r BCM53101_A0_MIISTS_EXT_P5r
#define MIISTS_EXT_P5r_SIZE BCM53101_A0_MIISTS_EXT_P5r_SIZE
typedef BCM53101_A0_MIISTS_EXT_P5r_t MIISTS_EXT_P5r_t;
#define MIISTS_EXT_P5r_CLR BCM53101_A0_MIISTS_EXT_P5r_CLR
#define MIISTS_EXT_P5r_SET BCM53101_A0_MIISTS_EXT_P5r_SET
#define MIISTS_EXT_P5r_GET BCM53101_A0_MIISTS_EXT_P5r_GET
#define MIISTS_EXT_P5r_EXT_CAPf_GET BCM53101_A0_MIISTS_EXT_P5r_EXT_CAPf_GET
#define MIISTS_EXT_P5r_EXT_CAPf_SET BCM53101_A0_MIISTS_EXT_P5r_EXT_CAPf_SET
#define MIISTS_EXT_P5r_JABBER_DETf_GET BCM53101_A0_MIISTS_EXT_P5r_JABBER_DETf_GET
#define MIISTS_EXT_P5r_JABBER_DETf_SET BCM53101_A0_MIISTS_EXT_P5r_JABBER_DETf_SET
#define MIISTS_EXT_P5r_LINK_STAf_GET BCM53101_A0_MIISTS_EXT_P5r_LINK_STAf_GET
#define MIISTS_EXT_P5r_LINK_STAf_SET BCM53101_A0_MIISTS_EXT_P5r_LINK_STAf_SET
#define MIISTS_EXT_P5r_AUTO_NEGO_CAPf_GET BCM53101_A0_MIISTS_EXT_P5r_AUTO_NEGO_CAPf_GET
#define MIISTS_EXT_P5r_AUTO_NEGO_CAPf_SET BCM53101_A0_MIISTS_EXT_P5r_AUTO_NEGO_CAPf_SET
#define MIISTS_EXT_P5r_RESERVED_1f_GET BCM53101_A0_MIISTS_EXT_P5r_RESERVED_1f_GET
#define MIISTS_EXT_P5r_RESERVED_1f_SET BCM53101_A0_MIISTS_EXT_P5r_RESERVED_1f_SET
#define MIISTS_EXT_P5r_AUTO_NEGO_COMPf_GET BCM53101_A0_MIISTS_EXT_P5r_AUTO_NEGO_COMPf_GET
#define MIISTS_EXT_P5r_AUTO_NEGO_COMPf_SET BCM53101_A0_MIISTS_EXT_P5r_AUTO_NEGO_COMPf_SET
#define MIISTS_EXT_P5r_MF_PRE_SUPf_GET BCM53101_A0_MIISTS_EXT_P5r_MF_PRE_SUPf_GET
#define MIISTS_EXT_P5r_MF_PRE_SUPf_SET BCM53101_A0_MIISTS_EXT_P5r_MF_PRE_SUPf_SET
#define MIISTS_EXT_P5r_RESERVEDf_GET BCM53101_A0_MIISTS_EXT_P5r_RESERVEDf_GET
#define MIISTS_EXT_P5r_RESERVEDf_SET BCM53101_A0_MIISTS_EXT_P5r_RESERVEDf_SET
#define MIISTS_EXT_P5r_B10T_CAPf_GET BCM53101_A0_MIISTS_EXT_P5r_B10T_CAPf_GET
#define MIISTS_EXT_P5r_B10T_CAPf_SET BCM53101_A0_MIISTS_EXT_P5r_B10T_CAPf_SET
#define MIISTS_EXT_P5r_B10T_FDX_CAPf_GET BCM53101_A0_MIISTS_EXT_P5r_B10T_FDX_CAPf_GET
#define MIISTS_EXT_P5r_B10T_FDX_CAPf_SET BCM53101_A0_MIISTS_EXT_P5r_B10T_FDX_CAPf_SET
#define MIISTS_EXT_P5r_B100TX_CAPf_GET BCM53101_A0_MIISTS_EXT_P5r_B100TX_CAPf_GET
#define MIISTS_EXT_P5r_B100TX_CAPf_SET BCM53101_A0_MIISTS_EXT_P5r_B100TX_CAPf_SET
#define MIISTS_EXT_P5r_B100TX_FDX_CAPf_GET BCM53101_A0_MIISTS_EXT_P5r_B100TX_FDX_CAPf_GET
#define MIISTS_EXT_P5r_B100TX_FDX_CAPf_SET BCM53101_A0_MIISTS_EXT_P5r_B100TX_FDX_CAPf_SET
#define MIISTS_EXT_P5r_B100T4_CAPf_GET BCM53101_A0_MIISTS_EXT_P5r_B100T4_CAPf_GET
#define MIISTS_EXT_P5r_B100T4_CAPf_SET BCM53101_A0_MIISTS_EXT_P5r_B100T4_CAPf_SET
#define READ_MIISTS_EXT_P5r BCM53101_A0_READ_MIISTS_EXT_P5r
#define WRITE_MIISTS_EXT_P5r BCM53101_A0_WRITE_MIISTS_EXT_P5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MIISTS_EXT_P5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MINIMUM_TCP_HDR_SZ
 * BLOCKS:   SYS
 * DESC:     Minimum TCP Header Size Register
 * SIZE:     8
 * FIELDS:
 *     MIN_TCP_HDR_SZ   MIN_TCP_Header_Size is programable between 0 and 255 bytes, inclusive. The default value is set to 20 bytes(TCP header without options).
 *
 ******************************************************************************/
#define BCM53101_A0_MINIMUM_TCP_HDR_SZr 0x00003604

#define BCM53101_A0_MINIMUM_TCP_HDR_SZr_SIZE 1

/*
 * This structure should be used to declare and program MINIMUM_TCP_HDR_SZ.
 *
 */
typedef union BCM53101_A0_MINIMUM_TCP_HDR_SZr_s {
	uint32_t v[1];
	uint32_t minimum_tcp_hdr_sz[1];
	uint32_t _minimum_tcp_hdr_sz;
} BCM53101_A0_MINIMUM_TCP_HDR_SZr_t;

#define BCM53101_A0_MINIMUM_TCP_HDR_SZr_CLR(r) (r).minimum_tcp_hdr_sz[0] = 0
#define BCM53101_A0_MINIMUM_TCP_HDR_SZr_SET(r,d) (r).minimum_tcp_hdr_sz[0] = d
#define BCM53101_A0_MINIMUM_TCP_HDR_SZr_GET(r) (r).minimum_tcp_hdr_sz[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MINIMUM_TCP_HDR_SZr_MIN_TCP_HDR_SZf_GET(r) (((r).minimum_tcp_hdr_sz[0]) & 0xff)
#define BCM53101_A0_MINIMUM_TCP_HDR_SZr_MIN_TCP_HDR_SZf_SET(r,f) (r).minimum_tcp_hdr_sz[0]=(((r).minimum_tcp_hdr_sz[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access MINIMUM_TCP_HDR_SZ.
 *
 */
#define BCM53101_A0_READ_MINIMUM_TCP_HDR_SZr(u,r) cdk_robo_reg_read(u,BCM53101_A0_MINIMUM_TCP_HDR_SZr,(r._minimum_tcp_hdr_sz),1)
#define BCM53101_A0_WRITE_MINIMUM_TCP_HDR_SZr(u,r) cdk_robo_reg_write(u,BCM53101_A0_MINIMUM_TCP_HDR_SZr,&(r._minimum_tcp_hdr_sz),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MINIMUM_TCP_HDR_SZr BCM53101_A0_MINIMUM_TCP_HDR_SZr
#define MINIMUM_TCP_HDR_SZr_SIZE BCM53101_A0_MINIMUM_TCP_HDR_SZr_SIZE
typedef BCM53101_A0_MINIMUM_TCP_HDR_SZr_t MINIMUM_TCP_HDR_SZr_t;
#define MINIMUM_TCP_HDR_SZr_CLR BCM53101_A0_MINIMUM_TCP_HDR_SZr_CLR
#define MINIMUM_TCP_HDR_SZr_SET BCM53101_A0_MINIMUM_TCP_HDR_SZr_SET
#define MINIMUM_TCP_HDR_SZr_GET BCM53101_A0_MINIMUM_TCP_HDR_SZr_GET
#define MINIMUM_TCP_HDR_SZr_MIN_TCP_HDR_SZf_GET BCM53101_A0_MINIMUM_TCP_HDR_SZr_MIN_TCP_HDR_SZf_GET
#define MINIMUM_TCP_HDR_SZr_MIN_TCP_HDR_SZf_SET BCM53101_A0_MINIMUM_TCP_HDR_SZr_MIN_TCP_HDR_SZf_SET
#define READ_MINIMUM_TCP_HDR_SZr BCM53101_A0_READ_MINIMUM_TCP_HDR_SZr
#define WRITE_MINIMUM_TCP_HDR_SZr BCM53101_A0_WRITE_MINIMUM_TCP_HDR_SZr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MINIMUM_TCP_HDR_SZr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MIRCAPCTL
 * BLOCKS:   SYS
 * DESC:     Mirror Capture Control Register
 * SIZE:     16
 * FIELDS:
 *     SMIR_CAP_PORT    Mirror Capture Port ID.Port ID which identifies the single unique port which is designated as the port to which all ingress and/or egress traffic is mirrored on this chip/system.
 *     RESERVED_0       Reserved
 *     RESERVED_1       Reserved
 *     BLK_NOT_MIR      When Enabled, all traffic to Mirror_Capture_Port will be blocked except mirror traffic.
 *     MIR_EN           Global enable/disable for all mirroring on this chip.When reset, mirroring is disabled.When set, mirroring is enabled according to the ingress and egress control rules, to the port designated by the MIRROR_CAPTURE_PORT.
 *
 ******************************************************************************/
#define BCM53101_A0_MIRCAPCTLr 0x00000210

#define BCM53101_A0_MIRCAPCTLr_SIZE 2

/*
 * This structure should be used to declare and program MIRCAPCTL.
 *
 */
typedef union BCM53101_A0_MIRCAPCTLr_s {
	uint32_t v[1];
	uint32_t mircapctl[1];
	uint32_t _mircapctl;
} BCM53101_A0_MIRCAPCTLr_t;

#define BCM53101_A0_MIRCAPCTLr_CLR(r) (r).mircapctl[0] = 0
#define BCM53101_A0_MIRCAPCTLr_SET(r,d) (r).mircapctl[0] = d
#define BCM53101_A0_MIRCAPCTLr_GET(r) (r).mircapctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MIRCAPCTLr_SMIR_CAP_PORTf_GET(r) (((r).mircapctl[0]) & 0xf)
#define BCM53101_A0_MIRCAPCTLr_SMIR_CAP_PORTf_SET(r,f) (r).mircapctl[0]=(((r).mircapctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53101_A0_MIRCAPCTLr_RESERVED_0f_GET(r) ((((r).mircapctl[0]) >> 4) & 0x3)
#define BCM53101_A0_MIRCAPCTLr_RESERVED_0f_SET(r,f) (r).mircapctl[0]=(((r).mircapctl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53101_A0_MIRCAPCTLr_RESERVED_1f_GET(r) ((((r).mircapctl[0]) >> 6) & 0xff)
#define BCM53101_A0_MIRCAPCTLr_RESERVED_1f_SET(r,f) (r).mircapctl[0]=(((r).mircapctl[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6))
#define BCM53101_A0_MIRCAPCTLr_BLK_NOT_MIRf_GET(r) ((((r).mircapctl[0]) >> 14) & 0x1)
#define BCM53101_A0_MIRCAPCTLr_BLK_NOT_MIRf_SET(r,f) (r).mircapctl[0]=(((r).mircapctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_MIRCAPCTLr_MIR_ENf_GET(r) ((((r).mircapctl[0]) >> 15) & 0x1)
#define BCM53101_A0_MIRCAPCTLr_MIR_ENf_SET(r,f) (r).mircapctl[0]=(((r).mircapctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MIRCAPCTL.
 *
 */
#define BCM53101_A0_READ_MIRCAPCTLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_MIRCAPCTLr,(r._mircapctl),2)
#define BCM53101_A0_WRITE_MIRCAPCTLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_MIRCAPCTLr,&(r._mircapctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MIRCAPCTLr BCM53101_A0_MIRCAPCTLr
#define MIRCAPCTLr_SIZE BCM53101_A0_MIRCAPCTLr_SIZE
typedef BCM53101_A0_MIRCAPCTLr_t MIRCAPCTLr_t;
#define MIRCAPCTLr_CLR BCM53101_A0_MIRCAPCTLr_CLR
#define MIRCAPCTLr_SET BCM53101_A0_MIRCAPCTLr_SET
#define MIRCAPCTLr_GET BCM53101_A0_MIRCAPCTLr_GET
#define MIRCAPCTLr_SMIR_CAP_PORTf_GET BCM53101_A0_MIRCAPCTLr_SMIR_CAP_PORTf_GET
#define MIRCAPCTLr_SMIR_CAP_PORTf_SET BCM53101_A0_MIRCAPCTLr_SMIR_CAP_PORTf_SET
#define MIRCAPCTLr_RESERVED_0f_GET BCM53101_A0_MIRCAPCTLr_RESERVED_0f_GET
#define MIRCAPCTLr_RESERVED_0f_SET BCM53101_A0_MIRCAPCTLr_RESERVED_0f_SET
#define MIRCAPCTLr_RESERVED_1f_GET BCM53101_A0_MIRCAPCTLr_RESERVED_1f_GET
#define MIRCAPCTLr_RESERVED_1f_SET BCM53101_A0_MIRCAPCTLr_RESERVED_1f_SET
#define MIRCAPCTLr_BLK_NOT_MIRf_GET BCM53101_A0_MIRCAPCTLr_BLK_NOT_MIRf_GET
#define MIRCAPCTLr_BLK_NOT_MIRf_SET BCM53101_A0_MIRCAPCTLr_BLK_NOT_MIRf_SET
#define MIRCAPCTLr_MIR_ENf_GET BCM53101_A0_MIRCAPCTLr_MIR_ENf_GET
#define MIRCAPCTLr_MIR_ENf_SET BCM53101_A0_MIRCAPCTLr_MIR_ENf_SET
#define READ_MIRCAPCTLr BCM53101_A0_READ_MIRCAPCTLr
#define WRITE_MIRCAPCTLr BCM53101_A0_WRITE_MIRCAPCTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MIRCAPCTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MLF_DROP_MAP
 * BLOCKS:   SYS
 * DESC:     Multicast Lookup Failed Forward Map Registrer
 * SIZE:     16
 * FIELDS:
 *     MUL_LOOKUP_FAIL_FRW_MAP Multicast Lookup Failed Forward Map.When Multicat lookup failed Drop is enabled (Page 00, Offset 21h) and Lookup failure happen, ARL will forward the frame according to the register setting.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_MLF_DROP_MAPr 0x00000034

#define BCM53101_A0_MLF_DROP_MAPr_SIZE 2

/*
 * This structure should be used to declare and program MLF_DROP_MAP.
 *
 */
typedef union BCM53101_A0_MLF_DROP_MAPr_s {
	uint32_t v[1];
	uint32_t mlf_drop_map[1];
	uint32_t _mlf_drop_map;
} BCM53101_A0_MLF_DROP_MAPr_t;

#define BCM53101_A0_MLF_DROP_MAPr_CLR(r) (r).mlf_drop_map[0] = 0
#define BCM53101_A0_MLF_DROP_MAPr_SET(r,d) (r).mlf_drop_map[0] = d
#define BCM53101_A0_MLF_DROP_MAPr_GET(r) (r).mlf_drop_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MLF_DROP_MAPr_MUL_LOOKUP_FAIL_FRW_MAPf_GET(r) (((r).mlf_drop_map[0]) & 0x1ff)
#define BCM53101_A0_MLF_DROP_MAPr_MUL_LOOKUP_FAIL_FRW_MAPf_SET(r,f) (r).mlf_drop_map[0]=(((r).mlf_drop_map[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_MLF_DROP_MAPr_RESERVEDf_GET(r) ((((r).mlf_drop_map[0]) >> 9) & 0x7f)
#define BCM53101_A0_MLF_DROP_MAPr_RESERVEDf_SET(r,f) (r).mlf_drop_map[0]=(((r).mlf_drop_map[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access MLF_DROP_MAP.
 *
 */
#define BCM53101_A0_READ_MLF_DROP_MAPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_MLF_DROP_MAPr,(r._mlf_drop_map),2)
#define BCM53101_A0_WRITE_MLF_DROP_MAPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_MLF_DROP_MAPr,&(r._mlf_drop_map),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MLF_DROP_MAPr BCM53101_A0_MLF_DROP_MAPr
#define MLF_DROP_MAPr_SIZE BCM53101_A0_MLF_DROP_MAPr_SIZE
typedef BCM53101_A0_MLF_DROP_MAPr_t MLF_DROP_MAPr_t;
#define MLF_DROP_MAPr_CLR BCM53101_A0_MLF_DROP_MAPr_CLR
#define MLF_DROP_MAPr_SET BCM53101_A0_MLF_DROP_MAPr_SET
#define MLF_DROP_MAPr_GET BCM53101_A0_MLF_DROP_MAPr_GET
#define MLF_DROP_MAPr_MUL_LOOKUP_FAIL_FRW_MAPf_GET BCM53101_A0_MLF_DROP_MAPr_MUL_LOOKUP_FAIL_FRW_MAPf_GET
#define MLF_DROP_MAPr_MUL_LOOKUP_FAIL_FRW_MAPf_SET BCM53101_A0_MLF_DROP_MAPr_MUL_LOOKUP_FAIL_FRW_MAPf_SET
#define MLF_DROP_MAPr_RESERVEDf_GET BCM53101_A0_MLF_DROP_MAPr_RESERVEDf_GET
#define MLF_DROP_MAPr_RESERVEDf_SET BCM53101_A0_MLF_DROP_MAPr_RESERVEDf_SET
#define READ_MLF_DROP_MAPr BCM53101_A0_READ_MLF_DROP_MAPr
#define WRITE_MLF_DROP_MAPr BCM53101_A0_WRITE_MLF_DROP_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MLF_DROP_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MLF_IPMC_FWD_MAP
 * BLOCKS:   SYS
 * DESC:     IPMC Forward Map Registrer
 * SIZE:     16
 * FIELDS:
 *     MLF_IPMC_FWD_MAP IPMC Forward map.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_MLF_IPMC_FWD_MAPr 0x00000036

#define BCM53101_A0_MLF_IPMC_FWD_MAPr_SIZE 2

/*
 * This structure should be used to declare and program MLF_IPMC_FWD_MAP.
 *
 */
typedef union BCM53101_A0_MLF_IPMC_FWD_MAPr_s {
	uint32_t v[1];
	uint32_t mlf_ipmc_fwd_map[1];
	uint32_t _mlf_ipmc_fwd_map;
} BCM53101_A0_MLF_IPMC_FWD_MAPr_t;

#define BCM53101_A0_MLF_IPMC_FWD_MAPr_CLR(r) (r).mlf_ipmc_fwd_map[0] = 0
#define BCM53101_A0_MLF_IPMC_FWD_MAPr_SET(r,d) (r).mlf_ipmc_fwd_map[0] = d
#define BCM53101_A0_MLF_IPMC_FWD_MAPr_GET(r) (r).mlf_ipmc_fwd_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MLF_IPMC_FWD_MAPr_MLF_IPMC_FWD_MAPf_GET(r) (((r).mlf_ipmc_fwd_map[0]) & 0x1ff)
#define BCM53101_A0_MLF_IPMC_FWD_MAPr_MLF_IPMC_FWD_MAPf_SET(r,f) (r).mlf_ipmc_fwd_map[0]=(((r).mlf_ipmc_fwd_map[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_MLF_IPMC_FWD_MAPr_RESERVEDf_GET(r) ((((r).mlf_ipmc_fwd_map[0]) >> 9) & 0x7f)
#define BCM53101_A0_MLF_IPMC_FWD_MAPr_RESERVEDf_SET(r,f) (r).mlf_ipmc_fwd_map[0]=(((r).mlf_ipmc_fwd_map[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access MLF_IPMC_FWD_MAP.
 *
 */
#define BCM53101_A0_READ_MLF_IPMC_FWD_MAPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_MLF_IPMC_FWD_MAPr,(r._mlf_ipmc_fwd_map),2)
#define BCM53101_A0_WRITE_MLF_IPMC_FWD_MAPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_MLF_IPMC_FWD_MAPr,&(r._mlf_ipmc_fwd_map),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MLF_IPMC_FWD_MAPr BCM53101_A0_MLF_IPMC_FWD_MAPr
#define MLF_IPMC_FWD_MAPr_SIZE BCM53101_A0_MLF_IPMC_FWD_MAPr_SIZE
typedef BCM53101_A0_MLF_IPMC_FWD_MAPr_t MLF_IPMC_FWD_MAPr_t;
#define MLF_IPMC_FWD_MAPr_CLR BCM53101_A0_MLF_IPMC_FWD_MAPr_CLR
#define MLF_IPMC_FWD_MAPr_SET BCM53101_A0_MLF_IPMC_FWD_MAPr_SET
#define MLF_IPMC_FWD_MAPr_GET BCM53101_A0_MLF_IPMC_FWD_MAPr_GET
#define MLF_IPMC_FWD_MAPr_MLF_IPMC_FWD_MAPf_GET BCM53101_A0_MLF_IPMC_FWD_MAPr_MLF_IPMC_FWD_MAPf_GET
#define MLF_IPMC_FWD_MAPr_MLF_IPMC_FWD_MAPf_SET BCM53101_A0_MLF_IPMC_FWD_MAPr_MLF_IPMC_FWD_MAPf_SET
#define MLF_IPMC_FWD_MAPr_RESERVEDf_GET BCM53101_A0_MLF_IPMC_FWD_MAPr_RESERVEDf_GET
#define MLF_IPMC_FWD_MAPr_RESERVEDf_SET BCM53101_A0_MLF_IPMC_FWD_MAPr_RESERVEDf_SET
#define READ_MLF_IPMC_FWD_MAPr BCM53101_A0_READ_MLF_IPMC_FWD_MAPr
#define WRITE_MLF_IPMC_FWD_MAPr BCM53101_A0_WRITE_MLF_IPMC_FWD_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MLF_IPMC_FWD_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MODEL_ID
 * BLOCKS:   SYS
 * DESC:     Model ID Register
 * SIZE:     32
 * FIELDS:
 *     MODELID          Chip Model ID
 *
 ******************************************************************************/
#define BCM53101_A0_MODEL_IDr 0x00000230

#define BCM53101_A0_MODEL_IDr_SIZE 4

/*
 * This structure should be used to declare and program MODEL_ID.
 *
 */
typedef union BCM53101_A0_MODEL_IDr_s {
	uint32_t v[1];
	uint32_t model_id[1];
	uint32_t _model_id;
} BCM53101_A0_MODEL_IDr_t;

#define BCM53101_A0_MODEL_IDr_CLR(r) (r).model_id[0] = 0
#define BCM53101_A0_MODEL_IDr_SET(r,d) (r).model_id[0] = d
#define BCM53101_A0_MODEL_IDr_GET(r) (r).model_id[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MODEL_IDr_MODELIDf_GET(r) ((r).model_id[0])
#define BCM53101_A0_MODEL_IDr_MODELIDf_SET(r,f) (r).model_id[0]=((uint32_t)f)

/*
 * These macros can be used to access MODEL_ID.
 *
 */
#define BCM53101_A0_READ_MODEL_IDr(u,r) cdk_robo_reg_read(u,BCM53101_A0_MODEL_IDr,(r._model_id),4)
#define BCM53101_A0_WRITE_MODEL_IDr(u,r) cdk_robo_reg_write(u,BCM53101_A0_MODEL_IDr,&(r._model_id),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MODEL_IDr BCM53101_A0_MODEL_IDr
#define MODEL_IDr_SIZE BCM53101_A0_MODEL_IDr_SIZE
typedef BCM53101_A0_MODEL_IDr_t MODEL_IDr_t;
#define MODEL_IDr_CLR BCM53101_A0_MODEL_IDr_CLR
#define MODEL_IDr_SET BCM53101_A0_MODEL_IDr_SET
#define MODEL_IDr_GET BCM53101_A0_MODEL_IDr_GET
#define MODEL_IDr_MODELIDf_GET BCM53101_A0_MODEL_IDr_MODELIDf_GET
#define MODEL_IDr_MODELIDf_SET BCM53101_A0_MODEL_IDr_MODELIDf_SET
#define READ_MODEL_IDr BCM53101_A0_READ_MODEL_IDr
#define WRITE_MODEL_IDr BCM53101_A0_WRITE_MODEL_IDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MODEL_IDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MPORTVEC0
 * BLOCKS:   SYS
 * DESC:     Multiport Vector 0 Register
 * SIZE:     32
 * FIELDS:
 *     PORT_VCTR        Multiport Vector 0.A bit mask corresponding to the physical ports on the chip.A frame with a DA matching the content of the Multiport Address 0 register will be forwarded to each port with a bit set in the Multiport Vector 0 bit map.Bits 0-7: Port 0-7 in chip 0.Bit 8: Management Port ( MII Management ).
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_MPORTVEC0r 0x00000418

#define BCM53101_A0_MPORTVEC0r_SIZE 4

/*
 * This structure should be used to declare and program MPORTVEC0.
 *
 */
typedef union BCM53101_A0_MPORTVEC0r_s {
	uint32_t v[1];
	uint32_t mportvec0[1];
	uint32_t _mportvec0;
} BCM53101_A0_MPORTVEC0r_t;

#define BCM53101_A0_MPORTVEC0r_CLR(r) (r).mportvec0[0] = 0
#define BCM53101_A0_MPORTVEC0r_SET(r,d) (r).mportvec0[0] = d
#define BCM53101_A0_MPORTVEC0r_GET(r) (r).mportvec0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MPORTVEC0r_PORT_VCTRf_GET(r) (((r).mportvec0[0]) & 0x1ff)
#define BCM53101_A0_MPORTVEC0r_PORT_VCTRf_SET(r,f) (r).mportvec0[0]=(((r).mportvec0[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_MPORTVEC0r_RESERVEDf_GET(r) ((((r).mportvec0[0]) >> 9) & 0x7fffff)
#define BCM53101_A0_MPORTVEC0r_RESERVEDf_SET(r,f) (r).mportvec0[0]=(((r).mportvec0[0] & ~((uint32_t)0x7fffff << 9)) | ((((uint32_t)f) & 0x7fffff) << 9))

/*
 * These macros can be used to access MPORTVEC0.
 *
 */
#define BCM53101_A0_READ_MPORTVEC0r(u,r) cdk_robo_reg_read(u,BCM53101_A0_MPORTVEC0r,(r._mportvec0),4)
#define BCM53101_A0_WRITE_MPORTVEC0r(u,r) cdk_robo_reg_write(u,BCM53101_A0_MPORTVEC0r,&(r._mportvec0),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MPORTVEC0r BCM53101_A0_MPORTVEC0r
#define MPORTVEC0r_SIZE BCM53101_A0_MPORTVEC0r_SIZE
typedef BCM53101_A0_MPORTVEC0r_t MPORTVEC0r_t;
#define MPORTVEC0r_CLR BCM53101_A0_MPORTVEC0r_CLR
#define MPORTVEC0r_SET BCM53101_A0_MPORTVEC0r_SET
#define MPORTVEC0r_GET BCM53101_A0_MPORTVEC0r_GET
#define MPORTVEC0r_PORT_VCTRf_GET BCM53101_A0_MPORTVEC0r_PORT_VCTRf_GET
#define MPORTVEC0r_PORT_VCTRf_SET BCM53101_A0_MPORTVEC0r_PORT_VCTRf_SET
#define MPORTVEC0r_RESERVEDf_GET BCM53101_A0_MPORTVEC0r_RESERVEDf_GET
#define MPORTVEC0r_RESERVEDf_SET BCM53101_A0_MPORTVEC0r_RESERVEDf_SET
#define READ_MPORTVEC0r BCM53101_A0_READ_MPORTVEC0r
#define WRITE_MPORTVEC0r BCM53101_A0_WRITE_MPORTVEC0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MPORTVEC0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MPORTVEC1
 * BLOCKS:   SYS
 * DESC:     Multiport Vector 1 Register
 * SIZE:     32
 * FIELDS:
 *     PORT_VCTR        Multiport Vector 1A bit mask corresponding to the physical ports on the chip.A frame with a DA matching the content of the Multiport Address 1 register will be forwarded to each port with a bit set in the Multiport Vector 1 bit map.Bit 8: Management Port (MII Management )
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_MPORTVEC1r 0x00000428

#define BCM53101_A0_MPORTVEC1r_SIZE 4

/*
 * This structure should be used to declare and program MPORTVEC1.
 *
 */
typedef union BCM53101_A0_MPORTVEC1r_s {
	uint32_t v[1];
	uint32_t mportvec1[1];
	uint32_t _mportvec1;
} BCM53101_A0_MPORTVEC1r_t;

#define BCM53101_A0_MPORTVEC1r_CLR(r) (r).mportvec1[0] = 0
#define BCM53101_A0_MPORTVEC1r_SET(r,d) (r).mportvec1[0] = d
#define BCM53101_A0_MPORTVEC1r_GET(r) (r).mportvec1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MPORTVEC1r_PORT_VCTRf_GET(r) (((r).mportvec1[0]) & 0x1ff)
#define BCM53101_A0_MPORTVEC1r_PORT_VCTRf_SET(r,f) (r).mportvec1[0]=(((r).mportvec1[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_MPORTVEC1r_RESERVEDf_GET(r) ((((r).mportvec1[0]) >> 9) & 0x7fffff)
#define BCM53101_A0_MPORTVEC1r_RESERVEDf_SET(r,f) (r).mportvec1[0]=(((r).mportvec1[0] & ~((uint32_t)0x7fffff << 9)) | ((((uint32_t)f) & 0x7fffff) << 9))

/*
 * These macros can be used to access MPORTVEC1.
 *
 */
#define BCM53101_A0_READ_MPORTVEC1r(u,r) cdk_robo_reg_read(u,BCM53101_A0_MPORTVEC1r,(r._mportvec1),4)
#define BCM53101_A0_WRITE_MPORTVEC1r(u,r) cdk_robo_reg_write(u,BCM53101_A0_MPORTVEC1r,&(r._mportvec1),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MPORTVEC1r BCM53101_A0_MPORTVEC1r
#define MPORTVEC1r_SIZE BCM53101_A0_MPORTVEC1r_SIZE
typedef BCM53101_A0_MPORTVEC1r_t MPORTVEC1r_t;
#define MPORTVEC1r_CLR BCM53101_A0_MPORTVEC1r_CLR
#define MPORTVEC1r_SET BCM53101_A0_MPORTVEC1r_SET
#define MPORTVEC1r_GET BCM53101_A0_MPORTVEC1r_GET
#define MPORTVEC1r_PORT_VCTRf_GET BCM53101_A0_MPORTVEC1r_PORT_VCTRf_GET
#define MPORTVEC1r_PORT_VCTRf_SET BCM53101_A0_MPORTVEC1r_PORT_VCTRf_SET
#define MPORTVEC1r_RESERVEDf_GET BCM53101_A0_MPORTVEC1r_RESERVEDf_GET
#define MPORTVEC1r_RESERVEDf_SET BCM53101_A0_MPORTVEC1r_RESERVEDf_SET
#define READ_MPORTVEC1r BCM53101_A0_READ_MPORTVEC1r
#define WRITE_MPORTVEC1r BCM53101_A0_WRITE_MPORTVEC1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MPORTVEC1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MPORTVEC2
 * BLOCKS:   SYS
 * DESC:     Multiport Vector 2 Register
 * SIZE:     32
 * FIELDS:
 *     PORT_VCTR        Multiport Vector 2.A bit mask corresponding to the physical ports on the chip.A frame with a DA matching the content of the Multiport Address 2 register will be forwarded to each port with a bit set in the Multiport Vector 2 bit map.Bits 0-7: Port 0-7 in chip 0.Bit 8: Management Port ( MII Management ).
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_MPORTVEC2r 0x00000438

#define BCM53101_A0_MPORTVEC2r_SIZE 4

/*
 * This structure should be used to declare and program MPORTVEC2.
 *
 */
typedef union BCM53101_A0_MPORTVEC2r_s {
	uint32_t v[1];
	uint32_t mportvec2[1];
	uint32_t _mportvec2;
} BCM53101_A0_MPORTVEC2r_t;

#define BCM53101_A0_MPORTVEC2r_CLR(r) (r).mportvec2[0] = 0
#define BCM53101_A0_MPORTVEC2r_SET(r,d) (r).mportvec2[0] = d
#define BCM53101_A0_MPORTVEC2r_GET(r) (r).mportvec2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MPORTVEC2r_PORT_VCTRf_GET(r) (((r).mportvec2[0]) & 0x1ff)
#define BCM53101_A0_MPORTVEC2r_PORT_VCTRf_SET(r,f) (r).mportvec2[0]=(((r).mportvec2[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_MPORTVEC2r_RESERVEDf_GET(r) ((((r).mportvec2[0]) >> 9) & 0x7fffff)
#define BCM53101_A0_MPORTVEC2r_RESERVEDf_SET(r,f) (r).mportvec2[0]=(((r).mportvec2[0] & ~((uint32_t)0x7fffff << 9)) | ((((uint32_t)f) & 0x7fffff) << 9))

/*
 * These macros can be used to access MPORTVEC2.
 *
 */
#define BCM53101_A0_READ_MPORTVEC2r(u,r) cdk_robo_reg_read(u,BCM53101_A0_MPORTVEC2r,(r._mportvec2),4)
#define BCM53101_A0_WRITE_MPORTVEC2r(u,r) cdk_robo_reg_write(u,BCM53101_A0_MPORTVEC2r,&(r._mportvec2),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MPORTVEC2r BCM53101_A0_MPORTVEC2r
#define MPORTVEC2r_SIZE BCM53101_A0_MPORTVEC2r_SIZE
typedef BCM53101_A0_MPORTVEC2r_t MPORTVEC2r_t;
#define MPORTVEC2r_CLR BCM53101_A0_MPORTVEC2r_CLR
#define MPORTVEC2r_SET BCM53101_A0_MPORTVEC2r_SET
#define MPORTVEC2r_GET BCM53101_A0_MPORTVEC2r_GET
#define MPORTVEC2r_PORT_VCTRf_GET BCM53101_A0_MPORTVEC2r_PORT_VCTRf_GET
#define MPORTVEC2r_PORT_VCTRf_SET BCM53101_A0_MPORTVEC2r_PORT_VCTRf_SET
#define MPORTVEC2r_RESERVEDf_GET BCM53101_A0_MPORTVEC2r_RESERVEDf_GET
#define MPORTVEC2r_RESERVEDf_SET BCM53101_A0_MPORTVEC2r_RESERVEDf_SET
#define READ_MPORTVEC2r BCM53101_A0_READ_MPORTVEC2r
#define WRITE_MPORTVEC2r BCM53101_A0_WRITE_MPORTVEC2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MPORTVEC2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MPORTVEC3
 * BLOCKS:   SYS
 * DESC:     Multiport Vector 3 Register
 * SIZE:     32
 * FIELDS:
 *     PORT_VCTR        Multiport Vector 3.A bit mask corresponding to the physical ports on the chip.A frame with a DA matching the content of the Multiport Address 3 register will be forwarded to each port with a bit set in the Multiport Vector 3 bit map.Bits 0-7: Port 0-7 in chip 0.Bit 8: Management Port ( MII Management ).
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_MPORTVEC3r 0x00000448

#define BCM53101_A0_MPORTVEC3r_SIZE 4

/*
 * This structure should be used to declare and program MPORTVEC3.
 *
 */
typedef union BCM53101_A0_MPORTVEC3r_s {
	uint32_t v[1];
	uint32_t mportvec3[1];
	uint32_t _mportvec3;
} BCM53101_A0_MPORTVEC3r_t;

#define BCM53101_A0_MPORTVEC3r_CLR(r) (r).mportvec3[0] = 0
#define BCM53101_A0_MPORTVEC3r_SET(r,d) (r).mportvec3[0] = d
#define BCM53101_A0_MPORTVEC3r_GET(r) (r).mportvec3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MPORTVEC3r_PORT_VCTRf_GET(r) (((r).mportvec3[0]) & 0x1ff)
#define BCM53101_A0_MPORTVEC3r_PORT_VCTRf_SET(r,f) (r).mportvec3[0]=(((r).mportvec3[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_MPORTVEC3r_RESERVEDf_GET(r) ((((r).mportvec3[0]) >> 9) & 0x7fffff)
#define BCM53101_A0_MPORTVEC3r_RESERVEDf_SET(r,f) (r).mportvec3[0]=(((r).mportvec3[0] & ~((uint32_t)0x7fffff << 9)) | ((((uint32_t)f) & 0x7fffff) << 9))

/*
 * These macros can be used to access MPORTVEC3.
 *
 */
#define BCM53101_A0_READ_MPORTVEC3r(u,r) cdk_robo_reg_read(u,BCM53101_A0_MPORTVEC3r,(r._mportvec3),4)
#define BCM53101_A0_WRITE_MPORTVEC3r(u,r) cdk_robo_reg_write(u,BCM53101_A0_MPORTVEC3r,&(r._mportvec3),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MPORTVEC3r BCM53101_A0_MPORTVEC3r
#define MPORTVEC3r_SIZE BCM53101_A0_MPORTVEC3r_SIZE
typedef BCM53101_A0_MPORTVEC3r_t MPORTVEC3r_t;
#define MPORTVEC3r_CLR BCM53101_A0_MPORTVEC3r_CLR
#define MPORTVEC3r_SET BCM53101_A0_MPORTVEC3r_SET
#define MPORTVEC3r_GET BCM53101_A0_MPORTVEC3r_GET
#define MPORTVEC3r_PORT_VCTRf_GET BCM53101_A0_MPORTVEC3r_PORT_VCTRf_GET
#define MPORTVEC3r_PORT_VCTRf_SET BCM53101_A0_MPORTVEC3r_PORT_VCTRf_SET
#define MPORTVEC3r_RESERVEDf_GET BCM53101_A0_MPORTVEC3r_RESERVEDf_GET
#define MPORTVEC3r_RESERVEDf_SET BCM53101_A0_MPORTVEC3r_RESERVEDf_SET
#define READ_MPORTVEC3r BCM53101_A0_READ_MPORTVEC3r
#define WRITE_MPORTVEC3r BCM53101_A0_WRITE_MPORTVEC3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MPORTVEC3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MPORTVEC4
 * BLOCKS:   SYS
 * DESC:     Multiport Vector 4 Register
 * SIZE:     32
 * FIELDS:
 *     PORT_VCTR        Multiport Vector 4.A bit mask corresponding to the physical ports on the chip.A frame with a DA matching the content of the Multiport Address 4 register will be forwarded to each port with a bit set in the Multiport Vector 4 bit map.Bits 0-7: Port 0-7 in chip 0.Bit 8: Management Port ( MII Management ).
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_MPORTVEC4r 0x00000458

#define BCM53101_A0_MPORTVEC4r_SIZE 4

/*
 * This structure should be used to declare and program MPORTVEC4.
 *
 */
typedef union BCM53101_A0_MPORTVEC4r_s {
	uint32_t v[1];
	uint32_t mportvec4[1];
	uint32_t _mportvec4;
} BCM53101_A0_MPORTVEC4r_t;

#define BCM53101_A0_MPORTVEC4r_CLR(r) (r).mportvec4[0] = 0
#define BCM53101_A0_MPORTVEC4r_SET(r,d) (r).mportvec4[0] = d
#define BCM53101_A0_MPORTVEC4r_GET(r) (r).mportvec4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MPORTVEC4r_PORT_VCTRf_GET(r) (((r).mportvec4[0]) & 0x1ff)
#define BCM53101_A0_MPORTVEC4r_PORT_VCTRf_SET(r,f) (r).mportvec4[0]=(((r).mportvec4[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_MPORTVEC4r_RESERVEDf_GET(r) ((((r).mportvec4[0]) >> 9) & 0x7fffff)
#define BCM53101_A0_MPORTVEC4r_RESERVEDf_SET(r,f) (r).mportvec4[0]=(((r).mportvec4[0] & ~((uint32_t)0x7fffff << 9)) | ((((uint32_t)f) & 0x7fffff) << 9))

/*
 * These macros can be used to access MPORTVEC4.
 *
 */
#define BCM53101_A0_READ_MPORTVEC4r(u,r) cdk_robo_reg_read(u,BCM53101_A0_MPORTVEC4r,(r._mportvec4),4)
#define BCM53101_A0_WRITE_MPORTVEC4r(u,r) cdk_robo_reg_write(u,BCM53101_A0_MPORTVEC4r,&(r._mportvec4),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MPORTVEC4r BCM53101_A0_MPORTVEC4r
#define MPORTVEC4r_SIZE BCM53101_A0_MPORTVEC4r_SIZE
typedef BCM53101_A0_MPORTVEC4r_t MPORTVEC4r_t;
#define MPORTVEC4r_CLR BCM53101_A0_MPORTVEC4r_CLR
#define MPORTVEC4r_SET BCM53101_A0_MPORTVEC4r_SET
#define MPORTVEC4r_GET BCM53101_A0_MPORTVEC4r_GET
#define MPORTVEC4r_PORT_VCTRf_GET BCM53101_A0_MPORTVEC4r_PORT_VCTRf_GET
#define MPORTVEC4r_PORT_VCTRf_SET BCM53101_A0_MPORTVEC4r_PORT_VCTRf_SET
#define MPORTVEC4r_RESERVEDf_GET BCM53101_A0_MPORTVEC4r_RESERVEDf_GET
#define MPORTVEC4r_RESERVEDf_SET BCM53101_A0_MPORTVEC4r_RESERVEDf_SET
#define READ_MPORTVEC4r BCM53101_A0_READ_MPORTVEC4r
#define WRITE_MPORTVEC4r BCM53101_A0_WRITE_MPORTVEC4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MPORTVEC4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MPORTVEC5
 * BLOCKS:   SYS
 * DESC:     Multiport Vector 5 Register
 * SIZE:     32
 * FIELDS:
 *     PORT_VCTR        Multiport Vector 5.A bit mask corresponding to the physical ports on the chip.A frame with a DA matching the content of the Multiport Address 5 register will be forwarded to each port with a bit set in the Multiport Vector 5 bit map.Bits 0-7: Port 0-7 in chip 0.Bit 8: Management Port ( MII Management ).
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_MPORTVEC5r 0x00000468

#define BCM53101_A0_MPORTVEC5r_SIZE 4

/*
 * This structure should be used to declare and program MPORTVEC5.
 *
 */
typedef union BCM53101_A0_MPORTVEC5r_s {
	uint32_t v[1];
	uint32_t mportvec5[1];
	uint32_t _mportvec5;
} BCM53101_A0_MPORTVEC5r_t;

#define BCM53101_A0_MPORTVEC5r_CLR(r) (r).mportvec5[0] = 0
#define BCM53101_A0_MPORTVEC5r_SET(r,d) (r).mportvec5[0] = d
#define BCM53101_A0_MPORTVEC5r_GET(r) (r).mportvec5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MPORTVEC5r_PORT_VCTRf_GET(r) (((r).mportvec5[0]) & 0x1ff)
#define BCM53101_A0_MPORTVEC5r_PORT_VCTRf_SET(r,f) (r).mportvec5[0]=(((r).mportvec5[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_MPORTVEC5r_RESERVEDf_GET(r) ((((r).mportvec5[0]) >> 9) & 0x7fffff)
#define BCM53101_A0_MPORTVEC5r_RESERVEDf_SET(r,f) (r).mportvec5[0]=(((r).mportvec5[0] & ~((uint32_t)0x7fffff << 9)) | ((((uint32_t)f) & 0x7fffff) << 9))

/*
 * These macros can be used to access MPORTVEC5.
 *
 */
#define BCM53101_A0_READ_MPORTVEC5r(u,r) cdk_robo_reg_read(u,BCM53101_A0_MPORTVEC5r,(r._mportvec5),4)
#define BCM53101_A0_WRITE_MPORTVEC5r(u,r) cdk_robo_reg_write(u,BCM53101_A0_MPORTVEC5r,&(r._mportvec5),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MPORTVEC5r BCM53101_A0_MPORTVEC5r
#define MPORTVEC5r_SIZE BCM53101_A0_MPORTVEC5r_SIZE
typedef BCM53101_A0_MPORTVEC5r_t MPORTVEC5r_t;
#define MPORTVEC5r_CLR BCM53101_A0_MPORTVEC5r_CLR
#define MPORTVEC5r_SET BCM53101_A0_MPORTVEC5r_SET
#define MPORTVEC5r_GET BCM53101_A0_MPORTVEC5r_GET
#define MPORTVEC5r_PORT_VCTRf_GET BCM53101_A0_MPORTVEC5r_PORT_VCTRf_GET
#define MPORTVEC5r_PORT_VCTRf_SET BCM53101_A0_MPORTVEC5r_PORT_VCTRf_SET
#define MPORTVEC5r_RESERVEDf_GET BCM53101_A0_MPORTVEC5r_RESERVEDf_GET
#define MPORTVEC5r_RESERVEDf_SET BCM53101_A0_MPORTVEC5r_RESERVEDf_SET
#define READ_MPORTVEC5r BCM53101_A0_READ_MPORTVEC5r
#define WRITE_MPORTVEC5r BCM53101_A0_WRITE_MPORTVEC5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MPORTVEC5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MST_AGE
 * BLOCKS:   SYS
 * DESC:     MST Ageing Control Register
 * SIZE:     32
 * FIELDS:
 *     AGE_EN_PRT       Per-spannibg tree aging enable.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_MST_AGEr 0x00004302

#define BCM53101_A0_MST_AGEr_SIZE 4

/*
 * This structure should be used to declare and program MST_AGE.
 *
 */
typedef union BCM53101_A0_MST_AGEr_s {
	uint32_t v[1];
	uint32_t mst_age[1];
	uint32_t _mst_age;
} BCM53101_A0_MST_AGEr_t;

#define BCM53101_A0_MST_AGEr_CLR(r) (r).mst_age[0] = 0
#define BCM53101_A0_MST_AGEr_SET(r,d) (r).mst_age[0] = d
#define BCM53101_A0_MST_AGEr_GET(r) (r).mst_age[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MST_AGEr_AGE_EN_PRTf_GET(r) (((r).mst_age[0]) & 0xff)
#define BCM53101_A0_MST_AGEr_AGE_EN_PRTf_SET(r,f) (r).mst_age[0]=(((r).mst_age[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53101_A0_MST_AGEr_RESERVEDf_GET(r) ((((r).mst_age[0]) >> 8) & 0xffffff)
#define BCM53101_A0_MST_AGEr_RESERVEDf_SET(r,f) (r).mst_age[0]=(((r).mst_age[0] & ~((uint32_t)0xffffff << 8)) | ((((uint32_t)f) & 0xffffff) << 8))

/*
 * These macros can be used to access MST_AGE.
 *
 */
#define BCM53101_A0_READ_MST_AGEr(u,r) cdk_robo_reg_read(u,BCM53101_A0_MST_AGEr,(r._mst_age),4)
#define BCM53101_A0_WRITE_MST_AGEr(u,r) cdk_robo_reg_write(u,BCM53101_A0_MST_AGEr,&(r._mst_age),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MST_AGEr BCM53101_A0_MST_AGEr
#define MST_AGEr_SIZE BCM53101_A0_MST_AGEr_SIZE
typedef BCM53101_A0_MST_AGEr_t MST_AGEr_t;
#define MST_AGEr_CLR BCM53101_A0_MST_AGEr_CLR
#define MST_AGEr_SET BCM53101_A0_MST_AGEr_SET
#define MST_AGEr_GET BCM53101_A0_MST_AGEr_GET
#define MST_AGEr_AGE_EN_PRTf_GET BCM53101_A0_MST_AGEr_AGE_EN_PRTf_GET
#define MST_AGEr_AGE_EN_PRTf_SET BCM53101_A0_MST_AGEr_AGE_EN_PRTf_SET
#define MST_AGEr_RESERVEDf_GET BCM53101_A0_MST_AGEr_RESERVEDf_GET
#define MST_AGEr_RESERVEDf_SET BCM53101_A0_MST_AGEr_RESERVEDf_SET
#define READ_MST_AGEr BCM53101_A0_READ_MST_AGEr
#define WRITE_MST_AGEr BCM53101_A0_WRITE_MST_AGEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MST_AGEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MST_CON
 * BLOCKS:   SYS
 * DESC:     MST Control Registers
 * SIZE:     8
 * FIELDS:
 *     EN_802_1S        1: Enable 802.1s0: Only one spanning tree support
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_MST_CONr 0x00004300

#define BCM53101_A0_MST_CONr_SIZE 1

/*
 * This structure should be used to declare and program MST_CON.
 *
 */
typedef union BCM53101_A0_MST_CONr_s {
	uint32_t v[1];
	uint32_t mst_con[1];
	uint32_t _mst_con;
} BCM53101_A0_MST_CONr_t;

#define BCM53101_A0_MST_CONr_CLR(r) (r).mst_con[0] = 0
#define BCM53101_A0_MST_CONr_SET(r,d) (r).mst_con[0] = d
#define BCM53101_A0_MST_CONr_GET(r) (r).mst_con[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MST_CONr_EN_802_1Sf_GET(r) (((r).mst_con[0]) & 0x1)
#define BCM53101_A0_MST_CONr_EN_802_1Sf_SET(r,f) (r).mst_con[0]=(((r).mst_con[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_MST_CONr_RESERVEDf_GET(r) ((((r).mst_con[0]) >> 1) & 0x7f)
#define BCM53101_A0_MST_CONr_RESERVEDf_SET(r,f) (r).mst_con[0]=(((r).mst_con[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access MST_CON.
 *
 */
#define BCM53101_A0_READ_MST_CONr(u,r) cdk_robo_reg_read(u,BCM53101_A0_MST_CONr,(r._mst_con),1)
#define BCM53101_A0_WRITE_MST_CONr(u,r) cdk_robo_reg_write(u,BCM53101_A0_MST_CONr,&(r._mst_con),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MST_CONr BCM53101_A0_MST_CONr
#define MST_CONr_SIZE BCM53101_A0_MST_CONr_SIZE
typedef BCM53101_A0_MST_CONr_t MST_CONr_t;
#define MST_CONr_CLR BCM53101_A0_MST_CONr_CLR
#define MST_CONr_SET BCM53101_A0_MST_CONr_SET
#define MST_CONr_GET BCM53101_A0_MST_CONr_GET
#define MST_CONr_EN_802_1Sf_GET BCM53101_A0_MST_CONr_EN_802_1Sf_GET
#define MST_CONr_EN_802_1Sf_SET BCM53101_A0_MST_CONr_EN_802_1Sf_SET
#define MST_CONr_RESERVEDf_GET BCM53101_A0_MST_CONr_RESERVEDf_GET
#define MST_CONr_RESERVEDf_SET BCM53101_A0_MST_CONr_RESERVEDf_SET
#define READ_MST_CONr BCM53101_A0_READ_MST_CONr
#define WRITE_MST_CONr BCM53101_A0_WRITE_MST_CONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MST_CONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MST_TAB
 * BLOCKS:   SYS
 * DESC:     MST Table N Enable Registers
 * SIZE:     32
 * FIELDS:
 *     SPT_STA0         Spanning tree state for port 0.000 : no spanning tree,001 : disable,010 : blocking,011 : listening,100 : learning,101 : forwarding,110-111 : reserved.
 *     SPT_STA1         Spanning tree state for port 1.000 : no spanning tree,001 : disable,010 : blocking,011 : listening,100 : learning,101 : forwarding,110-111 : reserved.
 *     SPT_STA2         Spanning tree state for port 2.000 : no spanning tree,001 : disable,010 : blocking,011 : listening,100 : learning,101 : forwarding,110-111 : reserved.
 *     SPT_STA3         Spanning tree state for port 3.000 : no spanning tree,001 : disable,010 : blocking,011 : listening,100 : learning,101 : forwarding,110-111 : reserved.
 *     SPT_STA4         Spanning tree state for port 4.000 : no spanning tree,001 : disable,010 : blocking,011 : listening,100 : learning,101 : forwarding,110-111 : reserved.
 *     SPT_STA5         Spanning tree state for port 5.000 : no spanning tree,001 : disable,010 : blocking,011 : listening,100 : learning,101 : forwarding,110-111 : reserved.
 *     RESERVED         
 *     MST_TAB_RSRV     Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_MST_TABr 0x00004310

#define BCM53101_A0_MST_TABr_SIZE 4

/*
 * This structure should be used to declare and program MST_TAB.
 *
 */
typedef union BCM53101_A0_MST_TABr_s {
	uint32_t v[1];
	uint32_t mst_tab[1];
	uint32_t _mst_tab;
} BCM53101_A0_MST_TABr_t;

#define BCM53101_A0_MST_TABr_CLR(r) (r).mst_tab[0] = 0
#define BCM53101_A0_MST_TABr_SET(r,d) (r).mst_tab[0] = d
#define BCM53101_A0_MST_TABr_GET(r) (r).mst_tab[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MST_TABr_SPT_STA0f_GET(r) (((r).mst_tab[0]) & 0x7)
#define BCM53101_A0_MST_TABr_SPT_STA0f_SET(r,f) (r).mst_tab[0]=(((r).mst_tab[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53101_A0_MST_TABr_SPT_STA1f_GET(r) ((((r).mst_tab[0]) >> 3) & 0x7)
#define BCM53101_A0_MST_TABr_SPT_STA1f_SET(r,f) (r).mst_tab[0]=(((r).mst_tab[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM53101_A0_MST_TABr_SPT_STA2f_GET(r) ((((r).mst_tab[0]) >> 6) & 0x7)
#define BCM53101_A0_MST_TABr_SPT_STA2f_SET(r,f) (r).mst_tab[0]=(((r).mst_tab[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM53101_A0_MST_TABr_SPT_STA3f_GET(r) ((((r).mst_tab[0]) >> 9) & 0x7)
#define BCM53101_A0_MST_TABr_SPT_STA3f_SET(r,f) (r).mst_tab[0]=(((r).mst_tab[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM53101_A0_MST_TABr_SPT_STA4f_GET(r) ((((r).mst_tab[0]) >> 12) & 0x7)
#define BCM53101_A0_MST_TABr_SPT_STA4f_SET(r,f) (r).mst_tab[0]=(((r).mst_tab[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53101_A0_MST_TABr_SPT_STA5f_GET(r) ((((r).mst_tab[0]) >> 15) & 0x7)
#define BCM53101_A0_MST_TABr_SPT_STA5f_SET(r,f) (r).mst_tab[0]=(((r).mst_tab[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM53101_A0_MST_TABr_RESERVEDf_GET(r) ((((r).mst_tab[0]) >> 18) & 0x1ff)
#define BCM53101_A0_MST_TABr_RESERVEDf_SET(r,f) (r).mst_tab[0]=(((r).mst_tab[0] & ~((uint32_t)0x1ff << 18)) | ((((uint32_t)f) & 0x1ff) << 18))
#define BCM53101_A0_MST_TABr_MST_TAB_RSRVf_GET(r) ((((r).mst_tab[0]) >> 27) & 0x1f)
#define BCM53101_A0_MST_TABr_MST_TAB_RSRVf_SET(r,f) (r).mst_tab[0]=(((r).mst_tab[0] & ~((uint32_t)0x1f << 27)) | ((((uint32_t)f) & 0x1f) << 27))

/*
 * These macros can be used to access MST_TAB.
 *
 */
#define BCM53101_A0_READ_MST_TABr(u,i,r) cdk_robo_reg_read(u,BCM53101_A0_MST_TABr+(4*(i)),(r._mst_tab),4)
#define BCM53101_A0_WRITE_MST_TABr(u,i,r) cdk_robo_reg_write(u,BCM53101_A0_MST_TABr+(4*(i)),&(r._mst_tab),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MST_TABr BCM53101_A0_MST_TABr
#define MST_TABr_SIZE BCM53101_A0_MST_TABr_SIZE
typedef BCM53101_A0_MST_TABr_t MST_TABr_t;
#define MST_TABr_CLR BCM53101_A0_MST_TABr_CLR
#define MST_TABr_SET BCM53101_A0_MST_TABr_SET
#define MST_TABr_GET BCM53101_A0_MST_TABr_GET
#define MST_TABr_SPT_STA0f_GET BCM53101_A0_MST_TABr_SPT_STA0f_GET
#define MST_TABr_SPT_STA0f_SET BCM53101_A0_MST_TABr_SPT_STA0f_SET
#define MST_TABr_SPT_STA1f_GET BCM53101_A0_MST_TABr_SPT_STA1f_GET
#define MST_TABr_SPT_STA1f_SET BCM53101_A0_MST_TABr_SPT_STA1f_SET
#define MST_TABr_SPT_STA2f_GET BCM53101_A0_MST_TABr_SPT_STA2f_GET
#define MST_TABr_SPT_STA2f_SET BCM53101_A0_MST_TABr_SPT_STA2f_SET
#define MST_TABr_SPT_STA3f_GET BCM53101_A0_MST_TABr_SPT_STA3f_GET
#define MST_TABr_SPT_STA3f_SET BCM53101_A0_MST_TABr_SPT_STA3f_SET
#define MST_TABr_SPT_STA4f_GET BCM53101_A0_MST_TABr_SPT_STA4f_GET
#define MST_TABr_SPT_STA4f_SET BCM53101_A0_MST_TABr_SPT_STA4f_SET
#define MST_TABr_SPT_STA5f_GET BCM53101_A0_MST_TABr_SPT_STA5f_GET
#define MST_TABr_SPT_STA5f_SET BCM53101_A0_MST_TABr_SPT_STA5f_SET
#define MST_TABr_RESERVEDf_GET BCM53101_A0_MST_TABr_RESERVEDf_GET
#define MST_TABr_RESERVEDf_SET BCM53101_A0_MST_TABr_RESERVEDf_SET
#define MST_TABr_MST_TAB_RSRVf_GET BCM53101_A0_MST_TABr_MST_TAB_RSRVf_GET
#define MST_TABr_MST_TAB_RSRVf_SET BCM53101_A0_MST_TABr_MST_TAB_RSRVf_SET
#define READ_MST_TABr BCM53101_A0_READ_MST_TABr
#define WRITE_MST_TABr BCM53101_A0_WRITE_MST_TABr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MST_TABr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MULTIPORT_ADDR0
 * BLOCKS:   SYS
 * DESC:     Multiport Address 0 Register (Default for TS)
 * SIZE:     64
 * FIELDS:
 *     MPORT_ADDR       Multiport Address 0.Allows a frames with a matching DA to this address to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 0 register.Must be enabled using the MPORT_ADDR_EN bit in the Global ARL Configuration register.
 *     MPORT_E_TYPE     Multiport Ethernet Type 0Allows a frames with a matching MPORT_E_TYPE to this Length Type field to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 0 register.Must be enabled using the MPORT_CTRLN bit in the MultiPort Control register.
 *
 ******************************************************************************/
#define BCM53101_A0_MULTIPORT_ADDR0r 0x00000410

#define BCM53101_A0_MULTIPORT_ADDR0r_SIZE 8

/*
 * This structure should be used to declare and program MULTIPORT_ADDR0.
 *
 */
typedef union BCM53101_A0_MULTIPORT_ADDR0r_s {
	uint32_t v[2];
	uint32_t multiport_addr0[2];
	uint32_t _multiport_addr0;
} BCM53101_A0_MULTIPORT_ADDR0r_t;

#define BCM53101_A0_MULTIPORT_ADDR0r_CLR(r) CDK_MEMSET(&((r)._multiport_addr0), 0, sizeof(BCM53101_A0_MULTIPORT_ADDR0r_t))
#define BCM53101_A0_MULTIPORT_ADDR0r_SET(r,i,d) (r).multiport_addr0[i] = d
#define BCM53101_A0_MULTIPORT_ADDR0r_GET(r,i) (r).multiport_addr0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MULTIPORT_ADDR0r_MPORT_ADDRf_GET(r,a) cdk_field_get((r).multiport_addr0,0,47,a)
#define BCM53101_A0_MULTIPORT_ADDR0r_MPORT_ADDRf_SET(r,a) cdk_field_set((r).multiport_addr0,0,47,a)
#define BCM53101_A0_MULTIPORT_ADDR0r_MPORT_E_TYPEf_GET(r) ((((r).multiport_addr0[1]) >> 16) & 0xffff)
#define BCM53101_A0_MULTIPORT_ADDR0r_MPORT_E_TYPEf_SET(r,f) (r).multiport_addr0[1]=(((r).multiport_addr0[1] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access MULTIPORT_ADDR0.
 *
 */
#define BCM53101_A0_READ_MULTIPORT_ADDR0r(u,r) cdk_robo_reg_read(u,BCM53101_A0_MULTIPORT_ADDR0r,(r._multiport_addr0),8)
#define BCM53101_A0_WRITE_MULTIPORT_ADDR0r(u,r) cdk_robo_reg_write(u,BCM53101_A0_MULTIPORT_ADDR0r,&(r._multiport_addr0),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MULTIPORT_ADDR0r BCM53101_A0_MULTIPORT_ADDR0r
#define MULTIPORT_ADDR0r_SIZE BCM53101_A0_MULTIPORT_ADDR0r_SIZE
typedef BCM53101_A0_MULTIPORT_ADDR0r_t MULTIPORT_ADDR0r_t;
#define MULTIPORT_ADDR0r_CLR BCM53101_A0_MULTIPORT_ADDR0r_CLR
#define MULTIPORT_ADDR0r_SET BCM53101_A0_MULTIPORT_ADDR0r_SET
#define MULTIPORT_ADDR0r_GET BCM53101_A0_MULTIPORT_ADDR0r_GET
#define MULTIPORT_ADDR0r_MPORT_ADDRf_GET BCM53101_A0_MULTIPORT_ADDR0r_MPORT_ADDRf_GET
#define MULTIPORT_ADDR0r_MPORT_ADDRf_SET BCM53101_A0_MULTIPORT_ADDR0r_MPORT_ADDRf_SET
#define MULTIPORT_ADDR0r_MPORT_E_TYPEf_GET BCM53101_A0_MULTIPORT_ADDR0r_MPORT_E_TYPEf_GET
#define MULTIPORT_ADDR0r_MPORT_E_TYPEf_SET BCM53101_A0_MULTIPORT_ADDR0r_MPORT_E_TYPEf_SET
#define READ_MULTIPORT_ADDR0r BCM53101_A0_READ_MULTIPORT_ADDR0r
#define WRITE_MULTIPORT_ADDR0r BCM53101_A0_WRITE_MULTIPORT_ADDR0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MULTIPORT_ADDR0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MULTIPORT_ADDR1
 * BLOCKS:   SYS
 * DESC:     Multiport Address 1 Register
 * SIZE:     64
 * FIELDS:
 *     MPORT_ADDR       Multiport Address 1.Allows a frames with a matching DA to this address to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 1 register.Must be enabled using the MPORT_ADDR_EN bit in the Global ARL Configuration register.
 *     MPORT_E_TYPE     Multiport Ethernet Type 1Allows a frames with a matching MPORT_E_TYPE to this Length Type field to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 1 register.Must be enabled using the MPORT_CTRLN bit in the MultiPort Control register.
 *
 ******************************************************************************/
#define BCM53101_A0_MULTIPORT_ADDR1r 0x00000420

#define BCM53101_A0_MULTIPORT_ADDR1r_SIZE 8

/*
 * This structure should be used to declare and program MULTIPORT_ADDR1.
 *
 */
typedef union BCM53101_A0_MULTIPORT_ADDR1r_s {
	uint32_t v[2];
	uint32_t multiport_addr1[2];
	uint32_t _multiport_addr1;
} BCM53101_A0_MULTIPORT_ADDR1r_t;

#define BCM53101_A0_MULTIPORT_ADDR1r_CLR(r) CDK_MEMSET(&((r)._multiport_addr1), 0, sizeof(BCM53101_A0_MULTIPORT_ADDR1r_t))
#define BCM53101_A0_MULTIPORT_ADDR1r_SET(r,i,d) (r).multiport_addr1[i] = d
#define BCM53101_A0_MULTIPORT_ADDR1r_GET(r,i) (r).multiport_addr1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MULTIPORT_ADDR1r_MPORT_ADDRf_GET(r,a) cdk_field_get((r).multiport_addr1,0,47,a)
#define BCM53101_A0_MULTIPORT_ADDR1r_MPORT_ADDRf_SET(r,a) cdk_field_set((r).multiport_addr1,0,47,a)
#define BCM53101_A0_MULTIPORT_ADDR1r_MPORT_E_TYPEf_GET(r) ((((r).multiport_addr1[1]) >> 16) & 0xffff)
#define BCM53101_A0_MULTIPORT_ADDR1r_MPORT_E_TYPEf_SET(r,f) (r).multiport_addr1[1]=(((r).multiport_addr1[1] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access MULTIPORT_ADDR1.
 *
 */
#define BCM53101_A0_READ_MULTIPORT_ADDR1r(u,r) cdk_robo_reg_read(u,BCM53101_A0_MULTIPORT_ADDR1r,(r._multiport_addr1),8)
#define BCM53101_A0_WRITE_MULTIPORT_ADDR1r(u,r) cdk_robo_reg_write(u,BCM53101_A0_MULTIPORT_ADDR1r,&(r._multiport_addr1),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MULTIPORT_ADDR1r BCM53101_A0_MULTIPORT_ADDR1r
#define MULTIPORT_ADDR1r_SIZE BCM53101_A0_MULTIPORT_ADDR1r_SIZE
typedef BCM53101_A0_MULTIPORT_ADDR1r_t MULTIPORT_ADDR1r_t;
#define MULTIPORT_ADDR1r_CLR BCM53101_A0_MULTIPORT_ADDR1r_CLR
#define MULTIPORT_ADDR1r_SET BCM53101_A0_MULTIPORT_ADDR1r_SET
#define MULTIPORT_ADDR1r_GET BCM53101_A0_MULTIPORT_ADDR1r_GET
#define MULTIPORT_ADDR1r_MPORT_ADDRf_GET BCM53101_A0_MULTIPORT_ADDR1r_MPORT_ADDRf_GET
#define MULTIPORT_ADDR1r_MPORT_ADDRf_SET BCM53101_A0_MULTIPORT_ADDR1r_MPORT_ADDRf_SET
#define MULTIPORT_ADDR1r_MPORT_E_TYPEf_GET BCM53101_A0_MULTIPORT_ADDR1r_MPORT_E_TYPEf_GET
#define MULTIPORT_ADDR1r_MPORT_E_TYPEf_SET BCM53101_A0_MULTIPORT_ADDR1r_MPORT_E_TYPEf_SET
#define READ_MULTIPORT_ADDR1r BCM53101_A0_READ_MULTIPORT_ADDR1r
#define WRITE_MULTIPORT_ADDR1r BCM53101_A0_WRITE_MULTIPORT_ADDR1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MULTIPORT_ADDR1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MULTIPORT_ADDR2
 * BLOCKS:   SYS
 * DESC:     Multiport Address 2 Register
 * SIZE:     64
 * FIELDS:
 *     MPORT_ADDR       Multiport Address 2.Allows a frames with a matching DA to this address to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 2 register.Must be enabled using the MPORT_ADDR_EN bit in the Global ARL Configuration register.
 *     MPORT_E_TYPE     Multiport Ethernet Type 2Allows a frames with a matching MPORT_E_TYPE to this Length Type field to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 2 register.Must be enabled using the MPORT_CTRLN bit in the MultiPort Control register.
 *
 ******************************************************************************/
#define BCM53101_A0_MULTIPORT_ADDR2r 0x00000430

#define BCM53101_A0_MULTIPORT_ADDR2r_SIZE 8

/*
 * This structure should be used to declare and program MULTIPORT_ADDR2.
 *
 */
typedef union BCM53101_A0_MULTIPORT_ADDR2r_s {
	uint32_t v[2];
	uint32_t multiport_addr2[2];
	uint32_t _multiport_addr2;
} BCM53101_A0_MULTIPORT_ADDR2r_t;

#define BCM53101_A0_MULTIPORT_ADDR2r_CLR(r) CDK_MEMSET(&((r)._multiport_addr2), 0, sizeof(BCM53101_A0_MULTIPORT_ADDR2r_t))
#define BCM53101_A0_MULTIPORT_ADDR2r_SET(r,i,d) (r).multiport_addr2[i] = d
#define BCM53101_A0_MULTIPORT_ADDR2r_GET(r,i) (r).multiport_addr2[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MULTIPORT_ADDR2r_MPORT_ADDRf_GET(r,a) cdk_field_get((r).multiport_addr2,0,47,a)
#define BCM53101_A0_MULTIPORT_ADDR2r_MPORT_ADDRf_SET(r,a) cdk_field_set((r).multiport_addr2,0,47,a)
#define BCM53101_A0_MULTIPORT_ADDR2r_MPORT_E_TYPEf_GET(r) ((((r).multiport_addr2[1]) >> 16) & 0xffff)
#define BCM53101_A0_MULTIPORT_ADDR2r_MPORT_E_TYPEf_SET(r,f) (r).multiport_addr2[1]=(((r).multiport_addr2[1] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access MULTIPORT_ADDR2.
 *
 */
#define BCM53101_A0_READ_MULTIPORT_ADDR2r(u,r) cdk_robo_reg_read(u,BCM53101_A0_MULTIPORT_ADDR2r,(r._multiport_addr2),8)
#define BCM53101_A0_WRITE_MULTIPORT_ADDR2r(u,r) cdk_robo_reg_write(u,BCM53101_A0_MULTIPORT_ADDR2r,&(r._multiport_addr2),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MULTIPORT_ADDR2r BCM53101_A0_MULTIPORT_ADDR2r
#define MULTIPORT_ADDR2r_SIZE BCM53101_A0_MULTIPORT_ADDR2r_SIZE
typedef BCM53101_A0_MULTIPORT_ADDR2r_t MULTIPORT_ADDR2r_t;
#define MULTIPORT_ADDR2r_CLR BCM53101_A0_MULTIPORT_ADDR2r_CLR
#define MULTIPORT_ADDR2r_SET BCM53101_A0_MULTIPORT_ADDR2r_SET
#define MULTIPORT_ADDR2r_GET BCM53101_A0_MULTIPORT_ADDR2r_GET
#define MULTIPORT_ADDR2r_MPORT_ADDRf_GET BCM53101_A0_MULTIPORT_ADDR2r_MPORT_ADDRf_GET
#define MULTIPORT_ADDR2r_MPORT_ADDRf_SET BCM53101_A0_MULTIPORT_ADDR2r_MPORT_ADDRf_SET
#define MULTIPORT_ADDR2r_MPORT_E_TYPEf_GET BCM53101_A0_MULTIPORT_ADDR2r_MPORT_E_TYPEf_GET
#define MULTIPORT_ADDR2r_MPORT_E_TYPEf_SET BCM53101_A0_MULTIPORT_ADDR2r_MPORT_E_TYPEf_SET
#define READ_MULTIPORT_ADDR2r BCM53101_A0_READ_MULTIPORT_ADDR2r
#define WRITE_MULTIPORT_ADDR2r BCM53101_A0_WRITE_MULTIPORT_ADDR2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MULTIPORT_ADDR2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MULTIPORT_ADDR3
 * BLOCKS:   SYS
 * DESC:     Multiport Address 3 Register
 * SIZE:     64
 * FIELDS:
 *     MPORT_ADDR       Multiport Address 3.Allows a frames with a matching DA to this address to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 3 register.Must be enabled using the MPORT_ADDR_EN bit in the Global ARL Configuration register.
 *     MPORT_E_TYPE     Multiport Ethernet Type 3Allows a frames with a matching MPORT_E_TYPE to this Length Type field to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 3 register.Must be enabled using the MPORT_CTRLN bit in the MultiPort Control register.
 *
 ******************************************************************************/
#define BCM53101_A0_MULTIPORT_ADDR3r 0x00000440

#define BCM53101_A0_MULTIPORT_ADDR3r_SIZE 8

/*
 * This structure should be used to declare and program MULTIPORT_ADDR3.
 *
 */
typedef union BCM53101_A0_MULTIPORT_ADDR3r_s {
	uint32_t v[2];
	uint32_t multiport_addr3[2];
	uint32_t _multiport_addr3;
} BCM53101_A0_MULTIPORT_ADDR3r_t;

#define BCM53101_A0_MULTIPORT_ADDR3r_CLR(r) CDK_MEMSET(&((r)._multiport_addr3), 0, sizeof(BCM53101_A0_MULTIPORT_ADDR3r_t))
#define BCM53101_A0_MULTIPORT_ADDR3r_SET(r,i,d) (r).multiport_addr3[i] = d
#define BCM53101_A0_MULTIPORT_ADDR3r_GET(r,i) (r).multiport_addr3[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MULTIPORT_ADDR3r_MPORT_ADDRf_GET(r,a) cdk_field_get((r).multiport_addr3,0,47,a)
#define BCM53101_A0_MULTIPORT_ADDR3r_MPORT_ADDRf_SET(r,a) cdk_field_set((r).multiport_addr3,0,47,a)
#define BCM53101_A0_MULTIPORT_ADDR3r_MPORT_E_TYPEf_GET(r) ((((r).multiport_addr3[1]) >> 16) & 0xffff)
#define BCM53101_A0_MULTIPORT_ADDR3r_MPORT_E_TYPEf_SET(r,f) (r).multiport_addr3[1]=(((r).multiport_addr3[1] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access MULTIPORT_ADDR3.
 *
 */
#define BCM53101_A0_READ_MULTIPORT_ADDR3r(u,r) cdk_robo_reg_read(u,BCM53101_A0_MULTIPORT_ADDR3r,(r._multiport_addr3),8)
#define BCM53101_A0_WRITE_MULTIPORT_ADDR3r(u,r) cdk_robo_reg_write(u,BCM53101_A0_MULTIPORT_ADDR3r,&(r._multiport_addr3),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MULTIPORT_ADDR3r BCM53101_A0_MULTIPORT_ADDR3r
#define MULTIPORT_ADDR3r_SIZE BCM53101_A0_MULTIPORT_ADDR3r_SIZE
typedef BCM53101_A0_MULTIPORT_ADDR3r_t MULTIPORT_ADDR3r_t;
#define MULTIPORT_ADDR3r_CLR BCM53101_A0_MULTIPORT_ADDR3r_CLR
#define MULTIPORT_ADDR3r_SET BCM53101_A0_MULTIPORT_ADDR3r_SET
#define MULTIPORT_ADDR3r_GET BCM53101_A0_MULTIPORT_ADDR3r_GET
#define MULTIPORT_ADDR3r_MPORT_ADDRf_GET BCM53101_A0_MULTIPORT_ADDR3r_MPORT_ADDRf_GET
#define MULTIPORT_ADDR3r_MPORT_ADDRf_SET BCM53101_A0_MULTIPORT_ADDR3r_MPORT_ADDRf_SET
#define MULTIPORT_ADDR3r_MPORT_E_TYPEf_GET BCM53101_A0_MULTIPORT_ADDR3r_MPORT_E_TYPEf_GET
#define MULTIPORT_ADDR3r_MPORT_E_TYPEf_SET BCM53101_A0_MULTIPORT_ADDR3r_MPORT_E_TYPEf_SET
#define READ_MULTIPORT_ADDR3r BCM53101_A0_READ_MULTIPORT_ADDR3r
#define WRITE_MULTIPORT_ADDR3r BCM53101_A0_WRITE_MULTIPORT_ADDR3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MULTIPORT_ADDR3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MULTIPORT_ADDR4
 * BLOCKS:   SYS
 * DESC:     Multiport Address 4 Register
 * SIZE:     64
 * FIELDS:
 *     MPORT_ADDR       Multiport Address 4.Allows a frames with a matching DA to this address to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 4 register.Must be enabled using the MPORT_ADDR_EN bit in the Global ARL Configuration register.
 *     MPORT_E_TYPE     Multiport Ethernet Type 4Allows a frames with a matching MPORT_E_TYPE to this Length Type field to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 4 register.Must be enabled using the MPORT_CTRLN bit in the MultiPort Control register.
 *
 ******************************************************************************/
#define BCM53101_A0_MULTIPORT_ADDR4r 0x00000450

#define BCM53101_A0_MULTIPORT_ADDR4r_SIZE 8

/*
 * This structure should be used to declare and program MULTIPORT_ADDR4.
 *
 */
typedef union BCM53101_A0_MULTIPORT_ADDR4r_s {
	uint32_t v[2];
	uint32_t multiport_addr4[2];
	uint32_t _multiport_addr4;
} BCM53101_A0_MULTIPORT_ADDR4r_t;

#define BCM53101_A0_MULTIPORT_ADDR4r_CLR(r) CDK_MEMSET(&((r)._multiport_addr4), 0, sizeof(BCM53101_A0_MULTIPORT_ADDR4r_t))
#define BCM53101_A0_MULTIPORT_ADDR4r_SET(r,i,d) (r).multiport_addr4[i] = d
#define BCM53101_A0_MULTIPORT_ADDR4r_GET(r,i) (r).multiport_addr4[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MULTIPORT_ADDR4r_MPORT_ADDRf_GET(r,a) cdk_field_get((r).multiport_addr4,0,47,a)
#define BCM53101_A0_MULTIPORT_ADDR4r_MPORT_ADDRf_SET(r,a) cdk_field_set((r).multiport_addr4,0,47,a)
#define BCM53101_A0_MULTIPORT_ADDR4r_MPORT_E_TYPEf_GET(r) ((((r).multiport_addr4[1]) >> 16) & 0xffff)
#define BCM53101_A0_MULTIPORT_ADDR4r_MPORT_E_TYPEf_SET(r,f) (r).multiport_addr4[1]=(((r).multiport_addr4[1] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access MULTIPORT_ADDR4.
 *
 */
#define BCM53101_A0_READ_MULTIPORT_ADDR4r(u,r) cdk_robo_reg_read(u,BCM53101_A0_MULTIPORT_ADDR4r,(r._multiport_addr4),8)
#define BCM53101_A0_WRITE_MULTIPORT_ADDR4r(u,r) cdk_robo_reg_write(u,BCM53101_A0_MULTIPORT_ADDR4r,&(r._multiport_addr4),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MULTIPORT_ADDR4r BCM53101_A0_MULTIPORT_ADDR4r
#define MULTIPORT_ADDR4r_SIZE BCM53101_A0_MULTIPORT_ADDR4r_SIZE
typedef BCM53101_A0_MULTIPORT_ADDR4r_t MULTIPORT_ADDR4r_t;
#define MULTIPORT_ADDR4r_CLR BCM53101_A0_MULTIPORT_ADDR4r_CLR
#define MULTIPORT_ADDR4r_SET BCM53101_A0_MULTIPORT_ADDR4r_SET
#define MULTIPORT_ADDR4r_GET BCM53101_A0_MULTIPORT_ADDR4r_GET
#define MULTIPORT_ADDR4r_MPORT_ADDRf_GET BCM53101_A0_MULTIPORT_ADDR4r_MPORT_ADDRf_GET
#define MULTIPORT_ADDR4r_MPORT_ADDRf_SET BCM53101_A0_MULTIPORT_ADDR4r_MPORT_ADDRf_SET
#define MULTIPORT_ADDR4r_MPORT_E_TYPEf_GET BCM53101_A0_MULTIPORT_ADDR4r_MPORT_E_TYPEf_GET
#define MULTIPORT_ADDR4r_MPORT_E_TYPEf_SET BCM53101_A0_MULTIPORT_ADDR4r_MPORT_E_TYPEf_SET
#define READ_MULTIPORT_ADDR4r BCM53101_A0_READ_MULTIPORT_ADDR4r
#define WRITE_MULTIPORT_ADDR4r BCM53101_A0_WRITE_MULTIPORT_ADDR4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MULTIPORT_ADDR4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MULTIPORT_ADDR5
 * BLOCKS:   SYS
 * DESC:     Multiport Address 5 Register
 * SIZE:     64
 * FIELDS:
 *     MPORT_ADDR       Multiport Address 5.Allows a frames with a matching DA to this address to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 5 register.Must be enabled using the MPORT_ADDR_EN bit in the Global ARL Configuration register.
 *     MPORT_E_TYPE     Multiport Ethernet Type 5Allows a frames with a matching MPORT_E_TYPE to this Length Type field to be forwarded to any programmable group of ports on the chip, as defined in the bit map in the Multiport Vector 5 register.Must be enabled using the MPORT_CTRLN bit in the MultiPort Control register.
 *
 ******************************************************************************/
#define BCM53101_A0_MULTIPORT_ADDR5r 0x00000460

#define BCM53101_A0_MULTIPORT_ADDR5r_SIZE 8

/*
 * This structure should be used to declare and program MULTIPORT_ADDR5.
 *
 */
typedef union BCM53101_A0_MULTIPORT_ADDR5r_s {
	uint32_t v[2];
	uint32_t multiport_addr5[2];
	uint32_t _multiport_addr5;
} BCM53101_A0_MULTIPORT_ADDR5r_t;

#define BCM53101_A0_MULTIPORT_ADDR5r_CLR(r) CDK_MEMSET(&((r)._multiport_addr5), 0, sizeof(BCM53101_A0_MULTIPORT_ADDR5r_t))
#define BCM53101_A0_MULTIPORT_ADDR5r_SET(r,i,d) (r).multiport_addr5[i] = d
#define BCM53101_A0_MULTIPORT_ADDR5r_GET(r,i) (r).multiport_addr5[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MULTIPORT_ADDR5r_MPORT_ADDRf_GET(r,a) cdk_field_get((r).multiport_addr5,0,47,a)
#define BCM53101_A0_MULTIPORT_ADDR5r_MPORT_ADDRf_SET(r,a) cdk_field_set((r).multiport_addr5,0,47,a)
#define BCM53101_A0_MULTIPORT_ADDR5r_MPORT_E_TYPEf_GET(r) ((((r).multiport_addr5[1]) >> 16) & 0xffff)
#define BCM53101_A0_MULTIPORT_ADDR5r_MPORT_E_TYPEf_SET(r,f) (r).multiport_addr5[1]=(((r).multiport_addr5[1] & ~((uint32_t)0xffff << 16)) | ((((uint32_t)f) & 0xffff) << 16))

/*
 * These macros can be used to access MULTIPORT_ADDR5.
 *
 */
#define BCM53101_A0_READ_MULTIPORT_ADDR5r(u,r) cdk_robo_reg_read(u,BCM53101_A0_MULTIPORT_ADDR5r,(r._multiport_addr5),8)
#define BCM53101_A0_WRITE_MULTIPORT_ADDR5r(u,r) cdk_robo_reg_write(u,BCM53101_A0_MULTIPORT_ADDR5r,&(r._multiport_addr5),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MULTIPORT_ADDR5r BCM53101_A0_MULTIPORT_ADDR5r
#define MULTIPORT_ADDR5r_SIZE BCM53101_A0_MULTIPORT_ADDR5r_SIZE
typedef BCM53101_A0_MULTIPORT_ADDR5r_t MULTIPORT_ADDR5r_t;
#define MULTIPORT_ADDR5r_CLR BCM53101_A0_MULTIPORT_ADDR5r_CLR
#define MULTIPORT_ADDR5r_SET BCM53101_A0_MULTIPORT_ADDR5r_SET
#define MULTIPORT_ADDR5r_GET BCM53101_A0_MULTIPORT_ADDR5r_GET
#define MULTIPORT_ADDR5r_MPORT_ADDRf_GET BCM53101_A0_MULTIPORT_ADDR5r_MPORT_ADDRf_GET
#define MULTIPORT_ADDR5r_MPORT_ADDRf_SET BCM53101_A0_MULTIPORT_ADDR5r_MPORT_ADDRf_SET
#define MULTIPORT_ADDR5r_MPORT_E_TYPEf_GET BCM53101_A0_MULTIPORT_ADDR5r_MPORT_E_TYPEf_GET
#define MULTIPORT_ADDR5r_MPORT_E_TYPEf_SET BCM53101_A0_MULTIPORT_ADDR5r_MPORT_E_TYPEf_SET
#define READ_MULTIPORT_ADDR5r BCM53101_A0_READ_MULTIPORT_ADDR5r
#define WRITE_MULTIPORT_ADDR5r BCM53101_A0_WRITE_MULTIPORT_ADDR5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MULTIPORT_ADDR5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  MULTI_PORT_CTL
 * BLOCKS:   SYS
 * DESC:     Multiport Control Register
 * SIZE:     16
 * FIELDS:
 *     MPORT_CTRL0      Multiport 0 Control .1'b00: Disable Multiport 0 Forward1'b10: Compare MPORT_ADD0 only, Forward based on MPORT_Vector 0 if matched1'b01: Compare MPORT_EYPE0 only, Forward based on MPORT_Vector 0 if matched1'b11: Compare MPORT_EYPE0 and MPORT_ADD0, Forward based on MPORT_Vector 0 if matched
 *     MPORT_CTRL1      Multiport 1 Control .1'b00: Disable Multiport 1 Forward1'b10: Compare MPORT_ADD1 only, Forward based on MPORT_Vector 1 if matched1'b01: Compare MPORT_EYPE1 only, Forward based on MPORT_Vector 1 if matched1'b11: Compare MPORT_EYPE1 and MPORT_ADD1, Forward based on MPORT_Vector 1 if matched
 *     MPORT_CTRL2      Multiport 2 Control .1'b00: Disable Multiport 2 Forward1'b10: Compare MPORT_ADD2 only, Forward based on MPORT_Vector 2 if matched1'b01: Compare MPORT_EYPE2 only, Forward based on MPORT_Vector 2 if matched1'b11: Compare MPORT_EYPE2 and MPORT_ADD2, Forward based on MPORT_Vector 2 if matched
 *     MPORT_CTRL3      Multiport 3 Control .1'b00: Disable Multiport 3 Forward1'b10: Compare MPORT_ADD3 only, Forward based on MPORT_Vector 3 if matched1'b01: Compare MPORT_EYPE3 only, Forward based on MPORT_Vector 3 if matched1'b11: Compare MPORT_EYPE3 and MPORT_ADD3, Forward based on MPORT_Vector 3 if matched
 *     MPORT_CTRL4      Multiport 4 Control .1'b00: Disable Multiport 4 Forward1'b10: Compare MPORT_ADD4 only, Forward based on MPORT_Vector 4 if matched1'b01: Compare MPORT_EYPE4 only, Forward based on MPORT_Vector 4 if matched1'b11: Compare MPORT_EYPE4 and MPORT_ADD4, Forward based on MPORT_Vector 4 if matched
 *     MPORT_CTRL5      Multiport 5 Control .1'b00: Disable Multiport 5 Forward1'b10: Compare MPORT_ADD5 only, Forward based on MPORT_Vector 5 if matched1'b01: Compare MPORT_EYPE5 only, Forward based on MPORT_Vector 5 if matched1'b11: Compare MPORT_EYPE5 and MPORT_ADD5, Forward based on MPORT_Vector 5 if matched
 *     RESERVED         Reserved
 *     MPORT0_TS_EN     Mport 0 Time Sync Enable1: Packet will be time stamped if forwarded to CPU.  MPORT_VECTOR0 should be programed to CPU only if the bit is set0: Packet will not be time-stamped
 *
 ******************************************************************************/
#define BCM53101_A0_MULTI_PORT_CTLr 0x0000040e

#define BCM53101_A0_MULTI_PORT_CTLr_SIZE 2

/*
 * This structure should be used to declare and program MULTI_PORT_CTL.
 *
 */
typedef union BCM53101_A0_MULTI_PORT_CTLr_s {
	uint32_t v[1];
	uint32_t multi_port_ctl[1];
	uint32_t _multi_port_ctl;
} BCM53101_A0_MULTI_PORT_CTLr_t;

#define BCM53101_A0_MULTI_PORT_CTLr_CLR(r) (r).multi_port_ctl[0] = 0
#define BCM53101_A0_MULTI_PORT_CTLr_SET(r,d) (r).multi_port_ctl[0] = d
#define BCM53101_A0_MULTI_PORT_CTLr_GET(r) (r).multi_port_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_MULTI_PORT_CTLr_MPORT_CTRL0f_GET(r) (((r).multi_port_ctl[0]) & 0x3)
#define BCM53101_A0_MULTI_PORT_CTLr_MPORT_CTRL0f_SET(r,f) (r).multi_port_ctl[0]=(((r).multi_port_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53101_A0_MULTI_PORT_CTLr_MPORT_CTRL1f_GET(r) ((((r).multi_port_ctl[0]) >> 2) & 0x3)
#define BCM53101_A0_MULTI_PORT_CTLr_MPORT_CTRL1f_SET(r,f) (r).multi_port_ctl[0]=(((r).multi_port_ctl[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53101_A0_MULTI_PORT_CTLr_MPORT_CTRL2f_GET(r) ((((r).multi_port_ctl[0]) >> 4) & 0x3)
#define BCM53101_A0_MULTI_PORT_CTLr_MPORT_CTRL2f_SET(r,f) (r).multi_port_ctl[0]=(((r).multi_port_ctl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53101_A0_MULTI_PORT_CTLr_MPORT_CTRL3f_GET(r) ((((r).multi_port_ctl[0]) >> 6) & 0x3)
#define BCM53101_A0_MULTI_PORT_CTLr_MPORT_CTRL3f_SET(r,f) (r).multi_port_ctl[0]=(((r).multi_port_ctl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53101_A0_MULTI_PORT_CTLr_MPORT_CTRL4f_GET(r) ((((r).multi_port_ctl[0]) >> 8) & 0x3)
#define BCM53101_A0_MULTI_PORT_CTLr_MPORT_CTRL4f_SET(r,f) (r).multi_port_ctl[0]=(((r).multi_port_ctl[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM53101_A0_MULTI_PORT_CTLr_MPORT_CTRL5f_GET(r) ((((r).multi_port_ctl[0]) >> 10) & 0x3)
#define BCM53101_A0_MULTI_PORT_CTLr_MPORT_CTRL5f_SET(r,f) (r).multi_port_ctl[0]=(((r).multi_port_ctl[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM53101_A0_MULTI_PORT_CTLr_RESERVEDf_GET(r) ((((r).multi_port_ctl[0]) >> 12) & 0x7)
#define BCM53101_A0_MULTI_PORT_CTLr_RESERVEDf_SET(r,f) (r).multi_port_ctl[0]=(((r).multi_port_ctl[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53101_A0_MULTI_PORT_CTLr_MPORT0_TS_ENf_GET(r) ((((r).multi_port_ctl[0]) >> 15) & 0x1)
#define BCM53101_A0_MULTI_PORT_CTLr_MPORT0_TS_ENf_SET(r,f) (r).multi_port_ctl[0]=(((r).multi_port_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access MULTI_PORT_CTL.
 *
 */
#define BCM53101_A0_READ_MULTI_PORT_CTLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_MULTI_PORT_CTLr,(r._multi_port_ctl),2)
#define BCM53101_A0_WRITE_MULTI_PORT_CTLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_MULTI_PORT_CTLr,&(r._multi_port_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define MULTI_PORT_CTLr BCM53101_A0_MULTI_PORT_CTLr
#define MULTI_PORT_CTLr_SIZE BCM53101_A0_MULTI_PORT_CTLr_SIZE
typedef BCM53101_A0_MULTI_PORT_CTLr_t MULTI_PORT_CTLr_t;
#define MULTI_PORT_CTLr_CLR BCM53101_A0_MULTI_PORT_CTLr_CLR
#define MULTI_PORT_CTLr_SET BCM53101_A0_MULTI_PORT_CTLr_SET
#define MULTI_PORT_CTLr_GET BCM53101_A0_MULTI_PORT_CTLr_GET
#define MULTI_PORT_CTLr_MPORT_CTRL0f_GET BCM53101_A0_MULTI_PORT_CTLr_MPORT_CTRL0f_GET
#define MULTI_PORT_CTLr_MPORT_CTRL0f_SET BCM53101_A0_MULTI_PORT_CTLr_MPORT_CTRL0f_SET
#define MULTI_PORT_CTLr_MPORT_CTRL1f_GET BCM53101_A0_MULTI_PORT_CTLr_MPORT_CTRL1f_GET
#define MULTI_PORT_CTLr_MPORT_CTRL1f_SET BCM53101_A0_MULTI_PORT_CTLr_MPORT_CTRL1f_SET
#define MULTI_PORT_CTLr_MPORT_CTRL2f_GET BCM53101_A0_MULTI_PORT_CTLr_MPORT_CTRL2f_GET
#define MULTI_PORT_CTLr_MPORT_CTRL2f_SET BCM53101_A0_MULTI_PORT_CTLr_MPORT_CTRL2f_SET
#define MULTI_PORT_CTLr_MPORT_CTRL3f_GET BCM53101_A0_MULTI_PORT_CTLr_MPORT_CTRL3f_GET
#define MULTI_PORT_CTLr_MPORT_CTRL3f_SET BCM53101_A0_MULTI_PORT_CTLr_MPORT_CTRL3f_SET
#define MULTI_PORT_CTLr_MPORT_CTRL4f_GET BCM53101_A0_MULTI_PORT_CTLr_MPORT_CTRL4f_GET
#define MULTI_PORT_CTLr_MPORT_CTRL4f_SET BCM53101_A0_MULTI_PORT_CTLr_MPORT_CTRL4f_SET
#define MULTI_PORT_CTLr_MPORT_CTRL5f_GET BCM53101_A0_MULTI_PORT_CTLr_MPORT_CTRL5f_GET
#define MULTI_PORT_CTLr_MPORT_CTRL5f_SET BCM53101_A0_MULTI_PORT_CTLr_MPORT_CTRL5f_SET
#define MULTI_PORT_CTLr_RESERVEDf_GET BCM53101_A0_MULTI_PORT_CTLr_RESERVEDf_GET
#define MULTI_PORT_CTLr_RESERVEDf_SET BCM53101_A0_MULTI_PORT_CTLr_RESERVEDf_SET
#define MULTI_PORT_CTLr_MPORT0_TS_ENf_GET BCM53101_A0_MULTI_PORT_CTLr_MPORT0_TS_ENf_GET
#define MULTI_PORT_CTLr_MPORT0_TS_ENf_SET BCM53101_A0_MULTI_PORT_CTLr_MPORT0_TS_ENf_SET
#define READ_MULTI_PORT_CTLr BCM53101_A0_READ_MULTI_PORT_CTLr
#define WRITE_MULTI_PORT_CTLr BCM53101_A0_WRITE_MULTI_PORT_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_MULTI_PORT_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  NEW_CTRL
 * BLOCKS:   SYS
 * DESC:     New Control Register
 * SIZE:     8
 * FIELDS:
 *     IP_MC            When set to a '1' it will support the new 4K IP multicast address scheme. It is illegal to set to zero.(Reserved for Engineering)
 *     OUTRANGEERR_DISCARD Out of Range Error DiscardWhen enabled, the ingress port will discard the frames with length field between 1500 and 1536 (exclude 1500 and 1536) and with good CRC. This option only controls the length field checking but not the frame length checking.
 *     INRANGEERR_DISCARD In Range Error DiscardWhen enabled, the ingress port will discard the frames with Length field mismatch the frame length. Following is the definition of InRangeErros. InRangeErrors Frames: The frames received with good CRC and one of the following. The value of Length/Type field is between 46 and 1500 inclusive, and does not match the number of(MAC Client Data + PAD)data octets received, OR The value of Length/Type field is less than 46, and the number of data octets received is greater than 46(which does not require padding).
 *     RESERVED         Reserved
 *     UC_FWD_EN        Unicast Forward Enable when ARL Miss.1: To enable DFL packet with unicast destination address to foward to ports defined as page 0,offset 34h.
 *     MC_FWD_EN        Multicast Foward Enable when ARL Miss.1: To enable DFL packet with multicast destination address to foward to the ports defined as page 0,offset 34h.
 *
 ******************************************************************************/
#define BCM53101_A0_NEW_CTRLr 0x00000021

#define BCM53101_A0_NEW_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program NEW_CTRL.
 *
 */
typedef union BCM53101_A0_NEW_CTRLr_s {
	uint32_t v[1];
	uint32_t new_ctrl[1];
	uint32_t _new_ctrl;
} BCM53101_A0_NEW_CTRLr_t;

#define BCM53101_A0_NEW_CTRLr_CLR(r) (r).new_ctrl[0] = 0
#define BCM53101_A0_NEW_CTRLr_SET(r,d) (r).new_ctrl[0] = d
#define BCM53101_A0_NEW_CTRLr_GET(r) (r).new_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_NEW_CTRLr_IP_MCf_GET(r) (((r).new_ctrl[0]) & 0x1)
#define BCM53101_A0_NEW_CTRLr_IP_MCf_SET(r,f) (r).new_ctrl[0]=(((r).new_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_NEW_CTRLr_OUTRANGEERR_DISCARDf_GET(r) ((((r).new_ctrl[0]) >> 1) & 0x1)
#define BCM53101_A0_NEW_CTRLr_OUTRANGEERR_DISCARDf_SET(r,f) (r).new_ctrl[0]=(((r).new_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_NEW_CTRLr_INRANGEERR_DISCARDf_GET(r) ((((r).new_ctrl[0]) >> 2) & 0x1)
#define BCM53101_A0_NEW_CTRLr_INRANGEERR_DISCARDf_SET(r,f) (r).new_ctrl[0]=(((r).new_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_NEW_CTRLr_RESERVEDf_GET(r) ((((r).new_ctrl[0]) >> 3) & 0x7)
#define BCM53101_A0_NEW_CTRLr_RESERVEDf_SET(r,f) (r).new_ctrl[0]=(((r).new_ctrl[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM53101_A0_NEW_CTRLr_UC_FWD_ENf_GET(r) ((((r).new_ctrl[0]) >> 6) & 0x1)
#define BCM53101_A0_NEW_CTRLr_UC_FWD_ENf_SET(r,f) (r).new_ctrl[0]=(((r).new_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_NEW_CTRLr_MC_FWD_ENf_GET(r) ((((r).new_ctrl[0]) >> 7) & 0x1)
#define BCM53101_A0_NEW_CTRLr_MC_FWD_ENf_SET(r,f) (r).new_ctrl[0]=(((r).new_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access NEW_CTRL.
 *
 */
#define BCM53101_A0_READ_NEW_CTRLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_NEW_CTRLr,(r._new_ctrl),1)
#define BCM53101_A0_WRITE_NEW_CTRLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_NEW_CTRLr,&(r._new_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define NEW_CTRLr BCM53101_A0_NEW_CTRLr
#define NEW_CTRLr_SIZE BCM53101_A0_NEW_CTRLr_SIZE
typedef BCM53101_A0_NEW_CTRLr_t NEW_CTRLr_t;
#define NEW_CTRLr_CLR BCM53101_A0_NEW_CTRLr_CLR
#define NEW_CTRLr_SET BCM53101_A0_NEW_CTRLr_SET
#define NEW_CTRLr_GET BCM53101_A0_NEW_CTRLr_GET
#define NEW_CTRLr_IP_MCf_GET BCM53101_A0_NEW_CTRLr_IP_MCf_GET
#define NEW_CTRLr_IP_MCf_SET BCM53101_A0_NEW_CTRLr_IP_MCf_SET
#define NEW_CTRLr_OUTRANGEERR_DISCARDf_GET BCM53101_A0_NEW_CTRLr_OUTRANGEERR_DISCARDf_GET
#define NEW_CTRLr_OUTRANGEERR_DISCARDf_SET BCM53101_A0_NEW_CTRLr_OUTRANGEERR_DISCARDf_SET
#define NEW_CTRLr_INRANGEERR_DISCARDf_GET BCM53101_A0_NEW_CTRLr_INRANGEERR_DISCARDf_GET
#define NEW_CTRLr_INRANGEERR_DISCARDf_SET BCM53101_A0_NEW_CTRLr_INRANGEERR_DISCARDf_SET
#define NEW_CTRLr_RESERVEDf_GET BCM53101_A0_NEW_CTRLr_RESERVEDf_GET
#define NEW_CTRLr_RESERVEDf_SET BCM53101_A0_NEW_CTRLr_RESERVEDf_SET
#define NEW_CTRLr_UC_FWD_ENf_GET BCM53101_A0_NEW_CTRLr_UC_FWD_ENf_GET
#define NEW_CTRLr_UC_FWD_ENf_SET BCM53101_A0_NEW_CTRLr_UC_FWD_ENf_SET
#define NEW_CTRLr_MC_FWD_ENf_GET BCM53101_A0_NEW_CTRLr_MC_FWD_ENf_GET
#define NEW_CTRLr_MC_FWD_ENf_SET BCM53101_A0_NEW_CTRLr_MC_FWD_ENf_SET
#define READ_NEW_CTRLr BCM53101_A0_READ_NEW_CTRLr
#define WRITE_NEW_CTRLr BCM53101_A0_WRITE_NEW_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_NEW_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  OTP_CTL_REG
 * BLOCKS:   SYS
 * DESC:     CPU OTP Control Registers
 * SIZE:     32
 * FIELDS:
 *     START            
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_OTP_CTL_REGr 0x0000e000

#define BCM53101_A0_OTP_CTL_REGr_SIZE 4

/*
 * This structure should be used to declare and program OTP_CTL_REG.
 *
 */
typedef union BCM53101_A0_OTP_CTL_REGr_s {
	uint32_t v[1];
	uint32_t otp_ctl_reg[1];
	uint32_t _otp_ctl_reg;
} BCM53101_A0_OTP_CTL_REGr_t;

#define BCM53101_A0_OTP_CTL_REGr_CLR(r) (r).otp_ctl_reg[0] = 0
#define BCM53101_A0_OTP_CTL_REGr_SET(r,d) (r).otp_ctl_reg[0] = d
#define BCM53101_A0_OTP_CTL_REGr_GET(r) (r).otp_ctl_reg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_OTP_CTL_REGr_STARTf_GET(r) (((r).otp_ctl_reg[0]) & 0x1)
#define BCM53101_A0_OTP_CTL_REGr_STARTf_SET(r,f) (r).otp_ctl_reg[0]=(((r).otp_ctl_reg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_OTP_CTL_REGr_RESERVEDf_GET(r) ((((r).otp_ctl_reg[0]) >> 1) & 0x7fffffff)
#define BCM53101_A0_OTP_CTL_REGr_RESERVEDf_SET(r,f) (r).otp_ctl_reg[0]=(((r).otp_ctl_reg[0] & ~((uint32_t)0x7fffffff << 1)) | ((((uint32_t)f) & 0x7fffffff) << 1))

/*
 * These macros can be used to access OTP_CTL_REG.
 *
 */
#define BCM53101_A0_READ_OTP_CTL_REGr(u,r) cdk_robo_reg_read(u,BCM53101_A0_OTP_CTL_REGr,(r._otp_ctl_reg),4)
#define BCM53101_A0_WRITE_OTP_CTL_REGr(u,r) cdk_robo_reg_write(u,BCM53101_A0_OTP_CTL_REGr,&(r._otp_ctl_reg),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OTP_CTL_REGr BCM53101_A0_OTP_CTL_REGr
#define OTP_CTL_REGr_SIZE BCM53101_A0_OTP_CTL_REGr_SIZE
typedef BCM53101_A0_OTP_CTL_REGr_t OTP_CTL_REGr_t;
#define OTP_CTL_REGr_CLR BCM53101_A0_OTP_CTL_REGr_CLR
#define OTP_CTL_REGr_SET BCM53101_A0_OTP_CTL_REGr_SET
#define OTP_CTL_REGr_GET BCM53101_A0_OTP_CTL_REGr_GET
#define OTP_CTL_REGr_STARTf_GET BCM53101_A0_OTP_CTL_REGr_STARTf_GET
#define OTP_CTL_REGr_STARTf_SET BCM53101_A0_OTP_CTL_REGr_STARTf_SET
#define OTP_CTL_REGr_RESERVEDf_GET BCM53101_A0_OTP_CTL_REGr_RESERVEDf_GET
#define OTP_CTL_REGr_RESERVEDf_SET BCM53101_A0_OTP_CTL_REGr_RESERVEDf_SET
#define READ_OTP_CTL_REGr BCM53101_A0_READ_OTP_CTL_REGr
#define WRITE_OTP_CTL_REGr BCM53101_A0_WRITE_OTP_CTL_REGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_OTP_CTL_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  OutRangeErrCount
 * BLOCKS:   EPIC0 CPIC
 * DESC:     OutRangeErrCount Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_OUTRANGEERRCOUNTr 0x000020b4

#define BCM53101_A0_OUTRANGEERRCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program OutRangeErrCount.
 *
 */
typedef union BCM53101_A0_OUTRANGEERRCOUNTr_s {
	uint32_t v[1];
	uint32_t outrangeerrcount[1];
	uint32_t _outrangeerrcount;
} BCM53101_A0_OUTRANGEERRCOUNTr_t;

#define BCM53101_A0_OUTRANGEERRCOUNTr_CLR(r) (r).outrangeerrcount[0] = 0
#define BCM53101_A0_OUTRANGEERRCOUNTr_SET(r,d) (r).outrangeerrcount[0] = d
#define BCM53101_A0_OUTRANGEERRCOUNTr_GET(r) (r).outrangeerrcount[0]


/*
 * These macros can be used to access OutRangeErrCount.
 *
 */
#define BCM53101_A0_READ_OUTRANGEERRCOUNTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_OUTRANGEERRCOUNTr,(r._outrangeerrcount),4)
#define BCM53101_A0_WRITE_OUTRANGEERRCOUNTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_OUTRANGEERRCOUNTr,&(r._outrangeerrcount),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OUTRANGEERRCOUNTr BCM53101_A0_OUTRANGEERRCOUNTr
#define OUTRANGEERRCOUNTr_SIZE BCM53101_A0_OUTRANGEERRCOUNTr_SIZE
typedef BCM53101_A0_OUTRANGEERRCOUNTr_t OUTRANGEERRCOUNTr_t;
#define OUTRANGEERRCOUNTr_CLR BCM53101_A0_OUTRANGEERRCOUNTr_CLR
#define OUTRANGEERRCOUNTr_SET BCM53101_A0_OUTRANGEERRCOUNTr_SET
#define OUTRANGEERRCOUNTr_GET BCM53101_A0_OUTRANGEERRCOUNTr_GET
#define READ_OUTRANGEERRCOUNTr BCM53101_A0_READ_OUTRANGEERRCOUNTr
#define WRITE_OUTRANGEERRCOUNTr BCM53101_A0_WRITE_OUTRANGEERRCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_OUTRANGEERRCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  OutRangeErrCount_IMP
 * BLOCKS:   CPIC
 * DESC:     OutRangeErrCount Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_OUTRANGEERRCOUNT_IMPr 0x000028b4

#define BCM53101_A0_OUTRANGEERRCOUNT_IMPr_SIZE 4

/*
 * This structure should be used to declare and program OutRangeErrCount_IMP.
 *
 */
typedef union BCM53101_A0_OUTRANGEERRCOUNT_IMPr_s {
	uint32_t v[1];
	uint32_t outrangeerrcount_imp[1];
	uint32_t _outrangeerrcount_imp;
} BCM53101_A0_OUTRANGEERRCOUNT_IMPr_t;

#define BCM53101_A0_OUTRANGEERRCOUNT_IMPr_CLR(r) (r).outrangeerrcount_imp[0] = 0
#define BCM53101_A0_OUTRANGEERRCOUNT_IMPr_SET(r,d) (r).outrangeerrcount_imp[0] = d
#define BCM53101_A0_OUTRANGEERRCOUNT_IMPr_GET(r) (r).outrangeerrcount_imp[0]


/*
 * These macros can be used to access OutRangeErrCount_IMP.
 *
 */
#define BCM53101_A0_READ_OUTRANGEERRCOUNT_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_OUTRANGEERRCOUNT_IMPr,(r._outrangeerrcount_imp),4)
#define BCM53101_A0_WRITE_OUTRANGEERRCOUNT_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_OUTRANGEERRCOUNT_IMPr,&(r._outrangeerrcount_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define OUTRANGEERRCOUNT_IMPr BCM53101_A0_OUTRANGEERRCOUNT_IMPr
#define OUTRANGEERRCOUNT_IMPr_SIZE BCM53101_A0_OUTRANGEERRCOUNT_IMPr_SIZE
typedef BCM53101_A0_OUTRANGEERRCOUNT_IMPr_t OUTRANGEERRCOUNT_IMPr_t;
#define OUTRANGEERRCOUNT_IMPr_CLR BCM53101_A0_OUTRANGEERRCOUNT_IMPr_CLR
#define OUTRANGEERRCOUNT_IMPr_SET BCM53101_A0_OUTRANGEERRCOUNT_IMPr_SET
#define OUTRANGEERRCOUNT_IMPr_GET BCM53101_A0_OUTRANGEERRCOUNT_IMPr_GET
#define READ_OUTRANGEERRCOUNT_IMPr BCM53101_A0_READ_OUTRANGEERRCOUNT_IMPr
#define WRITE_OUTRANGEERRCOUNT_IMPr BCM53101_A0_WRITE_OUTRANGEERRCOUNT_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_OUTRANGEERRCOUNT_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  P5_RGMII_TIME_DLY_GP
 * BLOCKS:   CPIC
 * DESC:     Port 5 RGMII TIMING DELAY register
 * SIZE:     8
 * FIELDS:
 *     DEL_ADDR         delay timing selection4'b0111 : clk_gtxt = 1'b14'b1000 : clk_gtxg = 1'b14'b1001 : clk_gtxr = 1'b14'b1010 : clk_rxg = 1'b14'b1011 : clk_rxr = 1'b14'b1100 : Reserved4'b1101 : Reserved
 *     DEL_VALUE        110 =-1.0x111 = -0.5x000 = 0.0x001 = +0.5x010 = +1.0x
 *     DEL_STRB         Delay Value Write Enable1: CPU over-write Enable, del_value and del_addr will affect the RGMII interface timing adjustment0: Del_value and del_addr will not affect RGMII interface timing adjustment
 *
 ******************************************************************************/
#define BCM53101_A0_P5_RGMII_TIME_DLY_GPr 0x0000006d

#define BCM53101_A0_P5_RGMII_TIME_DLY_GPr_SIZE 1

/*
 * This structure should be used to declare and program P5_RGMII_TIME_DLY_GP.
 *
 */
typedef union BCM53101_A0_P5_RGMII_TIME_DLY_GPr_s {
	uint32_t v[1];
	uint32_t p5_rgmii_time_dly_gp[1];
	uint32_t _p5_rgmii_time_dly_gp;
} BCM53101_A0_P5_RGMII_TIME_DLY_GPr_t;

#define BCM53101_A0_P5_RGMII_TIME_DLY_GPr_CLR(r) (r).p5_rgmii_time_dly_gp[0] = 0
#define BCM53101_A0_P5_RGMII_TIME_DLY_GPr_SET(r,d) (r).p5_rgmii_time_dly_gp[0] = d
#define BCM53101_A0_P5_RGMII_TIME_DLY_GPr_GET(r) (r).p5_rgmii_time_dly_gp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_P5_RGMII_TIME_DLY_GPr_DEL_ADDRf_GET(r) (((r).p5_rgmii_time_dly_gp[0]) & 0xf)
#define BCM53101_A0_P5_RGMII_TIME_DLY_GPr_DEL_ADDRf_SET(r,f) (r).p5_rgmii_time_dly_gp[0]=(((r).p5_rgmii_time_dly_gp[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53101_A0_P5_RGMII_TIME_DLY_GPr_DEL_VALUEf_GET(r) ((((r).p5_rgmii_time_dly_gp[0]) >> 4) & 0x7)
#define BCM53101_A0_P5_RGMII_TIME_DLY_GPr_DEL_VALUEf_SET(r,f) (r).p5_rgmii_time_dly_gp[0]=(((r).p5_rgmii_time_dly_gp[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM53101_A0_P5_RGMII_TIME_DLY_GPr_DEL_STRBf_GET(r) ((((r).p5_rgmii_time_dly_gp[0]) >> 7) & 0x1)
#define BCM53101_A0_P5_RGMII_TIME_DLY_GPr_DEL_STRBf_SET(r,f) (r).p5_rgmii_time_dly_gp[0]=(((r).p5_rgmii_time_dly_gp[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access P5_RGMII_TIME_DLY_GP.
 *
 */
#define BCM53101_A0_READ_P5_RGMII_TIME_DLY_GPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_P5_RGMII_TIME_DLY_GPr,(r._p5_rgmii_time_dly_gp),1)
#define BCM53101_A0_WRITE_P5_RGMII_TIME_DLY_GPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_P5_RGMII_TIME_DLY_GPr,&(r._p5_rgmii_time_dly_gp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define P5_RGMII_TIME_DLY_GPr BCM53101_A0_P5_RGMII_TIME_DLY_GPr
#define P5_RGMII_TIME_DLY_GPr_SIZE BCM53101_A0_P5_RGMII_TIME_DLY_GPr_SIZE
typedef BCM53101_A0_P5_RGMII_TIME_DLY_GPr_t P5_RGMII_TIME_DLY_GPr_t;
#define P5_RGMII_TIME_DLY_GPr_CLR BCM53101_A0_P5_RGMII_TIME_DLY_GPr_CLR
#define P5_RGMII_TIME_DLY_GPr_SET BCM53101_A0_P5_RGMII_TIME_DLY_GPr_SET
#define P5_RGMII_TIME_DLY_GPr_GET BCM53101_A0_P5_RGMII_TIME_DLY_GPr_GET
#define P5_RGMII_TIME_DLY_GPr_DEL_ADDRf_GET BCM53101_A0_P5_RGMII_TIME_DLY_GPr_DEL_ADDRf_GET
#define P5_RGMII_TIME_DLY_GPr_DEL_ADDRf_SET BCM53101_A0_P5_RGMII_TIME_DLY_GPr_DEL_ADDRf_SET
#define P5_RGMII_TIME_DLY_GPr_DEL_VALUEf_GET BCM53101_A0_P5_RGMII_TIME_DLY_GPr_DEL_VALUEf_GET
#define P5_RGMII_TIME_DLY_GPr_DEL_VALUEf_SET BCM53101_A0_P5_RGMII_TIME_DLY_GPr_DEL_VALUEf_SET
#define P5_RGMII_TIME_DLY_GPr_DEL_STRBf_GET BCM53101_A0_P5_RGMII_TIME_DLY_GPr_DEL_STRBf_GET
#define P5_RGMII_TIME_DLY_GPr_DEL_STRBf_SET BCM53101_A0_P5_RGMII_TIME_DLY_GPr_DEL_STRBf_SET
#define READ_P5_RGMII_TIME_DLY_GPr BCM53101_A0_READ_P5_RGMII_TIME_DLY_GPr
#define WRITE_P5_RGMII_TIME_DLY_GPr BCM53101_A0_WRITE_P5_RGMII_TIME_DLY_GPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_P5_RGMII_TIME_DLY_GPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  PAGEREG
 * BLOCKS:   SYS
 * DESC:     PAGE Control Registers
 * SIZE:     8
 * FIELDS:
 *     RESERVED         Next Page
 *
 ******************************************************************************/
#define BCM53101_A0_PAGEREGr 0x0000ffff

#define BCM53101_A0_PAGEREGr_SIZE 1

/*
 * This structure should be used to declare and program PAGEREG.
 *
 */
typedef union BCM53101_A0_PAGEREGr_s {
	uint32_t v[1];
	uint32_t pagereg[1];
	uint32_t _pagereg;
} BCM53101_A0_PAGEREGr_t;

#define BCM53101_A0_PAGEREGr_CLR(r) (r).pagereg[0] = 0
#define BCM53101_A0_PAGEREGr_SET(r,d) (r).pagereg[0] = d
#define BCM53101_A0_PAGEREGr_GET(r) (r).pagereg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_PAGEREGr_RESERVEDf_GET(r) (((r).pagereg[0]) & 0xff)
#define BCM53101_A0_PAGEREGr_RESERVEDf_SET(r,f) (r).pagereg[0]=(((r).pagereg[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access PAGEREG.
 *
 */
#define BCM53101_A0_READ_PAGEREGr(u,r) cdk_robo_reg_read(u,BCM53101_A0_PAGEREGr,(r._pagereg),1)
#define BCM53101_A0_WRITE_PAGEREGr(u,r) cdk_robo_reg_write(u,BCM53101_A0_PAGEREGr,&(r._pagereg),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PAGEREGr BCM53101_A0_PAGEREGr
#define PAGEREGr_SIZE BCM53101_A0_PAGEREGr_SIZE
typedef BCM53101_A0_PAGEREGr_t PAGEREGr_t;
#define PAGEREGr_CLR BCM53101_A0_PAGEREGr_CLR
#define PAGEREGr_SET BCM53101_A0_PAGEREGr_SET
#define PAGEREGr_GET BCM53101_A0_PAGEREGr_GET
#define PAGEREGr_RESERVEDf_GET BCM53101_A0_PAGEREGr_RESERVEDf_GET
#define PAGEREGr_RESERVEDf_SET BCM53101_A0_PAGEREGr_RESERVEDf_SET
#define READ_PAGEREGr BCM53101_A0_READ_PAGEREGr
#define WRITE_PAGEREGr BCM53101_A0_WRITE_PAGEREGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PAGEREGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  PAUSESTS
 * BLOCKS:   SYS
 * DESC:     Pause Status Summary Register
 * SIZE:     32
 * FIELDS:
 *     PAUSE_STS        PAUSE State.18 bit field indicating the PAUSE state for each 10/100/1000BASE-T port and IMP port.Bit 8- 0 = IMP port, Port 7 - Port 0 Transmit Pause CapabilityBit 17-9 = IMP port, Port 7 - Port 0 Receive Pause Capability0 = Disabled1 = Enabled
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_PAUSESTSr 0x0000010a

#define BCM53101_A0_PAUSESTSr_SIZE 4

/*
 * This structure should be used to declare and program PAUSESTS.
 *
 */
typedef union BCM53101_A0_PAUSESTSr_s {
	uint32_t v[1];
	uint32_t pausests[1];
	uint32_t _pausests;
} BCM53101_A0_PAUSESTSr_t;

#define BCM53101_A0_PAUSESTSr_CLR(r) (r).pausests[0] = 0
#define BCM53101_A0_PAUSESTSr_SET(r,d) (r).pausests[0] = d
#define BCM53101_A0_PAUSESTSr_GET(r) (r).pausests[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_PAUSESTSr_PAUSE_STSf_GET(r) (((r).pausests[0]) & 0x3ffff)
#define BCM53101_A0_PAUSESTSr_PAUSE_STSf_SET(r,f) (r).pausests[0]=(((r).pausests[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))
#define BCM53101_A0_PAUSESTSr_RESERVEDf_GET(r) ((((r).pausests[0]) >> 18) & 0x3fff)
#define BCM53101_A0_PAUSESTSr_RESERVEDf_SET(r,f) (r).pausests[0]=(((r).pausests[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access PAUSESTS.
 *
 */
#define BCM53101_A0_READ_PAUSESTSr(u,r) cdk_robo_reg_read(u,BCM53101_A0_PAUSESTSr,(r._pausests),4)
#define BCM53101_A0_WRITE_PAUSESTSr(u,r) cdk_robo_reg_write(u,BCM53101_A0_PAUSESTSr,&(r._pausests),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PAUSESTSr BCM53101_A0_PAUSESTSr
#define PAUSESTSr_SIZE BCM53101_A0_PAUSESTSr_SIZE
typedef BCM53101_A0_PAUSESTSr_t PAUSESTSr_t;
#define PAUSESTSr_CLR BCM53101_A0_PAUSESTSr_CLR
#define PAUSESTSr_SET BCM53101_A0_PAUSESTSr_SET
#define PAUSESTSr_GET BCM53101_A0_PAUSESTSr_GET
#define PAUSESTSr_PAUSE_STSf_GET BCM53101_A0_PAUSESTSr_PAUSE_STSf_GET
#define PAUSESTSr_PAUSE_STSf_SET BCM53101_A0_PAUSESTSr_PAUSE_STSf_SET
#define PAUSESTSr_RESERVEDf_GET BCM53101_A0_PAUSESTSr_RESERVEDf_GET
#define PAUSESTSr_RESERVEDf_SET BCM53101_A0_PAUSESTSr_RESERVEDf_SET
#define READ_PAUSESTSr BCM53101_A0_READ_PAUSESTSr
#define WRITE_PAUSESTSr BCM53101_A0_WRITE_PAUSESTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PAUSESTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  PAUSE_CAP
 * BLOCKS:   SYS
 * DESC:     PAUSE Capability Register
 * SIZE:     32
 * FIELDS:
 *     TX_PAUSE_CAP     Software setting for the capability of Transmitting Pause Frame.Bit 8 = Port 8.Bits 5:0 = Port 5 - Port 0.
 *     RX_PAUSE_CAP     Software setting for the capability of Receiving Pause Frame.Bit 17 = Port 8,Bits 16:9 = Port 7- Port 0.
 *     RESERVED         Reserved
 *     EN_OVERRIDE      Force the contents of the register to be used.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_PAUSE_CAPr 0x00000028

#define BCM53101_A0_PAUSE_CAPr_SIZE 4

/*
 * This structure should be used to declare and program PAUSE_CAP.
 *
 */
typedef union BCM53101_A0_PAUSE_CAPr_s {
	uint32_t v[1];
	uint32_t pause_cap[1];
	uint32_t _pause_cap;
} BCM53101_A0_PAUSE_CAPr_t;

#define BCM53101_A0_PAUSE_CAPr_CLR(r) (r).pause_cap[0] = 0
#define BCM53101_A0_PAUSE_CAPr_SET(r,d) (r).pause_cap[0] = d
#define BCM53101_A0_PAUSE_CAPr_GET(r) (r).pause_cap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_PAUSE_CAPr_TX_PAUSE_CAPf_GET(r) (((r).pause_cap[0]) & 0x1ff)
#define BCM53101_A0_PAUSE_CAPr_TX_PAUSE_CAPf_SET(r,f) (r).pause_cap[0]=(((r).pause_cap[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_PAUSE_CAPr_RX_PAUSE_CAPf_GET(r) ((((r).pause_cap[0]) >> 9) & 0x1ff)
#define BCM53101_A0_PAUSE_CAPr_RX_PAUSE_CAPf_SET(r,f) (r).pause_cap[0]=(((r).pause_cap[0] & ~((uint32_t)0x1ff << 9)) | ((((uint32_t)f) & 0x1ff) << 9))
#define BCM53101_A0_PAUSE_CAPr_RESERVEDf_GET(r) ((((r).pause_cap[0]) >> 18) & 0x1f)
#define BCM53101_A0_PAUSE_CAPr_RESERVEDf_SET(r,f) (r).pause_cap[0]=(((r).pause_cap[0] & ~((uint32_t)0x1f << 18)) | ((((uint32_t)f) & 0x1f) << 18))
#define BCM53101_A0_PAUSE_CAPr_EN_OVERRIDEf_GET(r) ((((r).pause_cap[0]) >> 23) & 0x1)
#define BCM53101_A0_PAUSE_CAPr_EN_OVERRIDEf_SET(r,f) (r).pause_cap[0]=(((r).pause_cap[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))
#define BCM53101_A0_PAUSE_CAPr_RESERVED_1f_GET(r) ((((r).pause_cap[0]) >> 24) & 0xff)
#define BCM53101_A0_PAUSE_CAPr_RESERVED_1f_SET(r,f) (r).pause_cap[0]=(((r).pause_cap[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access PAUSE_CAP.
 *
 */
#define BCM53101_A0_READ_PAUSE_CAPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_PAUSE_CAPr,(r._pause_cap),4)
#define BCM53101_A0_WRITE_PAUSE_CAPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_PAUSE_CAPr,&(r._pause_cap),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PAUSE_CAPr BCM53101_A0_PAUSE_CAPr
#define PAUSE_CAPr_SIZE BCM53101_A0_PAUSE_CAPr_SIZE
typedef BCM53101_A0_PAUSE_CAPr_t PAUSE_CAPr_t;
#define PAUSE_CAPr_CLR BCM53101_A0_PAUSE_CAPr_CLR
#define PAUSE_CAPr_SET BCM53101_A0_PAUSE_CAPr_SET
#define PAUSE_CAPr_GET BCM53101_A0_PAUSE_CAPr_GET
#define PAUSE_CAPr_TX_PAUSE_CAPf_GET BCM53101_A0_PAUSE_CAPr_TX_PAUSE_CAPf_GET
#define PAUSE_CAPr_TX_PAUSE_CAPf_SET BCM53101_A0_PAUSE_CAPr_TX_PAUSE_CAPf_SET
#define PAUSE_CAPr_RX_PAUSE_CAPf_GET BCM53101_A0_PAUSE_CAPr_RX_PAUSE_CAPf_GET
#define PAUSE_CAPr_RX_PAUSE_CAPf_SET BCM53101_A0_PAUSE_CAPr_RX_PAUSE_CAPf_SET
#define PAUSE_CAPr_RESERVEDf_GET BCM53101_A0_PAUSE_CAPr_RESERVEDf_GET
#define PAUSE_CAPr_RESERVEDf_SET BCM53101_A0_PAUSE_CAPr_RESERVEDf_SET
#define PAUSE_CAPr_EN_OVERRIDEf_GET BCM53101_A0_PAUSE_CAPr_EN_OVERRIDEf_GET
#define PAUSE_CAPr_EN_OVERRIDEf_SET BCM53101_A0_PAUSE_CAPr_EN_OVERRIDEf_SET
#define PAUSE_CAPr_RESERVED_1f_GET BCM53101_A0_PAUSE_CAPr_RESERVED_1f_GET
#define PAUSE_CAPr_RESERVED_1f_SET BCM53101_A0_PAUSE_CAPr_RESERVED_1f_SET
#define READ_PAUSE_CAPr BCM53101_A0_READ_PAUSE_CAPr
#define WRITE_PAUSE_CAPr BCM53101_A0_WRITE_PAUSE_CAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PAUSE_CAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  PAUSE_FRM_CTRL
 * BLOCKS:   SYS
 * DESC:     Pause Frame Detection Control Registrer
 * SIZE:     8
 * FIELDS:
 *     PAUSE_IGNORE_DA  Pause_ignore_DA0: Check DA field on Pause Frame detection1: Ignore DA field on Pause Frame detection
 *     RESERVED_1       Reserved, Should SET 2'b00 for correct operation
 *     RESERVED_2       Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_PAUSE_FRM_CTRLr 0x00000080

#define BCM53101_A0_PAUSE_FRM_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program PAUSE_FRM_CTRL.
 *
 */
typedef union BCM53101_A0_PAUSE_FRM_CTRLr_s {
	uint32_t v[1];
	uint32_t pause_frm_ctrl[1];
	uint32_t _pause_frm_ctrl;
} BCM53101_A0_PAUSE_FRM_CTRLr_t;

#define BCM53101_A0_PAUSE_FRM_CTRLr_CLR(r) (r).pause_frm_ctrl[0] = 0
#define BCM53101_A0_PAUSE_FRM_CTRLr_SET(r,d) (r).pause_frm_ctrl[0] = d
#define BCM53101_A0_PAUSE_FRM_CTRLr_GET(r) (r).pause_frm_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_PAUSE_FRM_CTRLr_PAUSE_IGNORE_DAf_GET(r) (((r).pause_frm_ctrl[0]) & 0x1)
#define BCM53101_A0_PAUSE_FRM_CTRLr_PAUSE_IGNORE_DAf_SET(r,f) (r).pause_frm_ctrl[0]=(((r).pause_frm_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_PAUSE_FRM_CTRLr_RESERVED_1f_GET(r) ((((r).pause_frm_ctrl[0]) >> 1) & 0x3)
#define BCM53101_A0_PAUSE_FRM_CTRLr_RESERVED_1f_SET(r,f) (r).pause_frm_ctrl[0]=(((r).pause_frm_ctrl[0] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1))
#define BCM53101_A0_PAUSE_FRM_CTRLr_RESERVED_2f_GET(r) ((((r).pause_frm_ctrl[0]) >> 3) & 0x1f)
#define BCM53101_A0_PAUSE_FRM_CTRLr_RESERVED_2f_SET(r,f) (r).pause_frm_ctrl[0]=(((r).pause_frm_ctrl[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3))

/*
 * These macros can be used to access PAUSE_FRM_CTRL.
 *
 */
#define BCM53101_A0_READ_PAUSE_FRM_CTRLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_PAUSE_FRM_CTRLr,(r._pause_frm_ctrl),1)
#define BCM53101_A0_WRITE_PAUSE_FRM_CTRLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_PAUSE_FRM_CTRLr,&(r._pause_frm_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PAUSE_FRM_CTRLr BCM53101_A0_PAUSE_FRM_CTRLr
#define PAUSE_FRM_CTRLr_SIZE BCM53101_A0_PAUSE_FRM_CTRLr_SIZE
typedef BCM53101_A0_PAUSE_FRM_CTRLr_t PAUSE_FRM_CTRLr_t;
#define PAUSE_FRM_CTRLr_CLR BCM53101_A0_PAUSE_FRM_CTRLr_CLR
#define PAUSE_FRM_CTRLr_SET BCM53101_A0_PAUSE_FRM_CTRLr_SET
#define PAUSE_FRM_CTRLr_GET BCM53101_A0_PAUSE_FRM_CTRLr_GET
#define PAUSE_FRM_CTRLr_PAUSE_IGNORE_DAf_GET BCM53101_A0_PAUSE_FRM_CTRLr_PAUSE_IGNORE_DAf_GET
#define PAUSE_FRM_CTRLr_PAUSE_IGNORE_DAf_SET BCM53101_A0_PAUSE_FRM_CTRLr_PAUSE_IGNORE_DAf_SET
#define PAUSE_FRM_CTRLr_RESERVED_1f_GET BCM53101_A0_PAUSE_FRM_CTRLr_RESERVED_1f_GET
#define PAUSE_FRM_CTRLr_RESERVED_1f_SET BCM53101_A0_PAUSE_FRM_CTRLr_RESERVED_1f_SET
#define PAUSE_FRM_CTRLr_RESERVED_2f_GET BCM53101_A0_PAUSE_FRM_CTRLr_RESERVED_2f_GET
#define PAUSE_FRM_CTRLr_RESERVED_2f_SET BCM53101_A0_PAUSE_FRM_CTRLr_RESERVED_2f_SET
#define READ_PAUSE_FRM_CTRLr BCM53101_A0_READ_PAUSE_FRM_CTRLr
#define WRITE_PAUSE_FRM_CTRLr BCM53101_A0_WRITE_PAUSE_FRM_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PAUSE_FRM_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  PAUSE_QUANTA
 * BLOCKS:   SYS
 * DESC:     PAUSE Quanta register
 * SIZE:     16
 * FIELDS:
 *     PAUSE_QUANTA     The number of slot times that the transmitter wishes the link partner to suspend its transmission. The same value is common to all ports which have Auto-Negotiated to full duplex with flow control enabled.
 *
 ******************************************************************************/
#define BCM53101_A0_PAUSE_QUANTAr 0x0000000c

#define BCM53101_A0_PAUSE_QUANTAr_SIZE 2

/*
 * This structure should be used to declare and program PAUSE_QUANTA.
 *
 */
typedef union BCM53101_A0_PAUSE_QUANTAr_s {
	uint32_t v[1];
	uint32_t pause_quanta[1];
	uint32_t _pause_quanta;
} BCM53101_A0_PAUSE_QUANTAr_t;

#define BCM53101_A0_PAUSE_QUANTAr_CLR(r) (r).pause_quanta[0] = 0
#define BCM53101_A0_PAUSE_QUANTAr_SET(r,d) (r).pause_quanta[0] = d
#define BCM53101_A0_PAUSE_QUANTAr_GET(r) (r).pause_quanta[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_PAUSE_QUANTAr_PAUSE_QUANTAf_GET(r) (((r).pause_quanta[0]) & 0xffff)
#define BCM53101_A0_PAUSE_QUANTAr_PAUSE_QUANTAf_SET(r,f) (r).pause_quanta[0]=(((r).pause_quanta[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PAUSE_QUANTA.
 *
 */
#define BCM53101_A0_READ_PAUSE_QUANTAr(u,r) cdk_robo_reg_read(u,BCM53101_A0_PAUSE_QUANTAr,(r._pause_quanta),2)
#define BCM53101_A0_WRITE_PAUSE_QUANTAr(u,r) cdk_robo_reg_write(u,BCM53101_A0_PAUSE_QUANTAr,&(r._pause_quanta),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PAUSE_QUANTAr BCM53101_A0_PAUSE_QUANTAr
#define PAUSE_QUANTAr_SIZE BCM53101_A0_PAUSE_QUANTAr_SIZE
typedef BCM53101_A0_PAUSE_QUANTAr_t PAUSE_QUANTAr_t;
#define PAUSE_QUANTAr_CLR BCM53101_A0_PAUSE_QUANTAr_CLR
#define PAUSE_QUANTAr_SET BCM53101_A0_PAUSE_QUANTAr_SET
#define PAUSE_QUANTAr_GET BCM53101_A0_PAUSE_QUANTAr_GET
#define PAUSE_QUANTAr_PAUSE_QUANTAf_GET BCM53101_A0_PAUSE_QUANTAr_PAUSE_QUANTAf_GET
#define PAUSE_QUANTAr_PAUSE_QUANTAf_SET BCM53101_A0_PAUSE_QUANTAr_PAUSE_QUANTAf_SET
#define READ_PAUSE_QUANTAr BCM53101_A0_READ_PAUSE_QUANTAr
#define WRITE_PAUSE_QUANTAr BCM53101_A0_WRITE_PAUSE_QUANTAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PAUSE_QUANTAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  PBPTRFIFO_0
 * BLOCKS:   SYS
 * DESC:     PBPTRFIFO Status Register 0
 * SIZE:     48
 * FIELDS:
 *     VALID_CNT_P0     Valid Counter of pbptrfifo for Port 0
 *     VALID_CNT_P1     Valid Counter of pbptrfifo for Port 1
 *     VALID_CNT_P2     Valid Counter of pbptrfifo for Port 2
 *     VALID_CNT_P3     Valid Counter of pbptrfifo for Port 3
 *     VALID_CNT_P4     Valid Counter of pbptrfifo for Port 4
 *     VALID_CNT_P5     Valid Counter of pbptrfifo for Port 5
 *
 ******************************************************************************/
#define BCM53101_A0_PBPTRFIFO_0r 0x00000150

#define BCM53101_A0_PBPTRFIFO_0r_SIZE 6

/*
 * This structure should be used to declare and program PBPTRFIFO_0.
 *
 */
typedef union BCM53101_A0_PBPTRFIFO_0r_s {
	uint32_t v[2];
	uint32_t pbptrfifo_0[2];
	uint32_t _pbptrfifo_0;
} BCM53101_A0_PBPTRFIFO_0r_t;

#define BCM53101_A0_PBPTRFIFO_0r_CLR(r) CDK_MEMSET(&((r)._pbptrfifo_0), 0, sizeof(BCM53101_A0_PBPTRFIFO_0r_t))
#define BCM53101_A0_PBPTRFIFO_0r_SET(r,i,d) (r).pbptrfifo_0[i] = d
#define BCM53101_A0_PBPTRFIFO_0r_GET(r,i) (r).pbptrfifo_0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_PBPTRFIFO_0r_VALID_CNT_P0f_GET(r) (((r).pbptrfifo_0[0]) & 0xff)
#define BCM53101_A0_PBPTRFIFO_0r_VALID_CNT_P0f_SET(r,f) (r).pbptrfifo_0[0]=(((r).pbptrfifo_0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53101_A0_PBPTRFIFO_0r_VALID_CNT_P1f_GET(r) ((((r).pbptrfifo_0[0]) >> 8) & 0xff)
#define BCM53101_A0_PBPTRFIFO_0r_VALID_CNT_P1f_SET(r,f) (r).pbptrfifo_0[0]=(((r).pbptrfifo_0[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM53101_A0_PBPTRFIFO_0r_VALID_CNT_P2f_GET(r) ((((r).pbptrfifo_0[0]) >> 16) & 0xff)
#define BCM53101_A0_PBPTRFIFO_0r_VALID_CNT_P2f_SET(r,f) (r).pbptrfifo_0[0]=(((r).pbptrfifo_0[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM53101_A0_PBPTRFIFO_0r_VALID_CNT_P3f_GET(r) ((((r).pbptrfifo_0[0]) >> 24) & 0xff)
#define BCM53101_A0_PBPTRFIFO_0r_VALID_CNT_P3f_SET(r,f) (r).pbptrfifo_0[0]=(((r).pbptrfifo_0[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))
#define BCM53101_A0_PBPTRFIFO_0r_VALID_CNT_P4f_GET(r) (((r).pbptrfifo_0[1]) & 0xff)
#define BCM53101_A0_PBPTRFIFO_0r_VALID_CNT_P4f_SET(r,f) (r).pbptrfifo_0[1]=(((r).pbptrfifo_0[1] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53101_A0_PBPTRFIFO_0r_VALID_CNT_P5f_GET(r) ((((r).pbptrfifo_0[1]) >> 8) & 0xff)
#define BCM53101_A0_PBPTRFIFO_0r_VALID_CNT_P5f_SET(r,f) (r).pbptrfifo_0[1]=(((r).pbptrfifo_0[1] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access PBPTRFIFO_0.
 *
 */
#define BCM53101_A0_READ_PBPTRFIFO_0r(u,r) cdk_robo_reg_read(u,BCM53101_A0_PBPTRFIFO_0r,(r._pbptrfifo_0),6)
#define BCM53101_A0_WRITE_PBPTRFIFO_0r(u,r) cdk_robo_reg_write(u,BCM53101_A0_PBPTRFIFO_0r,&(r._pbptrfifo_0),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PBPTRFIFO_0r BCM53101_A0_PBPTRFIFO_0r
#define PBPTRFIFO_0r_SIZE BCM53101_A0_PBPTRFIFO_0r_SIZE
typedef BCM53101_A0_PBPTRFIFO_0r_t PBPTRFIFO_0r_t;
#define PBPTRFIFO_0r_CLR BCM53101_A0_PBPTRFIFO_0r_CLR
#define PBPTRFIFO_0r_SET BCM53101_A0_PBPTRFIFO_0r_SET
#define PBPTRFIFO_0r_GET BCM53101_A0_PBPTRFIFO_0r_GET
#define PBPTRFIFO_0r_VALID_CNT_P0f_GET BCM53101_A0_PBPTRFIFO_0r_VALID_CNT_P0f_GET
#define PBPTRFIFO_0r_VALID_CNT_P0f_SET BCM53101_A0_PBPTRFIFO_0r_VALID_CNT_P0f_SET
#define PBPTRFIFO_0r_VALID_CNT_P1f_GET BCM53101_A0_PBPTRFIFO_0r_VALID_CNT_P1f_GET
#define PBPTRFIFO_0r_VALID_CNT_P1f_SET BCM53101_A0_PBPTRFIFO_0r_VALID_CNT_P1f_SET
#define PBPTRFIFO_0r_VALID_CNT_P2f_GET BCM53101_A0_PBPTRFIFO_0r_VALID_CNT_P2f_GET
#define PBPTRFIFO_0r_VALID_CNT_P2f_SET BCM53101_A0_PBPTRFIFO_0r_VALID_CNT_P2f_SET
#define PBPTRFIFO_0r_VALID_CNT_P3f_GET BCM53101_A0_PBPTRFIFO_0r_VALID_CNT_P3f_GET
#define PBPTRFIFO_0r_VALID_CNT_P3f_SET BCM53101_A0_PBPTRFIFO_0r_VALID_CNT_P3f_SET
#define PBPTRFIFO_0r_VALID_CNT_P4f_GET BCM53101_A0_PBPTRFIFO_0r_VALID_CNT_P4f_GET
#define PBPTRFIFO_0r_VALID_CNT_P4f_SET BCM53101_A0_PBPTRFIFO_0r_VALID_CNT_P4f_SET
#define PBPTRFIFO_0r_VALID_CNT_P5f_GET BCM53101_A0_PBPTRFIFO_0r_VALID_CNT_P5f_GET
#define PBPTRFIFO_0r_VALID_CNT_P5f_SET BCM53101_A0_PBPTRFIFO_0r_VALID_CNT_P5f_SET
#define READ_PBPTRFIFO_0r BCM53101_A0_READ_PBPTRFIFO_0r
#define WRITE_PBPTRFIFO_0r BCM53101_A0_WRITE_PBPTRFIFO_0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PBPTRFIFO_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  PBPTRFIFO_1
 * BLOCKS:   SYS
 * DESC:     PBPTRFIFO Status Register 1
 * SIZE:     16
 * FIELDS:
 *     VALID_CNT_P8     Valid Counter of pbptrfifo for Port 8(IMP Port).
 *     RESERVED         
 *
 ******************************************************************************/
#define BCM53101_A0_PBPTRFIFO_1r 0x00000156

#define BCM53101_A0_PBPTRFIFO_1r_SIZE 2

/*
 * This structure should be used to declare and program PBPTRFIFO_1.
 *
 */
typedef union BCM53101_A0_PBPTRFIFO_1r_s {
	uint32_t v[1];
	uint32_t pbptrfifo_1[1];
	uint32_t _pbptrfifo_1;
} BCM53101_A0_PBPTRFIFO_1r_t;

#define BCM53101_A0_PBPTRFIFO_1r_CLR(r) (r).pbptrfifo_1[0] = 0
#define BCM53101_A0_PBPTRFIFO_1r_SET(r,d) (r).pbptrfifo_1[0] = d
#define BCM53101_A0_PBPTRFIFO_1r_GET(r) (r).pbptrfifo_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_PBPTRFIFO_1r_VALID_CNT_P8f_GET(r) (((r).pbptrfifo_1[0]) & 0xff)
#define BCM53101_A0_PBPTRFIFO_1r_VALID_CNT_P8f_SET(r,f) (r).pbptrfifo_1[0]=(((r).pbptrfifo_1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53101_A0_PBPTRFIFO_1r_RESERVEDf_GET(r) ((((r).pbptrfifo_1[0]) >> 8) & 0xff)
#define BCM53101_A0_PBPTRFIFO_1r_RESERVEDf_SET(r,f) (r).pbptrfifo_1[0]=(((r).pbptrfifo_1[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access PBPTRFIFO_1.
 *
 */
#define BCM53101_A0_READ_PBPTRFIFO_1r(u,r) cdk_robo_reg_read(u,BCM53101_A0_PBPTRFIFO_1r,(r._pbptrfifo_1),2)
#define BCM53101_A0_WRITE_PBPTRFIFO_1r(u,r) cdk_robo_reg_write(u,BCM53101_A0_PBPTRFIFO_1r,&(r._pbptrfifo_1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PBPTRFIFO_1r BCM53101_A0_PBPTRFIFO_1r
#define PBPTRFIFO_1r_SIZE BCM53101_A0_PBPTRFIFO_1r_SIZE
typedef BCM53101_A0_PBPTRFIFO_1r_t PBPTRFIFO_1r_t;
#define PBPTRFIFO_1r_CLR BCM53101_A0_PBPTRFIFO_1r_CLR
#define PBPTRFIFO_1r_SET BCM53101_A0_PBPTRFIFO_1r_SET
#define PBPTRFIFO_1r_GET BCM53101_A0_PBPTRFIFO_1r_GET
#define PBPTRFIFO_1r_VALID_CNT_P8f_GET BCM53101_A0_PBPTRFIFO_1r_VALID_CNT_P8f_GET
#define PBPTRFIFO_1r_VALID_CNT_P8f_SET BCM53101_A0_PBPTRFIFO_1r_VALID_CNT_P8f_SET
#define PBPTRFIFO_1r_RESERVEDf_GET BCM53101_A0_PBPTRFIFO_1r_RESERVEDf_GET
#define PBPTRFIFO_1r_RESERVEDf_SET BCM53101_A0_PBPTRFIFO_1r_RESERVEDf_SET
#define READ_PBPTRFIFO_1r BCM53101_A0_READ_PBPTRFIFO_1r
#define WRITE_PBPTRFIFO_1r BCM53101_A0_WRITE_PBPTRFIFO_1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PBPTRFIFO_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  PEAK_TEMP_MON_RESU
 * BLOCKS:   SYS
 * DESC:     Peak Temperature Monitor Result Registers(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     PEAK_TEMP_DATA   It keeps track the peak temperature monitor result since the last read.- It's the minimum code for the highest temperature since the last read.- After read, the register to be reset to 0x1FF.(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM53101_A0_PEAK_TEMP_MON_RESUr 0x00000f04

#define BCM53101_A0_PEAK_TEMP_MON_RESUr_SIZE 2

/*
 * This structure should be used to declare and program PEAK_TEMP_MON_RESU.
 *
 */
typedef union BCM53101_A0_PEAK_TEMP_MON_RESUr_s {
	uint32_t v[1];
	uint32_t peak_temp_mon_resu[1];
	uint32_t _peak_temp_mon_resu;
} BCM53101_A0_PEAK_TEMP_MON_RESUr_t;

#define BCM53101_A0_PEAK_TEMP_MON_RESUr_CLR(r) (r).peak_temp_mon_resu[0] = 0
#define BCM53101_A0_PEAK_TEMP_MON_RESUr_SET(r,d) (r).peak_temp_mon_resu[0] = d
#define BCM53101_A0_PEAK_TEMP_MON_RESUr_GET(r) (r).peak_temp_mon_resu[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_PEAK_TEMP_MON_RESUr_PEAK_TEMP_DATAf_GET(r) (((r).peak_temp_mon_resu[0]) & 0x1ff)
#define BCM53101_A0_PEAK_TEMP_MON_RESUr_PEAK_TEMP_DATAf_SET(r,f) (r).peak_temp_mon_resu[0]=(((r).peak_temp_mon_resu[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_PEAK_TEMP_MON_RESUr_RESERVEDf_GET(r) ((((r).peak_temp_mon_resu[0]) >> 9) & 0x7f)
#define BCM53101_A0_PEAK_TEMP_MON_RESUr_RESERVEDf_SET(r,f) (r).peak_temp_mon_resu[0]=(((r).peak_temp_mon_resu[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access PEAK_TEMP_MON_RESU.
 *
 */
#define BCM53101_A0_READ_PEAK_TEMP_MON_RESUr(u,r) cdk_robo_reg_read(u,BCM53101_A0_PEAK_TEMP_MON_RESUr,(r._peak_temp_mon_resu),2)
#define BCM53101_A0_WRITE_PEAK_TEMP_MON_RESUr(u,r) cdk_robo_reg_write(u,BCM53101_A0_PEAK_TEMP_MON_RESUr,&(r._peak_temp_mon_resu),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PEAK_TEMP_MON_RESUr BCM53101_A0_PEAK_TEMP_MON_RESUr
#define PEAK_TEMP_MON_RESUr_SIZE BCM53101_A0_PEAK_TEMP_MON_RESUr_SIZE
typedef BCM53101_A0_PEAK_TEMP_MON_RESUr_t PEAK_TEMP_MON_RESUr_t;
#define PEAK_TEMP_MON_RESUr_CLR BCM53101_A0_PEAK_TEMP_MON_RESUr_CLR
#define PEAK_TEMP_MON_RESUr_SET BCM53101_A0_PEAK_TEMP_MON_RESUr_SET
#define PEAK_TEMP_MON_RESUr_GET BCM53101_A0_PEAK_TEMP_MON_RESUr_GET
#define PEAK_TEMP_MON_RESUr_PEAK_TEMP_DATAf_GET BCM53101_A0_PEAK_TEMP_MON_RESUr_PEAK_TEMP_DATAf_GET
#define PEAK_TEMP_MON_RESUr_PEAK_TEMP_DATAf_SET BCM53101_A0_PEAK_TEMP_MON_RESUr_PEAK_TEMP_DATAf_SET
#define PEAK_TEMP_MON_RESUr_RESERVEDf_GET BCM53101_A0_PEAK_TEMP_MON_RESUr_RESERVEDf_GET
#define PEAK_TEMP_MON_RESUr_RESERVEDf_SET BCM53101_A0_PEAK_TEMP_MON_RESUr_RESERVEDf_SET
#define READ_PEAK_TEMP_MON_RESUr BCM53101_A0_READ_PEAK_TEMP_MON_RESUr
#define WRITE_PEAK_TEMP_MON_RESUr BCM53101_A0_WRITE_PEAK_TEMP_MON_RESUr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PEAK_TEMP_MON_RESUr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  PHYIDH
 * BLOCKS:   EPIC0
 * DESC:     PHY ID High Register
 * SIZE:     16
 * FIELDS:
 *     MII_ADDR         Device ID.
 *
 ******************************************************************************/
#define BCM53101_A0_PHYIDHr 0x00001004

#define BCM53101_A0_PHYIDHr_SIZE 2

/*
 * This structure should be used to declare and program PHYIDH.
 *
 */
typedef union BCM53101_A0_PHYIDHr_s {
	uint32_t v[1];
	uint32_t phyidh[1];
	uint32_t _phyidh;
} BCM53101_A0_PHYIDHr_t;

#define BCM53101_A0_PHYIDHr_CLR(r) (r).phyidh[0] = 0
#define BCM53101_A0_PHYIDHr_SET(r,d) (r).phyidh[0] = d
#define BCM53101_A0_PHYIDHr_GET(r) (r).phyidh[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_PHYIDHr_MII_ADDRf_GET(r) (((r).phyidh[0]) & 0xffff)
#define BCM53101_A0_PHYIDHr_MII_ADDRf_SET(r,f) (r).phyidh[0]=(((r).phyidh[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PHYIDH.
 *
 */
#define BCM53101_A0_READ_PHYIDHr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_PHYIDHr,(r._phyidh),2)
#define BCM53101_A0_WRITE_PHYIDHr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_PHYIDHr,&(r._phyidh),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PHYIDHr BCM53101_A0_PHYIDHr
#define PHYIDHr_SIZE BCM53101_A0_PHYIDHr_SIZE
typedef BCM53101_A0_PHYIDHr_t PHYIDHr_t;
#define PHYIDHr_CLR BCM53101_A0_PHYIDHr_CLR
#define PHYIDHr_SET BCM53101_A0_PHYIDHr_SET
#define PHYIDHr_GET BCM53101_A0_PHYIDHr_GET
#define PHYIDHr_MII_ADDRf_GET BCM53101_A0_PHYIDHr_MII_ADDRf_GET
#define PHYIDHr_MII_ADDRf_SET BCM53101_A0_PHYIDHr_MII_ADDRf_SET
#define READ_PHYIDHr BCM53101_A0_READ_PHYIDHr
#define WRITE_PHYIDHr BCM53101_A0_WRITE_PHYIDHr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PHYIDHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  PHYIDL
 * BLOCKS:   EPIC0
 * DESC:     PHY ID Low Register
 * SIZE:     16
 * FIELDS:
 *     MII_ADDR         Device ID.
 *
 ******************************************************************************/
#define BCM53101_A0_PHYIDLr 0x00001006

#define BCM53101_A0_PHYIDLr_SIZE 2

/*
 * This structure should be used to declare and program PHYIDL.
 *
 */
typedef union BCM53101_A0_PHYIDLr_s {
	uint32_t v[1];
	uint32_t phyidl[1];
	uint32_t _phyidl;
} BCM53101_A0_PHYIDLr_t;

#define BCM53101_A0_PHYIDLr_CLR(r) (r).phyidl[0] = 0
#define BCM53101_A0_PHYIDLr_SET(r,d) (r).phyidl[0] = d
#define BCM53101_A0_PHYIDLr_GET(r) (r).phyidl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_PHYIDLr_MII_ADDRf_GET(r) (((r).phyidl[0]) & 0xffff)
#define BCM53101_A0_PHYIDLr_MII_ADDRf_SET(r,f) (r).phyidl[0]=(((r).phyidl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff))

/*
 * These macros can be used to access PHYIDL.
 *
 */
#define BCM53101_A0_READ_PHYIDLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_PHYIDLr,(r._phyidl),2)
#define BCM53101_A0_WRITE_PHYIDLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_PHYIDLr,&(r._phyidl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PHYIDLr BCM53101_A0_PHYIDLr
#define PHYIDLr_SIZE BCM53101_A0_PHYIDLr_SIZE
typedef BCM53101_A0_PHYIDLr_t PHYIDLr_t;
#define PHYIDLr_CLR BCM53101_A0_PHYIDLr_CLR
#define PHYIDLr_SET BCM53101_A0_PHYIDLr_SET
#define PHYIDLr_GET BCM53101_A0_PHYIDLr_GET
#define PHYIDLr_MII_ADDRf_GET BCM53101_A0_PHYIDLr_MII_ADDRf_GET
#define PHYIDLr_MII_ADDRf_SET BCM53101_A0_PHYIDLr_MII_ADDRf_SET
#define READ_PHYIDLr BCM53101_A0_READ_PHYIDLr
#define WRITE_PHYIDLr BCM53101_A0_WRITE_PHYIDLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PHYIDLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  PHY_CTRL
 * BLOCKS:   SYS
 * DESC:     PHY Control Registrer
 * SIZE:     16
 * FIELDS:
 *     PHY_PER_PORT_RESET Phy reset. Must be held low for at least 400ns while system clock is running. After reset_n deassertion, no phy activity should occur for 100us.bit[4:0] : port4-0
 *     RESERVED_1       Reserved
 *     ATEST_25MHZ_EN   Forces the PAD_ATEST to output the 25Mhz input clock.(testing only)
 *
 ******************************************************************************/
#define BCM53101_A0_PHY_CTRLr 0x00000048

#define BCM53101_A0_PHY_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program PHY_CTRL.
 *
 */
typedef union BCM53101_A0_PHY_CTRLr_s {
	uint32_t v[1];
	uint32_t phy_ctrl[1];
	uint32_t _phy_ctrl;
} BCM53101_A0_PHY_CTRLr_t;

#define BCM53101_A0_PHY_CTRLr_CLR(r) (r).phy_ctrl[0] = 0
#define BCM53101_A0_PHY_CTRLr_SET(r,d) (r).phy_ctrl[0] = d
#define BCM53101_A0_PHY_CTRLr_GET(r) (r).phy_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_PHY_CTRLr_PHY_PER_PORT_RESETf_GET(r) (((r).phy_ctrl[0]) & 0x1f)
#define BCM53101_A0_PHY_CTRLr_PHY_PER_PORT_RESETf_SET(r,f) (r).phy_ctrl[0]=(((r).phy_ctrl[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53101_A0_PHY_CTRLr_RESERVED_1f_GET(r) ((((r).phy_ctrl[0]) >> 5) & 0x3ff)
#define BCM53101_A0_PHY_CTRLr_RESERVED_1f_SET(r,f) (r).phy_ctrl[0]=(((r).phy_ctrl[0] & ~((uint32_t)0x3ff << 5)) | ((((uint32_t)f) & 0x3ff) << 5))
#define BCM53101_A0_PHY_CTRLr_ATEST_25MHZ_ENf_GET(r) ((((r).phy_ctrl[0]) >> 15) & 0x1)
#define BCM53101_A0_PHY_CTRLr_ATEST_25MHZ_ENf_SET(r,f) (r).phy_ctrl[0]=(((r).phy_ctrl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access PHY_CTRL.
 *
 */
#define BCM53101_A0_READ_PHY_CTRLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_PHY_CTRLr,(r._phy_ctrl),2)
#define BCM53101_A0_WRITE_PHY_CTRLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_PHY_CTRLr,&(r._phy_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PHY_CTRLr BCM53101_A0_PHY_CTRLr
#define PHY_CTRLr_SIZE BCM53101_A0_PHY_CTRLr_SIZE
typedef BCM53101_A0_PHY_CTRLr_t PHY_CTRLr_t;
#define PHY_CTRLr_CLR BCM53101_A0_PHY_CTRLr_CLR
#define PHY_CTRLr_SET BCM53101_A0_PHY_CTRLr_SET
#define PHY_CTRLr_GET BCM53101_A0_PHY_CTRLr_GET
#define PHY_CTRLr_PHY_PER_PORT_RESETf_GET BCM53101_A0_PHY_CTRLr_PHY_PER_PORT_RESETf_GET
#define PHY_CTRLr_PHY_PER_PORT_RESETf_SET BCM53101_A0_PHY_CTRLr_PHY_PER_PORT_RESETf_SET
#define PHY_CTRLr_RESERVED_1f_GET BCM53101_A0_PHY_CTRLr_RESERVED_1f_GET
#define PHY_CTRLr_RESERVED_1f_SET BCM53101_A0_PHY_CTRLr_RESERVED_1f_SET
#define PHY_CTRLr_ATEST_25MHZ_ENf_GET BCM53101_A0_PHY_CTRLr_ATEST_25MHZ_ENf_GET
#define PHY_CTRLr_ATEST_25MHZ_ENf_SET BCM53101_A0_PHY_CTRLr_ATEST_25MHZ_ENf_SET
#define READ_PHY_CTRLr BCM53101_A0_READ_PHY_CTRLr
#define WRITE_PHY_CTRLr BCM53101_A0_WRITE_PHY_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PHY_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  PHY_PWR_DOWN
 * BLOCKS:   SYS
 * DESC:     PHY Power Down Mode Registrer
 * SIZE:     32
 * FIELDS:
 *     PHY_PWR_DOWN_PHY_EN Power down phy #0 enable. when active, the phy is put into iddq mode. The RESET_N must be asserted when power down mode is removed.bit[4:0]: port4-0.
 *     PHY_PWR_DOWN_PHY_RD Power down phy #0 reset divider. when active, the phy is put into iddq mode. The RESET_N must be asserted when power down mode is removed.bit[9:5]: port4-0.
 *     PHY_PWR_DOWN_PHY_SD Power down phy #0 signal detect. when active, the phy is put into iddq mode. The RESET_N must be asserted when power down mode is removed.bit[14:10]: port4-0.
 *     PHY_PWR_DOWN_PHY_RX Power down phy #0 receiver. when active, the phy is put into iddq mode. The RESET_N must be asserted when power down mode is removed.bit[19:15]: port4-0.
 *     PHY_PWR_DOWN_PHY_TX Power down phy #0 transmitter. when active, the phy is put into iddq mode. The RESET_N must be asserted when power down mode is removed.bit[24:20]: port4-0.
 *     RESERVED         Reserved.
 *     PHY_PWR_DOWN_BIAS Power down bias. when active, the internal bias is put into iddq mode. The ENERGY_DET output is not valid when this input is active.
 *     PHY_PWR_DOWN_DLL Power down dll. when active, the internal pll is put into iddq mode.
 *
 ******************************************************************************/
#define BCM53101_A0_PHY_PWR_DOWNr 0x0000004a

#define BCM53101_A0_PHY_PWR_DOWNr_SIZE 4

/*
 * This structure should be used to declare and program PHY_PWR_DOWN.
 *
 */
typedef union BCM53101_A0_PHY_PWR_DOWNr_s {
	uint32_t v[1];
	uint32_t phy_pwr_down[1];
	uint32_t _phy_pwr_down;
} BCM53101_A0_PHY_PWR_DOWNr_t;

#define BCM53101_A0_PHY_PWR_DOWNr_CLR(r) (r).phy_pwr_down[0] = 0
#define BCM53101_A0_PHY_PWR_DOWNr_SET(r,d) (r).phy_pwr_down[0] = d
#define BCM53101_A0_PHY_PWR_DOWNr_GET(r) (r).phy_pwr_down[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_PHY_PWR_DOWNr_PHY_PWR_DOWN_PHY_ENf_GET(r) (((r).phy_pwr_down[0]) & 0x1f)
#define BCM53101_A0_PHY_PWR_DOWNr_PHY_PWR_DOWN_PHY_ENf_SET(r,f) (r).phy_pwr_down[0]=(((r).phy_pwr_down[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53101_A0_PHY_PWR_DOWNr_PHY_PWR_DOWN_PHY_RDf_GET(r) ((((r).phy_pwr_down[0]) >> 5) & 0x1f)
#define BCM53101_A0_PHY_PWR_DOWNr_PHY_PWR_DOWN_PHY_RDf_SET(r,f) (r).phy_pwr_down[0]=(((r).phy_pwr_down[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5))
#define BCM53101_A0_PHY_PWR_DOWNr_PHY_PWR_DOWN_PHY_SDf_GET(r) ((((r).phy_pwr_down[0]) >> 10) & 0x1f)
#define BCM53101_A0_PHY_PWR_DOWNr_PHY_PWR_DOWN_PHY_SDf_SET(r,f) (r).phy_pwr_down[0]=(((r).phy_pwr_down[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10))
#define BCM53101_A0_PHY_PWR_DOWNr_PHY_PWR_DOWN_PHY_RXf_GET(r) ((((r).phy_pwr_down[0]) >> 15) & 0x1f)
#define BCM53101_A0_PHY_PWR_DOWNr_PHY_PWR_DOWN_PHY_RXf_SET(r,f) (r).phy_pwr_down[0]=(((r).phy_pwr_down[0] & ~((uint32_t)0x1f << 15)) | ((((uint32_t)f) & 0x1f) << 15))
#define BCM53101_A0_PHY_PWR_DOWNr_PHY_PWR_DOWN_PHY_TXf_GET(r) ((((r).phy_pwr_down[0]) >> 20) & 0x1f)
#define BCM53101_A0_PHY_PWR_DOWNr_PHY_PWR_DOWN_PHY_TXf_SET(r,f) (r).phy_pwr_down[0]=(((r).phy_pwr_down[0] & ~((uint32_t)0x1f << 20)) | ((((uint32_t)f) & 0x1f) << 20))
#define BCM53101_A0_PHY_PWR_DOWNr_RESERVEDf_GET(r) ((((r).phy_pwr_down[0]) >> 25) & 0x1f)
#define BCM53101_A0_PHY_PWR_DOWNr_RESERVEDf_SET(r,f) (r).phy_pwr_down[0]=(((r).phy_pwr_down[0] & ~((uint32_t)0x1f << 25)) | ((((uint32_t)f) & 0x1f) << 25))
#define BCM53101_A0_PHY_PWR_DOWNr_PHY_PWR_DOWN_BIASf_GET(r) ((((r).phy_pwr_down[0]) >> 30) & 0x1)
#define BCM53101_A0_PHY_PWR_DOWNr_PHY_PWR_DOWN_BIASf_SET(r,f) (r).phy_pwr_down[0]=(((r).phy_pwr_down[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM53101_A0_PHY_PWR_DOWNr_PHY_PWR_DOWN_DLLf_GET(r) ((((r).phy_pwr_down[0]) >> 31) & 0x1)
#define BCM53101_A0_PHY_PWR_DOWNr_PHY_PWR_DOWN_DLLf_SET(r,f) (r).phy_pwr_down[0]=(((r).phy_pwr_down[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))

/*
 * These macros can be used to access PHY_PWR_DOWN.
 *
 */
#define BCM53101_A0_READ_PHY_PWR_DOWNr(u,r) cdk_robo_reg_read(u,BCM53101_A0_PHY_PWR_DOWNr,(r._phy_pwr_down),4)
#define BCM53101_A0_WRITE_PHY_PWR_DOWNr(u,r) cdk_robo_reg_write(u,BCM53101_A0_PHY_PWR_DOWNr,&(r._phy_pwr_down),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PHY_PWR_DOWNr BCM53101_A0_PHY_PWR_DOWNr
#define PHY_PWR_DOWNr_SIZE BCM53101_A0_PHY_PWR_DOWNr_SIZE
typedef BCM53101_A0_PHY_PWR_DOWNr_t PHY_PWR_DOWNr_t;
#define PHY_PWR_DOWNr_CLR BCM53101_A0_PHY_PWR_DOWNr_CLR
#define PHY_PWR_DOWNr_SET BCM53101_A0_PHY_PWR_DOWNr_SET
#define PHY_PWR_DOWNr_GET BCM53101_A0_PHY_PWR_DOWNr_GET
#define PHY_PWR_DOWNr_PHY_PWR_DOWN_PHY_ENf_GET BCM53101_A0_PHY_PWR_DOWNr_PHY_PWR_DOWN_PHY_ENf_GET
#define PHY_PWR_DOWNr_PHY_PWR_DOWN_PHY_ENf_SET BCM53101_A0_PHY_PWR_DOWNr_PHY_PWR_DOWN_PHY_ENf_SET
#define PHY_PWR_DOWNr_PHY_PWR_DOWN_PHY_RDf_GET BCM53101_A0_PHY_PWR_DOWNr_PHY_PWR_DOWN_PHY_RDf_GET
#define PHY_PWR_DOWNr_PHY_PWR_DOWN_PHY_RDf_SET BCM53101_A0_PHY_PWR_DOWNr_PHY_PWR_DOWN_PHY_RDf_SET
#define PHY_PWR_DOWNr_PHY_PWR_DOWN_PHY_SDf_GET BCM53101_A0_PHY_PWR_DOWNr_PHY_PWR_DOWN_PHY_SDf_GET
#define PHY_PWR_DOWNr_PHY_PWR_DOWN_PHY_SDf_SET BCM53101_A0_PHY_PWR_DOWNr_PHY_PWR_DOWN_PHY_SDf_SET
#define PHY_PWR_DOWNr_PHY_PWR_DOWN_PHY_RXf_GET BCM53101_A0_PHY_PWR_DOWNr_PHY_PWR_DOWN_PHY_RXf_GET
#define PHY_PWR_DOWNr_PHY_PWR_DOWN_PHY_RXf_SET BCM53101_A0_PHY_PWR_DOWNr_PHY_PWR_DOWN_PHY_RXf_SET
#define PHY_PWR_DOWNr_PHY_PWR_DOWN_PHY_TXf_GET BCM53101_A0_PHY_PWR_DOWNr_PHY_PWR_DOWN_PHY_TXf_GET
#define PHY_PWR_DOWNr_PHY_PWR_DOWN_PHY_TXf_SET BCM53101_A0_PHY_PWR_DOWNr_PHY_PWR_DOWN_PHY_TXf_SET
#define PHY_PWR_DOWNr_RESERVEDf_GET BCM53101_A0_PHY_PWR_DOWNr_RESERVEDf_GET
#define PHY_PWR_DOWNr_RESERVEDf_SET BCM53101_A0_PHY_PWR_DOWNr_RESERVEDf_SET
#define PHY_PWR_DOWNr_PHY_PWR_DOWN_BIASf_GET BCM53101_A0_PHY_PWR_DOWNr_PHY_PWR_DOWN_BIASf_GET
#define PHY_PWR_DOWNr_PHY_PWR_DOWN_BIASf_SET BCM53101_A0_PHY_PWR_DOWNr_PHY_PWR_DOWN_BIASf_SET
#define PHY_PWR_DOWNr_PHY_PWR_DOWN_DLLf_GET BCM53101_A0_PHY_PWR_DOWNr_PHY_PWR_DOWN_DLLf_GET
#define PHY_PWR_DOWNr_PHY_PWR_DOWN_DLLf_SET BCM53101_A0_PHY_PWR_DOWNr_PHY_PWR_DOWN_DLLf_SET
#define READ_PHY_PWR_DOWNr BCM53101_A0_READ_PHY_PWR_DOWNr
#define WRITE_PHY_PWR_DOWNr BCM53101_A0_WRITE_PHY_PWR_DOWNr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PHY_PWR_DOWNr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  PHY_STS
 * BLOCKS:   SYS
 * DESC:     PHY Status Registrer
 * SIZE:     16
 * FIELDS:
 *     PHY_ENERGY_DET   Phy #0. Energy detect output. when active, this indicates the presence of a signal on RD +/- receive analog pair.bit[4:0]: port4-0.
 *     RESERVED_1       Reserved
 *     PHY_PLL_LOCK     PLL Lock indicator
 *
 ******************************************************************************/
#define BCM53101_A0_PHY_STSr 0x0000004e

#define BCM53101_A0_PHY_STSr_SIZE 2

/*
 * This structure should be used to declare and program PHY_STS.
 *
 */
typedef union BCM53101_A0_PHY_STSr_s {
	uint32_t v[1];
	uint32_t phy_sts[1];
	uint32_t _phy_sts;
} BCM53101_A0_PHY_STSr_t;

#define BCM53101_A0_PHY_STSr_CLR(r) (r).phy_sts[0] = 0
#define BCM53101_A0_PHY_STSr_SET(r,d) (r).phy_sts[0] = d
#define BCM53101_A0_PHY_STSr_GET(r) (r).phy_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_PHY_STSr_PHY_ENERGY_DETf_GET(r) (((r).phy_sts[0]) & 0x1f)
#define BCM53101_A0_PHY_STSr_PHY_ENERGY_DETf_SET(r,f) (r).phy_sts[0]=(((r).phy_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53101_A0_PHY_STSr_RESERVED_1f_GET(r) ((((r).phy_sts[0]) >> 5) & 0x3ff)
#define BCM53101_A0_PHY_STSr_RESERVED_1f_SET(r,f) (r).phy_sts[0]=(((r).phy_sts[0] & ~((uint32_t)0x3ff << 5)) | ((((uint32_t)f) & 0x3ff) << 5))
#define BCM53101_A0_PHY_STSr_PHY_PLL_LOCKf_GET(r) ((((r).phy_sts[0]) >> 15) & 0x1)
#define BCM53101_A0_PHY_STSr_PHY_PLL_LOCKf_SET(r,f) (r).phy_sts[0]=(((r).phy_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access PHY_STS.
 *
 */
#define BCM53101_A0_READ_PHY_STSr(u,r) cdk_robo_reg_read(u,BCM53101_A0_PHY_STSr,(r._phy_sts),2)
#define BCM53101_A0_WRITE_PHY_STSr(u,r) cdk_robo_reg_write(u,BCM53101_A0_PHY_STSr,&(r._phy_sts),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PHY_STSr BCM53101_A0_PHY_STSr
#define PHY_STSr_SIZE BCM53101_A0_PHY_STSr_SIZE
typedef BCM53101_A0_PHY_STSr_t PHY_STSr_t;
#define PHY_STSr_CLR BCM53101_A0_PHY_STSr_CLR
#define PHY_STSr_SET BCM53101_A0_PHY_STSr_SET
#define PHY_STSr_GET BCM53101_A0_PHY_STSr_GET
#define PHY_STSr_PHY_ENERGY_DETf_GET BCM53101_A0_PHY_STSr_PHY_ENERGY_DETf_GET
#define PHY_STSr_PHY_ENERGY_DETf_SET BCM53101_A0_PHY_STSr_PHY_ENERGY_DETf_SET
#define PHY_STSr_RESERVED_1f_GET BCM53101_A0_PHY_STSr_RESERVED_1f_GET
#define PHY_STSr_RESERVED_1f_SET BCM53101_A0_PHY_STSr_RESERVED_1f_SET
#define PHY_STSr_PHY_PLL_LOCKf_GET BCM53101_A0_PHY_STSr_PHY_PLL_LOCKf_GET
#define PHY_STSr_PHY_PLL_LOCKf_SET BCM53101_A0_PHY_STSr_PHY_PLL_LOCKf_SET
#define READ_PHY_STSr BCM53101_A0_READ_PHY_STSr
#define WRITE_PHY_STSr BCM53101_A0_WRITE_PHY_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PHY_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  PLL_CTRL
 * BLOCKS:   SYS
 * DESC:     PLL Control Register(Engineering Use Only)
 * SIZE:     8
 * FIELDS:
 *     PLL_POWER_DOWN_CTRL PLL power down control[4]: PLL global power down[3]: clock comparator power down[2]: channel 1 power down[1]: channel 2 power down[0]: channel 3 power down
 *     RESERVED         RESERVED
 *     PLL_DRESET       PLL digital resetSoftware must reset the analog/digital circuit when releasing PLL global power down or releasing PLL clock comparator power down.
 *     PLL_ARESET       PLL analog resetSoftware must reset the analog/digital circuit when releasing PLL global power down or releasing PLL clock comparator power down.
 *
 ******************************************************************************/
#define BCM53101_A0_PLL_CTRLr 0x000000dc

#define BCM53101_A0_PLL_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program PLL_CTRL.
 *
 */
typedef union BCM53101_A0_PLL_CTRLr_s {
	uint32_t v[1];
	uint32_t pll_ctrl[1];
	uint32_t _pll_ctrl;
} BCM53101_A0_PLL_CTRLr_t;

#define BCM53101_A0_PLL_CTRLr_CLR(r) (r).pll_ctrl[0] = 0
#define BCM53101_A0_PLL_CTRLr_SET(r,d) (r).pll_ctrl[0] = d
#define BCM53101_A0_PLL_CTRLr_GET(r) (r).pll_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_PLL_CTRLr_PLL_POWER_DOWN_CTRLf_GET(r) (((r).pll_ctrl[0]) & 0x1f)
#define BCM53101_A0_PLL_CTRLr_PLL_POWER_DOWN_CTRLf_SET(r,f) (r).pll_ctrl[0]=(((r).pll_ctrl[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53101_A0_PLL_CTRLr_RESERVEDf_GET(r) ((((r).pll_ctrl[0]) >> 5) & 0x1)
#define BCM53101_A0_PLL_CTRLr_RESERVEDf_SET(r,f) (r).pll_ctrl[0]=(((r).pll_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_PLL_CTRLr_PLL_DRESETf_GET(r) ((((r).pll_ctrl[0]) >> 6) & 0x1)
#define BCM53101_A0_PLL_CTRLr_PLL_DRESETf_SET(r,f) (r).pll_ctrl[0]=(((r).pll_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_PLL_CTRLr_PLL_ARESETf_GET(r) ((((r).pll_ctrl[0]) >> 7) & 0x1)
#define BCM53101_A0_PLL_CTRLr_PLL_ARESETf_SET(r,f) (r).pll_ctrl[0]=(((r).pll_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access PLL_CTRL.
 *
 */
#define BCM53101_A0_READ_PLL_CTRLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_PLL_CTRLr,(r._pll_ctrl),1)
#define BCM53101_A0_WRITE_PLL_CTRLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_PLL_CTRLr,&(r._pll_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PLL_CTRLr BCM53101_A0_PLL_CTRLr
#define PLL_CTRLr_SIZE BCM53101_A0_PLL_CTRLr_SIZE
typedef BCM53101_A0_PLL_CTRLr_t PLL_CTRLr_t;
#define PLL_CTRLr_CLR BCM53101_A0_PLL_CTRLr_CLR
#define PLL_CTRLr_SET BCM53101_A0_PLL_CTRLr_SET
#define PLL_CTRLr_GET BCM53101_A0_PLL_CTRLr_GET
#define PLL_CTRLr_PLL_POWER_DOWN_CTRLf_GET BCM53101_A0_PLL_CTRLr_PLL_POWER_DOWN_CTRLf_GET
#define PLL_CTRLr_PLL_POWER_DOWN_CTRLf_SET BCM53101_A0_PLL_CTRLr_PLL_POWER_DOWN_CTRLf_SET
#define PLL_CTRLr_RESERVEDf_GET BCM53101_A0_PLL_CTRLr_RESERVEDf_GET
#define PLL_CTRLr_RESERVEDf_SET BCM53101_A0_PLL_CTRLr_RESERVEDf_SET
#define PLL_CTRLr_PLL_DRESETf_GET BCM53101_A0_PLL_CTRLr_PLL_DRESETf_GET
#define PLL_CTRLr_PLL_DRESETf_SET BCM53101_A0_PLL_CTRLr_PLL_DRESETf_SET
#define PLL_CTRLr_PLL_ARESETf_GET BCM53101_A0_PLL_CTRLr_PLL_ARESETf_GET
#define PLL_CTRLr_PLL_ARESETf_SET BCM53101_A0_PLL_CTRLr_PLL_ARESETf_SET
#define READ_PLL_CTRLr BCM53101_A0_READ_PLL_CTRLr
#define WRITE_PLL_CTRLr BCM53101_A0_WRITE_PLL_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PLL_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  PLL_FREQ_SEL
 * BLOCKS:   SYS
 * DESC:     PLL system clock frequency selector Register(Engineering Use Only)
 * SIZE:     40
 * FIELDS:
 *     CLKSET_KEY1      This field must be written with 0x68
 *     CLKSET_KEY2      This field must be written with 0xEA
 *     CLKSET_MDIV      Writting this field changes PLL channel 2's clock.The frequence is determined by this formula.F=VCO/CLKSET_MDIV, where VCO is fixed to 1Ghz, the divider should be larger than or equal to 13(decimal).
 *     RESERVED         Reserved, must be written with all zeros.
 *     CLKSET_RST       Setting this bit to 1'b1 to triggers a reset on PLL. Valid, when bit 31 is set to 1. Once the PLL reset is triggered, it requires 500us for PLL to lock. To modify system clock at run time a reset to PLL is not required.
 *     CLKSET_SPI       Setting this bit to 1 enables frequency control of PLL channel 2(system clock).Note: This register is effective only full 32-bit is written. The followings are for Lotus configuration,76.92Mhz : 32'hC0_0D_EA_6871.42Mhz : 32'hC0_0E_EA_6866.66Mhz : 32'hC0_0F_EA_68(recommended)50.00Mhz : 32'hC0_14_EA_68(bit30, CLKSET_RST is optional)
 *     CLKSET_DUMMY     This dummy byte is only required when writing in order to clock in the write command.When reading, the software should only read 32-bit.must be written with all zeros.
 *
 ******************************************************************************/
#define BCM53101_A0_PLL_FREQ_SELr 0x000000d8

#define BCM53101_A0_PLL_FREQ_SELr_SIZE 5

/*
 * This structure should be used to declare and program PLL_FREQ_SEL.
 *
 */
typedef union BCM53101_A0_PLL_FREQ_SELr_s {
	uint32_t v[2];
	uint32_t pll_freq_sel[2];
	uint32_t _pll_freq_sel;
} BCM53101_A0_PLL_FREQ_SELr_t;

#define BCM53101_A0_PLL_FREQ_SELr_CLR(r) CDK_MEMSET(&((r)._pll_freq_sel), 0, sizeof(BCM53101_A0_PLL_FREQ_SELr_t))
#define BCM53101_A0_PLL_FREQ_SELr_SET(r,i,d) (r).pll_freq_sel[i] = d
#define BCM53101_A0_PLL_FREQ_SELr_GET(r,i) (r).pll_freq_sel[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_PLL_FREQ_SELr_CLKSET_KEY1f_GET(r) (((r).pll_freq_sel[0]) & 0xff)
#define BCM53101_A0_PLL_FREQ_SELr_CLKSET_KEY1f_SET(r,f) (r).pll_freq_sel[0]=(((r).pll_freq_sel[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53101_A0_PLL_FREQ_SELr_CLKSET_KEY2f_GET(r) ((((r).pll_freq_sel[0]) >> 8) & 0xff)
#define BCM53101_A0_PLL_FREQ_SELr_CLKSET_KEY2f_SET(r,f) (r).pll_freq_sel[0]=(((r).pll_freq_sel[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))
#define BCM53101_A0_PLL_FREQ_SELr_CLKSET_MDIVf_GET(r) ((((r).pll_freq_sel[0]) >> 16) & 0xff)
#define BCM53101_A0_PLL_FREQ_SELr_CLKSET_MDIVf_SET(r,f) (r).pll_freq_sel[0]=(((r).pll_freq_sel[0] & ~((uint32_t)0xff << 16)) | ((((uint32_t)f) & 0xff) << 16))
#define BCM53101_A0_PLL_FREQ_SELr_RESERVEDf_GET(r) ((((r).pll_freq_sel[0]) >> 24) & 0x3f)
#define BCM53101_A0_PLL_FREQ_SELr_RESERVEDf_SET(r,f) (r).pll_freq_sel[0]=(((r).pll_freq_sel[0] & ~((uint32_t)0x3f << 24)) | ((((uint32_t)f) & 0x3f) << 24))
#define BCM53101_A0_PLL_FREQ_SELr_CLKSET_RSTf_GET(r) ((((r).pll_freq_sel[0]) >> 30) & 0x1)
#define BCM53101_A0_PLL_FREQ_SELr_CLKSET_RSTf_SET(r,f) (r).pll_freq_sel[0]=(((r).pll_freq_sel[0] & ~((uint32_t)0x1 << 30)) | ((((uint32_t)f) & 0x1) << 30))
#define BCM53101_A0_PLL_FREQ_SELr_CLKSET_SPIf_GET(r) ((((r).pll_freq_sel[0]) >> 31) & 0x1)
#define BCM53101_A0_PLL_FREQ_SELr_CLKSET_SPIf_SET(r,f) (r).pll_freq_sel[0]=(((r).pll_freq_sel[0] & ~((uint32_t)0x1 << 31)) | ((((uint32_t)f) & 0x1) << 31))
#define BCM53101_A0_PLL_FREQ_SELr_CLKSET_DUMMYf_GET(r) (((r).pll_freq_sel[1]) & 0xff)
#define BCM53101_A0_PLL_FREQ_SELr_CLKSET_DUMMYf_SET(r,f) (r).pll_freq_sel[1]=(((r).pll_freq_sel[1] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access PLL_FREQ_SEL.
 *
 */
#define BCM53101_A0_READ_PLL_FREQ_SELr(u,r) cdk_robo_reg_read(u,BCM53101_A0_PLL_FREQ_SELr,(r._pll_freq_sel),5)
#define BCM53101_A0_WRITE_PLL_FREQ_SELr(u,r) cdk_robo_reg_write(u,BCM53101_A0_PLL_FREQ_SELr,&(r._pll_freq_sel),5)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PLL_FREQ_SELr BCM53101_A0_PLL_FREQ_SELr
#define PLL_FREQ_SELr_SIZE BCM53101_A0_PLL_FREQ_SELr_SIZE
typedef BCM53101_A0_PLL_FREQ_SELr_t PLL_FREQ_SELr_t;
#define PLL_FREQ_SELr_CLR BCM53101_A0_PLL_FREQ_SELr_CLR
#define PLL_FREQ_SELr_SET BCM53101_A0_PLL_FREQ_SELr_SET
#define PLL_FREQ_SELr_GET BCM53101_A0_PLL_FREQ_SELr_GET
#define PLL_FREQ_SELr_CLKSET_KEY1f_GET BCM53101_A0_PLL_FREQ_SELr_CLKSET_KEY1f_GET
#define PLL_FREQ_SELr_CLKSET_KEY1f_SET BCM53101_A0_PLL_FREQ_SELr_CLKSET_KEY1f_SET
#define PLL_FREQ_SELr_CLKSET_KEY2f_GET BCM53101_A0_PLL_FREQ_SELr_CLKSET_KEY2f_GET
#define PLL_FREQ_SELr_CLKSET_KEY2f_SET BCM53101_A0_PLL_FREQ_SELr_CLKSET_KEY2f_SET
#define PLL_FREQ_SELr_CLKSET_MDIVf_GET BCM53101_A0_PLL_FREQ_SELr_CLKSET_MDIVf_GET
#define PLL_FREQ_SELr_CLKSET_MDIVf_SET BCM53101_A0_PLL_FREQ_SELr_CLKSET_MDIVf_SET
#define PLL_FREQ_SELr_RESERVEDf_GET BCM53101_A0_PLL_FREQ_SELr_RESERVEDf_GET
#define PLL_FREQ_SELr_RESERVEDf_SET BCM53101_A0_PLL_FREQ_SELr_RESERVEDf_SET
#define PLL_FREQ_SELr_CLKSET_RSTf_GET BCM53101_A0_PLL_FREQ_SELr_CLKSET_RSTf_GET
#define PLL_FREQ_SELr_CLKSET_RSTf_SET BCM53101_A0_PLL_FREQ_SELr_CLKSET_RSTf_SET
#define PLL_FREQ_SELr_CLKSET_SPIf_GET BCM53101_A0_PLL_FREQ_SELr_CLKSET_SPIf_GET
#define PLL_FREQ_SELr_CLKSET_SPIf_SET BCM53101_A0_PLL_FREQ_SELr_CLKSET_SPIf_SET
#define PLL_FREQ_SELr_CLKSET_DUMMYf_GET BCM53101_A0_PLL_FREQ_SELr_CLKSET_DUMMYf_GET
#define PLL_FREQ_SELr_CLKSET_DUMMYf_SET BCM53101_A0_PLL_FREQ_SELr_CLKSET_DUMMYf_SET
#define READ_PLL_FREQ_SELr BCM53101_A0_READ_PLL_FREQ_SELr
#define WRITE_PLL_FREQ_SELr BCM53101_A0_WRITE_PLL_FREQ_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PLL_FREQ_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  PLL_STS
 * BLOCKS:   SYS
 * DESC:     PLL Status Register(Engineering Use Only)
 * SIZE:     8
 * FIELDS:
 *     PLL_LOCK         This bit indicates the PLL lock status
 *     RESERVED         RESERVED
 *
 ******************************************************************************/
#define BCM53101_A0_PLL_STSr 0x000000dd

#define BCM53101_A0_PLL_STSr_SIZE 1

/*
 * This structure should be used to declare and program PLL_STS.
 *
 */
typedef union BCM53101_A0_PLL_STSr_s {
	uint32_t v[1];
	uint32_t pll_sts[1];
	uint32_t _pll_sts;
} BCM53101_A0_PLL_STSr_t;

#define BCM53101_A0_PLL_STSr_CLR(r) (r).pll_sts[0] = 0
#define BCM53101_A0_PLL_STSr_SET(r,d) (r).pll_sts[0] = d
#define BCM53101_A0_PLL_STSr_GET(r) (r).pll_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_PLL_STSr_PLL_LOCKf_GET(r) (((r).pll_sts[0]) & 0x1)
#define BCM53101_A0_PLL_STSr_PLL_LOCKf_SET(r,f) (r).pll_sts[0]=(((r).pll_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_PLL_STSr_RESERVEDf_GET(r) ((((r).pll_sts[0]) >> 1) & 0x7f)
#define BCM53101_A0_PLL_STSr_RESERVEDf_SET(r,f) (r).pll_sts[0]=(((r).pll_sts[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access PLL_STS.
 *
 */
#define BCM53101_A0_READ_PLL_STSr(u,r) cdk_robo_reg_read(u,BCM53101_A0_PLL_STSr,(r._pll_sts),1)
#define BCM53101_A0_WRITE_PLL_STSr(u,r) cdk_robo_reg_write(u,BCM53101_A0_PLL_STSr,&(r._pll_sts),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PLL_STSr BCM53101_A0_PLL_STSr
#define PLL_STSr_SIZE BCM53101_A0_PLL_STSr_SIZE
typedef BCM53101_A0_PLL_STSr_t PLL_STSr_t;
#define PLL_STSr_CLR BCM53101_A0_PLL_STSr_CLR
#define PLL_STSr_SET BCM53101_A0_PLL_STSr_SET
#define PLL_STSr_GET BCM53101_A0_PLL_STSr_GET
#define PLL_STSr_PLL_LOCKf_GET BCM53101_A0_PLL_STSr_PLL_LOCKf_GET
#define PLL_STSr_PLL_LOCKf_SET BCM53101_A0_PLL_STSr_PLL_LOCKf_SET
#define PLL_STSr_RESERVEDf_GET BCM53101_A0_PLL_STSr_RESERVEDf_GET
#define PLL_STSr_RESERVEDf_SET BCM53101_A0_PLL_STSr_RESERVEDf_SET
#define READ_PLL_STSr BCM53101_A0_READ_PLL_STSr
#define WRITE_PLL_STSr BCM53101_A0_WRITE_PLL_STSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PLL_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  PLL_TEST_CTRL_I
 * BLOCKS:   SYS
 * DESC:     PLL Test Control Register I Registrer
 * SIZE:     8
 * FIELDS:
 *     PLL_SW_RST       PLL Software reset(normal mode and PLL test mode)When set, this bit assert the PLL reset. Hardware will auto-clear this bit when the reset process is done.
 *     PLL_TEST_EN      PLL Test Enable(normal mode)
 *     PLL_TEST_SEL     PLL Test Selection(normal mode)
 *     PLL_VCO_RNG      PLL VCO Range(normal mode)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_PLL_TEST_CTRL_Ir 0x000000d0

#define BCM53101_A0_PLL_TEST_CTRL_Ir_SIZE 1

/*
 * This structure should be used to declare and program PLL_TEST_CTRL_I.
 *
 */
typedef union BCM53101_A0_PLL_TEST_CTRL_Ir_s {
	uint32_t v[1];
	uint32_t pll_test_ctrl_i[1];
	uint32_t _pll_test_ctrl_i;
} BCM53101_A0_PLL_TEST_CTRL_Ir_t;

#define BCM53101_A0_PLL_TEST_CTRL_Ir_CLR(r) (r).pll_test_ctrl_i[0] = 0
#define BCM53101_A0_PLL_TEST_CTRL_Ir_SET(r,d) (r).pll_test_ctrl_i[0] = d
#define BCM53101_A0_PLL_TEST_CTRL_Ir_GET(r) (r).pll_test_ctrl_i[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_PLL_TEST_CTRL_Ir_PLL_SW_RSTf_GET(r) (((r).pll_test_ctrl_i[0]) & 0x1)
#define BCM53101_A0_PLL_TEST_CTRL_Ir_PLL_SW_RSTf_SET(r,f) (r).pll_test_ctrl_i[0]=(((r).pll_test_ctrl_i[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_PLL_TEST_CTRL_Ir_PLL_TEST_ENf_GET(r) ((((r).pll_test_ctrl_i[0]) >> 1) & 0x1)
#define BCM53101_A0_PLL_TEST_CTRL_Ir_PLL_TEST_ENf_SET(r,f) (r).pll_test_ctrl_i[0]=(((r).pll_test_ctrl_i[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_PLL_TEST_CTRL_Ir_PLL_TEST_SELf_GET(r) ((((r).pll_test_ctrl_i[0]) >> 2) & 0x7)
#define BCM53101_A0_PLL_TEST_CTRL_Ir_PLL_TEST_SELf_SET(r,f) (r).pll_test_ctrl_i[0]=(((r).pll_test_ctrl_i[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2))
#define BCM53101_A0_PLL_TEST_CTRL_Ir_PLL_VCO_RNGf_GET(r) ((((r).pll_test_ctrl_i[0]) >> 5) & 0x3)
#define BCM53101_A0_PLL_TEST_CTRL_Ir_PLL_VCO_RNGf_SET(r,f) (r).pll_test_ctrl_i[0]=(((r).pll_test_ctrl_i[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM53101_A0_PLL_TEST_CTRL_Ir_RESERVEDf_GET(r) ((((r).pll_test_ctrl_i[0]) >> 7) & 0x1)
#define BCM53101_A0_PLL_TEST_CTRL_Ir_RESERVEDf_SET(r,f) (r).pll_test_ctrl_i[0]=(((r).pll_test_ctrl_i[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access PLL_TEST_CTRL_I.
 *
 */
#define BCM53101_A0_READ_PLL_TEST_CTRL_Ir(u,r) cdk_robo_reg_read(u,BCM53101_A0_PLL_TEST_CTRL_Ir,(r._pll_test_ctrl_i),1)
#define BCM53101_A0_WRITE_PLL_TEST_CTRL_Ir(u,r) cdk_robo_reg_write(u,BCM53101_A0_PLL_TEST_CTRL_Ir,&(r._pll_test_ctrl_i),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PLL_TEST_CTRL_Ir BCM53101_A0_PLL_TEST_CTRL_Ir
#define PLL_TEST_CTRL_Ir_SIZE BCM53101_A0_PLL_TEST_CTRL_Ir_SIZE
typedef BCM53101_A0_PLL_TEST_CTRL_Ir_t PLL_TEST_CTRL_Ir_t;
#define PLL_TEST_CTRL_Ir_CLR BCM53101_A0_PLL_TEST_CTRL_Ir_CLR
#define PLL_TEST_CTRL_Ir_SET BCM53101_A0_PLL_TEST_CTRL_Ir_SET
#define PLL_TEST_CTRL_Ir_GET BCM53101_A0_PLL_TEST_CTRL_Ir_GET
#define PLL_TEST_CTRL_Ir_PLL_SW_RSTf_GET BCM53101_A0_PLL_TEST_CTRL_Ir_PLL_SW_RSTf_GET
#define PLL_TEST_CTRL_Ir_PLL_SW_RSTf_SET BCM53101_A0_PLL_TEST_CTRL_Ir_PLL_SW_RSTf_SET
#define PLL_TEST_CTRL_Ir_PLL_TEST_ENf_GET BCM53101_A0_PLL_TEST_CTRL_Ir_PLL_TEST_ENf_GET
#define PLL_TEST_CTRL_Ir_PLL_TEST_ENf_SET BCM53101_A0_PLL_TEST_CTRL_Ir_PLL_TEST_ENf_SET
#define PLL_TEST_CTRL_Ir_PLL_TEST_SELf_GET BCM53101_A0_PLL_TEST_CTRL_Ir_PLL_TEST_SELf_GET
#define PLL_TEST_CTRL_Ir_PLL_TEST_SELf_SET BCM53101_A0_PLL_TEST_CTRL_Ir_PLL_TEST_SELf_SET
#define PLL_TEST_CTRL_Ir_PLL_VCO_RNGf_GET BCM53101_A0_PLL_TEST_CTRL_Ir_PLL_VCO_RNGf_GET
#define PLL_TEST_CTRL_Ir_PLL_VCO_RNGf_SET BCM53101_A0_PLL_TEST_CTRL_Ir_PLL_VCO_RNGf_SET
#define PLL_TEST_CTRL_Ir_RESERVEDf_GET BCM53101_A0_PLL_TEST_CTRL_Ir_RESERVEDf_GET
#define PLL_TEST_CTRL_Ir_RESERVEDf_SET BCM53101_A0_PLL_TEST_CTRL_Ir_RESERVEDf_SET
#define READ_PLL_TEST_CTRL_Ir BCM53101_A0_READ_PLL_TEST_CTRL_Ir
#define WRITE_PLL_TEST_CTRL_Ir BCM53101_A0_WRITE_PLL_TEST_CTRL_Ir

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PLL_TEST_CTRL_Ir'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  PLL_TEST_CTRL_II
 * BLOCKS:   SYS
 * DESC:     PLL Test Control Register II Registrer
 * SIZE:     48
 * FIELDS:
 *     PLL_TEST_CTRL    PLL Test Control(normal mode and PLL test mode)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_PLL_TEST_CTRL_IIr 0x000000d1

#define BCM53101_A0_PLL_TEST_CTRL_IIr_SIZE 6

/*
 * This structure should be used to declare and program PLL_TEST_CTRL_II.
 *
 */
typedef union BCM53101_A0_PLL_TEST_CTRL_IIr_s {
	uint32_t v[2];
	uint32_t pll_test_ctrl_ii[2];
	uint32_t _pll_test_ctrl_ii;
} BCM53101_A0_PLL_TEST_CTRL_IIr_t;

#define BCM53101_A0_PLL_TEST_CTRL_IIr_CLR(r) CDK_MEMSET(&((r)._pll_test_ctrl_ii), 0, sizeof(BCM53101_A0_PLL_TEST_CTRL_IIr_t))
#define BCM53101_A0_PLL_TEST_CTRL_IIr_SET(r,i,d) (r).pll_test_ctrl_ii[i] = d
#define BCM53101_A0_PLL_TEST_CTRL_IIr_GET(r,i) (r).pll_test_ctrl_ii[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_PLL_TEST_CTRL_IIr_PLL_TEST_CTRLf_GET(r,a) cdk_field_get((r).pll_test_ctrl_ii,0,37,a)
#define BCM53101_A0_PLL_TEST_CTRL_IIr_PLL_TEST_CTRLf_SET(r,a) cdk_field_set((r).pll_test_ctrl_ii,0,37,a)
#define BCM53101_A0_PLL_TEST_CTRL_IIr_RESERVEDf_GET(r) ((((r).pll_test_ctrl_ii[1]) >> 6) & 0x3ff)
#define BCM53101_A0_PLL_TEST_CTRL_IIr_RESERVEDf_SET(r,f) (r).pll_test_ctrl_ii[1]=(((r).pll_test_ctrl_ii[1] & ~((uint32_t)0x3ff << 6)) | ((((uint32_t)f) & 0x3ff) << 6))

/*
 * These macros can be used to access PLL_TEST_CTRL_II.
 *
 */
#define BCM53101_A0_READ_PLL_TEST_CTRL_IIr(u,r) cdk_robo_reg_read(u,BCM53101_A0_PLL_TEST_CTRL_IIr,(r._pll_test_ctrl_ii),6)
#define BCM53101_A0_WRITE_PLL_TEST_CTRL_IIr(u,r) cdk_robo_reg_write(u,BCM53101_A0_PLL_TEST_CTRL_IIr,&(r._pll_test_ctrl_ii),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PLL_TEST_CTRL_IIr BCM53101_A0_PLL_TEST_CTRL_IIr
#define PLL_TEST_CTRL_IIr_SIZE BCM53101_A0_PLL_TEST_CTRL_IIr_SIZE
typedef BCM53101_A0_PLL_TEST_CTRL_IIr_t PLL_TEST_CTRL_IIr_t;
#define PLL_TEST_CTRL_IIr_CLR BCM53101_A0_PLL_TEST_CTRL_IIr_CLR
#define PLL_TEST_CTRL_IIr_SET BCM53101_A0_PLL_TEST_CTRL_IIr_SET
#define PLL_TEST_CTRL_IIr_GET BCM53101_A0_PLL_TEST_CTRL_IIr_GET
#define PLL_TEST_CTRL_IIr_PLL_TEST_CTRLf_GET BCM53101_A0_PLL_TEST_CTRL_IIr_PLL_TEST_CTRLf_GET
#define PLL_TEST_CTRL_IIr_PLL_TEST_CTRLf_SET BCM53101_A0_PLL_TEST_CTRL_IIr_PLL_TEST_CTRLf_SET
#define PLL_TEST_CTRL_IIr_RESERVEDf_GET BCM53101_A0_PLL_TEST_CTRL_IIr_RESERVEDf_GET
#define PLL_TEST_CTRL_IIr_RESERVEDf_SET BCM53101_A0_PLL_TEST_CTRL_IIr_RESERVEDf_SET
#define READ_PLL_TEST_CTRL_IIr BCM53101_A0_READ_PLL_TEST_CTRL_IIr
#define WRITE_PLL_TEST_CTRL_IIr BCM53101_A0_WRITE_PLL_TEST_CTRL_IIr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PLL_TEST_CTRL_IIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  PN_PCP2TC
 * BLOCKS:   CPIC EPIC0
 * DESC:     Port N(0~4) PCP to TC Map Register
 * SIZE:     32
 * FIELDS:
 *     TAG000_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 000 to Priority ID map Register
 *     TAG001_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 001 to Priority ID map Register
 *     TAG010_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 010 to Priority ID map Register
 *     TAG011_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 011 to Priority ID map Register
 *     TAG100_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 100 to Priority ID map Register
 *     TAG101_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 101 to Priority ID map Register
 *     TAG110_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 110 to Priority ID map Register
 *     TAG111_PRI_MAP   Priority Map.802.1P/1Q Priority Tag field == 111 to Priority ID map Register
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_PN_PCP2TCr 0x00003010

#define BCM53101_A0_PN_PCP2TCr_SIZE 4

/*
 * This structure should be used to declare and program PN_PCP2TC.
 *
 */
typedef union BCM53101_A0_PN_PCP2TCr_s {
	uint32_t v[1];
	uint32_t pn_pcp2tc[1];
	uint32_t _pn_pcp2tc;
} BCM53101_A0_PN_PCP2TCr_t;

#define BCM53101_A0_PN_PCP2TCr_CLR(r) (r).pn_pcp2tc[0] = 0
#define BCM53101_A0_PN_PCP2TCr_SET(r,d) (r).pn_pcp2tc[0] = d
#define BCM53101_A0_PN_PCP2TCr_GET(r) (r).pn_pcp2tc[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_PN_PCP2TCr_TAG000_PRI_MAPf_GET(r) (((r).pn_pcp2tc[0]) & 0x7)
#define BCM53101_A0_PN_PCP2TCr_TAG000_PRI_MAPf_SET(r,f) (r).pn_pcp2tc[0]=(((r).pn_pcp2tc[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53101_A0_PN_PCP2TCr_TAG001_PRI_MAPf_GET(r) ((((r).pn_pcp2tc[0]) >> 3) & 0x7)
#define BCM53101_A0_PN_PCP2TCr_TAG001_PRI_MAPf_SET(r,f) (r).pn_pcp2tc[0]=(((r).pn_pcp2tc[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM53101_A0_PN_PCP2TCr_TAG010_PRI_MAPf_GET(r) ((((r).pn_pcp2tc[0]) >> 6) & 0x7)
#define BCM53101_A0_PN_PCP2TCr_TAG010_PRI_MAPf_SET(r,f) (r).pn_pcp2tc[0]=(((r).pn_pcp2tc[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM53101_A0_PN_PCP2TCr_TAG011_PRI_MAPf_GET(r) ((((r).pn_pcp2tc[0]) >> 9) & 0x7)
#define BCM53101_A0_PN_PCP2TCr_TAG011_PRI_MAPf_SET(r,f) (r).pn_pcp2tc[0]=(((r).pn_pcp2tc[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM53101_A0_PN_PCP2TCr_TAG100_PRI_MAPf_GET(r) ((((r).pn_pcp2tc[0]) >> 12) & 0x7)
#define BCM53101_A0_PN_PCP2TCr_TAG100_PRI_MAPf_SET(r,f) (r).pn_pcp2tc[0]=(((r).pn_pcp2tc[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53101_A0_PN_PCP2TCr_TAG101_PRI_MAPf_GET(r) ((((r).pn_pcp2tc[0]) >> 15) & 0x7)
#define BCM53101_A0_PN_PCP2TCr_TAG101_PRI_MAPf_SET(r,f) (r).pn_pcp2tc[0]=(((r).pn_pcp2tc[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM53101_A0_PN_PCP2TCr_TAG110_PRI_MAPf_GET(r) ((((r).pn_pcp2tc[0]) >> 18) & 0x7)
#define BCM53101_A0_PN_PCP2TCr_TAG110_PRI_MAPf_SET(r,f) (r).pn_pcp2tc[0]=(((r).pn_pcp2tc[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM53101_A0_PN_PCP2TCr_TAG111_PRI_MAPf_GET(r) ((((r).pn_pcp2tc[0]) >> 21) & 0x7)
#define BCM53101_A0_PN_PCP2TCr_TAG111_PRI_MAPf_SET(r,f) (r).pn_pcp2tc[0]=(((r).pn_pcp2tc[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM53101_A0_PN_PCP2TCr_RESERVEDf_GET(r) ((((r).pn_pcp2tc[0]) >> 24) & 0xff)
#define BCM53101_A0_PN_PCP2TCr_RESERVEDf_SET(r,f) (r).pn_pcp2tc[0]=(((r).pn_pcp2tc[0] & ~((uint32_t)0xff << 24)) | ((((uint32_t)f) & 0xff) << 24))

/*
 * These macros can be used to access PN_PCP2TC.
 *
 */
#define BCM53101_A0_READ_PN_PCP2TCr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_PN_PCP2TCr,(r._pn_pcp2tc),4)
#define BCM53101_A0_WRITE_PN_PCP2TCr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_PN_PCP2TCr,&(r._pn_pcp2tc),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PN_PCP2TCr BCM53101_A0_PN_PCP2TCr
#define PN_PCP2TCr_SIZE BCM53101_A0_PN_PCP2TCr_SIZE
typedef BCM53101_A0_PN_PCP2TCr_t PN_PCP2TCr_t;
#define PN_PCP2TCr_CLR BCM53101_A0_PN_PCP2TCr_CLR
#define PN_PCP2TCr_SET BCM53101_A0_PN_PCP2TCr_SET
#define PN_PCP2TCr_GET BCM53101_A0_PN_PCP2TCr_GET
#define PN_PCP2TCr_TAG000_PRI_MAPf_GET BCM53101_A0_PN_PCP2TCr_TAG000_PRI_MAPf_GET
#define PN_PCP2TCr_TAG000_PRI_MAPf_SET BCM53101_A0_PN_PCP2TCr_TAG000_PRI_MAPf_SET
#define PN_PCP2TCr_TAG001_PRI_MAPf_GET BCM53101_A0_PN_PCP2TCr_TAG001_PRI_MAPf_GET
#define PN_PCP2TCr_TAG001_PRI_MAPf_SET BCM53101_A0_PN_PCP2TCr_TAG001_PRI_MAPf_SET
#define PN_PCP2TCr_TAG010_PRI_MAPf_GET BCM53101_A0_PN_PCP2TCr_TAG010_PRI_MAPf_GET
#define PN_PCP2TCr_TAG010_PRI_MAPf_SET BCM53101_A0_PN_PCP2TCr_TAG010_PRI_MAPf_SET
#define PN_PCP2TCr_TAG011_PRI_MAPf_GET BCM53101_A0_PN_PCP2TCr_TAG011_PRI_MAPf_GET
#define PN_PCP2TCr_TAG011_PRI_MAPf_SET BCM53101_A0_PN_PCP2TCr_TAG011_PRI_MAPf_SET
#define PN_PCP2TCr_TAG100_PRI_MAPf_GET BCM53101_A0_PN_PCP2TCr_TAG100_PRI_MAPf_GET
#define PN_PCP2TCr_TAG100_PRI_MAPf_SET BCM53101_A0_PN_PCP2TCr_TAG100_PRI_MAPf_SET
#define PN_PCP2TCr_TAG101_PRI_MAPf_GET BCM53101_A0_PN_PCP2TCr_TAG101_PRI_MAPf_GET
#define PN_PCP2TCr_TAG101_PRI_MAPf_SET BCM53101_A0_PN_PCP2TCr_TAG101_PRI_MAPf_SET
#define PN_PCP2TCr_TAG110_PRI_MAPf_GET BCM53101_A0_PN_PCP2TCr_TAG110_PRI_MAPf_GET
#define PN_PCP2TCr_TAG110_PRI_MAPf_SET BCM53101_A0_PN_PCP2TCr_TAG110_PRI_MAPf_SET
#define PN_PCP2TCr_TAG111_PRI_MAPf_GET BCM53101_A0_PN_PCP2TCr_TAG111_PRI_MAPf_GET
#define PN_PCP2TCr_TAG111_PRI_MAPf_SET BCM53101_A0_PN_PCP2TCr_TAG111_PRI_MAPf_SET
#define PN_PCP2TCr_RESERVEDf_GET BCM53101_A0_PN_PCP2TCr_RESERVEDf_GET
#define PN_PCP2TCr_RESERVEDf_SET BCM53101_A0_PN_PCP2TCr_RESERVEDf_SET
#define READ_PN_PCP2TCr BCM53101_A0_READ_PN_PCP2TCr
#define WRITE_PN_PCP2TCr BCM53101_A0_WRITE_PN_PCP2TCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PN_PCP2TCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  PORT5_RGMII_CTL_GP
 * BLOCKS:   CPIC
 * DESC:     Port 5 RGMII Control register
 * SIZE:     8
 * FIELDS:
 *     TXC_DLL_DLY_EN   1: RGMII tx_clk delayed timing mode0: RGMII tx_clk aligned timing modedefault value by strap pin gmii_txc_delay.
 *     RXC_DLL_DLY_EN   1: clock delay by DLL is enabled0: clock delay by DLL is disabled (Normal Mode)default value by strap pin gmii_rxc_delay.
 *     RESERVED_1       Reserved
 *     RESERVED_2       Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_PORT5_RGMII_CTL_GPr 0x00000065

#define BCM53101_A0_PORT5_RGMII_CTL_GPr_SIZE 1

/*
 * This structure should be used to declare and program PORT5_RGMII_CTL_GP.
 *
 */
typedef union BCM53101_A0_PORT5_RGMII_CTL_GPr_s {
	uint32_t v[1];
	uint32_t port5_rgmii_ctl_gp[1];
	uint32_t _port5_rgmii_ctl_gp;
} BCM53101_A0_PORT5_RGMII_CTL_GPr_t;

#define BCM53101_A0_PORT5_RGMII_CTL_GPr_CLR(r) (r).port5_rgmii_ctl_gp[0] = 0
#define BCM53101_A0_PORT5_RGMII_CTL_GPr_SET(r,d) (r).port5_rgmii_ctl_gp[0] = d
#define BCM53101_A0_PORT5_RGMII_CTL_GPr_GET(r) (r).port5_rgmii_ctl_gp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_PORT5_RGMII_CTL_GPr_TXC_DLL_DLY_ENf_GET(r) (((r).port5_rgmii_ctl_gp[0]) & 0x1)
#define BCM53101_A0_PORT5_RGMII_CTL_GPr_TXC_DLL_DLY_ENf_SET(r,f) (r).port5_rgmii_ctl_gp[0]=(((r).port5_rgmii_ctl_gp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_PORT5_RGMII_CTL_GPr_RXC_DLL_DLY_ENf_GET(r) ((((r).port5_rgmii_ctl_gp[0]) >> 1) & 0x1)
#define BCM53101_A0_PORT5_RGMII_CTL_GPr_RXC_DLL_DLY_ENf_SET(r,f) (r).port5_rgmii_ctl_gp[0]=(((r).port5_rgmii_ctl_gp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_PORT5_RGMII_CTL_GPr_RESERVED_1f_GET(r) ((((r).port5_rgmii_ctl_gp[0]) >> 2) & 0x3)
#define BCM53101_A0_PORT5_RGMII_CTL_GPr_RESERVED_1f_SET(r,f) (r).port5_rgmii_ctl_gp[0]=(((r).port5_rgmii_ctl_gp[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53101_A0_PORT5_RGMII_CTL_GPr_RESERVED_2f_GET(r) ((((r).port5_rgmii_ctl_gp[0]) >> 4) & 0xf)
#define BCM53101_A0_PORT5_RGMII_CTL_GPr_RESERVED_2f_SET(r,f) (r).port5_rgmii_ctl_gp[0]=(((r).port5_rgmii_ctl_gp[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access PORT5_RGMII_CTL_GP.
 *
 */
#define BCM53101_A0_READ_PORT5_RGMII_CTL_GPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_PORT5_RGMII_CTL_GPr,(r._port5_rgmii_ctl_gp),1)
#define BCM53101_A0_WRITE_PORT5_RGMII_CTL_GPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_PORT5_RGMII_CTL_GPr,&(r._port5_rgmii_ctl_gp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT5_RGMII_CTL_GPr BCM53101_A0_PORT5_RGMII_CTL_GPr
#define PORT5_RGMII_CTL_GPr_SIZE BCM53101_A0_PORT5_RGMII_CTL_GPr_SIZE
typedef BCM53101_A0_PORT5_RGMII_CTL_GPr_t PORT5_RGMII_CTL_GPr_t;
#define PORT5_RGMII_CTL_GPr_CLR BCM53101_A0_PORT5_RGMII_CTL_GPr_CLR
#define PORT5_RGMII_CTL_GPr_SET BCM53101_A0_PORT5_RGMII_CTL_GPr_SET
#define PORT5_RGMII_CTL_GPr_GET BCM53101_A0_PORT5_RGMII_CTL_GPr_GET
#define PORT5_RGMII_CTL_GPr_TXC_DLL_DLY_ENf_GET BCM53101_A0_PORT5_RGMII_CTL_GPr_TXC_DLL_DLY_ENf_GET
#define PORT5_RGMII_CTL_GPr_TXC_DLL_DLY_ENf_SET BCM53101_A0_PORT5_RGMII_CTL_GPr_TXC_DLL_DLY_ENf_SET
#define PORT5_RGMII_CTL_GPr_RXC_DLL_DLY_ENf_GET BCM53101_A0_PORT5_RGMII_CTL_GPr_RXC_DLL_DLY_ENf_GET
#define PORT5_RGMII_CTL_GPr_RXC_DLL_DLY_ENf_SET BCM53101_A0_PORT5_RGMII_CTL_GPr_RXC_DLL_DLY_ENf_SET
#define PORT5_RGMII_CTL_GPr_RESERVED_1f_GET BCM53101_A0_PORT5_RGMII_CTL_GPr_RESERVED_1f_GET
#define PORT5_RGMII_CTL_GPr_RESERVED_1f_SET BCM53101_A0_PORT5_RGMII_CTL_GPr_RESERVED_1f_SET
#define PORT5_RGMII_CTL_GPr_RESERVED_2f_GET BCM53101_A0_PORT5_RGMII_CTL_GPr_RESERVED_2f_GET
#define PORT5_RGMII_CTL_GPr_RESERVED_2f_SET BCM53101_A0_PORT5_RGMII_CTL_GPr_RESERVED_2f_SET
#define READ_PORT5_RGMII_CTL_GPr BCM53101_A0_READ_PORT5_RGMII_CTL_GPr
#define WRITE_PORT5_RGMII_CTL_GPr BCM53101_A0_WRITE_PORT5_RGMII_CTL_GPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PORT5_RGMII_CTL_GPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  PORT_CROSS_CONNECT
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Port Cross Connect Destination Register
 * SIZE:     16
 * FIELDS:
 *     PCC_DEST         Per bit per port cross connect destination registerA bit mask corresponding to the physical ports on the chip.  When the receive port is configured to be in the cross connect mode, all received packets are forwarded to the destination port(s) that is specified by this register, regardless of the result of layer 2 lookup operation. Setting the corresponding bit to `1` indicates it is the destination port.Bit8: port 8.Bit0-7: port 0-7.
 *     RESERVED         Reserved
 *     PCC_ENABLE       Per port cross connect enable registerSetting this field to `1` enables the port to operate in cross connect mode.The port-cross-connect decision will overrule all the ARL decisions. Therefore MAC-LAND(MACDA=MACSA) packets which are originally dropped by ARL will pass through in port-cross-connect mode.However, dos-attack drop and ACL will still take effect when enabled.It is recommended that user should also configure disable-learning and preserve-ingress-packet-format registers for port-cross-connect function.
 *
 ******************************************************************************/
#define BCM53101_A0_PORT_CROSS_CONNECTr 0x00000090

#define BCM53101_A0_PORT_CROSS_CONNECTr_SIZE 2

/*
 * This structure should be used to declare and program PORT_CROSS_CONNECT.
 *
 */
typedef union BCM53101_A0_PORT_CROSS_CONNECTr_s {
	uint32_t v[1];
	uint32_t port_cross_connect[1];
	uint32_t _port_cross_connect;
} BCM53101_A0_PORT_CROSS_CONNECTr_t;

#define BCM53101_A0_PORT_CROSS_CONNECTr_CLR(r) (r).port_cross_connect[0] = 0
#define BCM53101_A0_PORT_CROSS_CONNECTr_SET(r,d) (r).port_cross_connect[0] = d
#define BCM53101_A0_PORT_CROSS_CONNECTr_GET(r) (r).port_cross_connect[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_PORT_CROSS_CONNECTr_PCC_DESTf_GET(r) (((r).port_cross_connect[0]) & 0x1ff)
#define BCM53101_A0_PORT_CROSS_CONNECTr_PCC_DESTf_SET(r,f) (r).port_cross_connect[0]=(((r).port_cross_connect[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_PORT_CROSS_CONNECTr_RESERVEDf_GET(r) ((((r).port_cross_connect[0]) >> 9) & 0x3f)
#define BCM53101_A0_PORT_CROSS_CONNECTr_RESERVEDf_SET(r,f) (r).port_cross_connect[0]=(((r).port_cross_connect[0] & ~((uint32_t)0x3f << 9)) | ((((uint32_t)f) & 0x3f) << 9))
#define BCM53101_A0_PORT_CROSS_CONNECTr_PCC_ENABLEf_GET(r) ((((r).port_cross_connect[0]) >> 15) & 0x1)
#define BCM53101_A0_PORT_CROSS_CONNECTr_PCC_ENABLEf_SET(r,f) (r).port_cross_connect[0]=(((r).port_cross_connect[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access PORT_CROSS_CONNECT.
 *
 */
#define BCM53101_A0_READ_PORT_CROSS_CONNECTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_PORT_CROSS_CONNECTr,(r._port_cross_connect),2)
#define BCM53101_A0_WRITE_PORT_CROSS_CONNECTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_PORT_CROSS_CONNECTr,&(r._port_cross_connect),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_CROSS_CONNECTr BCM53101_A0_PORT_CROSS_CONNECTr
#define PORT_CROSS_CONNECTr_SIZE BCM53101_A0_PORT_CROSS_CONNECTr_SIZE
typedef BCM53101_A0_PORT_CROSS_CONNECTr_t PORT_CROSS_CONNECTr_t;
#define PORT_CROSS_CONNECTr_CLR BCM53101_A0_PORT_CROSS_CONNECTr_CLR
#define PORT_CROSS_CONNECTr_SET BCM53101_A0_PORT_CROSS_CONNECTr_SET
#define PORT_CROSS_CONNECTr_GET BCM53101_A0_PORT_CROSS_CONNECTr_GET
#define PORT_CROSS_CONNECTr_PCC_DESTf_GET BCM53101_A0_PORT_CROSS_CONNECTr_PCC_DESTf_GET
#define PORT_CROSS_CONNECTr_PCC_DESTf_SET BCM53101_A0_PORT_CROSS_CONNECTr_PCC_DESTf_SET
#define PORT_CROSS_CONNECTr_RESERVEDf_GET BCM53101_A0_PORT_CROSS_CONNECTr_RESERVEDf_GET
#define PORT_CROSS_CONNECTr_RESERVEDf_SET BCM53101_A0_PORT_CROSS_CONNECTr_RESERVEDf_SET
#define PORT_CROSS_CONNECTr_PCC_ENABLEf_GET BCM53101_A0_PORT_CROSS_CONNECTr_PCC_ENABLEf_GET
#define PORT_CROSS_CONNECTr_PCC_ENABLEf_SET BCM53101_A0_PORT_CROSS_CONNECTr_PCC_ENABLEf_SET
#define READ_PORT_CROSS_CONNECTr BCM53101_A0_READ_PORT_CROSS_CONNECTr
#define WRITE_PORT_CROSS_CONNECTr BCM53101_A0_WRITE_PORT_CROSS_CONNECTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PORT_CROSS_CONNECTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  PORT_EAP_CON
 * BLOCKS:   EPIC0
 * DESC:     Port EAP Configuration Registers
 * SIZE:     64
 * FIELDS:
 *     EAP_UNI_DA       EAP frame DA register.
 *     EAP_EN_UNI_DA    enable EAP frame with DA.
 *     EAP_BLK_MODE     00: Do not check EAP_BLK_MODE.01: Check EAP_BLK_MODE on ingress port, only frame defined in EAP_GCFG will be forwarded. Otherwise frame will be dropped.10: Reserved11: Check EAP_BLK_MODE on both ingress and egress port, only frame defined in EAP_GCFG will be forwarded. Especially, the forwarding process will check whether each egress port is at block mode or not.
 *     EAP_MODE         00 : Basic mode, do not check SA,01 : Reserved.10 : Extend mode, check SA & port-number. Drop if SA is unknown.11 : Simplified mode, check SA & port-number. Trap to mgnt-port if SA is unknown.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_PORT_EAP_CONr 0x00004220

#define BCM53101_A0_PORT_EAP_CONr_SIZE 8

/*
 * This structure should be used to declare and program PORT_EAP_CON.
 *
 */
typedef union BCM53101_A0_PORT_EAP_CONr_s {
	uint32_t v[2];
	uint32_t port_eap_con[2];
	uint32_t _port_eap_con;
} BCM53101_A0_PORT_EAP_CONr_t;

#define BCM53101_A0_PORT_EAP_CONr_CLR(r) CDK_MEMSET(&((r)._port_eap_con), 0, sizeof(BCM53101_A0_PORT_EAP_CONr_t))
#define BCM53101_A0_PORT_EAP_CONr_SET(r,i,d) (r).port_eap_con[i] = d
#define BCM53101_A0_PORT_EAP_CONr_GET(r,i) (r).port_eap_con[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_PORT_EAP_CONr_EAP_UNI_DAf_GET(r,a) cdk_field_get((r).port_eap_con,0,47,a)
#define BCM53101_A0_PORT_EAP_CONr_EAP_UNI_DAf_SET(r,a) cdk_field_set((r).port_eap_con,0,47,a)
#define BCM53101_A0_PORT_EAP_CONr_EAP_EN_UNI_DAf_GET(r) ((((r).port_eap_con[1]) >> 16) & 0x1)
#define BCM53101_A0_PORT_EAP_CONr_EAP_EN_UNI_DAf_SET(r,f) (r).port_eap_con[1]=(((r).port_eap_con[1] & ~((uint32_t)0x1 << 16)) | ((((uint32_t)f) & 0x1) << 16))
#define BCM53101_A0_PORT_EAP_CONr_EAP_BLK_MODEf_GET(r) ((((r).port_eap_con[1]) >> 17) & 0x3)
#define BCM53101_A0_PORT_EAP_CONr_EAP_BLK_MODEf_SET(r,f) (r).port_eap_con[1]=(((r).port_eap_con[1] & ~((uint32_t)0x3 << 17)) | ((((uint32_t)f) & 0x3) << 17))
#define BCM53101_A0_PORT_EAP_CONr_EAP_MODEf_GET(r) ((((r).port_eap_con[1]) >> 19) & 0x3)
#define BCM53101_A0_PORT_EAP_CONr_EAP_MODEf_SET(r,f) (r).port_eap_con[1]=(((r).port_eap_con[1] & ~((uint32_t)0x3 << 19)) | ((((uint32_t)f) & 0x3) << 19))
#define BCM53101_A0_PORT_EAP_CONr_RESERVEDf_GET(r) ((((r).port_eap_con[1]) >> 21) & 0x7ff)
#define BCM53101_A0_PORT_EAP_CONr_RESERVEDf_SET(r,f) (r).port_eap_con[1]=(((r).port_eap_con[1] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access PORT_EAP_CON.
 *
 */
#define BCM53101_A0_READ_PORT_EAP_CONr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_PORT_EAP_CONr,(r._port_eap_con),8)
#define BCM53101_A0_WRITE_PORT_EAP_CONr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_PORT_EAP_CONr,&(r._port_eap_con),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_EAP_CONr BCM53101_A0_PORT_EAP_CONr
#define PORT_EAP_CONr_SIZE BCM53101_A0_PORT_EAP_CONr_SIZE
typedef BCM53101_A0_PORT_EAP_CONr_t PORT_EAP_CONr_t;
#define PORT_EAP_CONr_CLR BCM53101_A0_PORT_EAP_CONr_CLR
#define PORT_EAP_CONr_SET BCM53101_A0_PORT_EAP_CONr_SET
#define PORT_EAP_CONr_GET BCM53101_A0_PORT_EAP_CONr_GET
#define PORT_EAP_CONr_EAP_UNI_DAf_GET BCM53101_A0_PORT_EAP_CONr_EAP_UNI_DAf_GET
#define PORT_EAP_CONr_EAP_UNI_DAf_SET BCM53101_A0_PORT_EAP_CONr_EAP_UNI_DAf_SET
#define PORT_EAP_CONr_EAP_EN_UNI_DAf_GET BCM53101_A0_PORT_EAP_CONr_EAP_EN_UNI_DAf_GET
#define PORT_EAP_CONr_EAP_EN_UNI_DAf_SET BCM53101_A0_PORT_EAP_CONr_EAP_EN_UNI_DAf_SET
#define PORT_EAP_CONr_EAP_BLK_MODEf_GET BCM53101_A0_PORT_EAP_CONr_EAP_BLK_MODEf_GET
#define PORT_EAP_CONr_EAP_BLK_MODEf_SET BCM53101_A0_PORT_EAP_CONr_EAP_BLK_MODEf_SET
#define PORT_EAP_CONr_EAP_MODEf_GET BCM53101_A0_PORT_EAP_CONr_EAP_MODEf_GET
#define PORT_EAP_CONr_EAP_MODEf_SET BCM53101_A0_PORT_EAP_CONr_EAP_MODEf_SET
#define PORT_EAP_CONr_RESERVEDf_GET BCM53101_A0_PORT_EAP_CONr_RESERVEDf_GET
#define PORT_EAP_CONr_RESERVEDf_SET BCM53101_A0_PORT_EAP_CONr_RESERVEDf_SET
#define READ_PORT_EAP_CONr BCM53101_A0_READ_PORT_EAP_CONr
#define WRITE_PORT_EAP_CONr BCM53101_A0_WRITE_PORT_EAP_CONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PORT_EAP_CONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  PORT_ERC_CON
 * BLOCKS:   CPIC EPIC0
 * DESC:     Port Egress Rate Control Configuration Registers
 * SIZE:     16
 * FIELDS:
 *     REF_CNT          Refresh count for bucket.
 *     BUCKET_SIZE      Bucket Size.000 : 16KB001 : 20KB,010 : 28KB,011 : 40KB,100 : 76KB,others : 500KB.
 *     EGRESS_RC_EN     Egress Rate control Enable.
 *     PORT_ERC_CON_RSRV2 Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_PORT_ERC_CONr 0x00004180

#define BCM53101_A0_PORT_ERC_CONr_SIZE 2

/*
 * This structure should be used to declare and program PORT_ERC_CON.
 *
 */
typedef union BCM53101_A0_PORT_ERC_CONr_s {
	uint32_t v[1];
	uint32_t port_erc_con[1];
	uint32_t _port_erc_con;
} BCM53101_A0_PORT_ERC_CONr_t;

#define BCM53101_A0_PORT_ERC_CONr_CLR(r) (r).port_erc_con[0] = 0
#define BCM53101_A0_PORT_ERC_CONr_SET(r,d) (r).port_erc_con[0] = d
#define BCM53101_A0_PORT_ERC_CONr_GET(r) (r).port_erc_con[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_PORT_ERC_CONr_REF_CNTf_GET(r) (((r).port_erc_con[0]) & 0xff)
#define BCM53101_A0_PORT_ERC_CONr_REF_CNTf_SET(r,f) (r).port_erc_con[0]=(((r).port_erc_con[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53101_A0_PORT_ERC_CONr_BUCKET_SIZEf_GET(r) ((((r).port_erc_con[0]) >> 8) & 0x7)
#define BCM53101_A0_PORT_ERC_CONr_BUCKET_SIZEf_SET(r,f) (r).port_erc_con[0]=(((r).port_erc_con[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCM53101_A0_PORT_ERC_CONr_EGRESS_RC_ENf_GET(r) ((((r).port_erc_con[0]) >> 11) & 0x1)
#define BCM53101_A0_PORT_ERC_CONr_EGRESS_RC_ENf_SET(r,f) (r).port_erc_con[0]=(((r).port_erc_con[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53101_A0_PORT_ERC_CONr_PORT_ERC_CON_RSRV2f_GET(r) ((((r).port_erc_con[0]) >> 12) & 0xf)
#define BCM53101_A0_PORT_ERC_CONr_PORT_ERC_CON_RSRV2f_SET(r,f) (r).port_erc_con[0]=(((r).port_erc_con[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access PORT_ERC_CON.
 *
 */
#define BCM53101_A0_READ_PORT_ERC_CONr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_PORT_ERC_CONr,(r._port_erc_con),2)
#define BCM53101_A0_WRITE_PORT_ERC_CONr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_PORT_ERC_CONr,&(r._port_erc_con),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_ERC_CONr BCM53101_A0_PORT_ERC_CONr
#define PORT_ERC_CONr_SIZE BCM53101_A0_PORT_ERC_CONr_SIZE
typedef BCM53101_A0_PORT_ERC_CONr_t PORT_ERC_CONr_t;
#define PORT_ERC_CONr_CLR BCM53101_A0_PORT_ERC_CONr_CLR
#define PORT_ERC_CONr_SET BCM53101_A0_PORT_ERC_CONr_SET
#define PORT_ERC_CONr_GET BCM53101_A0_PORT_ERC_CONr_GET
#define PORT_ERC_CONr_REF_CNTf_GET BCM53101_A0_PORT_ERC_CONr_REF_CNTf_GET
#define PORT_ERC_CONr_REF_CNTf_SET BCM53101_A0_PORT_ERC_CONr_REF_CNTf_SET
#define PORT_ERC_CONr_BUCKET_SIZEf_GET BCM53101_A0_PORT_ERC_CONr_BUCKET_SIZEf_GET
#define PORT_ERC_CONr_BUCKET_SIZEf_SET BCM53101_A0_PORT_ERC_CONr_BUCKET_SIZEf_SET
#define PORT_ERC_CONr_EGRESS_RC_ENf_GET BCM53101_A0_PORT_ERC_CONr_EGRESS_RC_ENf_GET
#define PORT_ERC_CONr_EGRESS_RC_ENf_SET BCM53101_A0_PORT_ERC_CONr_EGRESS_RC_ENf_SET
#define PORT_ERC_CONr_PORT_ERC_CON_RSRV2f_GET BCM53101_A0_PORT_ERC_CONr_PORT_ERC_CON_RSRV2f_GET
#define PORT_ERC_CONr_PORT_ERC_CON_RSRV2f_SET BCM53101_A0_PORT_ERC_CONr_PORT_ERC_CON_RSRV2f_SET
#define READ_PORT_ERC_CONr BCM53101_A0_READ_PORT_ERC_CONr
#define WRITE_PORT_ERC_CONr BCM53101_A0_WRITE_PORT_ERC_CONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PORT_ERC_CONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  PORT_ERC_CON_IMP
 * BLOCKS:   CPIC
 * DESC:     Port 8 Egress Rate Control Configuration Registers
 * SIZE:     16
 * FIELDS:
 *     REF_CNT          Refresh count for bucket.
 *     BUCKET_SIZE      Bucket Size.000 : 16KB001 : 20KB,010 : 28KB,011 : 40KB,100 : 76KB,others : 500KB.
 *     EGRESS_RC_EN     Egress Rate control Enable.
 *     PORT_ERC_CON_RSRV2 Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_PORT_ERC_CON_IMPr 0x00004190

#define BCM53101_A0_PORT_ERC_CON_IMPr_SIZE 2

/*
 * This structure should be used to declare and program PORT_ERC_CON_IMP.
 *
 */
typedef union BCM53101_A0_PORT_ERC_CON_IMPr_s {
	uint32_t v[1];
	uint32_t port_erc_con_imp[1];
	uint32_t _port_erc_con_imp;
} BCM53101_A0_PORT_ERC_CON_IMPr_t;

#define BCM53101_A0_PORT_ERC_CON_IMPr_CLR(r) (r).port_erc_con_imp[0] = 0
#define BCM53101_A0_PORT_ERC_CON_IMPr_SET(r,d) (r).port_erc_con_imp[0] = d
#define BCM53101_A0_PORT_ERC_CON_IMPr_GET(r) (r).port_erc_con_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_PORT_ERC_CON_IMPr_REF_CNTf_GET(r) (((r).port_erc_con_imp[0]) & 0xff)
#define BCM53101_A0_PORT_ERC_CON_IMPr_REF_CNTf_SET(r,f) (r).port_erc_con_imp[0]=(((r).port_erc_con_imp[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53101_A0_PORT_ERC_CON_IMPr_BUCKET_SIZEf_GET(r) ((((r).port_erc_con_imp[0]) >> 8) & 0x7)
#define BCM53101_A0_PORT_ERC_CON_IMPr_BUCKET_SIZEf_SET(r,f) (r).port_erc_con_imp[0]=(((r).port_erc_con_imp[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8))
#define BCM53101_A0_PORT_ERC_CON_IMPr_EGRESS_RC_ENf_GET(r) ((((r).port_erc_con_imp[0]) >> 11) & 0x1)
#define BCM53101_A0_PORT_ERC_CON_IMPr_EGRESS_RC_ENf_SET(r,f) (r).port_erc_con_imp[0]=(((r).port_erc_con_imp[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53101_A0_PORT_ERC_CON_IMPr_PORT_ERC_CON_RSRV2f_GET(r) ((((r).port_erc_con_imp[0]) >> 12) & 0xf)
#define BCM53101_A0_PORT_ERC_CON_IMPr_PORT_ERC_CON_RSRV2f_SET(r,f) (r).port_erc_con_imp[0]=(((r).port_erc_con_imp[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access PORT_ERC_CON_IMP.
 *
 */
#define BCM53101_A0_READ_PORT_ERC_CON_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_PORT_ERC_CON_IMPr,(r._port_erc_con_imp),2)
#define BCM53101_A0_WRITE_PORT_ERC_CON_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_PORT_ERC_CON_IMPr,&(r._port_erc_con_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_ERC_CON_IMPr BCM53101_A0_PORT_ERC_CON_IMPr
#define PORT_ERC_CON_IMPr_SIZE BCM53101_A0_PORT_ERC_CON_IMPr_SIZE
typedef BCM53101_A0_PORT_ERC_CON_IMPr_t PORT_ERC_CON_IMPr_t;
#define PORT_ERC_CON_IMPr_CLR BCM53101_A0_PORT_ERC_CON_IMPr_CLR
#define PORT_ERC_CON_IMPr_SET BCM53101_A0_PORT_ERC_CON_IMPr_SET
#define PORT_ERC_CON_IMPr_GET BCM53101_A0_PORT_ERC_CON_IMPr_GET
#define PORT_ERC_CON_IMPr_REF_CNTf_GET BCM53101_A0_PORT_ERC_CON_IMPr_REF_CNTf_GET
#define PORT_ERC_CON_IMPr_REF_CNTf_SET BCM53101_A0_PORT_ERC_CON_IMPr_REF_CNTf_SET
#define PORT_ERC_CON_IMPr_BUCKET_SIZEf_GET BCM53101_A0_PORT_ERC_CON_IMPr_BUCKET_SIZEf_GET
#define PORT_ERC_CON_IMPr_BUCKET_SIZEf_SET BCM53101_A0_PORT_ERC_CON_IMPr_BUCKET_SIZEf_SET
#define PORT_ERC_CON_IMPr_EGRESS_RC_ENf_GET BCM53101_A0_PORT_ERC_CON_IMPr_EGRESS_RC_ENf_GET
#define PORT_ERC_CON_IMPr_EGRESS_RC_ENf_SET BCM53101_A0_PORT_ERC_CON_IMPr_EGRESS_RC_ENf_SET
#define PORT_ERC_CON_IMPr_PORT_ERC_CON_RSRV2f_GET BCM53101_A0_PORT_ERC_CON_IMPr_PORT_ERC_CON_RSRV2f_GET
#define PORT_ERC_CON_IMPr_PORT_ERC_CON_RSRV2f_SET BCM53101_A0_PORT_ERC_CON_IMPr_PORT_ERC_CON_RSRV2f_SET
#define READ_PORT_ERC_CON_IMPr BCM53101_A0_READ_PORT_ERC_CON_IMPr
#define WRITE_PORT_ERC_CON_IMPr BCM53101_A0_WRITE_PORT_ERC_CON_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PORT_ERC_CON_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  PORT_VLAN_CTL
 * BLOCKS:   CPIC EPIC0
 * DESC:     PORT X VLAN Control Register
 * SIZE:     16
 * FIELDS:
 *     PORT_EGRESS_EN   Per bit per port VLAN forwarding vector.A bit mask corresponding to the physical ports on the chip.Set corresponding bit to 1' to enable forwarding to the egress port. Set 0' inhibit the forwarding.Bit 8: mask for MII port.Bit 0-7: Port 0-7.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_PORT_VLAN_CTLr 0x00003100

#define BCM53101_A0_PORT_VLAN_CTLr_SIZE 2

/*
 * This structure should be used to declare and program PORT_VLAN_CTL.
 *
 */
typedef union BCM53101_A0_PORT_VLAN_CTLr_s {
	uint32_t v[1];
	uint32_t port_vlan_ctl[1];
	uint32_t _port_vlan_ctl;
} BCM53101_A0_PORT_VLAN_CTLr_t;

#define BCM53101_A0_PORT_VLAN_CTLr_CLR(r) (r).port_vlan_ctl[0] = 0
#define BCM53101_A0_PORT_VLAN_CTLr_SET(r,d) (r).port_vlan_ctl[0] = d
#define BCM53101_A0_PORT_VLAN_CTLr_GET(r) (r).port_vlan_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_PORT_VLAN_CTLr_PORT_EGRESS_ENf_GET(r) (((r).port_vlan_ctl[0]) & 0x1ff)
#define BCM53101_A0_PORT_VLAN_CTLr_PORT_EGRESS_ENf_SET(r,f) (r).port_vlan_ctl[0]=(((r).port_vlan_ctl[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_PORT_VLAN_CTLr_RESERVEDf_GET(r) ((((r).port_vlan_ctl[0]) >> 9) & 0x7f)
#define BCM53101_A0_PORT_VLAN_CTLr_RESERVEDf_SET(r,f) (r).port_vlan_ctl[0]=(((r).port_vlan_ctl[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access PORT_VLAN_CTL.
 *
 */
#define BCM53101_A0_READ_PORT_VLAN_CTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_PORT_VLAN_CTLr,(r._port_vlan_ctl),2)
#define BCM53101_A0_WRITE_PORT_VLAN_CTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_PORT_VLAN_CTLr,&(r._port_vlan_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_VLAN_CTLr BCM53101_A0_PORT_VLAN_CTLr
#define PORT_VLAN_CTLr_SIZE BCM53101_A0_PORT_VLAN_CTLr_SIZE
typedef BCM53101_A0_PORT_VLAN_CTLr_t PORT_VLAN_CTLr_t;
#define PORT_VLAN_CTLr_CLR BCM53101_A0_PORT_VLAN_CTLr_CLR
#define PORT_VLAN_CTLr_SET BCM53101_A0_PORT_VLAN_CTLr_SET
#define PORT_VLAN_CTLr_GET BCM53101_A0_PORT_VLAN_CTLr_GET
#define PORT_VLAN_CTLr_PORT_EGRESS_ENf_GET BCM53101_A0_PORT_VLAN_CTLr_PORT_EGRESS_ENf_GET
#define PORT_VLAN_CTLr_PORT_EGRESS_ENf_SET BCM53101_A0_PORT_VLAN_CTLr_PORT_EGRESS_ENf_SET
#define PORT_VLAN_CTLr_RESERVEDf_GET BCM53101_A0_PORT_VLAN_CTLr_RESERVEDf_GET
#define PORT_VLAN_CTLr_RESERVEDf_SET BCM53101_A0_PORT_VLAN_CTLr_RESERVEDf_SET
#define READ_PORT_VLAN_CTLr BCM53101_A0_READ_PORT_VLAN_CTLr
#define WRITE_PORT_VLAN_CTLr BCM53101_A0_WRITE_PORT_VLAN_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PORT_VLAN_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  PORT_VLAN_CTL_IMP
 * BLOCKS:   CPIC
 * DESC:     PORT 8 VLAN Control Register
 * SIZE:     16
 * FIELDS:
 *     PORT_EGRESS_EN   Per bit per port VLAN forwarding vector.A bit mask corresponding to the physical ports on the chip.Set corresponding bit to 1' to enable forwarding to the egress port. Set 0' inhibit the forwarding.Bit 8: mask for MII port.Bit 0-7: Port 0-7.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_PORT_VLAN_CTL_IMPr 0x00003110

#define BCM53101_A0_PORT_VLAN_CTL_IMPr_SIZE 2

/*
 * This structure should be used to declare and program PORT_VLAN_CTL_IMP.
 *
 */
typedef union BCM53101_A0_PORT_VLAN_CTL_IMPr_s {
	uint32_t v[1];
	uint32_t port_vlan_ctl_imp[1];
	uint32_t _port_vlan_ctl_imp;
} BCM53101_A0_PORT_VLAN_CTL_IMPr_t;

#define BCM53101_A0_PORT_VLAN_CTL_IMPr_CLR(r) (r).port_vlan_ctl_imp[0] = 0
#define BCM53101_A0_PORT_VLAN_CTL_IMPr_SET(r,d) (r).port_vlan_ctl_imp[0] = d
#define BCM53101_A0_PORT_VLAN_CTL_IMPr_GET(r) (r).port_vlan_ctl_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_PORT_VLAN_CTL_IMPr_PORT_EGRESS_ENf_GET(r) (((r).port_vlan_ctl_imp[0]) & 0x1ff)
#define BCM53101_A0_PORT_VLAN_CTL_IMPr_PORT_EGRESS_ENf_SET(r,f) (r).port_vlan_ctl_imp[0]=(((r).port_vlan_ctl_imp[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_PORT_VLAN_CTL_IMPr_RESERVEDf_GET(r) ((((r).port_vlan_ctl_imp[0]) >> 9) & 0x7f)
#define BCM53101_A0_PORT_VLAN_CTL_IMPr_RESERVEDf_SET(r,f) (r).port_vlan_ctl_imp[0]=(((r).port_vlan_ctl_imp[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access PORT_VLAN_CTL_IMP.
 *
 */
#define BCM53101_A0_READ_PORT_VLAN_CTL_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_PORT_VLAN_CTL_IMPr,(r._port_vlan_ctl_imp),2)
#define BCM53101_A0_WRITE_PORT_VLAN_CTL_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_PORT_VLAN_CTL_IMPr,&(r._port_vlan_ctl_imp),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PORT_VLAN_CTL_IMPr BCM53101_A0_PORT_VLAN_CTL_IMPr
#define PORT_VLAN_CTL_IMPr_SIZE BCM53101_A0_PORT_VLAN_CTL_IMPr_SIZE
typedef BCM53101_A0_PORT_VLAN_CTL_IMPr_t PORT_VLAN_CTL_IMPr_t;
#define PORT_VLAN_CTL_IMPr_CLR BCM53101_A0_PORT_VLAN_CTL_IMPr_CLR
#define PORT_VLAN_CTL_IMPr_SET BCM53101_A0_PORT_VLAN_CTL_IMPr_SET
#define PORT_VLAN_CTL_IMPr_GET BCM53101_A0_PORT_VLAN_CTL_IMPr_GET
#define PORT_VLAN_CTL_IMPr_PORT_EGRESS_ENf_GET BCM53101_A0_PORT_VLAN_CTL_IMPr_PORT_EGRESS_ENf_GET
#define PORT_VLAN_CTL_IMPr_PORT_EGRESS_ENf_SET BCM53101_A0_PORT_VLAN_CTL_IMPr_PORT_EGRESS_ENf_SET
#define PORT_VLAN_CTL_IMPr_RESERVEDf_GET BCM53101_A0_PORT_VLAN_CTL_IMPr_RESERVEDf_GET
#define PORT_VLAN_CTL_IMPr_RESERVEDf_SET BCM53101_A0_PORT_VLAN_CTL_IMPr_RESERVEDf_SET
#define READ_PORT_VLAN_CTL_IMPr BCM53101_A0_READ_PORT_VLAN_CTL_IMPr
#define WRITE_PORT_VLAN_CTL_IMPr BCM53101_A0_WRITE_PORT_VLAN_CTL_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PORT_VLAN_CTL_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  PRESERVE_PKT_FORMAT
 * BLOCKS:   SYS
 * DESC:      Preserve Ingress Packet formatControl Register
 * SIZE:     16
 * FIELDS:
 *     PRESERVE_PACKET_FORMAT Preserve Ingress packet formatThis register is a per-port configuration. User should also set this register for the ingress port which is in port-cross-connect mode.When enable, the ingress frame format is preserved without being affected by 1Q/double-tag normalization process on the ingress logic and tag/untag process on the egrss logici.e. untag in -> untag out	1Q/1p tag in -> 1Q/1p tag out	double tags in -> double tags out[8]: port8[5:0]: port5-port0However, the ingress logic can still insert time stamp if required.And if broadcom header enabled, the egress logic is still able to inserted broadcom header, and the ingress logic is able to remove broadcom header.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_PRESERVE_PKT_FORMATr 0x00000022

#define BCM53101_A0_PRESERVE_PKT_FORMATr_SIZE 2

/*
 * This structure should be used to declare and program PRESERVE_PKT_FORMAT.
 *
 */
typedef union BCM53101_A0_PRESERVE_PKT_FORMATr_s {
	uint32_t v[1];
	uint32_t preserve_pkt_format[1];
	uint32_t _preserve_pkt_format;
} BCM53101_A0_PRESERVE_PKT_FORMATr_t;

#define BCM53101_A0_PRESERVE_PKT_FORMATr_CLR(r) (r).preserve_pkt_format[0] = 0
#define BCM53101_A0_PRESERVE_PKT_FORMATr_SET(r,d) (r).preserve_pkt_format[0] = d
#define BCM53101_A0_PRESERVE_PKT_FORMATr_GET(r) (r).preserve_pkt_format[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_PRESERVE_PKT_FORMATr_PRESERVE_PACKET_FORMATf_GET(r) (((r).preserve_pkt_format[0]) & 0x1ff)
#define BCM53101_A0_PRESERVE_PKT_FORMATr_PRESERVE_PACKET_FORMATf_SET(r,f) (r).preserve_pkt_format[0]=(((r).preserve_pkt_format[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_PRESERVE_PKT_FORMATr_RESERVEDf_GET(r) ((((r).preserve_pkt_format[0]) >> 9) & 0x7f)
#define BCM53101_A0_PRESERVE_PKT_FORMATr_RESERVEDf_SET(r,f) (r).preserve_pkt_format[0]=(((r).preserve_pkt_format[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access PRESERVE_PKT_FORMAT.
 *
 */
#define BCM53101_A0_READ_PRESERVE_PKT_FORMATr(u,r) cdk_robo_reg_read(u,BCM53101_A0_PRESERVE_PKT_FORMATr,(r._preserve_pkt_format),2)
#define BCM53101_A0_WRITE_PRESERVE_PKT_FORMATr(u,r) cdk_robo_reg_write(u,BCM53101_A0_PRESERVE_PKT_FORMATr,&(r._preserve_pkt_format),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PRESERVE_PKT_FORMATr BCM53101_A0_PRESERVE_PKT_FORMATr
#define PRESERVE_PKT_FORMATr_SIZE BCM53101_A0_PRESERVE_PKT_FORMATr_SIZE
typedef BCM53101_A0_PRESERVE_PKT_FORMATr_t PRESERVE_PKT_FORMATr_t;
#define PRESERVE_PKT_FORMATr_CLR BCM53101_A0_PRESERVE_PKT_FORMATr_CLR
#define PRESERVE_PKT_FORMATr_SET BCM53101_A0_PRESERVE_PKT_FORMATr_SET
#define PRESERVE_PKT_FORMATr_GET BCM53101_A0_PRESERVE_PKT_FORMATr_GET
#define PRESERVE_PKT_FORMATr_PRESERVE_PACKET_FORMATf_GET BCM53101_A0_PRESERVE_PKT_FORMATr_PRESERVE_PACKET_FORMATf_GET
#define PRESERVE_PKT_FORMATr_PRESERVE_PACKET_FORMATf_SET BCM53101_A0_PRESERVE_PKT_FORMATr_PRESERVE_PACKET_FORMATf_SET
#define PRESERVE_PKT_FORMATr_RESERVEDf_GET BCM53101_A0_PRESERVE_PKT_FORMATr_RESERVEDf_GET
#define PRESERVE_PKT_FORMATr_RESERVEDf_SET BCM53101_A0_PRESERVE_PKT_FORMATr_RESERVEDf_SET
#define READ_PRESERVE_PKT_FORMATr BCM53101_A0_READ_PRESERVE_PKT_FORMATr
#define WRITE_PRESERVE_PKT_FORMATr BCM53101_A0_WRITE_PRESERVE_PKT_FORMATr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PRESERVE_PKT_FORMATr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  PROTECTED_SEL
 * BLOCKS:   SYS
 * DESC:     Protected Port Select Register
 * SIZE:     16
 * FIELDS:
 *     PORT_SEL         Protected Port Selection.When set, the Port will be the protected Port.Protected Ports will not be able to Transmit/Receive Frame to/from each other.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_PROTECTED_SELr 0x00000024

#define BCM53101_A0_PROTECTED_SELr_SIZE 2

/*
 * This structure should be used to declare and program PROTECTED_SEL.
 *
 */
typedef union BCM53101_A0_PROTECTED_SELr_s {
	uint32_t v[1];
	uint32_t protected_sel[1];
	uint32_t _protected_sel;
} BCM53101_A0_PROTECTED_SELr_t;

#define BCM53101_A0_PROTECTED_SELr_CLR(r) (r).protected_sel[0] = 0
#define BCM53101_A0_PROTECTED_SELr_SET(r,d) (r).protected_sel[0] = d
#define BCM53101_A0_PROTECTED_SELr_GET(r) (r).protected_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_PROTECTED_SELr_PORT_SELf_GET(r) (((r).protected_sel[0]) & 0x1ff)
#define BCM53101_A0_PROTECTED_SELr_PORT_SELf_SET(r,f) (r).protected_sel[0]=(((r).protected_sel[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_PROTECTED_SELr_RESERVEDf_GET(r) ((((r).protected_sel[0]) >> 9) & 0x7f)
#define BCM53101_A0_PROTECTED_SELr_RESERVEDf_SET(r,f) (r).protected_sel[0]=(((r).protected_sel[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access PROTECTED_SEL.
 *
 */
#define BCM53101_A0_READ_PROTECTED_SELr(u,r) cdk_robo_reg_read(u,BCM53101_A0_PROTECTED_SELr,(r._protected_sel),2)
#define BCM53101_A0_WRITE_PROTECTED_SELr(u,r) cdk_robo_reg_write(u,BCM53101_A0_PROTECTED_SELr,&(r._protected_sel),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PROTECTED_SELr BCM53101_A0_PROTECTED_SELr
#define PROTECTED_SELr_SIZE BCM53101_A0_PROTECTED_SELr_SIZE
typedef BCM53101_A0_PROTECTED_SELr_t PROTECTED_SELr_t;
#define PROTECTED_SELr_CLR BCM53101_A0_PROTECTED_SELr_CLR
#define PROTECTED_SELr_SET BCM53101_A0_PROTECTED_SELr_SET
#define PROTECTED_SELr_GET BCM53101_A0_PROTECTED_SELr_GET
#define PROTECTED_SELr_PORT_SELf_GET BCM53101_A0_PROTECTED_SELr_PORT_SELf_GET
#define PROTECTED_SELr_PORT_SELf_SET BCM53101_A0_PROTECTED_SELr_PORT_SELf_SET
#define PROTECTED_SELr_RESERVEDf_GET BCM53101_A0_PROTECTED_SELr_RESERVEDf_GET
#define PROTECTED_SELr_RESERVEDf_SET BCM53101_A0_PROTECTED_SELr_RESERVEDf_SET
#define READ_PROTECTED_SELr BCM53101_A0_READ_PROTECTED_SELr
#define WRITE_PROTECTED_SELr BCM53101_A0_WRITE_PROTECTED_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PROTECTED_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  PRS_FIFO_DEBUG_CTRL
 * BLOCKS:   SYS
 * DESC:     PRS_FIFO Debug Control Register
 * SIZE:     8
 * FIELDS:
 *     PRS_FIFO_DBG_CTRL Control the prs_fifo_debug bus muxing[3:2]'d0: slice 0'd1: slice 1'd2: slice 2'd3: slice 3[1:0]'d0: slice[63:0]'d1: slice[127:64]'d2: slice[191:128]'d3: {23'h0,ipv6_vld,ipv4_vld,slice[229:192]}
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_PRS_FIFO_DEBUG_CTRLr 0x00000870

#define BCM53101_A0_PRS_FIFO_DEBUG_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program PRS_FIFO_DEBUG_CTRL.
 *
 */
typedef union BCM53101_A0_PRS_FIFO_DEBUG_CTRLr_s {
	uint32_t v[1];
	uint32_t prs_fifo_debug_ctrl[1];
	uint32_t _prs_fifo_debug_ctrl;
} BCM53101_A0_PRS_FIFO_DEBUG_CTRLr_t;

#define BCM53101_A0_PRS_FIFO_DEBUG_CTRLr_CLR(r) (r).prs_fifo_debug_ctrl[0] = 0
#define BCM53101_A0_PRS_FIFO_DEBUG_CTRLr_SET(r,d) (r).prs_fifo_debug_ctrl[0] = d
#define BCM53101_A0_PRS_FIFO_DEBUG_CTRLr_GET(r) (r).prs_fifo_debug_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_PRS_FIFO_DEBUG_CTRLr_PRS_FIFO_DBG_CTRLf_GET(r) (((r).prs_fifo_debug_ctrl[0]) & 0xf)
#define BCM53101_A0_PRS_FIFO_DEBUG_CTRLr_PRS_FIFO_DBG_CTRLf_SET(r,f) (r).prs_fifo_debug_ctrl[0]=(((r).prs_fifo_debug_ctrl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53101_A0_PRS_FIFO_DEBUG_CTRLr_RESERVEDf_GET(r) ((((r).prs_fifo_debug_ctrl[0]) >> 4) & 0xf)
#define BCM53101_A0_PRS_FIFO_DEBUG_CTRLr_RESERVEDf_SET(r,f) (r).prs_fifo_debug_ctrl[0]=(((r).prs_fifo_debug_ctrl[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4))

/*
 * These macros can be used to access PRS_FIFO_DEBUG_CTRL.
 *
 */
#define BCM53101_A0_READ_PRS_FIFO_DEBUG_CTRLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_PRS_FIFO_DEBUG_CTRLr,(r._prs_fifo_debug_ctrl),1)
#define BCM53101_A0_WRITE_PRS_FIFO_DEBUG_CTRLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_PRS_FIFO_DEBUG_CTRLr,&(r._prs_fifo_debug_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PRS_FIFO_DEBUG_CTRLr BCM53101_A0_PRS_FIFO_DEBUG_CTRLr
#define PRS_FIFO_DEBUG_CTRLr_SIZE BCM53101_A0_PRS_FIFO_DEBUG_CTRLr_SIZE
typedef BCM53101_A0_PRS_FIFO_DEBUG_CTRLr_t PRS_FIFO_DEBUG_CTRLr_t;
#define PRS_FIFO_DEBUG_CTRLr_CLR BCM53101_A0_PRS_FIFO_DEBUG_CTRLr_CLR
#define PRS_FIFO_DEBUG_CTRLr_SET BCM53101_A0_PRS_FIFO_DEBUG_CTRLr_SET
#define PRS_FIFO_DEBUG_CTRLr_GET BCM53101_A0_PRS_FIFO_DEBUG_CTRLr_GET
#define PRS_FIFO_DEBUG_CTRLr_PRS_FIFO_DBG_CTRLf_GET BCM53101_A0_PRS_FIFO_DEBUG_CTRLr_PRS_FIFO_DBG_CTRLf_GET
#define PRS_FIFO_DEBUG_CTRLr_PRS_FIFO_DBG_CTRLf_SET BCM53101_A0_PRS_FIFO_DEBUG_CTRLr_PRS_FIFO_DBG_CTRLf_SET
#define PRS_FIFO_DEBUG_CTRLr_RESERVEDf_GET BCM53101_A0_PRS_FIFO_DEBUG_CTRLr_RESERVEDf_GET
#define PRS_FIFO_DEBUG_CTRLr_RESERVEDf_SET BCM53101_A0_PRS_FIFO_DEBUG_CTRLr_RESERVEDf_SET
#define READ_PRS_FIFO_DEBUG_CTRLr BCM53101_A0_READ_PRS_FIFO_DEBUG_CTRLr
#define WRITE_PRS_FIFO_DEBUG_CTRLr BCM53101_A0_WRITE_PRS_FIFO_DEBUG_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PRS_FIFO_DEBUG_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  PRS_FIFO_DEBUG_DATA
 * BLOCKS:   SYS
 * DESC:     PRS_FIFO Debug Data Register
 * SIZE:     64
 * FIELDS:
 *     PRS_FIFO_DBG_DATA Provide 64 bits prs_fifo debug bus data according to the PRS_FIFO_DBG_CTRL.
 *
 ******************************************************************************/
#define BCM53101_A0_PRS_FIFO_DEBUG_DATAr 0x00000871

#define BCM53101_A0_PRS_FIFO_DEBUG_DATAr_SIZE 8

/*
 * This structure should be used to declare and program PRS_FIFO_DEBUG_DATA.
 *
 */
typedef union BCM53101_A0_PRS_FIFO_DEBUG_DATAr_s {
	uint32_t v[2];
	uint32_t prs_fifo_debug_data[2];
	uint32_t _prs_fifo_debug_data;
} BCM53101_A0_PRS_FIFO_DEBUG_DATAr_t;

#define BCM53101_A0_PRS_FIFO_DEBUG_DATAr_CLR(r) CDK_MEMSET(&((r)._prs_fifo_debug_data), 0, sizeof(BCM53101_A0_PRS_FIFO_DEBUG_DATAr_t))
#define BCM53101_A0_PRS_FIFO_DEBUG_DATAr_SET(r,i,d) (r).prs_fifo_debug_data[i] = d
#define BCM53101_A0_PRS_FIFO_DEBUG_DATAr_GET(r,i) (r).prs_fifo_debug_data[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_PRS_FIFO_DEBUG_DATAr_PRS_FIFO_DBG_DATAf_GET(r,a) cdk_field_get((r).prs_fifo_debug_data,0,63,a)
#define BCM53101_A0_PRS_FIFO_DEBUG_DATAr_PRS_FIFO_DBG_DATAf_SET(r,a) cdk_field_set((r).prs_fifo_debug_data,0,63,a)

/*
 * These macros can be used to access PRS_FIFO_DEBUG_DATA.
 *
 */
#define BCM53101_A0_READ_PRS_FIFO_DEBUG_DATAr(u,r) cdk_robo_reg_read(u,BCM53101_A0_PRS_FIFO_DEBUG_DATAr,(r._prs_fifo_debug_data),8)
#define BCM53101_A0_WRITE_PRS_FIFO_DEBUG_DATAr(u,r) cdk_robo_reg_write(u,BCM53101_A0_PRS_FIFO_DEBUG_DATAr,&(r._prs_fifo_debug_data),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PRS_FIFO_DEBUG_DATAr BCM53101_A0_PRS_FIFO_DEBUG_DATAr
#define PRS_FIFO_DEBUG_DATAr_SIZE BCM53101_A0_PRS_FIFO_DEBUG_DATAr_SIZE
typedef BCM53101_A0_PRS_FIFO_DEBUG_DATAr_t PRS_FIFO_DEBUG_DATAr_t;
#define PRS_FIFO_DEBUG_DATAr_CLR BCM53101_A0_PRS_FIFO_DEBUG_DATAr_CLR
#define PRS_FIFO_DEBUG_DATAr_SET BCM53101_A0_PRS_FIFO_DEBUG_DATAr_SET
#define PRS_FIFO_DEBUG_DATAr_GET BCM53101_A0_PRS_FIFO_DEBUG_DATAr_GET
#define PRS_FIFO_DEBUG_DATAr_PRS_FIFO_DBG_DATAf_GET BCM53101_A0_PRS_FIFO_DEBUG_DATAr_PRS_FIFO_DBG_DATAf_GET
#define PRS_FIFO_DEBUG_DATAr_PRS_FIFO_DBG_DATAf_SET BCM53101_A0_PRS_FIFO_DEBUG_DATAr_PRS_FIFO_DBG_DATAf_SET
#define READ_PRS_FIFO_DEBUG_DATAr BCM53101_A0_READ_PRS_FIFO_DEBUG_DATAr
#define WRITE_PRS_FIFO_DEBUG_DATAr BCM53101_A0_WRITE_PRS_FIFO_DEBUG_DATAr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PRS_FIFO_DEBUG_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  Pkts1024toMaxPktOctets
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Rx 1024 to MaxPkt Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_PKTS1024TOMAXPKTOCTETSr 0x00002074

#define BCM53101_A0_PKTS1024TOMAXPKTOCTETSr_SIZE 4

/*
 * This structure should be used to declare and program Pkts1024toMaxPktOctets.
 *
 */
typedef union BCM53101_A0_PKTS1024TOMAXPKTOCTETSr_s {
	uint32_t v[1];
	uint32_t pkts1024tomaxpktoctets[1];
	uint32_t _pkts1024tomaxpktoctets;
} BCM53101_A0_PKTS1024TOMAXPKTOCTETSr_t;

#define BCM53101_A0_PKTS1024TOMAXPKTOCTETSr_CLR(r) (r).pkts1024tomaxpktoctets[0] = 0
#define BCM53101_A0_PKTS1024TOMAXPKTOCTETSr_SET(r,d) (r).pkts1024tomaxpktoctets[0] = d
#define BCM53101_A0_PKTS1024TOMAXPKTOCTETSr_GET(r) (r).pkts1024tomaxpktoctets[0]


/*
 * These macros can be used to access Pkts1024toMaxPktOctets.
 *
 */
#define BCM53101_A0_READ_PKTS1024TOMAXPKTOCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_PKTS1024TOMAXPKTOCTETSr,(r._pkts1024tomaxpktoctets),4)
#define BCM53101_A0_WRITE_PKTS1024TOMAXPKTOCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_PKTS1024TOMAXPKTOCTETSr,&(r._pkts1024tomaxpktoctets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS1024TOMAXPKTOCTETSr BCM53101_A0_PKTS1024TOMAXPKTOCTETSr
#define PKTS1024TOMAXPKTOCTETSr_SIZE BCM53101_A0_PKTS1024TOMAXPKTOCTETSr_SIZE
typedef BCM53101_A0_PKTS1024TOMAXPKTOCTETSr_t PKTS1024TOMAXPKTOCTETSr_t;
#define PKTS1024TOMAXPKTOCTETSr_CLR BCM53101_A0_PKTS1024TOMAXPKTOCTETSr_CLR
#define PKTS1024TOMAXPKTOCTETSr_SET BCM53101_A0_PKTS1024TOMAXPKTOCTETSr_SET
#define PKTS1024TOMAXPKTOCTETSr_GET BCM53101_A0_PKTS1024TOMAXPKTOCTETSr_GET
#define READ_PKTS1024TOMAXPKTOCTETSr BCM53101_A0_READ_PKTS1024TOMAXPKTOCTETSr
#define WRITE_PKTS1024TOMAXPKTOCTETSr BCM53101_A0_WRITE_PKTS1024TOMAXPKTOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PKTS1024TOMAXPKTOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  Pkts1024toMaxPktOctets_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx 1024 to MaxPkt Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_PKTS1024TOMAXPKTOCTETS_IMPr 0x00002874

#define BCM53101_A0_PKTS1024TOMAXPKTOCTETS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program Pkts1024toMaxPktOctets_IMP.
 *
 */
typedef union BCM53101_A0_PKTS1024TOMAXPKTOCTETS_IMPr_s {
	uint32_t v[1];
	uint32_t pkts1024tomaxpktoctets_imp[1];
	uint32_t _pkts1024tomaxpktoctets_imp;
} BCM53101_A0_PKTS1024TOMAXPKTOCTETS_IMPr_t;

#define BCM53101_A0_PKTS1024TOMAXPKTOCTETS_IMPr_CLR(r) (r).pkts1024tomaxpktoctets_imp[0] = 0
#define BCM53101_A0_PKTS1024TOMAXPKTOCTETS_IMPr_SET(r,d) (r).pkts1024tomaxpktoctets_imp[0] = d
#define BCM53101_A0_PKTS1024TOMAXPKTOCTETS_IMPr_GET(r) (r).pkts1024tomaxpktoctets_imp[0]


/*
 * These macros can be used to access Pkts1024toMaxPktOctets_IMP.
 *
 */
#define BCM53101_A0_READ_PKTS1024TOMAXPKTOCTETS_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_PKTS1024TOMAXPKTOCTETS_IMPr,(r._pkts1024tomaxpktoctets_imp),4)
#define BCM53101_A0_WRITE_PKTS1024TOMAXPKTOCTETS_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_PKTS1024TOMAXPKTOCTETS_IMPr,&(r._pkts1024tomaxpktoctets_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS1024TOMAXPKTOCTETS_IMPr BCM53101_A0_PKTS1024TOMAXPKTOCTETS_IMPr
#define PKTS1024TOMAXPKTOCTETS_IMPr_SIZE BCM53101_A0_PKTS1024TOMAXPKTOCTETS_IMPr_SIZE
typedef BCM53101_A0_PKTS1024TOMAXPKTOCTETS_IMPr_t PKTS1024TOMAXPKTOCTETS_IMPr_t;
#define PKTS1024TOMAXPKTOCTETS_IMPr_CLR BCM53101_A0_PKTS1024TOMAXPKTOCTETS_IMPr_CLR
#define PKTS1024TOMAXPKTOCTETS_IMPr_SET BCM53101_A0_PKTS1024TOMAXPKTOCTETS_IMPr_SET
#define PKTS1024TOMAXPKTOCTETS_IMPr_GET BCM53101_A0_PKTS1024TOMAXPKTOCTETS_IMPr_GET
#define READ_PKTS1024TOMAXPKTOCTETS_IMPr BCM53101_A0_READ_PKTS1024TOMAXPKTOCTETS_IMPr
#define WRITE_PKTS1024TOMAXPKTOCTETS_IMPr BCM53101_A0_WRITE_PKTS1024TOMAXPKTOCTETS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PKTS1024TOMAXPKTOCTETS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  Pkts128to255Octets
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Rx 128 to 255 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_PKTS128TO255OCTETSr 0x00002068

#define BCM53101_A0_PKTS128TO255OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program Pkts128to255Octets.
 *
 */
typedef union BCM53101_A0_PKTS128TO255OCTETSr_s {
	uint32_t v[1];
	uint32_t pkts128to255octets[1];
	uint32_t _pkts128to255octets;
} BCM53101_A0_PKTS128TO255OCTETSr_t;

#define BCM53101_A0_PKTS128TO255OCTETSr_CLR(r) (r).pkts128to255octets[0] = 0
#define BCM53101_A0_PKTS128TO255OCTETSr_SET(r,d) (r).pkts128to255octets[0] = d
#define BCM53101_A0_PKTS128TO255OCTETSr_GET(r) (r).pkts128to255octets[0]


/*
 * These macros can be used to access Pkts128to255Octets.
 *
 */
#define BCM53101_A0_READ_PKTS128TO255OCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_PKTS128TO255OCTETSr,(r._pkts128to255octets),4)
#define BCM53101_A0_WRITE_PKTS128TO255OCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_PKTS128TO255OCTETSr,&(r._pkts128to255octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS128TO255OCTETSr BCM53101_A0_PKTS128TO255OCTETSr
#define PKTS128TO255OCTETSr_SIZE BCM53101_A0_PKTS128TO255OCTETSr_SIZE
typedef BCM53101_A0_PKTS128TO255OCTETSr_t PKTS128TO255OCTETSr_t;
#define PKTS128TO255OCTETSr_CLR BCM53101_A0_PKTS128TO255OCTETSr_CLR
#define PKTS128TO255OCTETSr_SET BCM53101_A0_PKTS128TO255OCTETSr_SET
#define PKTS128TO255OCTETSr_GET BCM53101_A0_PKTS128TO255OCTETSr_GET
#define READ_PKTS128TO255OCTETSr BCM53101_A0_READ_PKTS128TO255OCTETSr
#define WRITE_PKTS128TO255OCTETSr BCM53101_A0_WRITE_PKTS128TO255OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PKTS128TO255OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  Pkts128to255Octets_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx 128 to 255 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_PKTS128TO255OCTETS_IMPr 0x00002868

#define BCM53101_A0_PKTS128TO255OCTETS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program Pkts128to255Octets_IMP.
 *
 */
typedef union BCM53101_A0_PKTS128TO255OCTETS_IMPr_s {
	uint32_t v[1];
	uint32_t pkts128to255octets_imp[1];
	uint32_t _pkts128to255octets_imp;
} BCM53101_A0_PKTS128TO255OCTETS_IMPr_t;

#define BCM53101_A0_PKTS128TO255OCTETS_IMPr_CLR(r) (r).pkts128to255octets_imp[0] = 0
#define BCM53101_A0_PKTS128TO255OCTETS_IMPr_SET(r,d) (r).pkts128to255octets_imp[0] = d
#define BCM53101_A0_PKTS128TO255OCTETS_IMPr_GET(r) (r).pkts128to255octets_imp[0]


/*
 * These macros can be used to access Pkts128to255Octets_IMP.
 *
 */
#define BCM53101_A0_READ_PKTS128TO255OCTETS_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_PKTS128TO255OCTETS_IMPr,(r._pkts128to255octets_imp),4)
#define BCM53101_A0_WRITE_PKTS128TO255OCTETS_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_PKTS128TO255OCTETS_IMPr,&(r._pkts128to255octets_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS128TO255OCTETS_IMPr BCM53101_A0_PKTS128TO255OCTETS_IMPr
#define PKTS128TO255OCTETS_IMPr_SIZE BCM53101_A0_PKTS128TO255OCTETS_IMPr_SIZE
typedef BCM53101_A0_PKTS128TO255OCTETS_IMPr_t PKTS128TO255OCTETS_IMPr_t;
#define PKTS128TO255OCTETS_IMPr_CLR BCM53101_A0_PKTS128TO255OCTETS_IMPr_CLR
#define PKTS128TO255OCTETS_IMPr_SET BCM53101_A0_PKTS128TO255OCTETS_IMPr_SET
#define PKTS128TO255OCTETS_IMPr_GET BCM53101_A0_PKTS128TO255OCTETS_IMPr_GET
#define READ_PKTS128TO255OCTETS_IMPr BCM53101_A0_READ_PKTS128TO255OCTETS_IMPr
#define WRITE_PKTS128TO255OCTETS_IMPr BCM53101_A0_WRITE_PKTS128TO255OCTETS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PKTS128TO255OCTETS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  Pkts256to511Octets
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Rx 256 to 511 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_PKTS256TO511OCTETSr 0x0000206c

#define BCM53101_A0_PKTS256TO511OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program Pkts256to511Octets.
 *
 */
typedef union BCM53101_A0_PKTS256TO511OCTETSr_s {
	uint32_t v[1];
	uint32_t pkts256to511octets[1];
	uint32_t _pkts256to511octets;
} BCM53101_A0_PKTS256TO511OCTETSr_t;

#define BCM53101_A0_PKTS256TO511OCTETSr_CLR(r) (r).pkts256to511octets[0] = 0
#define BCM53101_A0_PKTS256TO511OCTETSr_SET(r,d) (r).pkts256to511octets[0] = d
#define BCM53101_A0_PKTS256TO511OCTETSr_GET(r) (r).pkts256to511octets[0]


/*
 * These macros can be used to access Pkts256to511Octets.
 *
 */
#define BCM53101_A0_READ_PKTS256TO511OCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_PKTS256TO511OCTETSr,(r._pkts256to511octets),4)
#define BCM53101_A0_WRITE_PKTS256TO511OCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_PKTS256TO511OCTETSr,&(r._pkts256to511octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS256TO511OCTETSr BCM53101_A0_PKTS256TO511OCTETSr
#define PKTS256TO511OCTETSr_SIZE BCM53101_A0_PKTS256TO511OCTETSr_SIZE
typedef BCM53101_A0_PKTS256TO511OCTETSr_t PKTS256TO511OCTETSr_t;
#define PKTS256TO511OCTETSr_CLR BCM53101_A0_PKTS256TO511OCTETSr_CLR
#define PKTS256TO511OCTETSr_SET BCM53101_A0_PKTS256TO511OCTETSr_SET
#define PKTS256TO511OCTETSr_GET BCM53101_A0_PKTS256TO511OCTETSr_GET
#define READ_PKTS256TO511OCTETSr BCM53101_A0_READ_PKTS256TO511OCTETSr
#define WRITE_PKTS256TO511OCTETSr BCM53101_A0_WRITE_PKTS256TO511OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PKTS256TO511OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  Pkts256to511Octets_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx 256 to 511 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_PKTS256TO511OCTETS_IMPr 0x0000286c

#define BCM53101_A0_PKTS256TO511OCTETS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program Pkts256to511Octets_IMP.
 *
 */
typedef union BCM53101_A0_PKTS256TO511OCTETS_IMPr_s {
	uint32_t v[1];
	uint32_t pkts256to511octets_imp[1];
	uint32_t _pkts256to511octets_imp;
} BCM53101_A0_PKTS256TO511OCTETS_IMPr_t;

#define BCM53101_A0_PKTS256TO511OCTETS_IMPr_CLR(r) (r).pkts256to511octets_imp[0] = 0
#define BCM53101_A0_PKTS256TO511OCTETS_IMPr_SET(r,d) (r).pkts256to511octets_imp[0] = d
#define BCM53101_A0_PKTS256TO511OCTETS_IMPr_GET(r) (r).pkts256to511octets_imp[0]


/*
 * These macros can be used to access Pkts256to511Octets_IMP.
 *
 */
#define BCM53101_A0_READ_PKTS256TO511OCTETS_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_PKTS256TO511OCTETS_IMPr,(r._pkts256to511octets_imp),4)
#define BCM53101_A0_WRITE_PKTS256TO511OCTETS_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_PKTS256TO511OCTETS_IMPr,&(r._pkts256to511octets_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS256TO511OCTETS_IMPr BCM53101_A0_PKTS256TO511OCTETS_IMPr
#define PKTS256TO511OCTETS_IMPr_SIZE BCM53101_A0_PKTS256TO511OCTETS_IMPr_SIZE
typedef BCM53101_A0_PKTS256TO511OCTETS_IMPr_t PKTS256TO511OCTETS_IMPr_t;
#define PKTS256TO511OCTETS_IMPr_CLR BCM53101_A0_PKTS256TO511OCTETS_IMPr_CLR
#define PKTS256TO511OCTETS_IMPr_SET BCM53101_A0_PKTS256TO511OCTETS_IMPr_SET
#define PKTS256TO511OCTETS_IMPr_GET BCM53101_A0_PKTS256TO511OCTETS_IMPr_GET
#define READ_PKTS256TO511OCTETS_IMPr BCM53101_A0_READ_PKTS256TO511OCTETS_IMPr
#define WRITE_PKTS256TO511OCTETS_IMPr BCM53101_A0_WRITE_PKTS256TO511OCTETS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PKTS256TO511OCTETS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  Pkts512to1023Octets
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Rx 512 to 1023 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_PKTS512TO1023OCTETSr 0x00002070

#define BCM53101_A0_PKTS512TO1023OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program Pkts512to1023Octets.
 *
 */
typedef union BCM53101_A0_PKTS512TO1023OCTETSr_s {
	uint32_t v[1];
	uint32_t pkts512to1023octets[1];
	uint32_t _pkts512to1023octets;
} BCM53101_A0_PKTS512TO1023OCTETSr_t;

#define BCM53101_A0_PKTS512TO1023OCTETSr_CLR(r) (r).pkts512to1023octets[0] = 0
#define BCM53101_A0_PKTS512TO1023OCTETSr_SET(r,d) (r).pkts512to1023octets[0] = d
#define BCM53101_A0_PKTS512TO1023OCTETSr_GET(r) (r).pkts512to1023octets[0]


/*
 * These macros can be used to access Pkts512to1023Octets.
 *
 */
#define BCM53101_A0_READ_PKTS512TO1023OCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_PKTS512TO1023OCTETSr,(r._pkts512to1023octets),4)
#define BCM53101_A0_WRITE_PKTS512TO1023OCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_PKTS512TO1023OCTETSr,&(r._pkts512to1023octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS512TO1023OCTETSr BCM53101_A0_PKTS512TO1023OCTETSr
#define PKTS512TO1023OCTETSr_SIZE BCM53101_A0_PKTS512TO1023OCTETSr_SIZE
typedef BCM53101_A0_PKTS512TO1023OCTETSr_t PKTS512TO1023OCTETSr_t;
#define PKTS512TO1023OCTETSr_CLR BCM53101_A0_PKTS512TO1023OCTETSr_CLR
#define PKTS512TO1023OCTETSr_SET BCM53101_A0_PKTS512TO1023OCTETSr_SET
#define PKTS512TO1023OCTETSr_GET BCM53101_A0_PKTS512TO1023OCTETSr_GET
#define READ_PKTS512TO1023OCTETSr BCM53101_A0_READ_PKTS512TO1023OCTETSr
#define WRITE_PKTS512TO1023OCTETSr BCM53101_A0_WRITE_PKTS512TO1023OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PKTS512TO1023OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  Pkts512to1023Octets_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx 512 to 1023 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_PKTS512TO1023OCTETS_IMPr 0x00002870

#define BCM53101_A0_PKTS512TO1023OCTETS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program Pkts512to1023Octets_IMP.
 *
 */
typedef union BCM53101_A0_PKTS512TO1023OCTETS_IMPr_s {
	uint32_t v[1];
	uint32_t pkts512to1023octets_imp[1];
	uint32_t _pkts512to1023octets_imp;
} BCM53101_A0_PKTS512TO1023OCTETS_IMPr_t;

#define BCM53101_A0_PKTS512TO1023OCTETS_IMPr_CLR(r) (r).pkts512to1023octets_imp[0] = 0
#define BCM53101_A0_PKTS512TO1023OCTETS_IMPr_SET(r,d) (r).pkts512to1023octets_imp[0] = d
#define BCM53101_A0_PKTS512TO1023OCTETS_IMPr_GET(r) (r).pkts512to1023octets_imp[0]


/*
 * These macros can be used to access Pkts512to1023Octets_IMP.
 *
 */
#define BCM53101_A0_READ_PKTS512TO1023OCTETS_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_PKTS512TO1023OCTETS_IMPr,(r._pkts512to1023octets_imp),4)
#define BCM53101_A0_WRITE_PKTS512TO1023OCTETS_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_PKTS512TO1023OCTETS_IMPr,&(r._pkts512to1023octets_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS512TO1023OCTETS_IMPr BCM53101_A0_PKTS512TO1023OCTETS_IMPr
#define PKTS512TO1023OCTETS_IMPr_SIZE BCM53101_A0_PKTS512TO1023OCTETS_IMPr_SIZE
typedef BCM53101_A0_PKTS512TO1023OCTETS_IMPr_t PKTS512TO1023OCTETS_IMPr_t;
#define PKTS512TO1023OCTETS_IMPr_CLR BCM53101_A0_PKTS512TO1023OCTETS_IMPr_CLR
#define PKTS512TO1023OCTETS_IMPr_SET BCM53101_A0_PKTS512TO1023OCTETS_IMPr_SET
#define PKTS512TO1023OCTETS_IMPr_GET BCM53101_A0_PKTS512TO1023OCTETS_IMPr_GET
#define READ_PKTS512TO1023OCTETS_IMPr BCM53101_A0_READ_PKTS512TO1023OCTETS_IMPr
#define WRITE_PKTS512TO1023OCTETS_IMPr BCM53101_A0_WRITE_PKTS512TO1023OCTETS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PKTS512TO1023OCTETS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  Pkts64Octets
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Rx 64 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_PKTS64OCTETSr 0x00002060

#define BCM53101_A0_PKTS64OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program Pkts64Octets.
 *
 */
typedef union BCM53101_A0_PKTS64OCTETSr_s {
	uint32_t v[1];
	uint32_t pkts64octets[1];
	uint32_t _pkts64octets;
} BCM53101_A0_PKTS64OCTETSr_t;

#define BCM53101_A0_PKTS64OCTETSr_CLR(r) (r).pkts64octets[0] = 0
#define BCM53101_A0_PKTS64OCTETSr_SET(r,d) (r).pkts64octets[0] = d
#define BCM53101_A0_PKTS64OCTETSr_GET(r) (r).pkts64octets[0]


/*
 * These macros can be used to access Pkts64Octets.
 *
 */
#define BCM53101_A0_READ_PKTS64OCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_PKTS64OCTETSr,(r._pkts64octets),4)
#define BCM53101_A0_WRITE_PKTS64OCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_PKTS64OCTETSr,&(r._pkts64octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS64OCTETSr BCM53101_A0_PKTS64OCTETSr
#define PKTS64OCTETSr_SIZE BCM53101_A0_PKTS64OCTETSr_SIZE
typedef BCM53101_A0_PKTS64OCTETSr_t PKTS64OCTETSr_t;
#define PKTS64OCTETSr_CLR BCM53101_A0_PKTS64OCTETSr_CLR
#define PKTS64OCTETSr_SET BCM53101_A0_PKTS64OCTETSr_SET
#define PKTS64OCTETSr_GET BCM53101_A0_PKTS64OCTETSr_GET
#define READ_PKTS64OCTETSr BCM53101_A0_READ_PKTS64OCTETSr
#define WRITE_PKTS64OCTETSr BCM53101_A0_WRITE_PKTS64OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PKTS64OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  Pkts64Octets_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx 64 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_PKTS64OCTETS_IMPr 0x00002860

#define BCM53101_A0_PKTS64OCTETS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program Pkts64Octets_IMP.
 *
 */
typedef union BCM53101_A0_PKTS64OCTETS_IMPr_s {
	uint32_t v[1];
	uint32_t pkts64octets_imp[1];
	uint32_t _pkts64octets_imp;
} BCM53101_A0_PKTS64OCTETS_IMPr_t;

#define BCM53101_A0_PKTS64OCTETS_IMPr_CLR(r) (r).pkts64octets_imp[0] = 0
#define BCM53101_A0_PKTS64OCTETS_IMPr_SET(r,d) (r).pkts64octets_imp[0] = d
#define BCM53101_A0_PKTS64OCTETS_IMPr_GET(r) (r).pkts64octets_imp[0]


/*
 * These macros can be used to access Pkts64Octets_IMP.
 *
 */
#define BCM53101_A0_READ_PKTS64OCTETS_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_PKTS64OCTETS_IMPr,(r._pkts64octets_imp),4)
#define BCM53101_A0_WRITE_PKTS64OCTETS_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_PKTS64OCTETS_IMPr,&(r._pkts64octets_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS64OCTETS_IMPr BCM53101_A0_PKTS64OCTETS_IMPr
#define PKTS64OCTETS_IMPr_SIZE BCM53101_A0_PKTS64OCTETS_IMPr_SIZE
typedef BCM53101_A0_PKTS64OCTETS_IMPr_t PKTS64OCTETS_IMPr_t;
#define PKTS64OCTETS_IMPr_CLR BCM53101_A0_PKTS64OCTETS_IMPr_CLR
#define PKTS64OCTETS_IMPr_SET BCM53101_A0_PKTS64OCTETS_IMPr_SET
#define PKTS64OCTETS_IMPr_GET BCM53101_A0_PKTS64OCTETS_IMPr_GET
#define READ_PKTS64OCTETS_IMPr BCM53101_A0_READ_PKTS64OCTETS_IMPr
#define WRITE_PKTS64OCTETS_IMPr BCM53101_A0_WRITE_PKTS64OCTETS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PKTS64OCTETS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  Pkts65to127Octets
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Rx 65 to 127 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_PKTS65TO127OCTETSr 0x00002064

#define BCM53101_A0_PKTS65TO127OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program Pkts65to127Octets.
 *
 */
typedef union BCM53101_A0_PKTS65TO127OCTETSr_s {
	uint32_t v[1];
	uint32_t pkts65to127octets[1];
	uint32_t _pkts65to127octets;
} BCM53101_A0_PKTS65TO127OCTETSr_t;

#define BCM53101_A0_PKTS65TO127OCTETSr_CLR(r) (r).pkts65to127octets[0] = 0
#define BCM53101_A0_PKTS65TO127OCTETSr_SET(r,d) (r).pkts65to127octets[0] = d
#define BCM53101_A0_PKTS65TO127OCTETSr_GET(r) (r).pkts65to127octets[0]


/*
 * These macros can be used to access Pkts65to127Octets.
 *
 */
#define BCM53101_A0_READ_PKTS65TO127OCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_PKTS65TO127OCTETSr,(r._pkts65to127octets),4)
#define BCM53101_A0_WRITE_PKTS65TO127OCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_PKTS65TO127OCTETSr,&(r._pkts65to127octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS65TO127OCTETSr BCM53101_A0_PKTS65TO127OCTETSr
#define PKTS65TO127OCTETSr_SIZE BCM53101_A0_PKTS65TO127OCTETSr_SIZE
typedef BCM53101_A0_PKTS65TO127OCTETSr_t PKTS65TO127OCTETSr_t;
#define PKTS65TO127OCTETSr_CLR BCM53101_A0_PKTS65TO127OCTETSr_CLR
#define PKTS65TO127OCTETSr_SET BCM53101_A0_PKTS65TO127OCTETSr_SET
#define PKTS65TO127OCTETSr_GET BCM53101_A0_PKTS65TO127OCTETSr_GET
#define READ_PKTS65TO127OCTETSr BCM53101_A0_READ_PKTS65TO127OCTETSr
#define WRITE_PKTS65TO127OCTETSr BCM53101_A0_WRITE_PKTS65TO127OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PKTS65TO127OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  Pkts65to127Octets_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx 65 to 127 Bytes Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_PKTS65TO127OCTETS_IMPr 0x00002864

#define BCM53101_A0_PKTS65TO127OCTETS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program Pkts65to127Octets_IMP.
 *
 */
typedef union BCM53101_A0_PKTS65TO127OCTETS_IMPr_s {
	uint32_t v[1];
	uint32_t pkts65to127octets_imp[1];
	uint32_t _pkts65to127octets_imp;
} BCM53101_A0_PKTS65TO127OCTETS_IMPr_t;

#define BCM53101_A0_PKTS65TO127OCTETS_IMPr_CLR(r) (r).pkts65to127octets_imp[0] = 0
#define BCM53101_A0_PKTS65TO127OCTETS_IMPr_SET(r,d) (r).pkts65to127octets_imp[0] = d
#define BCM53101_A0_PKTS65TO127OCTETS_IMPr_GET(r) (r).pkts65to127octets_imp[0]


/*
 * These macros can be used to access Pkts65to127Octets_IMP.
 *
 */
#define BCM53101_A0_READ_PKTS65TO127OCTETS_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_PKTS65TO127OCTETS_IMPr,(r._pkts65to127octets_imp),4)
#define BCM53101_A0_WRITE_PKTS65TO127OCTETS_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_PKTS65TO127OCTETS_IMPr,&(r._pkts65to127octets_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define PKTS65TO127OCTETS_IMPr BCM53101_A0_PKTS65TO127OCTETS_IMPr
#define PKTS65TO127OCTETS_IMPr_SIZE BCM53101_A0_PKTS65TO127OCTETS_IMPr_SIZE
typedef BCM53101_A0_PKTS65TO127OCTETS_IMPr_t PKTS65TO127OCTETS_IMPr_t;
#define PKTS65TO127OCTETS_IMPr_CLR BCM53101_A0_PKTS65TO127OCTETS_IMPr_CLR
#define PKTS65TO127OCTETS_IMPr_SET BCM53101_A0_PKTS65TO127OCTETS_IMPr_SET
#define PKTS65TO127OCTETS_IMPr_GET BCM53101_A0_PKTS65TO127OCTETS_IMPr_GET
#define READ_PKTS65TO127OCTETS_IMPr BCM53101_A0_READ_PKTS65TO127OCTETS_IMPr
#define WRITE_PKTS65TO127OCTETS_IMPr BCM53101_A0_WRITE_PKTS65TO127OCTETS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_PKTS65TO127OCTETS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  QOS_1P_EN
 * BLOCKS:   SYS
 * DESC:     QoS 802.1P Enable Register
 * SIZE:     16
 * FIELDS:
 *     QOS_1P_EN        Enable 802.1p priority for individual ports.Bit 8:0 = Port 8~ Port 0.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_QOS_1P_ENr 0x00003004

#define BCM53101_A0_QOS_1P_ENr_SIZE 2

/*
 * This structure should be used to declare and program QOS_1P_EN.
 *
 */
typedef union BCM53101_A0_QOS_1P_ENr_s {
	uint32_t v[1];
	uint32_t qos_1p_en[1];
	uint32_t _qos_1p_en;
} BCM53101_A0_QOS_1P_ENr_t;

#define BCM53101_A0_QOS_1P_ENr_CLR(r) (r).qos_1p_en[0] = 0
#define BCM53101_A0_QOS_1P_ENr_SET(r,d) (r).qos_1p_en[0] = d
#define BCM53101_A0_QOS_1P_ENr_GET(r) (r).qos_1p_en[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_QOS_1P_ENr_QOS_1P_ENf_GET(r) (((r).qos_1p_en[0]) & 0x1ff)
#define BCM53101_A0_QOS_1P_ENr_QOS_1P_ENf_SET(r,f) (r).qos_1p_en[0]=(((r).qos_1p_en[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_QOS_1P_ENr_RESERVEDf_GET(r) ((((r).qos_1p_en[0]) >> 9) & 0x7f)
#define BCM53101_A0_QOS_1P_ENr_RESERVEDf_SET(r,f) (r).qos_1p_en[0]=(((r).qos_1p_en[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access QOS_1P_EN.
 *
 */
#define BCM53101_A0_READ_QOS_1P_ENr(u,r) cdk_robo_reg_read(u,BCM53101_A0_QOS_1P_ENr,(r._qos_1p_en),2)
#define BCM53101_A0_WRITE_QOS_1P_ENr(u,r) cdk_robo_reg_write(u,BCM53101_A0_QOS_1P_ENr,&(r._qos_1p_en),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_1P_ENr BCM53101_A0_QOS_1P_ENr
#define QOS_1P_ENr_SIZE BCM53101_A0_QOS_1P_ENr_SIZE
typedef BCM53101_A0_QOS_1P_ENr_t QOS_1P_ENr_t;
#define QOS_1P_ENr_CLR BCM53101_A0_QOS_1P_ENr_CLR
#define QOS_1P_ENr_SET BCM53101_A0_QOS_1P_ENr_SET
#define QOS_1P_ENr_GET BCM53101_A0_QOS_1P_ENr_GET
#define QOS_1P_ENr_QOS_1P_ENf_GET BCM53101_A0_QOS_1P_ENr_QOS_1P_ENf_GET
#define QOS_1P_ENr_QOS_1P_ENf_SET BCM53101_A0_QOS_1P_ENr_QOS_1P_ENf_SET
#define QOS_1P_ENr_RESERVEDf_GET BCM53101_A0_QOS_1P_ENr_RESERVEDf_GET
#define QOS_1P_ENr_RESERVEDf_SET BCM53101_A0_QOS_1P_ENr_RESERVEDf_SET
#define READ_QOS_1P_ENr BCM53101_A0_READ_QOS_1P_ENr
#define WRITE_QOS_1P_ENr BCM53101_A0_WRITE_QOS_1P_ENr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_QOS_1P_ENr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  QOS_DIFF_DSCP0
 * BLOCKS:   SYS
 * DESC:     DiffServ Priority Map 0 Register
 * SIZE:     48
 * FIELDS:
 *     PRI_DSCP_000000  DiffServ DSCP== 000000 to Priority ID map Register.
 *     PRI_DSCP_000001  DiffServ DSCP== 000001 to Priority ID map Register.
 *     PRI_DSCP_000010  DiffServ DSCP== 000010 to Priority ID map Register.
 *     PRI_DSCP_000011  DiffServ DSCP== 000011 to Priority ID map Register.
 *     PRI_DSCP_000100  DiffServ DSCP== 000100 to Priority ID map Register.
 *     PRI_DSCP_000101  DiffServ DSCP== 000101 to Priority ID map Register.
 *     PRI_DSCP_000110  DiffServ DSCP== 000110 to Priority ID map Register.
 *     PRI_DSCP_000111  DiffServ DSCP== 000111 to Priority ID map Register.
 *     PRI_DSCP_001000  DiffServ DSCP== 001000 to Priority ID map Register.
 *     PRI_DSCP_001001  DiffServ DSCP== 001001 to Priority ID map Register.
 *     PRI_DSCP_001010  DiffServ DSCP== 001010 to Priority ID map Register.
 *     PRI_DSCP_001011  DiffServ DSCP== 001011 to Priority ID map Register.
 *     PRI_DSCP_001100  DiffServ DSCP== 001100 to Priority ID map Register.
 *     PRI_DSCP_001101  DiffServ DSCP== 001101 to Priority ID map Register.
 *     PRI_DSCP_001110  DiffServ DSCP== 001110 to Priority ID map Register.
 *     PRI_DSCP_001111  DiffServ DSCP== 001111 to Priority ID map Register.
 *
 ******************************************************************************/
#define BCM53101_A0_QOS_DIFF_DSCP0r 0x00003030

#define BCM53101_A0_QOS_DIFF_DSCP0r_SIZE 6

/*
 * This structure should be used to declare and program QOS_DIFF_DSCP0.
 *
 */
typedef union BCM53101_A0_QOS_DIFF_DSCP0r_s {
	uint32_t v[2];
	uint32_t qos_diff_dscp0[2];
	uint32_t _qos_diff_dscp0;
} BCM53101_A0_QOS_DIFF_DSCP0r_t;

#define BCM53101_A0_QOS_DIFF_DSCP0r_CLR(r) CDK_MEMSET(&((r)._qos_diff_dscp0), 0, sizeof(BCM53101_A0_QOS_DIFF_DSCP0r_t))
#define BCM53101_A0_QOS_DIFF_DSCP0r_SET(r,i,d) (r).qos_diff_dscp0[i] = d
#define BCM53101_A0_QOS_DIFF_DSCP0r_GET(r,i) (r).qos_diff_dscp0[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000000f_GET(r) (((r).qos_diff_dscp0[0]) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000000f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000001f_GET(r) ((((r).qos_diff_dscp0[0]) >> 3) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000001f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000010f_GET(r) ((((r).qos_diff_dscp0[0]) >> 6) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000010f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000011f_GET(r) ((((r).qos_diff_dscp0[0]) >> 9) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000011f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000100f_GET(r) ((((r).qos_diff_dscp0[0]) >> 12) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000100f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000101f_GET(r) ((((r).qos_diff_dscp0[0]) >> 15) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000101f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000110f_GET(r) ((((r).qos_diff_dscp0[0]) >> 18) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000110f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000111f_GET(r) ((((r).qos_diff_dscp0[0]) >> 21) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000111f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001000f_GET(r) ((((r).qos_diff_dscp0[0]) >> 24) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001000f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001001f_GET(r) ((((r).qos_diff_dscp0[0]) >> 27) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001001f_SET(r,f) (r).qos_diff_dscp0[0]=(((r).qos_diff_dscp0[0] & ~((uint32_t)0x7 << 27)) | ((((uint32_t)f) & 0x7) << 27))
#define BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001010f_GET(r) cdk_field32_get((r).qos_diff_dscp0,30,32)
#define BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001010f_SET(r,f) cdk_field32_set((r).qos_diff_dscp0,30,32,f)
#define BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001011f_GET(r) ((((r).qos_diff_dscp0[1]) >> 1) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001011f_SET(r,f) (r).qos_diff_dscp0[1]=(((r).qos_diff_dscp0[1] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001100f_GET(r) ((((r).qos_diff_dscp0[1]) >> 4) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001100f_SET(r,f) (r).qos_diff_dscp0[1]=(((r).qos_diff_dscp0[1] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001101f_GET(r) ((((r).qos_diff_dscp0[1]) >> 7) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001101f_SET(r,f) (r).qos_diff_dscp0[1]=(((r).qos_diff_dscp0[1] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001110f_GET(r) ((((r).qos_diff_dscp0[1]) >> 10) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001110f_SET(r,f) (r).qos_diff_dscp0[1]=(((r).qos_diff_dscp0[1] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001111f_GET(r) ((((r).qos_diff_dscp0[1]) >> 13) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001111f_SET(r,f) (r).qos_diff_dscp0[1]=(((r).qos_diff_dscp0[1] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access QOS_DIFF_DSCP0.
 *
 */
#define BCM53101_A0_READ_QOS_DIFF_DSCP0r(u,r) cdk_robo_reg_read(u,BCM53101_A0_QOS_DIFF_DSCP0r,(r._qos_diff_dscp0),6)
#define BCM53101_A0_WRITE_QOS_DIFF_DSCP0r(u,r) cdk_robo_reg_write(u,BCM53101_A0_QOS_DIFF_DSCP0r,&(r._qos_diff_dscp0),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_DIFF_DSCP0r BCM53101_A0_QOS_DIFF_DSCP0r
#define QOS_DIFF_DSCP0r_SIZE BCM53101_A0_QOS_DIFF_DSCP0r_SIZE
typedef BCM53101_A0_QOS_DIFF_DSCP0r_t QOS_DIFF_DSCP0r_t;
#define QOS_DIFF_DSCP0r_CLR BCM53101_A0_QOS_DIFF_DSCP0r_CLR
#define QOS_DIFF_DSCP0r_SET BCM53101_A0_QOS_DIFF_DSCP0r_SET
#define QOS_DIFF_DSCP0r_GET BCM53101_A0_QOS_DIFF_DSCP0r_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000000f_GET BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000000f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000000f_SET BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000000f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000001f_GET BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000001f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000001f_SET BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000001f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000010f_GET BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000010f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000010f_SET BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000010f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000011f_GET BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000011f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000011f_SET BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000011f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000100f_GET BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000100f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000100f_SET BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000100f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000101f_GET BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000101f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000101f_SET BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000101f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000110f_GET BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000110f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000110f_SET BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000110f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000111f_GET BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000111f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_000111f_SET BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_000111f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001000f_GET BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001000f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001000f_SET BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001000f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001001f_GET BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001001f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001001f_SET BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001001f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001010f_GET BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001010f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001010f_SET BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001010f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001011f_GET BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001011f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001011f_SET BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001011f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001100f_GET BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001100f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001100f_SET BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001100f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001101f_GET BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001101f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001101f_SET BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001101f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001110f_GET BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001110f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001110f_SET BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001110f_SET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001111f_GET BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001111f_GET
#define QOS_DIFF_DSCP0r_PRI_DSCP_001111f_SET BCM53101_A0_QOS_DIFF_DSCP0r_PRI_DSCP_001111f_SET
#define READ_QOS_DIFF_DSCP0r BCM53101_A0_READ_QOS_DIFF_DSCP0r
#define WRITE_QOS_DIFF_DSCP0r BCM53101_A0_WRITE_QOS_DIFF_DSCP0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_QOS_DIFF_DSCP0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  QOS_DIFF_DSCP1
 * BLOCKS:   SYS
 * DESC:     DiffServ Priority Map 1 Register
 * SIZE:     48
 * FIELDS:
 *     PRI_DSCP_010000  DiffServ DSCP== 010000 to Priority ID map Register.
 *     PRI_DSCP_010001  DiffServ DSCP== 010001 to Priority ID map Register.
 *     PRI_DSCP_010010  DiffServ DSCP== 010010 to Priority ID map Register.
 *     PRI_DSCP_010011  DiffServ DSCP== 010011 to Priority ID map Register.
 *     PRI_DSCP_010100  DiffServ DSCP== 010100 to Priority ID map Register.
 *     PRI_DSCP_010101  DiffServ DSCP== 010101 to Priority ID map Register.
 *     PRI_DSCP_010110  DiffServ DSCP== 010110 to Priority ID map Register.
 *     PRI_DSCP_010111  DiffServ DSCP== 010111 to Priority ID map Register.
 *     PRI_DSCP_011000  DiffServ DSCP== 011000 to Priority ID map Register.
 *     PRI_DSCP_011001  DiffServ DSCP== 011001 to Priority ID map Register.
 *     PRI_DSCP_011010  DiffServ DSCP== 011010 to Priority ID map Register.
 *     PRI_DSCP_011011  DiffServ DSCP== 011011 to Priority ID map Register.
 *     PRI_DSCP_011100  DiffServ DSCP== 011100 to Priority ID map Register.
 *     PRI_DSCP_011101  DiffServ DSCP== 011101 to Priority ID map Register.
 *     PRI_DSCP_011110  DiffServ DSCP== 011110 to Priority ID map Register.
 *     PRI_DSCP_011111  DiffServ DSCP== 011111 to Priority ID map Register.
 *
 ******************************************************************************/
#define BCM53101_A0_QOS_DIFF_DSCP1r 0x00003036

#define BCM53101_A0_QOS_DIFF_DSCP1r_SIZE 6

/*
 * This structure should be used to declare and program QOS_DIFF_DSCP1.
 *
 */
typedef union BCM53101_A0_QOS_DIFF_DSCP1r_s {
	uint32_t v[2];
	uint32_t qos_diff_dscp1[2];
	uint32_t _qos_diff_dscp1;
} BCM53101_A0_QOS_DIFF_DSCP1r_t;

#define BCM53101_A0_QOS_DIFF_DSCP1r_CLR(r) CDK_MEMSET(&((r)._qos_diff_dscp1), 0, sizeof(BCM53101_A0_QOS_DIFF_DSCP1r_t))
#define BCM53101_A0_QOS_DIFF_DSCP1r_SET(r,i,d) (r).qos_diff_dscp1[i] = d
#define BCM53101_A0_QOS_DIFF_DSCP1r_GET(r,i) (r).qos_diff_dscp1[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010000f_GET(r) (((r).qos_diff_dscp1[0]) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010000f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010001f_GET(r) ((((r).qos_diff_dscp1[0]) >> 3) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010001f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010010f_GET(r) ((((r).qos_diff_dscp1[0]) >> 6) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010010f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010011f_GET(r) ((((r).qos_diff_dscp1[0]) >> 9) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010011f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010100f_GET(r) ((((r).qos_diff_dscp1[0]) >> 12) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010100f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010101f_GET(r) ((((r).qos_diff_dscp1[0]) >> 15) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010101f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010110f_GET(r) ((((r).qos_diff_dscp1[0]) >> 18) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010110f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010111f_GET(r) ((((r).qos_diff_dscp1[0]) >> 21) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010111f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011000f_GET(r) ((((r).qos_diff_dscp1[0]) >> 24) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011000f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011001f_GET(r) ((((r).qos_diff_dscp1[0]) >> 27) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011001f_SET(r,f) (r).qos_diff_dscp1[0]=(((r).qos_diff_dscp1[0] & ~((uint32_t)0x7 << 27)) | ((((uint32_t)f) & 0x7) << 27))
#define BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011010f_GET(r) cdk_field32_get((r).qos_diff_dscp1,30,32)
#define BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011010f_SET(r,f) cdk_field32_set((r).qos_diff_dscp1,30,32,f)
#define BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011011f_GET(r) ((((r).qos_diff_dscp1[1]) >> 1) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011011f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011100f_GET(r) ((((r).qos_diff_dscp1[1]) >> 4) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011100f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011101f_GET(r) ((((r).qos_diff_dscp1[1]) >> 7) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011101f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011110f_GET(r) ((((r).qos_diff_dscp1[1]) >> 10) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011110f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011111f_GET(r) ((((r).qos_diff_dscp1[1]) >> 13) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011111f_SET(r,f) (r).qos_diff_dscp1[1]=(((r).qos_diff_dscp1[1] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access QOS_DIFF_DSCP1.
 *
 */
#define BCM53101_A0_READ_QOS_DIFF_DSCP1r(u,r) cdk_robo_reg_read(u,BCM53101_A0_QOS_DIFF_DSCP1r,(r._qos_diff_dscp1),6)
#define BCM53101_A0_WRITE_QOS_DIFF_DSCP1r(u,r) cdk_robo_reg_write(u,BCM53101_A0_QOS_DIFF_DSCP1r,&(r._qos_diff_dscp1),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_DIFF_DSCP1r BCM53101_A0_QOS_DIFF_DSCP1r
#define QOS_DIFF_DSCP1r_SIZE BCM53101_A0_QOS_DIFF_DSCP1r_SIZE
typedef BCM53101_A0_QOS_DIFF_DSCP1r_t QOS_DIFF_DSCP1r_t;
#define QOS_DIFF_DSCP1r_CLR BCM53101_A0_QOS_DIFF_DSCP1r_CLR
#define QOS_DIFF_DSCP1r_SET BCM53101_A0_QOS_DIFF_DSCP1r_SET
#define QOS_DIFF_DSCP1r_GET BCM53101_A0_QOS_DIFF_DSCP1r_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010000f_GET BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010000f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010000f_SET BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010000f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010001f_GET BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010001f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010001f_SET BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010001f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010010f_GET BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010010f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010010f_SET BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010010f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010011f_GET BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010011f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010011f_SET BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010011f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010100f_GET BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010100f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010100f_SET BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010100f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010101f_GET BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010101f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010101f_SET BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010101f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010110f_GET BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010110f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010110f_SET BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010110f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010111f_GET BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010111f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_010111f_SET BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_010111f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011000f_GET BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011000f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011000f_SET BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011000f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011001f_GET BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011001f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011001f_SET BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011001f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011010f_GET BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011010f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011010f_SET BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011010f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011011f_GET BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011011f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011011f_SET BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011011f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011100f_GET BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011100f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011100f_SET BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011100f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011101f_GET BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011101f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011101f_SET BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011101f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011110f_GET BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011110f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011110f_SET BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011110f_SET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011111f_GET BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011111f_GET
#define QOS_DIFF_DSCP1r_PRI_DSCP_011111f_SET BCM53101_A0_QOS_DIFF_DSCP1r_PRI_DSCP_011111f_SET
#define READ_QOS_DIFF_DSCP1r BCM53101_A0_READ_QOS_DIFF_DSCP1r
#define WRITE_QOS_DIFF_DSCP1r BCM53101_A0_WRITE_QOS_DIFF_DSCP1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_QOS_DIFF_DSCP1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  QOS_DIFF_DSCP2
 * BLOCKS:   SYS
 * DESC:     DiffServ Priority Map 2 Register
 * SIZE:     48
 * FIELDS:
 *     PRI_DSCP_100000  DiffServ DSCP== 100000 to Priority ID map Register.
 *     PRI_DSCP_100001  DiffServ DSCP== 100001 to Priority ID map Register.
 *     PRI_DSCP_100010  DiffServ DSCP== 100010 to Priority ID map Register.
 *     PRI_DSCP_100011  DiffServ DSCP== 100011 to Priority ID map Register.
 *     PRI_DSCP_100100  DiffServ DSCP== 100100 to Priority ID map Register.
 *     PRI_DSCP_100101  DiffServ DSCP== 100101 to Priority ID map Register.
 *     PRI_DSCP_100110  DiffServ DSCP== 100110 to Priority ID map Register.
 *     PRI_DSCP_100111  DiffServ DSCP== 000111 to Priority ID map Register.
 *     PRI_DSCP_101000  DiffServ DSCP== 101000 to Priority ID map Register.
 *     PRI_DSCP_101001  DiffServ DSCP== 101001 to Priority ID map Register.
 *     PRI_DSCP_101010  DiffServ DSCP== 101010 to Priority ID map Register.
 *     PRI_DSCP_101011  DiffServ DSCP== 101011 to Priority ID map Register.
 *     PRI_DSCP_101100  DiffServ DSCP== 101100 to Priority ID map Register.
 *     PRI_DSCP_101101  DiffServ DSCP== 101101 to Priority ID map Register.
 *     PRI_DSCP_101110  DiffServ DSCP== 101110 to Priority ID map Register.
 *     PRI_DSCP_101111  DiffServ DSCP== 101111 to Priority ID map Register.
 *
 ******************************************************************************/
#define BCM53101_A0_QOS_DIFF_DSCP2r 0x0000303c

#define BCM53101_A0_QOS_DIFF_DSCP2r_SIZE 6

/*
 * This structure should be used to declare and program QOS_DIFF_DSCP2.
 *
 */
typedef union BCM53101_A0_QOS_DIFF_DSCP2r_s {
	uint32_t v[2];
	uint32_t qos_diff_dscp2[2];
	uint32_t _qos_diff_dscp2;
} BCM53101_A0_QOS_DIFF_DSCP2r_t;

#define BCM53101_A0_QOS_DIFF_DSCP2r_CLR(r) CDK_MEMSET(&((r)._qos_diff_dscp2), 0, sizeof(BCM53101_A0_QOS_DIFF_DSCP2r_t))
#define BCM53101_A0_QOS_DIFF_DSCP2r_SET(r,i,d) (r).qos_diff_dscp2[i] = d
#define BCM53101_A0_QOS_DIFF_DSCP2r_GET(r,i) (r).qos_diff_dscp2[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100000f_GET(r) (((r).qos_diff_dscp2[0]) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100000f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100001f_GET(r) ((((r).qos_diff_dscp2[0]) >> 3) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100001f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100010f_GET(r) ((((r).qos_diff_dscp2[0]) >> 6) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100010f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100011f_GET(r) ((((r).qos_diff_dscp2[0]) >> 9) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100011f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100100f_GET(r) ((((r).qos_diff_dscp2[0]) >> 12) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100100f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100101f_GET(r) ((((r).qos_diff_dscp2[0]) >> 15) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100101f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100110f_GET(r) ((((r).qos_diff_dscp2[0]) >> 18) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100110f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100111f_GET(r) ((((r).qos_diff_dscp2[0]) >> 21) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100111f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101000f_GET(r) ((((r).qos_diff_dscp2[0]) >> 24) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101000f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101001f_GET(r) ((((r).qos_diff_dscp2[0]) >> 27) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101001f_SET(r,f) (r).qos_diff_dscp2[0]=(((r).qos_diff_dscp2[0] & ~((uint32_t)0x7 << 27)) | ((((uint32_t)f) & 0x7) << 27))
#define BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101010f_GET(r) cdk_field32_get((r).qos_diff_dscp2,30,32)
#define BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101010f_SET(r,f) cdk_field32_set((r).qos_diff_dscp2,30,32,f)
#define BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101011f_GET(r) ((((r).qos_diff_dscp2[1]) >> 1) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101011f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101100f_GET(r) ((((r).qos_diff_dscp2[1]) >> 4) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101100f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101101f_GET(r) ((((r).qos_diff_dscp2[1]) >> 7) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101101f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101110f_GET(r) ((((r).qos_diff_dscp2[1]) >> 10) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101110f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101111f_GET(r) ((((r).qos_diff_dscp2[1]) >> 13) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101111f_SET(r,f) (r).qos_diff_dscp2[1]=(((r).qos_diff_dscp2[1] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access QOS_DIFF_DSCP2.
 *
 */
#define BCM53101_A0_READ_QOS_DIFF_DSCP2r(u,r) cdk_robo_reg_read(u,BCM53101_A0_QOS_DIFF_DSCP2r,(r._qos_diff_dscp2),6)
#define BCM53101_A0_WRITE_QOS_DIFF_DSCP2r(u,r) cdk_robo_reg_write(u,BCM53101_A0_QOS_DIFF_DSCP2r,&(r._qos_diff_dscp2),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_DIFF_DSCP2r BCM53101_A0_QOS_DIFF_DSCP2r
#define QOS_DIFF_DSCP2r_SIZE BCM53101_A0_QOS_DIFF_DSCP2r_SIZE
typedef BCM53101_A0_QOS_DIFF_DSCP2r_t QOS_DIFF_DSCP2r_t;
#define QOS_DIFF_DSCP2r_CLR BCM53101_A0_QOS_DIFF_DSCP2r_CLR
#define QOS_DIFF_DSCP2r_SET BCM53101_A0_QOS_DIFF_DSCP2r_SET
#define QOS_DIFF_DSCP2r_GET BCM53101_A0_QOS_DIFF_DSCP2r_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100000f_GET BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100000f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100000f_SET BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100000f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100001f_GET BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100001f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100001f_SET BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100001f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100010f_GET BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100010f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100010f_SET BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100010f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100011f_GET BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100011f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100011f_SET BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100011f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100100f_GET BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100100f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100100f_SET BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100100f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100101f_GET BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100101f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100101f_SET BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100101f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100110f_GET BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100110f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100110f_SET BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100110f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100111f_GET BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100111f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_100111f_SET BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_100111f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101000f_GET BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101000f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101000f_SET BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101000f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101001f_GET BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101001f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101001f_SET BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101001f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101010f_GET BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101010f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101010f_SET BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101010f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101011f_GET BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101011f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101011f_SET BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101011f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101100f_GET BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101100f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101100f_SET BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101100f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101101f_GET BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101101f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101101f_SET BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101101f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101110f_GET BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101110f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101110f_SET BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101110f_SET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101111f_GET BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101111f_GET
#define QOS_DIFF_DSCP2r_PRI_DSCP_101111f_SET BCM53101_A0_QOS_DIFF_DSCP2r_PRI_DSCP_101111f_SET
#define READ_QOS_DIFF_DSCP2r BCM53101_A0_READ_QOS_DIFF_DSCP2r
#define WRITE_QOS_DIFF_DSCP2r BCM53101_A0_WRITE_QOS_DIFF_DSCP2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_QOS_DIFF_DSCP2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  QOS_DIFF_DSCP3
 * BLOCKS:   SYS
 * DESC:     DiffServ Priority Map 3 Register
 * SIZE:     48
 * FIELDS:
 *     PRI_DSCP_110000  DiffServ DSCP== 110000 to Priority ID map Register.
 *     PRI_DSCP_110001  DiffServ DSCP== 110001 to Priority ID map Register.
 *     PRI_DSCP_110010  DiffServ DSCP== 110010 to Priority ID map Register.
 *     PRI_DSCP_110011  DiffServ DSCP== 110011 to Priority ID map Register.
 *     PRI_DSCP_110100  DiffServ DSCP== 110100 to Priority ID map Register.
 *     PRI_DSCP_110101  DiffServ DSCP== 110101 to Priority ID map Register.
 *     PRI_DSCP_110110  DiffServ DSCP== 110110 to Priority ID map Register.
 *     PRI_DSCP_110111  DiffServ DSCP== 110111 to Priority ID map Register.
 *     PRI_DSCP_111000  DiffServ DSCP== 111000 to Priority ID map Register.
 *     PRI_DSCP_111001  DiffServ DSCP== 111001 to Priority ID map Register.
 *     PRI_DSCP_111010  DiffServ DSCP== 111010 to Priority ID map Register.
 *     PRI_DSCP_111011  DiffServ DSCP== 111011 to Priority ID map Register.
 *     PRI_DSCP_111100  DiffServ DSCP== 111100 to Priority ID map Register.
 *     PRI_DSCP_111101  DiffServ DSCP== 111101 to Priority ID map Register.
 *     PRI_DSCP_111110  DiffServ DSCP== 111110 to Priority ID map Register.
 *     PRI_DSCP_111111  DiffServ DSCP== 111111 to Priority ID map Register.
 *
 ******************************************************************************/
#define BCM53101_A0_QOS_DIFF_DSCP3r 0x00003042

#define BCM53101_A0_QOS_DIFF_DSCP3r_SIZE 6

/*
 * This structure should be used to declare and program QOS_DIFF_DSCP3.
 *
 */
typedef union BCM53101_A0_QOS_DIFF_DSCP3r_s {
	uint32_t v[2];
	uint32_t qos_diff_dscp3[2];
	uint32_t _qos_diff_dscp3;
} BCM53101_A0_QOS_DIFF_DSCP3r_t;

#define BCM53101_A0_QOS_DIFF_DSCP3r_CLR(r) CDK_MEMSET(&((r)._qos_diff_dscp3), 0, sizeof(BCM53101_A0_QOS_DIFF_DSCP3r_t))
#define BCM53101_A0_QOS_DIFF_DSCP3r_SET(r,i,d) (r).qos_diff_dscp3[i] = d
#define BCM53101_A0_QOS_DIFF_DSCP3r_GET(r,i) (r).qos_diff_dscp3[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110000f_GET(r) (((r).qos_diff_dscp3[0]) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110000f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7))
#define BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110001f_GET(r) ((((r).qos_diff_dscp3[0]) >> 3) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110001f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3))
#define BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110010f_GET(r) ((((r).qos_diff_dscp3[0]) >> 6) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110010f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110011f_GET(r) ((((r).qos_diff_dscp3[0]) >> 9) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110011f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9))
#define BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110100f_GET(r) ((((r).qos_diff_dscp3[0]) >> 12) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110100f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12))
#define BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110101f_GET(r) ((((r).qos_diff_dscp3[0]) >> 15) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110101f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 15)) | ((((uint32_t)f) & 0x7) << 15))
#define BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110110f_GET(r) ((((r).qos_diff_dscp3[0]) >> 18) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110110f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110111f_GET(r) ((((r).qos_diff_dscp3[0]) >> 21) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110111f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 21)) | ((((uint32_t)f) & 0x7) << 21))
#define BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111000f_GET(r) ((((r).qos_diff_dscp3[0]) >> 24) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111000f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 24)) | ((((uint32_t)f) & 0x7) << 24))
#define BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111001f_GET(r) ((((r).qos_diff_dscp3[0]) >> 27) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111001f_SET(r,f) (r).qos_diff_dscp3[0]=(((r).qos_diff_dscp3[0] & ~((uint32_t)0x7 << 27)) | ((((uint32_t)f) & 0x7) << 27))
#define BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111010f_GET(r) cdk_field32_get((r).qos_diff_dscp3,30,32)
#define BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111010f_SET(r,f) cdk_field32_set((r).qos_diff_dscp3,30,32,f)
#define BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111011f_GET(r) ((((r).qos_diff_dscp3[1]) >> 1) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111011f_SET(r,f) (r).qos_diff_dscp3[1]=(((r).qos_diff_dscp3[1] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111100f_GET(r) ((((r).qos_diff_dscp3[1]) >> 4) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111100f_SET(r,f) (r).qos_diff_dscp3[1]=(((r).qos_diff_dscp3[1] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111101f_GET(r) ((((r).qos_diff_dscp3[1]) >> 7) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111101f_SET(r,f) (r).qos_diff_dscp3[1]=(((r).qos_diff_dscp3[1] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7))
#define BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111110f_GET(r) ((((r).qos_diff_dscp3[1]) >> 10) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111110f_SET(r,f) (r).qos_diff_dscp3[1]=(((r).qos_diff_dscp3[1] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10))
#define BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111111f_GET(r) ((((r).qos_diff_dscp3[1]) >> 13) & 0x7)
#define BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111111f_SET(r,f) (r).qos_diff_dscp3[1]=(((r).qos_diff_dscp3[1] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))

/*
 * These macros can be used to access QOS_DIFF_DSCP3.
 *
 */
#define BCM53101_A0_READ_QOS_DIFF_DSCP3r(u,r) cdk_robo_reg_read(u,BCM53101_A0_QOS_DIFF_DSCP3r,(r._qos_diff_dscp3),6)
#define BCM53101_A0_WRITE_QOS_DIFF_DSCP3r(u,r) cdk_robo_reg_write(u,BCM53101_A0_QOS_DIFF_DSCP3r,&(r._qos_diff_dscp3),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_DIFF_DSCP3r BCM53101_A0_QOS_DIFF_DSCP3r
#define QOS_DIFF_DSCP3r_SIZE BCM53101_A0_QOS_DIFF_DSCP3r_SIZE
typedef BCM53101_A0_QOS_DIFF_DSCP3r_t QOS_DIFF_DSCP3r_t;
#define QOS_DIFF_DSCP3r_CLR BCM53101_A0_QOS_DIFF_DSCP3r_CLR
#define QOS_DIFF_DSCP3r_SET BCM53101_A0_QOS_DIFF_DSCP3r_SET
#define QOS_DIFF_DSCP3r_GET BCM53101_A0_QOS_DIFF_DSCP3r_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110000f_GET BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110000f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110000f_SET BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110000f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110001f_GET BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110001f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110001f_SET BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110001f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110010f_GET BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110010f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110010f_SET BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110010f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110011f_GET BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110011f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110011f_SET BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110011f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110100f_GET BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110100f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110100f_SET BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110100f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110101f_GET BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110101f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110101f_SET BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110101f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110110f_GET BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110110f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110110f_SET BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110110f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110111f_GET BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110111f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_110111f_SET BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_110111f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111000f_GET BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111000f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111000f_SET BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111000f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111001f_GET BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111001f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111001f_SET BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111001f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111010f_GET BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111010f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111010f_SET BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111010f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111011f_GET BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111011f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111011f_SET BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111011f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111100f_GET BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111100f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111100f_SET BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111100f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111101f_GET BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111101f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111101f_SET BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111101f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111110f_GET BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111110f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111110f_SET BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111110f_SET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111111f_GET BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111111f_GET
#define QOS_DIFF_DSCP3r_PRI_DSCP_111111f_SET BCM53101_A0_QOS_DIFF_DSCP3r_PRI_DSCP_111111f_SET
#define READ_QOS_DIFF_DSCP3r BCM53101_A0_READ_QOS_DIFF_DSCP3r
#define WRITE_QOS_DIFF_DSCP3r BCM53101_A0_WRITE_QOS_DIFF_DSCP3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_QOS_DIFF_DSCP3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  QOS_EN_DIFFSERV
 * BLOCKS:   SYS
 * DESC:     QOS DiffServ Enable Register
 * SIZE:     16
 * FIELDS:
 *     QOS_EN_DIFFSERV  Enable DiffServ priority for individual ports.Bit 8:0 = Port 8~ Port 0.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_QOS_EN_DIFFSERVr 0x00003006

#define BCM53101_A0_QOS_EN_DIFFSERVr_SIZE 2

/*
 * This structure should be used to declare and program QOS_EN_DIFFSERV.
 *
 */
typedef union BCM53101_A0_QOS_EN_DIFFSERVr_s {
	uint32_t v[1];
	uint32_t qos_en_diffserv[1];
	uint32_t _qos_en_diffserv;
} BCM53101_A0_QOS_EN_DIFFSERVr_t;

#define BCM53101_A0_QOS_EN_DIFFSERVr_CLR(r) (r).qos_en_diffserv[0] = 0
#define BCM53101_A0_QOS_EN_DIFFSERVr_SET(r,d) (r).qos_en_diffserv[0] = d
#define BCM53101_A0_QOS_EN_DIFFSERVr_GET(r) (r).qos_en_diffserv[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_QOS_EN_DIFFSERVr_QOS_EN_DIFFSERVf_GET(r) (((r).qos_en_diffserv[0]) & 0x1ff)
#define BCM53101_A0_QOS_EN_DIFFSERVr_QOS_EN_DIFFSERVf_SET(r,f) (r).qos_en_diffserv[0]=(((r).qos_en_diffserv[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_QOS_EN_DIFFSERVr_RESERVEDf_GET(r) ((((r).qos_en_diffserv[0]) >> 9) & 0x7f)
#define BCM53101_A0_QOS_EN_DIFFSERVr_RESERVEDf_SET(r,f) (r).qos_en_diffserv[0]=(((r).qos_en_diffserv[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access QOS_EN_DIFFSERV.
 *
 */
#define BCM53101_A0_READ_QOS_EN_DIFFSERVr(u,r) cdk_robo_reg_read(u,BCM53101_A0_QOS_EN_DIFFSERVr,(r._qos_en_diffserv),2)
#define BCM53101_A0_WRITE_QOS_EN_DIFFSERVr(u,r) cdk_robo_reg_write(u,BCM53101_A0_QOS_EN_DIFFSERVr,&(r._qos_en_diffserv),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_EN_DIFFSERVr BCM53101_A0_QOS_EN_DIFFSERVr
#define QOS_EN_DIFFSERVr_SIZE BCM53101_A0_QOS_EN_DIFFSERVr_SIZE
typedef BCM53101_A0_QOS_EN_DIFFSERVr_t QOS_EN_DIFFSERVr_t;
#define QOS_EN_DIFFSERVr_CLR BCM53101_A0_QOS_EN_DIFFSERVr_CLR
#define QOS_EN_DIFFSERVr_SET BCM53101_A0_QOS_EN_DIFFSERVr_SET
#define QOS_EN_DIFFSERVr_GET BCM53101_A0_QOS_EN_DIFFSERVr_GET
#define QOS_EN_DIFFSERVr_QOS_EN_DIFFSERVf_GET BCM53101_A0_QOS_EN_DIFFSERVr_QOS_EN_DIFFSERVf_GET
#define QOS_EN_DIFFSERVr_QOS_EN_DIFFSERVf_SET BCM53101_A0_QOS_EN_DIFFSERVr_QOS_EN_DIFFSERVf_SET
#define QOS_EN_DIFFSERVr_RESERVEDf_GET BCM53101_A0_QOS_EN_DIFFSERVr_RESERVEDf_GET
#define QOS_EN_DIFFSERVr_RESERVEDf_SET BCM53101_A0_QOS_EN_DIFFSERVr_RESERVEDf_SET
#define READ_QOS_EN_DIFFSERVr BCM53101_A0_READ_QOS_EN_DIFFSERVr
#define WRITE_QOS_EN_DIFFSERVr BCM53101_A0_WRITE_QOS_EN_DIFFSERVr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_QOS_EN_DIFFSERVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  QOS_GLOBAL_CTRL
 * BLOCKS:   SYS
 * DESC:     QOS Global Control Register
 * SIZE:     8
 * FIELDS:
 *     RESERVED         
 *     QOS_LAYER_SEL    QOS IP Layer/Mac Layer Selection.2'b00: Layer 2 QOS only.       Select 802.1p if enabled and the RX frame is tagged, otherwise select mac-based2'b01: IP QOS only Select Diffserv if enabled, otherwise priority=0.2'b10: If (IP) then IP QOS ELSE LAYER2 QOS For IP frame, select Diffserv (0 if Diffserv is off), for L2 frames, select 802.1p if enabled and tagged, otherwise mac-based2'b11: Max Priority of All QOS algorithm Select max priority from port-based, Diffserv if enabled, 802.1p if enabled,
 *     RESERVED_0       Reserved
 *     PORT_QOS_EN      Port Based QOS Enable.When Set, Priority of Packet of individual Port can be assigned by Default Priority bits in Defualt 802.1Q Tag Register (Page:34h Address 10h-21h,26-27h)If Port-based QOS is enabled, it overrides all other priorities except the case of qos_layer_sel=11.Default value by Strap pin qos_en.
 *     AGGREGATION_MODE When set the IMP operated as the uplink port to the upstream network processor and the COS is decided from the TC based the normal packet classification flow. Otherwise, the IMP operates as the interface to the management CPU, and the COS is decided based on the reasons for forwarding the packet to the CPU.
 *
 ******************************************************************************/
#define BCM53101_A0_QOS_GLOBAL_CTRLr 0x00003000

#define BCM53101_A0_QOS_GLOBAL_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program QOS_GLOBAL_CTRL.
 *
 */
typedef union BCM53101_A0_QOS_GLOBAL_CTRLr_s {
	uint32_t v[1];
	uint32_t qos_global_ctrl[1];
	uint32_t _qos_global_ctrl;
} BCM53101_A0_QOS_GLOBAL_CTRLr_t;

#define BCM53101_A0_QOS_GLOBAL_CTRLr_CLR(r) (r).qos_global_ctrl[0] = 0
#define BCM53101_A0_QOS_GLOBAL_CTRLr_SET(r,d) (r).qos_global_ctrl[0] = d
#define BCM53101_A0_QOS_GLOBAL_CTRLr_GET(r) (r).qos_global_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_QOS_GLOBAL_CTRLr_RESERVEDf_GET(r) (((r).qos_global_ctrl[0]) & 0x3)
#define BCM53101_A0_QOS_GLOBAL_CTRLr_RESERVEDf_SET(r,f) (r).qos_global_ctrl[0]=(((r).qos_global_ctrl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53101_A0_QOS_GLOBAL_CTRLr_QOS_LAYER_SELf_GET(r) ((((r).qos_global_ctrl[0]) >> 2) & 0x3)
#define BCM53101_A0_QOS_GLOBAL_CTRLr_QOS_LAYER_SELf_SET(r,f) (r).qos_global_ctrl[0]=(((r).qos_global_ctrl[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53101_A0_QOS_GLOBAL_CTRLr_RESERVED_0f_GET(r) ((((r).qos_global_ctrl[0]) >> 4) & 0x3)
#define BCM53101_A0_QOS_GLOBAL_CTRLr_RESERVED_0f_SET(r,f) (r).qos_global_ctrl[0]=(((r).qos_global_ctrl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53101_A0_QOS_GLOBAL_CTRLr_PORT_QOS_ENf_GET(r) ((((r).qos_global_ctrl[0]) >> 6) & 0x1)
#define BCM53101_A0_QOS_GLOBAL_CTRLr_PORT_QOS_ENf_SET(r,f) (r).qos_global_ctrl[0]=(((r).qos_global_ctrl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_QOS_GLOBAL_CTRLr_AGGREGATION_MODEf_GET(r) ((((r).qos_global_ctrl[0]) >> 7) & 0x1)
#define BCM53101_A0_QOS_GLOBAL_CTRLr_AGGREGATION_MODEf_SET(r,f) (r).qos_global_ctrl[0]=(((r).qos_global_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access QOS_GLOBAL_CTRL.
 *
 */
#define BCM53101_A0_READ_QOS_GLOBAL_CTRLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_QOS_GLOBAL_CTRLr,(r._qos_global_ctrl),1)
#define BCM53101_A0_WRITE_QOS_GLOBAL_CTRLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_QOS_GLOBAL_CTRLr,&(r._qos_global_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_GLOBAL_CTRLr BCM53101_A0_QOS_GLOBAL_CTRLr
#define QOS_GLOBAL_CTRLr_SIZE BCM53101_A0_QOS_GLOBAL_CTRLr_SIZE
typedef BCM53101_A0_QOS_GLOBAL_CTRLr_t QOS_GLOBAL_CTRLr_t;
#define QOS_GLOBAL_CTRLr_CLR BCM53101_A0_QOS_GLOBAL_CTRLr_CLR
#define QOS_GLOBAL_CTRLr_SET BCM53101_A0_QOS_GLOBAL_CTRLr_SET
#define QOS_GLOBAL_CTRLr_GET BCM53101_A0_QOS_GLOBAL_CTRLr_GET
#define QOS_GLOBAL_CTRLr_RESERVEDf_GET BCM53101_A0_QOS_GLOBAL_CTRLr_RESERVEDf_GET
#define QOS_GLOBAL_CTRLr_RESERVEDf_SET BCM53101_A0_QOS_GLOBAL_CTRLr_RESERVEDf_SET
#define QOS_GLOBAL_CTRLr_QOS_LAYER_SELf_GET BCM53101_A0_QOS_GLOBAL_CTRLr_QOS_LAYER_SELf_GET
#define QOS_GLOBAL_CTRLr_QOS_LAYER_SELf_SET BCM53101_A0_QOS_GLOBAL_CTRLr_QOS_LAYER_SELf_SET
#define QOS_GLOBAL_CTRLr_RESERVED_0f_GET BCM53101_A0_QOS_GLOBAL_CTRLr_RESERVED_0f_GET
#define QOS_GLOBAL_CTRLr_RESERVED_0f_SET BCM53101_A0_QOS_GLOBAL_CTRLr_RESERVED_0f_SET
#define QOS_GLOBAL_CTRLr_PORT_QOS_ENf_GET BCM53101_A0_QOS_GLOBAL_CTRLr_PORT_QOS_ENf_GET
#define QOS_GLOBAL_CTRLr_PORT_QOS_ENf_SET BCM53101_A0_QOS_GLOBAL_CTRLr_PORT_QOS_ENf_SET
#define QOS_GLOBAL_CTRLr_AGGREGATION_MODEf_GET BCM53101_A0_QOS_GLOBAL_CTRLr_AGGREGATION_MODEf_GET
#define QOS_GLOBAL_CTRLr_AGGREGATION_MODEf_SET BCM53101_A0_QOS_GLOBAL_CTRLr_AGGREGATION_MODEf_SET
#define READ_QOS_GLOBAL_CTRLr BCM53101_A0_READ_QOS_GLOBAL_CTRLr
#define WRITE_QOS_GLOBAL_CTRLr BCM53101_A0_WRITE_QOS_GLOBAL_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_QOS_GLOBAL_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  QOS_TX_CTRL
 * BLOCKS:   SYS
 * DESC:     QOS TX Control Register
 * SIZE:     8
 * FIELDS:
 *     QOS_PRIORITY_CTRL Best Effort Queues Priority ControlThis field controls the scheduling priority of the best effort queues. It does not affect the behavior of Q4 and Q5.00: all queues are weighted round robin01: Q3 is strict priority, Q2-Q0  are weighted round robin.10: Q3 and Q2 is strict priority, Q1-Q0 are weighted round robin.11: Q3, Q2, Q1 and Q0 are in strict priority.Strict priority: When it is in strict priority, the priority is Q3 > Q2 > Q1 > Q0. The G_TXPORT will always serve the higher queue first if it is not empty. In this mode, the service weight are don't care.Weighted round robin: When it is in weighted round robin mode, thequeues are scheduled in a round robin way according to the serviceweight of each queue.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_QOS_TX_CTRLr 0x00003080

#define BCM53101_A0_QOS_TX_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program QOS_TX_CTRL.
 *
 */
typedef union BCM53101_A0_QOS_TX_CTRLr_s {
	uint32_t v[1];
	uint32_t qos_tx_ctrl[1];
	uint32_t _qos_tx_ctrl;
} BCM53101_A0_QOS_TX_CTRLr_t;

#define BCM53101_A0_QOS_TX_CTRLr_CLR(r) (r).qos_tx_ctrl[0] = 0
#define BCM53101_A0_QOS_TX_CTRLr_SET(r,d) (r).qos_tx_ctrl[0] = d
#define BCM53101_A0_QOS_TX_CTRLr_GET(r) (r).qos_tx_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_QOS_TX_CTRLr_QOS_PRIORITY_CTRLf_GET(r) (((r).qos_tx_ctrl[0]) & 0x3)
#define BCM53101_A0_QOS_TX_CTRLr_QOS_PRIORITY_CTRLf_SET(r,f) (r).qos_tx_ctrl[0]=(((r).qos_tx_ctrl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53101_A0_QOS_TX_CTRLr_RESERVED_1f_GET(r) ((((r).qos_tx_ctrl[0]) >> 2) & 0x3f)
#define BCM53101_A0_QOS_TX_CTRLr_RESERVED_1f_SET(r,f) (r).qos_tx_ctrl[0]=(((r).qos_tx_ctrl[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))

/*
 * These macros can be used to access QOS_TX_CTRL.
 *
 */
#define BCM53101_A0_READ_QOS_TX_CTRLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_QOS_TX_CTRLr,(r._qos_tx_ctrl),1)
#define BCM53101_A0_WRITE_QOS_TX_CTRLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_QOS_TX_CTRLr,&(r._qos_tx_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_TX_CTRLr BCM53101_A0_QOS_TX_CTRLr
#define QOS_TX_CTRLr_SIZE BCM53101_A0_QOS_TX_CTRLr_SIZE
typedef BCM53101_A0_QOS_TX_CTRLr_t QOS_TX_CTRLr_t;
#define QOS_TX_CTRLr_CLR BCM53101_A0_QOS_TX_CTRLr_CLR
#define QOS_TX_CTRLr_SET BCM53101_A0_QOS_TX_CTRLr_SET
#define QOS_TX_CTRLr_GET BCM53101_A0_QOS_TX_CTRLr_GET
#define QOS_TX_CTRLr_QOS_PRIORITY_CTRLf_GET BCM53101_A0_QOS_TX_CTRLr_QOS_PRIORITY_CTRLf_GET
#define QOS_TX_CTRLr_QOS_PRIORITY_CTRLf_SET BCM53101_A0_QOS_TX_CTRLr_QOS_PRIORITY_CTRLf_SET
#define QOS_TX_CTRLr_RESERVED_1f_GET BCM53101_A0_QOS_TX_CTRLr_RESERVED_1f_GET
#define QOS_TX_CTRLr_RESERVED_1f_SET BCM53101_A0_QOS_TX_CTRLr_RESERVED_1f_SET
#define READ_QOS_TX_CTRLr BCM53101_A0_READ_QOS_TX_CTRLr
#define WRITE_QOS_TX_CTRLr BCM53101_A0_WRITE_QOS_TX_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_QOS_TX_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  QOS_WEIGHT
 * BLOCKS:   SYS
 * DESC:     Queue N Weight Register
 * SIZE:     8
 * FIELDS:
 *     WEIGHTS          Queue N Weight Register.***Service Weight unit is for packet count***This field defines the service weight for Quene N if the QOS is under weight round robin mode. If it is strict priority mode, this field doesn't affect the QOS scheduler. User should program breg_q3_weight>=breg_q2_weight>=breg_q1_weight>=breg_q0_weight. And this field mustn't be programmed as zero.
 *
 ******************************************************************************/
#define BCM53101_A0_QOS_WEIGHTr 0x00003081

#define BCM53101_A0_QOS_WEIGHTr_SIZE 1

/*
 * This structure should be used to declare and program QOS_WEIGHT.
 *
 */
typedef union BCM53101_A0_QOS_WEIGHTr_s {
	uint32_t v[1];
	uint32_t qos_weight[1];
	uint32_t _qos_weight;
} BCM53101_A0_QOS_WEIGHTr_t;

#define BCM53101_A0_QOS_WEIGHTr_CLR(r) (r).qos_weight[0] = 0
#define BCM53101_A0_QOS_WEIGHTr_SET(r,d) (r).qos_weight[0] = d
#define BCM53101_A0_QOS_WEIGHTr_GET(r) (r).qos_weight[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_QOS_WEIGHTr_WEIGHTSf_GET(r) (((r).qos_weight[0]) & 0xff)
#define BCM53101_A0_QOS_WEIGHTr_WEIGHTSf_SET(r,f) (r).qos_weight[0]=(((r).qos_weight[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access QOS_WEIGHT.
 *
 */
#define BCM53101_A0_READ_QOS_WEIGHTr(u,i,r) cdk_robo_reg_read(u,BCM53101_A0_QOS_WEIGHTr+(1*(i)),(r._qos_weight),1)
#define BCM53101_A0_WRITE_QOS_WEIGHTr(u,i,r) cdk_robo_reg_write(u,BCM53101_A0_QOS_WEIGHTr+(1*(i)),&(r._qos_weight),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define QOS_WEIGHTr BCM53101_A0_QOS_WEIGHTr
#define QOS_WEIGHTr_SIZE BCM53101_A0_QOS_WEIGHTr_SIZE
typedef BCM53101_A0_QOS_WEIGHTr_t QOS_WEIGHTr_t;
#define QOS_WEIGHTr_CLR BCM53101_A0_QOS_WEIGHTr_CLR
#define QOS_WEIGHTr_SET BCM53101_A0_QOS_WEIGHTr_SET
#define QOS_WEIGHTr_GET BCM53101_A0_QOS_WEIGHTr_GET
#define QOS_WEIGHTr_WEIGHTSf_GET BCM53101_A0_QOS_WEIGHTr_WEIGHTSf_GET
#define QOS_WEIGHTr_WEIGHTSf_SET BCM53101_A0_QOS_WEIGHTr_WEIGHTSf_SET
#define READ_QOS_WEIGHTr BCM53101_A0_READ_QOS_WEIGHTr
#define WRITE_QOS_WEIGHTr BCM53101_A0_WRITE_QOS_WEIGHTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_QOS_WEIGHTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RESE_AV_EN_CTRL
 * BLOCKS:   SYS
 * DESC:     ResE AV Enable Control Register
 * SIZE:     16
 * FIELDS:
 *     AV_EN            AV enableThis field to define AV enable of each port.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_RESE_AV_EN_CTRLr 0x00009000

#define BCM53101_A0_RESE_AV_EN_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program RESE_AV_EN_CTRL.
 *
 */
typedef union BCM53101_A0_RESE_AV_EN_CTRLr_s {
	uint32_t v[1];
	uint32_t rese_av_en_ctrl[1];
	uint32_t _rese_av_en_ctrl;
} BCM53101_A0_RESE_AV_EN_CTRLr_t;

#define BCM53101_A0_RESE_AV_EN_CTRLr_CLR(r) (r).rese_av_en_ctrl[0] = 0
#define BCM53101_A0_RESE_AV_EN_CTRLr_SET(r,d) (r).rese_av_en_ctrl[0] = d
#define BCM53101_A0_RESE_AV_EN_CTRLr_GET(r) (r).rese_av_en_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_RESE_AV_EN_CTRLr_AV_ENf_GET(r) (((r).rese_av_en_ctrl[0]) & 0x3f)
#define BCM53101_A0_RESE_AV_EN_CTRLr_AV_ENf_SET(r,f) (r).rese_av_en_ctrl[0]=(((r).rese_av_en_ctrl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53101_A0_RESE_AV_EN_CTRLr_RESERVEDf_GET(r) ((((r).rese_av_en_ctrl[0]) >> 6) & 0x3ff)
#define BCM53101_A0_RESE_AV_EN_CTRLr_RESERVEDf_SET(r,f) (r).rese_av_en_ctrl[0]=(((r).rese_av_en_ctrl[0] & ~((uint32_t)0x3ff << 6)) | ((((uint32_t)f) & 0x3ff) << 6))

/*
 * These macros can be used to access RESE_AV_EN_CTRL.
 *
 */
#define BCM53101_A0_READ_RESE_AV_EN_CTRLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_RESE_AV_EN_CTRLr,(r._rese_av_en_ctrl),2)
#define BCM53101_A0_WRITE_RESE_AV_EN_CTRLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_RESE_AV_EN_CTRLr,&(r._rese_av_en_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RESE_AV_EN_CTRLr BCM53101_A0_RESE_AV_EN_CTRLr
#define RESE_AV_EN_CTRLr_SIZE BCM53101_A0_RESE_AV_EN_CTRLr_SIZE
typedef BCM53101_A0_RESE_AV_EN_CTRLr_t RESE_AV_EN_CTRLr_t;
#define RESE_AV_EN_CTRLr_CLR BCM53101_A0_RESE_AV_EN_CTRLr_CLR
#define RESE_AV_EN_CTRLr_SET BCM53101_A0_RESE_AV_EN_CTRLr_SET
#define RESE_AV_EN_CTRLr_GET BCM53101_A0_RESE_AV_EN_CTRLr_GET
#define RESE_AV_EN_CTRLr_AV_ENf_GET BCM53101_A0_RESE_AV_EN_CTRLr_AV_ENf_GET
#define RESE_AV_EN_CTRLr_AV_ENf_SET BCM53101_A0_RESE_AV_EN_CTRLr_AV_ENf_SET
#define RESE_AV_EN_CTRLr_RESERVEDf_GET BCM53101_A0_RESE_AV_EN_CTRLr_RESERVEDf_GET
#define RESE_AV_EN_CTRLr_RESERVEDf_SET BCM53101_A0_RESE_AV_EN_CTRLr_RESERVEDf_SET
#define READ_RESE_AV_EN_CTRLr BCM53101_A0_READ_RESE_AV_EN_CTRLr
#define WRITE_RESE_AV_EN_CTRLr BCM53101_A0_WRITE_RESE_AV_EN_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RESE_AV_EN_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RESE_C4_BW_CNTL
 * BLOCKS:   EPIC0
 * DESC:     ResE Class 4 Bandwidth Control Register  
 * SIZE:     16
 * FIELDS:
 *     C4_BW            Class 4 Bandwidth for port NThis field defines the byte count allowed for Class 4 traffic transmission within a slot time.  
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_RESE_C4_BW_CNTLr 0x00009060

#define BCM53101_A0_RESE_C4_BW_CNTLr_SIZE 2

/*
 * This structure should be used to declare and program RESE_C4_BW_CNTL.
 *
 */
typedef union BCM53101_A0_RESE_C4_BW_CNTLr_s {
	uint32_t v[1];
	uint32_t rese_c4_bw_cntl[1];
	uint32_t _rese_c4_bw_cntl;
} BCM53101_A0_RESE_C4_BW_CNTLr_t;

#define BCM53101_A0_RESE_C4_BW_CNTLr_CLR(r) (r).rese_c4_bw_cntl[0] = 0
#define BCM53101_A0_RESE_C4_BW_CNTLr_SET(r,d) (r).rese_c4_bw_cntl[0] = d
#define BCM53101_A0_RESE_C4_BW_CNTLr_GET(r) (r).rese_c4_bw_cntl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_RESE_C4_BW_CNTLr_C4_BWf_GET(r) (((r).rese_c4_bw_cntl[0]) & 0x3fff)
#define BCM53101_A0_RESE_C4_BW_CNTLr_C4_BWf_SET(r,f) (r).rese_c4_bw_cntl[0]=(((r).rese_c4_bw_cntl[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM53101_A0_RESE_C4_BW_CNTLr_RESERVEDf_GET(r) ((((r).rese_c4_bw_cntl[0]) >> 14) & 0x3)
#define BCM53101_A0_RESE_C4_BW_CNTLr_RESERVEDf_SET(r,f) (r).rese_c4_bw_cntl[0]=(((r).rese_c4_bw_cntl[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access RESE_C4_BW_CNTL.
 *
 */
#define BCM53101_A0_READ_RESE_C4_BW_CNTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_RESE_C4_BW_CNTLr,(r._rese_c4_bw_cntl),2)
#define BCM53101_A0_WRITE_RESE_C4_BW_CNTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_RESE_C4_BW_CNTLr,&(r._rese_c4_bw_cntl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RESE_C4_BW_CNTLr BCM53101_A0_RESE_C4_BW_CNTLr
#define RESE_C4_BW_CNTLr_SIZE BCM53101_A0_RESE_C4_BW_CNTLr_SIZE
typedef BCM53101_A0_RESE_C4_BW_CNTLr_t RESE_C4_BW_CNTLr_t;
#define RESE_C4_BW_CNTLr_CLR BCM53101_A0_RESE_C4_BW_CNTLr_CLR
#define RESE_C4_BW_CNTLr_SET BCM53101_A0_RESE_C4_BW_CNTLr_SET
#define RESE_C4_BW_CNTLr_GET BCM53101_A0_RESE_C4_BW_CNTLr_GET
#define RESE_C4_BW_CNTLr_C4_BWf_GET BCM53101_A0_RESE_C4_BW_CNTLr_C4_BWf_GET
#define RESE_C4_BW_CNTLr_C4_BWf_SET BCM53101_A0_RESE_C4_BW_CNTLr_C4_BWf_SET
#define RESE_C4_BW_CNTLr_RESERVEDf_GET BCM53101_A0_RESE_C4_BW_CNTLr_RESERVEDf_GET
#define RESE_C4_BW_CNTLr_RESERVEDf_SET BCM53101_A0_RESE_C4_BW_CNTLr_RESERVEDf_SET
#define READ_RESE_C4_BW_CNTLr BCM53101_A0_READ_RESE_C4_BW_CNTLr
#define WRITE_RESE_C4_BW_CNTLr BCM53101_A0_WRITE_RESE_C4_BW_CNTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RESE_C4_BW_CNTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RESE_C5_BW_CNTL
 * BLOCKS:   EPIC0
 * DESC:     ResE Class 5 Bandwidth Control Register  
 * SIZE:     16
 * FIELDS:
 *     C5_BW            Class 5 Bandwidth for port NThis field defines the byte count allowed for Class 5 traffic transmission within a slot time.
 *     RESERVED         Reserved
 *     C5_WNDW          Class 5 traffic  Credit Carry-over control for port NThe purpose is to control the credit carry-over under different link speed. For 100M link, the 125us slot is too small such that ResE packet could easily "slip slot", so the credit carry-over should be allowed. For 1G link, 125us slot is reasonably big such that the BW reservation could be done in a conservative way to prevent "slot slipping", so credit carry-over is not needed.
 *
 ******************************************************************************/
#define BCM53101_A0_RESE_C5_BW_CNTLr 0x00009030

#define BCM53101_A0_RESE_C5_BW_CNTLr_SIZE 2

/*
 * This structure should be used to declare and program RESE_C5_BW_CNTL.
 *
 */
typedef union BCM53101_A0_RESE_C5_BW_CNTLr_s {
	uint32_t v[1];
	uint32_t rese_c5_bw_cntl[1];
	uint32_t _rese_c5_bw_cntl;
} BCM53101_A0_RESE_C5_BW_CNTLr_t;

#define BCM53101_A0_RESE_C5_BW_CNTLr_CLR(r) (r).rese_c5_bw_cntl[0] = 0
#define BCM53101_A0_RESE_C5_BW_CNTLr_SET(r,d) (r).rese_c5_bw_cntl[0] = d
#define BCM53101_A0_RESE_C5_BW_CNTLr_GET(r) (r).rese_c5_bw_cntl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_RESE_C5_BW_CNTLr_C5_BWf_GET(r) (((r).rese_c5_bw_cntl[0]) & 0x3fff)
#define BCM53101_A0_RESE_C5_BW_CNTLr_C5_BWf_SET(r,f) (r).rese_c5_bw_cntl[0]=(((r).rese_c5_bw_cntl[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff))
#define BCM53101_A0_RESE_C5_BW_CNTLr_RESERVEDf_GET(r) ((((r).rese_c5_bw_cntl[0]) >> 14) & 0x1)
#define BCM53101_A0_RESE_C5_BW_CNTLr_RESERVEDf_SET(r,f) (r).rese_c5_bw_cntl[0]=(((r).rese_c5_bw_cntl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14))
#define BCM53101_A0_RESE_C5_BW_CNTLr_C5_WNDWf_GET(r) ((((r).rese_c5_bw_cntl[0]) >> 15) & 0x1)
#define BCM53101_A0_RESE_C5_BW_CNTLr_C5_WNDWf_SET(r,f) (r).rese_c5_bw_cntl[0]=(((r).rese_c5_bw_cntl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15))

/*
 * These macros can be used to access RESE_C5_BW_CNTL.
 *
 */
#define BCM53101_A0_READ_RESE_C5_BW_CNTLr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_RESE_C5_BW_CNTLr,(r._rese_c5_bw_cntl),2)
#define BCM53101_A0_WRITE_RESE_C5_BW_CNTLr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_RESE_C5_BW_CNTLr,&(r._rese_c5_bw_cntl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RESE_C5_BW_CNTLr BCM53101_A0_RESE_C5_BW_CNTLr
#define RESE_C5_BW_CNTLr_SIZE BCM53101_A0_RESE_C5_BW_CNTLr_SIZE
typedef BCM53101_A0_RESE_C5_BW_CNTLr_t RESE_C5_BW_CNTLr_t;
#define RESE_C5_BW_CNTLr_CLR BCM53101_A0_RESE_C5_BW_CNTLr_CLR
#define RESE_C5_BW_CNTLr_SET BCM53101_A0_RESE_C5_BW_CNTLr_SET
#define RESE_C5_BW_CNTLr_GET BCM53101_A0_RESE_C5_BW_CNTLr_GET
#define RESE_C5_BW_CNTLr_C5_BWf_GET BCM53101_A0_RESE_C5_BW_CNTLr_C5_BWf_GET
#define RESE_C5_BW_CNTLr_C5_BWf_SET BCM53101_A0_RESE_C5_BW_CNTLr_C5_BWf_SET
#define RESE_C5_BW_CNTLr_RESERVEDf_GET BCM53101_A0_RESE_C5_BW_CNTLr_RESERVEDf_GET
#define RESE_C5_BW_CNTLr_RESERVEDf_SET BCM53101_A0_RESE_C5_BW_CNTLr_RESERVEDf_SET
#define RESE_C5_BW_CNTLr_C5_WNDWf_GET BCM53101_A0_RESE_C5_BW_CNTLr_C5_WNDWf_GET
#define RESE_C5_BW_CNTLr_C5_WNDWf_SET BCM53101_A0_RESE_C5_BW_CNTLr_C5_WNDWf_SET
#define READ_RESE_C5_BW_CNTLr BCM53101_A0_READ_RESE_C5_BW_CNTLr
#define WRITE_RESE_C5_BW_CNTLr BCM53101_A0_WRITE_RESE_C5_BW_CNTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RESE_C5_BW_CNTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RESE_EGRESS_TM_STAMP
 * BLOCKS:   EPIC0
 * DESC:     ResE Egress Time Stamp Register 
 * SIZE:     32
 * FIELDS:
 *     EGRESS_TS_TM_STAMP Egress Time Sync. Packet Time StampThis field reports the time stamp of egress time sync. packet. It use 32-bit time base as time stamping. The time between the departure of first byte of MAC DA and the time stamping point should be constant.
 *
 ******************************************************************************/
#define BCM53101_A0_RESE_EGRESS_TM_STAMPr 0x00009090

#define BCM53101_A0_RESE_EGRESS_TM_STAMPr_SIZE 4

/*
 * This structure should be used to declare and program RESE_EGRESS_TM_STAMP.
 *
 */
typedef union BCM53101_A0_RESE_EGRESS_TM_STAMPr_s {
	uint32_t v[1];
	uint32_t rese_egress_tm_stamp[1];
	uint32_t _rese_egress_tm_stamp;
} BCM53101_A0_RESE_EGRESS_TM_STAMPr_t;

#define BCM53101_A0_RESE_EGRESS_TM_STAMPr_CLR(r) (r).rese_egress_tm_stamp[0] = 0
#define BCM53101_A0_RESE_EGRESS_TM_STAMPr_SET(r,d) (r).rese_egress_tm_stamp[0] = d
#define BCM53101_A0_RESE_EGRESS_TM_STAMPr_GET(r) (r).rese_egress_tm_stamp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_RESE_EGRESS_TM_STAMPr_EGRESS_TS_TM_STAMPf_GET(r) ((r).rese_egress_tm_stamp[0])
#define BCM53101_A0_RESE_EGRESS_TM_STAMPr_EGRESS_TS_TM_STAMPf_SET(r,f) (r).rese_egress_tm_stamp[0]=((uint32_t)f)

/*
 * These macros can be used to access RESE_EGRESS_TM_STAMP.
 *
 */
#define BCM53101_A0_READ_RESE_EGRESS_TM_STAMPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_RESE_EGRESS_TM_STAMPr,(r._rese_egress_tm_stamp),4)
#define BCM53101_A0_WRITE_RESE_EGRESS_TM_STAMPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_RESE_EGRESS_TM_STAMPr,&(r._rese_egress_tm_stamp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RESE_EGRESS_TM_STAMPr BCM53101_A0_RESE_EGRESS_TM_STAMPr
#define RESE_EGRESS_TM_STAMPr_SIZE BCM53101_A0_RESE_EGRESS_TM_STAMPr_SIZE
typedef BCM53101_A0_RESE_EGRESS_TM_STAMPr_t RESE_EGRESS_TM_STAMPr_t;
#define RESE_EGRESS_TM_STAMPr_CLR BCM53101_A0_RESE_EGRESS_TM_STAMPr_CLR
#define RESE_EGRESS_TM_STAMPr_SET BCM53101_A0_RESE_EGRESS_TM_STAMPr_SET
#define RESE_EGRESS_TM_STAMPr_GET BCM53101_A0_RESE_EGRESS_TM_STAMPr_GET
#define RESE_EGRESS_TM_STAMPr_EGRESS_TS_TM_STAMPf_GET BCM53101_A0_RESE_EGRESS_TM_STAMPr_EGRESS_TS_TM_STAMPf_GET
#define RESE_EGRESS_TM_STAMPr_EGRESS_TS_TM_STAMPf_SET BCM53101_A0_RESE_EGRESS_TM_STAMPr_EGRESS_TS_TM_STAMPf_SET
#define READ_RESE_EGRESS_TM_STAMPr BCM53101_A0_READ_RESE_EGRESS_TM_STAMPr
#define WRITE_RESE_EGRESS_TM_STAMPr BCM53101_A0_WRITE_RESE_EGRESS_TM_STAMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RESE_EGRESS_TM_STAMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RESE_MAX_AV_PKT_SZ
 * BLOCKS:   SYS
 * DESC:     ResE MAX AV Packet Size Register
 * SIZE:     16
 * FIELDS:
 *     MAX_AV_PKT_SZ    Max.AV Packet SizeThis field is to define the max packet size of AV packet (Residential Ethernet).  The ingress port uses it to qualify if the packet is allowed to pass through an AV link. The egress port uses it to perform shaping gate.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_RESE_MAX_AV_PKT_SZr 0x00009004

#define BCM53101_A0_RESE_MAX_AV_PKT_SZr_SIZE 2

/*
 * This structure should be used to declare and program RESE_MAX_AV_PKT_SZ.
 *
 */
typedef union BCM53101_A0_RESE_MAX_AV_PKT_SZr_s {
	uint32_t v[1];
	uint32_t rese_max_av_pkt_sz[1];
	uint32_t _rese_max_av_pkt_sz;
} BCM53101_A0_RESE_MAX_AV_PKT_SZr_t;

#define BCM53101_A0_RESE_MAX_AV_PKT_SZr_CLR(r) (r).rese_max_av_pkt_sz[0] = 0
#define BCM53101_A0_RESE_MAX_AV_PKT_SZr_SET(r,d) (r).rese_max_av_pkt_sz[0] = d
#define BCM53101_A0_RESE_MAX_AV_PKT_SZr_GET(r) (r).rese_max_av_pkt_sz[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_RESE_MAX_AV_PKT_SZr_MAX_AV_PKT_SZf_GET(r) (((r).rese_max_av_pkt_sz[0]) & 0xfff)
#define BCM53101_A0_RESE_MAX_AV_PKT_SZr_MAX_AV_PKT_SZf_SET(r,f) (r).rese_max_av_pkt_sz[0]=(((r).rese_max_av_pkt_sz[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff))
#define BCM53101_A0_RESE_MAX_AV_PKT_SZr_RESERVEDf_GET(r) ((((r).rese_max_av_pkt_sz[0]) >> 12) & 0xf)
#define BCM53101_A0_RESE_MAX_AV_PKT_SZr_RESERVEDf_SET(r,f) (r).rese_max_av_pkt_sz[0]=(((r).rese_max_av_pkt_sz[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access RESE_MAX_AV_PKT_SZ.
 *
 */
#define BCM53101_A0_READ_RESE_MAX_AV_PKT_SZr(u,r) cdk_robo_reg_read(u,BCM53101_A0_RESE_MAX_AV_PKT_SZr,(r._rese_max_av_pkt_sz),2)
#define BCM53101_A0_WRITE_RESE_MAX_AV_PKT_SZr(u,r) cdk_robo_reg_write(u,BCM53101_A0_RESE_MAX_AV_PKT_SZr,&(r._rese_max_av_pkt_sz),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RESE_MAX_AV_PKT_SZr BCM53101_A0_RESE_MAX_AV_PKT_SZr
#define RESE_MAX_AV_PKT_SZr_SIZE BCM53101_A0_RESE_MAX_AV_PKT_SZr_SIZE
typedef BCM53101_A0_RESE_MAX_AV_PKT_SZr_t RESE_MAX_AV_PKT_SZr_t;
#define RESE_MAX_AV_PKT_SZr_CLR BCM53101_A0_RESE_MAX_AV_PKT_SZr_CLR
#define RESE_MAX_AV_PKT_SZr_SET BCM53101_A0_RESE_MAX_AV_PKT_SZr_SET
#define RESE_MAX_AV_PKT_SZr_GET BCM53101_A0_RESE_MAX_AV_PKT_SZr_GET
#define RESE_MAX_AV_PKT_SZr_MAX_AV_PKT_SZf_GET BCM53101_A0_RESE_MAX_AV_PKT_SZr_MAX_AV_PKT_SZf_GET
#define RESE_MAX_AV_PKT_SZr_MAX_AV_PKT_SZf_SET BCM53101_A0_RESE_MAX_AV_PKT_SZr_MAX_AV_PKT_SZf_SET
#define RESE_MAX_AV_PKT_SZr_RESERVEDf_GET BCM53101_A0_RESE_MAX_AV_PKT_SZr_RESERVEDf_GET
#define RESE_MAX_AV_PKT_SZr_RESERVEDf_SET BCM53101_A0_RESE_MAX_AV_PKT_SZr_RESERVEDf_SET
#define READ_RESE_MAX_AV_PKT_SZr BCM53101_A0_READ_RESE_MAX_AV_PKT_SZr
#define WRITE_RESE_MAX_AV_PKT_SZr BCM53101_A0_WRITE_RESE_MAX_AV_PKT_SZr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RESE_MAX_AV_PKT_SZr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RESE_SLOT_ADJ
 * BLOCKS:   SYS
 * DESC:     ResE Slot Adjustment Register
 * SIZE:     32
 * FIELDS:
 *     SLOT_ADJ         Slot AdjustmentThis field defines when the Slot Number Counter increment by 1. 00: Slot Number increment by 1 when tick counter rolls over 312501:312610:312411: Reserved
 *     RESERVED_2       Reserved
 *     SLOT_ADJ_PRD     Slot Adjust PeriodThis field defines the number of Slots to apply the altered SlotAdjustment.
 *     RESERVED_1       Reserved
 *     MCRO_SLOT_PRD    Macro Slot PeriodThis field defines the slot time of a Macro slot for Class 4 traffic.00: 1 ms01: 2 ms10: 4 ms11: reservedClass 5 traffic slot time is always 125 us period.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_RESE_SLOT_ADJr 0x0000901c

#define BCM53101_A0_RESE_SLOT_ADJr_SIZE 4

/*
 * This structure should be used to declare and program RESE_SLOT_ADJ.
 *
 */
typedef union BCM53101_A0_RESE_SLOT_ADJr_s {
	uint32_t v[1];
	uint32_t rese_slot_adj[1];
	uint32_t _rese_slot_adj;
} BCM53101_A0_RESE_SLOT_ADJr_t;

#define BCM53101_A0_RESE_SLOT_ADJr_CLR(r) (r).rese_slot_adj[0] = 0
#define BCM53101_A0_RESE_SLOT_ADJr_SET(r,d) (r).rese_slot_adj[0] = d
#define BCM53101_A0_RESE_SLOT_ADJr_GET(r) (r).rese_slot_adj[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_RESE_SLOT_ADJr_SLOT_ADJf_GET(r) (((r).rese_slot_adj[0]) & 0x3)
#define BCM53101_A0_RESE_SLOT_ADJr_SLOT_ADJf_SET(r,f) (r).rese_slot_adj[0]=(((r).rese_slot_adj[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53101_A0_RESE_SLOT_ADJr_RESERVED_2f_GET(r) ((((r).rese_slot_adj[0]) >> 2) & 0x3f)
#define BCM53101_A0_RESE_SLOT_ADJr_RESERVED_2f_SET(r,f) (r).rese_slot_adj[0]=(((r).rese_slot_adj[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2))
#define BCM53101_A0_RESE_SLOT_ADJr_SLOT_ADJ_PRDf_GET(r) ((((r).rese_slot_adj[0]) >> 8) & 0xf)
#define BCM53101_A0_RESE_SLOT_ADJr_SLOT_ADJ_PRDf_SET(r,f) (r).rese_slot_adj[0]=(((r).rese_slot_adj[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53101_A0_RESE_SLOT_ADJr_RESERVED_1f_GET(r) ((((r).rese_slot_adj[0]) >> 12) & 0xf)
#define BCM53101_A0_RESE_SLOT_ADJr_RESERVED_1f_SET(r,f) (r).rese_slot_adj[0]=(((r).rese_slot_adj[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))
#define BCM53101_A0_RESE_SLOT_ADJr_MCRO_SLOT_PRDf_GET(r) ((((r).rese_slot_adj[0]) >> 16) & 0x3)
#define BCM53101_A0_RESE_SLOT_ADJr_MCRO_SLOT_PRDf_SET(r,f) (r).rese_slot_adj[0]=(((r).rese_slot_adj[0] & ~((uint32_t)0x3 << 16)) | ((((uint32_t)f) & 0x3) << 16))
#define BCM53101_A0_RESE_SLOT_ADJr_RESERVED_0f_GET(r) ((((r).rese_slot_adj[0]) >> 18) & 0x3fff)
#define BCM53101_A0_RESE_SLOT_ADJr_RESERVED_0f_SET(r,f) (r).rese_slot_adj[0]=(((r).rese_slot_adj[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access RESE_SLOT_ADJ.
 *
 */
#define BCM53101_A0_READ_RESE_SLOT_ADJr(u,r) cdk_robo_reg_read(u,BCM53101_A0_RESE_SLOT_ADJr,(r._rese_slot_adj),4)
#define BCM53101_A0_WRITE_RESE_SLOT_ADJr(u,r) cdk_robo_reg_write(u,BCM53101_A0_RESE_SLOT_ADJr,&(r._rese_slot_adj),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RESE_SLOT_ADJr BCM53101_A0_RESE_SLOT_ADJr
#define RESE_SLOT_ADJr_SIZE BCM53101_A0_RESE_SLOT_ADJr_SIZE
typedef BCM53101_A0_RESE_SLOT_ADJr_t RESE_SLOT_ADJr_t;
#define RESE_SLOT_ADJr_CLR BCM53101_A0_RESE_SLOT_ADJr_CLR
#define RESE_SLOT_ADJr_SET BCM53101_A0_RESE_SLOT_ADJr_SET
#define RESE_SLOT_ADJr_GET BCM53101_A0_RESE_SLOT_ADJr_GET
#define RESE_SLOT_ADJr_SLOT_ADJf_GET BCM53101_A0_RESE_SLOT_ADJr_SLOT_ADJf_GET
#define RESE_SLOT_ADJr_SLOT_ADJf_SET BCM53101_A0_RESE_SLOT_ADJr_SLOT_ADJf_SET
#define RESE_SLOT_ADJr_RESERVED_2f_GET BCM53101_A0_RESE_SLOT_ADJr_RESERVED_2f_GET
#define RESE_SLOT_ADJr_RESERVED_2f_SET BCM53101_A0_RESE_SLOT_ADJr_RESERVED_2f_SET
#define RESE_SLOT_ADJr_SLOT_ADJ_PRDf_GET BCM53101_A0_RESE_SLOT_ADJr_SLOT_ADJ_PRDf_GET
#define RESE_SLOT_ADJr_SLOT_ADJ_PRDf_SET BCM53101_A0_RESE_SLOT_ADJr_SLOT_ADJ_PRDf_SET
#define RESE_SLOT_ADJr_RESERVED_1f_GET BCM53101_A0_RESE_SLOT_ADJr_RESERVED_1f_GET
#define RESE_SLOT_ADJr_RESERVED_1f_SET BCM53101_A0_RESE_SLOT_ADJr_RESERVED_1f_SET
#define RESE_SLOT_ADJr_MCRO_SLOT_PRDf_GET BCM53101_A0_RESE_SLOT_ADJr_MCRO_SLOT_PRDf_GET
#define RESE_SLOT_ADJr_MCRO_SLOT_PRDf_SET BCM53101_A0_RESE_SLOT_ADJr_MCRO_SLOT_PRDf_SET
#define RESE_SLOT_ADJr_RESERVED_0f_GET BCM53101_A0_RESE_SLOT_ADJr_RESERVED_0f_GET
#define RESE_SLOT_ADJr_RESERVED_0f_SET BCM53101_A0_RESE_SLOT_ADJr_RESERVED_0f_SET
#define READ_RESE_SLOT_ADJr BCM53101_A0_READ_RESE_SLOT_ADJr
#define WRITE_RESE_SLOT_ADJr BCM53101_A0_WRITE_RESE_SLOT_ADJr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RESE_SLOT_ADJr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RESE_SLOT_TICK_CNTR
 * BLOCKS:   SYS
 * DESC:     ResE Slot Number and Tick Counter Register
 * SIZE:     32
 * FIELDS:
 *     SLOT_NUM         Slot NumberThis field specifies the Slot Number for ResE.
 *     RESERVED_1       Reserved
 *     TICK_CNTR        Tick CounterThis is the tick counter which defines when will Slot Number increment. It runs from 1 to 3125 (or 3124, or 3126, depends on Slot Adjustment register setting) under 25MHz.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_RESE_SLOT_TICK_CNTRr 0x00009018

#define BCM53101_A0_RESE_SLOT_TICK_CNTRr_SIZE 4

/*
 * This structure should be used to declare and program RESE_SLOT_TICK_CNTR.
 *
 */
typedef union BCM53101_A0_RESE_SLOT_TICK_CNTRr_s {
	uint32_t v[1];
	uint32_t rese_slot_tick_cntr[1];
	uint32_t _rese_slot_tick_cntr;
} BCM53101_A0_RESE_SLOT_TICK_CNTRr_t;

#define BCM53101_A0_RESE_SLOT_TICK_CNTRr_CLR(r) (r).rese_slot_tick_cntr[0] = 0
#define BCM53101_A0_RESE_SLOT_TICK_CNTRr_SET(r,d) (r).rese_slot_tick_cntr[0] = d
#define BCM53101_A0_RESE_SLOT_TICK_CNTRr_GET(r) (r).rese_slot_tick_cntr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_RESE_SLOT_TICK_CNTRr_SLOT_NUMf_GET(r) (((r).rese_slot_tick_cntr[0]) & 0x1f)
#define BCM53101_A0_RESE_SLOT_TICK_CNTRr_SLOT_NUMf_SET(r,f) (r).rese_slot_tick_cntr[0]=(((r).rese_slot_tick_cntr[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f))
#define BCM53101_A0_RESE_SLOT_TICK_CNTRr_RESERVED_1f_GET(r) ((((r).rese_slot_tick_cntr[0]) >> 5) & 0x7ff)
#define BCM53101_A0_RESE_SLOT_TICK_CNTRr_RESERVED_1f_SET(r,f) (r).rese_slot_tick_cntr[0]=(((r).rese_slot_tick_cntr[0] & ~((uint32_t)0x7ff << 5)) | ((((uint32_t)f) & 0x7ff) << 5))
#define BCM53101_A0_RESE_SLOT_TICK_CNTRr_TICK_CNTRf_GET(r) ((((r).rese_slot_tick_cntr[0]) >> 16) & 0xfff)
#define BCM53101_A0_RESE_SLOT_TICK_CNTRr_TICK_CNTRf_SET(r,f) (r).rese_slot_tick_cntr[0]=(((r).rese_slot_tick_cntr[0] & ~((uint32_t)0xfff << 16)) | ((((uint32_t)f) & 0xfff) << 16))
#define BCM53101_A0_RESE_SLOT_TICK_CNTRr_RESERVED_0f_GET(r) ((((r).rese_slot_tick_cntr[0]) >> 28) & 0xf)
#define BCM53101_A0_RESE_SLOT_TICK_CNTRr_RESERVED_0f_SET(r,f) (r).rese_slot_tick_cntr[0]=(((r).rese_slot_tick_cntr[0] & ~((uint32_t)0xf << 28)) | ((((uint32_t)f) & 0xf) << 28))

/*
 * These macros can be used to access RESE_SLOT_TICK_CNTR.
 *
 */
#define BCM53101_A0_READ_RESE_SLOT_TICK_CNTRr(u,r) cdk_robo_reg_read(u,BCM53101_A0_RESE_SLOT_TICK_CNTRr,(r._rese_slot_tick_cntr),4)
#define BCM53101_A0_WRITE_RESE_SLOT_TICK_CNTRr(u,r) cdk_robo_reg_write(u,BCM53101_A0_RESE_SLOT_TICK_CNTRr,&(r._rese_slot_tick_cntr),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RESE_SLOT_TICK_CNTRr BCM53101_A0_RESE_SLOT_TICK_CNTRr
#define RESE_SLOT_TICK_CNTRr_SIZE BCM53101_A0_RESE_SLOT_TICK_CNTRr_SIZE
typedef BCM53101_A0_RESE_SLOT_TICK_CNTRr_t RESE_SLOT_TICK_CNTRr_t;
#define RESE_SLOT_TICK_CNTRr_CLR BCM53101_A0_RESE_SLOT_TICK_CNTRr_CLR
#define RESE_SLOT_TICK_CNTRr_SET BCM53101_A0_RESE_SLOT_TICK_CNTRr_SET
#define RESE_SLOT_TICK_CNTRr_GET BCM53101_A0_RESE_SLOT_TICK_CNTRr_GET
#define RESE_SLOT_TICK_CNTRr_SLOT_NUMf_GET BCM53101_A0_RESE_SLOT_TICK_CNTRr_SLOT_NUMf_GET
#define RESE_SLOT_TICK_CNTRr_SLOT_NUMf_SET BCM53101_A0_RESE_SLOT_TICK_CNTRr_SLOT_NUMf_SET
#define RESE_SLOT_TICK_CNTRr_RESERVED_1f_GET BCM53101_A0_RESE_SLOT_TICK_CNTRr_RESERVED_1f_GET
#define RESE_SLOT_TICK_CNTRr_RESERVED_1f_SET BCM53101_A0_RESE_SLOT_TICK_CNTRr_RESERVED_1f_SET
#define RESE_SLOT_TICK_CNTRr_TICK_CNTRf_GET BCM53101_A0_RESE_SLOT_TICK_CNTRr_TICK_CNTRf_GET
#define RESE_SLOT_TICK_CNTRr_TICK_CNTRf_SET BCM53101_A0_RESE_SLOT_TICK_CNTRr_TICK_CNTRf_SET
#define RESE_SLOT_TICK_CNTRr_RESERVED_0f_GET BCM53101_A0_RESE_SLOT_TICK_CNTRr_RESERVED_0f_GET
#define RESE_SLOT_TICK_CNTRr_RESERVED_0f_SET BCM53101_A0_RESE_SLOT_TICK_CNTRr_RESERVED_0f_SET
#define READ_RESE_SLOT_TICK_CNTRr BCM53101_A0_READ_RESE_SLOT_TICK_CNTRr
#define WRITE_RESE_SLOT_TICK_CNTRr BCM53101_A0_WRITE_RESE_SLOT_TICK_CNTRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RESE_SLOT_TICK_CNTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RESE_TM_ADJ
 * BLOCKS:   SYS
 * DESC:     ResE Time Base Adjustment Register
 * SIZE:     32
 * FIELDS:
 *     TM_INC           Time IncrementThis field defines the value to add into Time Base in each 25Mhz tick. Default is 40.
 *     RESERVED_1       Reserved
 *     TM_ADJ_PRD       Time Adjust PeriodThis field defines the tick numbers to apply the adjusted Time Increment (when Time Increment does not equal to 40). For example, increment the Time Base 41 for 10 ticks. In this case, Time Adjust Period is 10, and Time Increment is 41.
 *     RESERVED_0       Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_RESE_TM_ADJr 0x00009014

#define BCM53101_A0_RESE_TM_ADJr_SIZE 4

/*
 * This structure should be used to declare and program RESE_TM_ADJ.
 *
 */
typedef union BCM53101_A0_RESE_TM_ADJr_s {
	uint32_t v[1];
	uint32_t rese_tm_adj[1];
	uint32_t _rese_tm_adj;
} BCM53101_A0_RESE_TM_ADJr_t;

#define BCM53101_A0_RESE_TM_ADJr_CLR(r) (r).rese_tm_adj[0] = 0
#define BCM53101_A0_RESE_TM_ADJr_SET(r,d) (r).rese_tm_adj[0] = d
#define BCM53101_A0_RESE_TM_ADJr_GET(r) (r).rese_tm_adj[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_RESE_TM_ADJr_TM_INCf_GET(r) (((r).rese_tm_adj[0]) & 0x3f)
#define BCM53101_A0_RESE_TM_ADJr_TM_INCf_SET(r,f) (r).rese_tm_adj[0]=(((r).rese_tm_adj[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53101_A0_RESE_TM_ADJr_RESERVED_1f_GET(r) ((((r).rese_tm_adj[0]) >> 6) & 0x3)
#define BCM53101_A0_RESE_TM_ADJr_RESERVED_1f_SET(r,f) (r).rese_tm_adj[0]=(((r).rese_tm_adj[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53101_A0_RESE_TM_ADJr_TM_ADJ_PRDf_GET(r) ((((r).rese_tm_adj[0]) >> 8) & 0xf)
#define BCM53101_A0_RESE_TM_ADJr_TM_ADJ_PRDf_SET(r,f) (r).rese_tm_adj[0]=(((r).rese_tm_adj[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8))
#define BCM53101_A0_RESE_TM_ADJr_RESERVED_0f_GET(r) ((((r).rese_tm_adj[0]) >> 12) & 0xfffff)
#define BCM53101_A0_RESE_TM_ADJr_RESERVED_0f_SET(r,f) (r).rese_tm_adj[0]=(((r).rese_tm_adj[0] & ~((uint32_t)0xfffff << 12)) | ((((uint32_t)f) & 0xfffff) << 12))

/*
 * These macros can be used to access RESE_TM_ADJ.
 *
 */
#define BCM53101_A0_READ_RESE_TM_ADJr(u,r) cdk_robo_reg_read(u,BCM53101_A0_RESE_TM_ADJr,(r._rese_tm_adj),4)
#define BCM53101_A0_WRITE_RESE_TM_ADJr(u,r) cdk_robo_reg_write(u,BCM53101_A0_RESE_TM_ADJr,&(r._rese_tm_adj),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RESE_TM_ADJr BCM53101_A0_RESE_TM_ADJr
#define RESE_TM_ADJr_SIZE BCM53101_A0_RESE_TM_ADJr_SIZE
typedef BCM53101_A0_RESE_TM_ADJr_t RESE_TM_ADJr_t;
#define RESE_TM_ADJr_CLR BCM53101_A0_RESE_TM_ADJr_CLR
#define RESE_TM_ADJr_SET BCM53101_A0_RESE_TM_ADJr_SET
#define RESE_TM_ADJr_GET BCM53101_A0_RESE_TM_ADJr_GET
#define RESE_TM_ADJr_TM_INCf_GET BCM53101_A0_RESE_TM_ADJr_TM_INCf_GET
#define RESE_TM_ADJr_TM_INCf_SET BCM53101_A0_RESE_TM_ADJr_TM_INCf_SET
#define RESE_TM_ADJr_RESERVED_1f_GET BCM53101_A0_RESE_TM_ADJr_RESERVED_1f_GET
#define RESE_TM_ADJr_RESERVED_1f_SET BCM53101_A0_RESE_TM_ADJr_RESERVED_1f_SET
#define RESE_TM_ADJr_TM_ADJ_PRDf_GET BCM53101_A0_RESE_TM_ADJr_TM_ADJ_PRDf_GET
#define RESE_TM_ADJr_TM_ADJ_PRDf_SET BCM53101_A0_RESE_TM_ADJr_TM_ADJ_PRDf_SET
#define RESE_TM_ADJr_RESERVED_0f_GET BCM53101_A0_RESE_TM_ADJr_RESERVED_0f_GET
#define RESE_TM_ADJr_RESERVED_0f_SET BCM53101_A0_RESE_TM_ADJr_RESERVED_0f_SET
#define READ_RESE_TM_ADJr BCM53101_A0_READ_RESE_TM_ADJr
#define WRITE_RESE_TM_ADJr BCM53101_A0_WRITE_RESE_TM_ADJr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RESE_TM_ADJr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RESE_TM_BASE
 * BLOCKS:   SYS
 * DESC:     ResE Time Base Register
 * SIZE:     32
 * FIELDS:
 *     TM_BASE          Time BaseThis is 32-bit free running clock (running in 25MHz) for ResE time base. Ingress port and Egress port use it for Time Synchronization Packet Time Stamp.
 *
 ******************************************************************************/
#define BCM53101_A0_RESE_TM_BASEr 0x00009010

#define BCM53101_A0_RESE_TM_BASEr_SIZE 4

/*
 * This structure should be used to declare and program RESE_TM_BASE.
 *
 */
typedef union BCM53101_A0_RESE_TM_BASEr_s {
	uint32_t v[1];
	uint32_t rese_tm_base[1];
	uint32_t _rese_tm_base;
} BCM53101_A0_RESE_TM_BASEr_t;

#define BCM53101_A0_RESE_TM_BASEr_CLR(r) (r).rese_tm_base[0] = 0
#define BCM53101_A0_RESE_TM_BASEr_SET(r,d) (r).rese_tm_base[0] = d
#define BCM53101_A0_RESE_TM_BASEr_GET(r) (r).rese_tm_base[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_RESE_TM_BASEr_TM_BASEf_GET(r) ((r).rese_tm_base[0])
#define BCM53101_A0_RESE_TM_BASEr_TM_BASEf_SET(r,f) (r).rese_tm_base[0]=((uint32_t)f)

/*
 * These macros can be used to access RESE_TM_BASE.
 *
 */
#define BCM53101_A0_READ_RESE_TM_BASEr(u,r) cdk_robo_reg_read(u,BCM53101_A0_RESE_TM_BASEr,(r._rese_tm_base),4)
#define BCM53101_A0_WRITE_RESE_TM_BASEr(u,r) cdk_robo_reg_write(u,BCM53101_A0_RESE_TM_BASEr,&(r._rese_tm_base),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RESE_TM_BASEr BCM53101_A0_RESE_TM_BASEr
#define RESE_TM_BASEr_SIZE BCM53101_A0_RESE_TM_BASEr_SIZE
typedef BCM53101_A0_RESE_TM_BASEr_t RESE_TM_BASEr_t;
#define RESE_TM_BASEr_CLR BCM53101_A0_RESE_TM_BASEr_CLR
#define RESE_TM_BASEr_SET BCM53101_A0_RESE_TM_BASEr_SET
#define RESE_TM_BASEr_GET BCM53101_A0_RESE_TM_BASEr_GET
#define RESE_TM_BASEr_TM_BASEf_GET BCM53101_A0_RESE_TM_BASEr_TM_BASEf_GET
#define RESE_TM_BASEr_TM_BASEf_SET BCM53101_A0_RESE_TM_BASEr_TM_BASEf_SET
#define READ_RESE_TM_BASEr BCM53101_A0_READ_RESE_TM_BASEr
#define WRITE_RESE_TM_BASEr BCM53101_A0_WRITE_RESE_TM_BASEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RESE_TM_BASEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RMONSTEER
 * BLOCKS:   SYS
 * DESC:     RMON MIB Steering Register
 * SIZE:     16
 * FIELDS:
 *     OR_RMON_RCV      Override RMON Receive.Forces the RMON packet size bucket counters from the normal default of snooping on the receive side of the MAC, to the transmit side. This allows the RMON bucket counters to snoop either transmit or receive, allowing full duplex MAC support.Bit 0-5: Port0-5Bit 8: Port 8(IMP port)
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_RMONSTEERr 0x00000204

#define BCM53101_A0_RMONSTEERr_SIZE 2

/*
 * This structure should be used to declare and program RMONSTEER.
 *
 */
typedef union BCM53101_A0_RMONSTEERr_s {
	uint32_t v[1];
	uint32_t rmonsteer[1];
	uint32_t _rmonsteer;
} BCM53101_A0_RMONSTEERr_t;

#define BCM53101_A0_RMONSTEERr_CLR(r) (r).rmonsteer[0] = 0
#define BCM53101_A0_RMONSTEERr_SET(r,d) (r).rmonsteer[0] = d
#define BCM53101_A0_RMONSTEERr_GET(r) (r).rmonsteer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_RMONSTEERr_OR_RMON_RCVf_GET(r) (((r).rmonsteer[0]) & 0x1ff)
#define BCM53101_A0_RMONSTEERr_OR_RMON_RCVf_SET(r,f) (r).rmonsteer[0]=(((r).rmonsteer[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_RMONSTEERr_RESERVEDf_GET(r) ((((r).rmonsteer[0]) >> 9) & 0x7f)
#define BCM53101_A0_RMONSTEERr_RESERVEDf_SET(r,f) (r).rmonsteer[0]=(((r).rmonsteer[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access RMONSTEER.
 *
 */
#define BCM53101_A0_READ_RMONSTEERr(u,r) cdk_robo_reg_read(u,BCM53101_A0_RMONSTEERr,(r._rmonsteer),2)
#define BCM53101_A0_WRITE_RMONSTEERr(u,r) cdk_robo_reg_write(u,BCM53101_A0_RMONSTEERr,&(r._rmonsteer),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RMONSTEERr BCM53101_A0_RMONSTEERr
#define RMONSTEERr_SIZE BCM53101_A0_RMONSTEERr_SIZE
typedef BCM53101_A0_RMONSTEERr_t RMONSTEERr_t;
#define RMONSTEERr_CLR BCM53101_A0_RMONSTEERr_CLR
#define RMONSTEERr_SET BCM53101_A0_RMONSTEERr_SET
#define RMONSTEERr_GET BCM53101_A0_RMONSTEERr_GET
#define RMONSTEERr_OR_RMON_RCVf_GET BCM53101_A0_RMONSTEERr_OR_RMON_RCVf_GET
#define RMONSTEERr_OR_RMON_RCVf_SET BCM53101_A0_RMONSTEERr_OR_RMON_RCVf_SET
#define RMONSTEERr_RESERVEDf_GET BCM53101_A0_RMONSTEERr_RESERVEDf_GET
#define RMONSTEERr_RESERVEDf_SET BCM53101_A0_RMONSTEERr_RESERVEDf_SET
#define READ_RMONSTEERr BCM53101_A0_READ_RMONSTEERr
#define WRITE_RMONSTEERr BCM53101_A0_WRITE_RMONSTEERr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RMONSTEERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RSV_MCAST_CTRL
 * BLOCKS:   SYS
 * DESC:     Reserved Multicast Register
 * SIZE:     8
 * FIELDS:
 *     EN_MUL_0         bit[0] :01-80-C2-00-00-00.(Can be set in Unmanaged mode only)0: Forward (default).1: Drop.
 *     EN_MUL_1         bit[1] :01-80-C2-00-00-02 ~ 01-80-C2-00-00-0F.(Can be set in Unmanaged mode only)0: Forward1: Drop (default)
 *     EN_MUL_2         bit[2] :01-80-C2-00-00-10.(Can be set in Unmanaged mode only)0: Forward (default).1: Drop.
 *     EN_MUL_3         bit[3] :01-80-C2-00-00-11 ~ 01-80-C2-00-00-1F.(Can be set in Unmanaged mode only)0: Forward (default).1: Drop.
 *     EN_MUL_4         bit[4] :01-80-C2-00-00-20 ~ 01-80-C2-00-00-2F.(Can be set in Unmanaged mode only)0: Forward (default).1: Drop.
 *     RESERVED         Reserved
 *     EN_RES_MUL_LEARN bit[7] : en_reserved_McastDA_learn.(Can be set in Unmanaged mode only)0: Don't learn (default )1: Learn
 *
 ******************************************************************************/
#define BCM53101_A0_RSV_MCAST_CTRLr 0x0000002f

#define BCM53101_A0_RSV_MCAST_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program RSV_MCAST_CTRL.
 *
 */
typedef union BCM53101_A0_RSV_MCAST_CTRLr_s {
	uint32_t v[1];
	uint32_t rsv_mcast_ctrl[1];
	uint32_t _rsv_mcast_ctrl;
} BCM53101_A0_RSV_MCAST_CTRLr_t;

#define BCM53101_A0_RSV_MCAST_CTRLr_CLR(r) (r).rsv_mcast_ctrl[0] = 0
#define BCM53101_A0_RSV_MCAST_CTRLr_SET(r,d) (r).rsv_mcast_ctrl[0] = d
#define BCM53101_A0_RSV_MCAST_CTRLr_GET(r) (r).rsv_mcast_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_RSV_MCAST_CTRLr_EN_MUL_0f_GET(r) (((r).rsv_mcast_ctrl[0]) & 0x1)
#define BCM53101_A0_RSV_MCAST_CTRLr_EN_MUL_0f_SET(r,f) (r).rsv_mcast_ctrl[0]=(((r).rsv_mcast_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_RSV_MCAST_CTRLr_EN_MUL_1f_GET(r) ((((r).rsv_mcast_ctrl[0]) >> 1) & 0x1)
#define BCM53101_A0_RSV_MCAST_CTRLr_EN_MUL_1f_SET(r,f) (r).rsv_mcast_ctrl[0]=(((r).rsv_mcast_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_RSV_MCAST_CTRLr_EN_MUL_2f_GET(r) ((((r).rsv_mcast_ctrl[0]) >> 2) & 0x1)
#define BCM53101_A0_RSV_MCAST_CTRLr_EN_MUL_2f_SET(r,f) (r).rsv_mcast_ctrl[0]=(((r).rsv_mcast_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_RSV_MCAST_CTRLr_EN_MUL_3f_GET(r) ((((r).rsv_mcast_ctrl[0]) >> 3) & 0x1)
#define BCM53101_A0_RSV_MCAST_CTRLr_EN_MUL_3f_SET(r,f) (r).rsv_mcast_ctrl[0]=(((r).rsv_mcast_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_RSV_MCAST_CTRLr_EN_MUL_4f_GET(r) ((((r).rsv_mcast_ctrl[0]) >> 4) & 0x1)
#define BCM53101_A0_RSV_MCAST_CTRLr_EN_MUL_4f_SET(r,f) (r).rsv_mcast_ctrl[0]=(((r).rsv_mcast_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_RSV_MCAST_CTRLr_RESERVEDf_GET(r) ((((r).rsv_mcast_ctrl[0]) >> 5) & 0x3)
#define BCM53101_A0_RSV_MCAST_CTRLr_RESERVEDf_SET(r,f) (r).rsv_mcast_ctrl[0]=(((r).rsv_mcast_ctrl[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM53101_A0_RSV_MCAST_CTRLr_EN_RES_MUL_LEARNf_GET(r) ((((r).rsv_mcast_ctrl[0]) >> 7) & 0x1)
#define BCM53101_A0_RSV_MCAST_CTRLr_EN_RES_MUL_LEARNf_SET(r,f) (r).rsv_mcast_ctrl[0]=(((r).rsv_mcast_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access RSV_MCAST_CTRL.
 *
 */
#define BCM53101_A0_READ_RSV_MCAST_CTRLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_RSV_MCAST_CTRLr,(r._rsv_mcast_ctrl),1)
#define BCM53101_A0_WRITE_RSV_MCAST_CTRLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_RSV_MCAST_CTRLr,&(r._rsv_mcast_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RSV_MCAST_CTRLr BCM53101_A0_RSV_MCAST_CTRLr
#define RSV_MCAST_CTRLr_SIZE BCM53101_A0_RSV_MCAST_CTRLr_SIZE
typedef BCM53101_A0_RSV_MCAST_CTRLr_t RSV_MCAST_CTRLr_t;
#define RSV_MCAST_CTRLr_CLR BCM53101_A0_RSV_MCAST_CTRLr_CLR
#define RSV_MCAST_CTRLr_SET BCM53101_A0_RSV_MCAST_CTRLr_SET
#define RSV_MCAST_CTRLr_GET BCM53101_A0_RSV_MCAST_CTRLr_GET
#define RSV_MCAST_CTRLr_EN_MUL_0f_GET BCM53101_A0_RSV_MCAST_CTRLr_EN_MUL_0f_GET
#define RSV_MCAST_CTRLr_EN_MUL_0f_SET BCM53101_A0_RSV_MCAST_CTRLr_EN_MUL_0f_SET
#define RSV_MCAST_CTRLr_EN_MUL_1f_GET BCM53101_A0_RSV_MCAST_CTRLr_EN_MUL_1f_GET
#define RSV_MCAST_CTRLr_EN_MUL_1f_SET BCM53101_A0_RSV_MCAST_CTRLr_EN_MUL_1f_SET
#define RSV_MCAST_CTRLr_EN_MUL_2f_GET BCM53101_A0_RSV_MCAST_CTRLr_EN_MUL_2f_GET
#define RSV_MCAST_CTRLr_EN_MUL_2f_SET BCM53101_A0_RSV_MCAST_CTRLr_EN_MUL_2f_SET
#define RSV_MCAST_CTRLr_EN_MUL_3f_GET BCM53101_A0_RSV_MCAST_CTRLr_EN_MUL_3f_GET
#define RSV_MCAST_CTRLr_EN_MUL_3f_SET BCM53101_A0_RSV_MCAST_CTRLr_EN_MUL_3f_SET
#define RSV_MCAST_CTRLr_EN_MUL_4f_GET BCM53101_A0_RSV_MCAST_CTRLr_EN_MUL_4f_GET
#define RSV_MCAST_CTRLr_EN_MUL_4f_SET BCM53101_A0_RSV_MCAST_CTRLr_EN_MUL_4f_SET
#define RSV_MCAST_CTRLr_RESERVEDf_GET BCM53101_A0_RSV_MCAST_CTRLr_RESERVEDf_GET
#define RSV_MCAST_CTRLr_RESERVEDf_SET BCM53101_A0_RSV_MCAST_CTRLr_RESERVEDf_SET
#define RSV_MCAST_CTRLr_EN_RES_MUL_LEARNf_GET BCM53101_A0_RSV_MCAST_CTRLr_EN_RES_MUL_LEARNf_GET
#define RSV_MCAST_CTRLr_EN_RES_MUL_LEARNf_SET BCM53101_A0_RSV_MCAST_CTRLr_EN_RES_MUL_LEARNf_SET
#define READ_RSV_MCAST_CTRLr BCM53101_A0_READ_RSV_MCAST_CTRLr
#define WRITE_RSV_MCAST_CTRLr BCM53101_A0_WRITE_RSV_MCAST_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RSV_MCAST_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RXDISCARD
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Rx Discard Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_RXDISCARDr 0x000020c0

#define BCM53101_A0_RXDISCARDr_SIZE 4

/*
 * This structure should be used to declare and program RXDISCARD.
 *
 */
typedef union BCM53101_A0_RXDISCARDr_s {
	uint32_t v[1];
	uint32_t rxdiscard[1];
	uint32_t _rxdiscard;
} BCM53101_A0_RXDISCARDr_t;

#define BCM53101_A0_RXDISCARDr_CLR(r) (r).rxdiscard[0] = 0
#define BCM53101_A0_RXDISCARDr_SET(r,d) (r).rxdiscard[0] = d
#define BCM53101_A0_RXDISCARDr_GET(r) (r).rxdiscard[0]


/*
 * These macros can be used to access RXDISCARD.
 *
 */
#define BCM53101_A0_READ_RXDISCARDr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_RXDISCARDr,(r._rxdiscard),4)
#define BCM53101_A0_WRITE_RXDISCARDr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_RXDISCARDr,&(r._rxdiscard),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXDISCARDr BCM53101_A0_RXDISCARDr
#define RXDISCARDr_SIZE BCM53101_A0_RXDISCARDr_SIZE
typedef BCM53101_A0_RXDISCARDr_t RXDISCARDr_t;
#define RXDISCARDr_CLR BCM53101_A0_RXDISCARDr_CLR
#define RXDISCARDr_SET BCM53101_A0_RXDISCARDr_SET
#define RXDISCARDr_GET BCM53101_A0_RXDISCARDr_GET
#define READ_RXDISCARDr BCM53101_A0_READ_RXDISCARDr
#define WRITE_RXDISCARDr BCM53101_A0_WRITE_RXDISCARDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RXDISCARDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RXDISCARD_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Discard Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_RXDISCARD_IMPr 0x000028c0

#define BCM53101_A0_RXDISCARD_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RXDISCARD_IMP.
 *
 */
typedef union BCM53101_A0_RXDISCARD_IMPr_s {
	uint32_t v[1];
	uint32_t rxdiscard_imp[1];
	uint32_t _rxdiscard_imp;
} BCM53101_A0_RXDISCARD_IMPr_t;

#define BCM53101_A0_RXDISCARD_IMPr_CLR(r) (r).rxdiscard_imp[0] = 0
#define BCM53101_A0_RXDISCARD_IMPr_SET(r,d) (r).rxdiscard_imp[0] = d
#define BCM53101_A0_RXDISCARD_IMPr_GET(r) (r).rxdiscard_imp[0]


/*
 * These macros can be used to access RXDISCARD_IMP.
 *
 */
#define BCM53101_A0_READ_RXDISCARD_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_RXDISCARD_IMPr,(r._rxdiscard_imp),4)
#define BCM53101_A0_WRITE_RXDISCARD_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_RXDISCARD_IMPr,&(r._rxdiscard_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXDISCARD_IMPr BCM53101_A0_RXDISCARD_IMPr
#define RXDISCARD_IMPr_SIZE BCM53101_A0_RXDISCARD_IMPr_SIZE
typedef BCM53101_A0_RXDISCARD_IMPr_t RXDISCARD_IMPr_t;
#define RXDISCARD_IMPr_CLR BCM53101_A0_RXDISCARD_IMPr_CLR
#define RXDISCARD_IMPr_SET BCM53101_A0_RXDISCARD_IMPr_SET
#define RXDISCARD_IMPr_GET BCM53101_A0_RXDISCARD_IMPr_GET
#define READ_RXDISCARD_IMPr BCM53101_A0_READ_RXDISCARD_IMPr
#define WRITE_RXDISCARD_IMPr BCM53101_A0_WRITE_RXDISCARD_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RXDISCARD_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RXSymblErr
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Rx Symbol Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_RXSYMBLERRr 0x000020ac

#define BCM53101_A0_RXSYMBLERRr_SIZE 4

/*
 * This structure should be used to declare and program RXSymblErr.
 *
 */
typedef union BCM53101_A0_RXSYMBLERRr_s {
	uint32_t v[1];
	uint32_t rxsymblerr[1];
	uint32_t _rxsymblerr;
} BCM53101_A0_RXSYMBLERRr_t;

#define BCM53101_A0_RXSYMBLERRr_CLR(r) (r).rxsymblerr[0] = 0
#define BCM53101_A0_RXSYMBLERRr_SET(r,d) (r).rxsymblerr[0] = d
#define BCM53101_A0_RXSYMBLERRr_GET(r) (r).rxsymblerr[0]


/*
 * These macros can be used to access RXSymblErr.
 *
 */
#define BCM53101_A0_READ_RXSYMBLERRr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_RXSYMBLERRr,(r._rxsymblerr),4)
#define BCM53101_A0_WRITE_RXSYMBLERRr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_RXSYMBLERRr,&(r._rxsymblerr),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXSYMBLERRr BCM53101_A0_RXSYMBLERRr
#define RXSYMBLERRr_SIZE BCM53101_A0_RXSYMBLERRr_SIZE
typedef BCM53101_A0_RXSYMBLERRr_t RXSYMBLERRr_t;
#define RXSYMBLERRr_CLR BCM53101_A0_RXSYMBLERRr_CLR
#define RXSYMBLERRr_SET BCM53101_A0_RXSYMBLERRr_SET
#define RXSYMBLERRr_GET BCM53101_A0_RXSYMBLERRr_GET
#define READ_RXSYMBLERRr BCM53101_A0_READ_RXSYMBLERRr
#define WRITE_RXSYMBLERRr BCM53101_A0_WRITE_RXSYMBLERRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RXSYMBLERRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RXSymblErr_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Symbol Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_RXSYMBLERR_IMPr 0x000028ac

#define BCM53101_A0_RXSYMBLERR_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RXSymblErr_IMP.
 *
 */
typedef union BCM53101_A0_RXSYMBLERR_IMPr_s {
	uint32_t v[1];
	uint32_t rxsymblerr_imp[1];
	uint32_t _rxsymblerr_imp;
} BCM53101_A0_RXSYMBLERR_IMPr_t;

#define BCM53101_A0_RXSYMBLERR_IMPr_CLR(r) (r).rxsymblerr_imp[0] = 0
#define BCM53101_A0_RXSYMBLERR_IMPr_SET(r,d) (r).rxsymblerr_imp[0] = d
#define BCM53101_A0_RXSYMBLERR_IMPr_GET(r) (r).rxsymblerr_imp[0]


/*
 * These macros can be used to access RXSymblErr_IMP.
 *
 */
#define BCM53101_A0_READ_RXSYMBLERR_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_RXSYMBLERR_IMPr,(r._rxsymblerr_imp),4)
#define BCM53101_A0_WRITE_RXSYMBLERR_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_RXSYMBLERR_IMPr,&(r._rxsymblerr_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXSYMBLERR_IMPr BCM53101_A0_RXSYMBLERR_IMPr
#define RXSYMBLERR_IMPr_SIZE BCM53101_A0_RXSYMBLERR_IMPr_SIZE
typedef BCM53101_A0_RXSYMBLERR_IMPr_t RXSYMBLERR_IMPr_t;
#define RXSYMBLERR_IMPr_CLR BCM53101_A0_RXSYMBLERR_IMPr_CLR
#define RXSYMBLERR_IMPr_SET BCM53101_A0_RXSYMBLERR_IMPr_SET
#define RXSYMBLERR_IMPr_GET BCM53101_A0_RXSYMBLERR_IMPr_GET
#define READ_RXSYMBLERR_IMPr BCM53101_A0_READ_RXSYMBLERR_IMPr
#define WRITE_RXSYMBLERR_IMPr BCM53101_A0_WRITE_RXSYMBLERR_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RXSYMBLERR_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RX_GLOBAL_CTL
 * BLOCKS:   SYS
 * DESC:     RX Global Control register
 * SIZE:     8
 * FIELDS:
 *     FMOK_LATENCY_CNT fmok latency counter.
 *     DIS_CRC_CHK      Disable Ingress CRC check.
 *     DIS_ECC_CHK      Disable ECC check for all SRAM which implement the ECC, except Buffer Tag and TXQ.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_RX_GLOBAL_CTLr 0x0000000a

#define BCM53101_A0_RX_GLOBAL_CTLr_SIZE 1

/*
 * This structure should be used to declare and program RX_GLOBAL_CTL.
 *
 */
typedef union BCM53101_A0_RX_GLOBAL_CTLr_s {
	uint32_t v[1];
	uint32_t rx_global_ctl[1];
	uint32_t _rx_global_ctl;
} BCM53101_A0_RX_GLOBAL_CTLr_t;

#define BCM53101_A0_RX_GLOBAL_CTLr_CLR(r) (r).rx_global_ctl[0] = 0
#define BCM53101_A0_RX_GLOBAL_CTLr_SET(r,d) (r).rx_global_ctl[0] = d
#define BCM53101_A0_RX_GLOBAL_CTLr_GET(r) (r).rx_global_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_RX_GLOBAL_CTLr_FMOK_LATENCY_CNTf_GET(r) (((r).rx_global_ctl[0]) & 0xf)
#define BCM53101_A0_RX_GLOBAL_CTLr_FMOK_LATENCY_CNTf_SET(r,f) (r).rx_global_ctl[0]=(((r).rx_global_ctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53101_A0_RX_GLOBAL_CTLr_DIS_CRC_CHKf_GET(r) ((((r).rx_global_ctl[0]) >> 4) & 0x1)
#define BCM53101_A0_RX_GLOBAL_CTLr_DIS_CRC_CHKf_SET(r,f) (r).rx_global_ctl[0]=(((r).rx_global_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_RX_GLOBAL_CTLr_DIS_ECC_CHKf_GET(r) ((((r).rx_global_ctl[0]) >> 5) & 0x1)
#define BCM53101_A0_RX_GLOBAL_CTLr_DIS_ECC_CHKf_SET(r,f) (r).rx_global_ctl[0]=(((r).rx_global_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_RX_GLOBAL_CTLr_RESERVEDf_GET(r) ((((r).rx_global_ctl[0]) >> 6) & 0x3)
#define BCM53101_A0_RX_GLOBAL_CTLr_RESERVEDf_SET(r,f) (r).rx_global_ctl[0]=(((r).rx_global_ctl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access RX_GLOBAL_CTL.
 *
 */
#define BCM53101_A0_READ_RX_GLOBAL_CTLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_RX_GLOBAL_CTLr,(r._rx_global_ctl),1)
#define BCM53101_A0_WRITE_RX_GLOBAL_CTLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_RX_GLOBAL_CTLr,&(r._rx_global_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_GLOBAL_CTLr BCM53101_A0_RX_GLOBAL_CTLr
#define RX_GLOBAL_CTLr_SIZE BCM53101_A0_RX_GLOBAL_CTLr_SIZE
typedef BCM53101_A0_RX_GLOBAL_CTLr_t RX_GLOBAL_CTLr_t;
#define RX_GLOBAL_CTLr_CLR BCM53101_A0_RX_GLOBAL_CTLr_CLR
#define RX_GLOBAL_CTLr_SET BCM53101_A0_RX_GLOBAL_CTLr_SET
#define RX_GLOBAL_CTLr_GET BCM53101_A0_RX_GLOBAL_CTLr_GET
#define RX_GLOBAL_CTLr_FMOK_LATENCY_CNTf_GET BCM53101_A0_RX_GLOBAL_CTLr_FMOK_LATENCY_CNTf_GET
#define RX_GLOBAL_CTLr_FMOK_LATENCY_CNTf_SET BCM53101_A0_RX_GLOBAL_CTLr_FMOK_LATENCY_CNTf_SET
#define RX_GLOBAL_CTLr_DIS_CRC_CHKf_GET BCM53101_A0_RX_GLOBAL_CTLr_DIS_CRC_CHKf_GET
#define RX_GLOBAL_CTLr_DIS_CRC_CHKf_SET BCM53101_A0_RX_GLOBAL_CTLr_DIS_CRC_CHKf_SET
#define RX_GLOBAL_CTLr_DIS_ECC_CHKf_GET BCM53101_A0_RX_GLOBAL_CTLr_DIS_ECC_CHKf_GET
#define RX_GLOBAL_CTLr_DIS_ECC_CHKf_SET BCM53101_A0_RX_GLOBAL_CTLr_DIS_ECC_CHKf_SET
#define RX_GLOBAL_CTLr_RESERVEDf_GET BCM53101_A0_RX_GLOBAL_CTLr_RESERVEDf_GET
#define RX_GLOBAL_CTLr_RESERVEDf_SET BCM53101_A0_RX_GLOBAL_CTLr_RESERVEDf_SET
#define READ_RX_GLOBAL_CTLr BCM53101_A0_READ_RX_GLOBAL_CTLr
#define WRITE_RX_GLOBAL_CTLr BCM53101_A0_WRITE_RX_GLOBAL_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RX_GLOBAL_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RX_PAUSE_PASS
 * BLOCKS:   SYS
 * DESC:     Pause pass Through for RX Registrer
 * SIZE:     16
 * FIELDS:
 *     RX_PAUSE_PASS    RX pause pass through map.bit[8] : Port 8.bit[5:0] : Port 5-01 : ignore 802.3x.0 : comply with 802.3x pause frame receiving.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_RX_PAUSE_PASSr 0x00000038

#define BCM53101_A0_RX_PAUSE_PASSr_SIZE 2

/*
 * This structure should be used to declare and program RX_PAUSE_PASS.
 *
 */
typedef union BCM53101_A0_RX_PAUSE_PASSr_s {
	uint32_t v[1];
	uint32_t rx_pause_pass[1];
	uint32_t _rx_pause_pass;
} BCM53101_A0_RX_PAUSE_PASSr_t;

#define BCM53101_A0_RX_PAUSE_PASSr_CLR(r) (r).rx_pause_pass[0] = 0
#define BCM53101_A0_RX_PAUSE_PASSr_SET(r,d) (r).rx_pause_pass[0] = d
#define BCM53101_A0_RX_PAUSE_PASSr_GET(r) (r).rx_pause_pass[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_RX_PAUSE_PASSr_RX_PAUSE_PASSf_GET(r) (((r).rx_pause_pass[0]) & 0xff)
#define BCM53101_A0_RX_PAUSE_PASSr_RX_PAUSE_PASSf_SET(r,f) (r).rx_pause_pass[0]=(((r).rx_pause_pass[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))
#define BCM53101_A0_RX_PAUSE_PASSr_RESERVEDf_GET(r) ((((r).rx_pause_pass[0]) >> 8) & 0xff)
#define BCM53101_A0_RX_PAUSE_PASSr_RESERVEDf_SET(r,f) (r).rx_pause_pass[0]=(((r).rx_pause_pass[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8))

/*
 * These macros can be used to access RX_PAUSE_PASS.
 *
 */
#define BCM53101_A0_READ_RX_PAUSE_PASSr(u,r) cdk_robo_reg_read(u,BCM53101_A0_RX_PAUSE_PASSr,(r._rx_pause_pass),2)
#define BCM53101_A0_WRITE_RX_PAUSE_PASSr(u,r) cdk_robo_reg_write(u,BCM53101_A0_RX_PAUSE_PASSr,&(r._rx_pause_pass),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RX_PAUSE_PASSr BCM53101_A0_RX_PAUSE_PASSr
#define RX_PAUSE_PASSr_SIZE BCM53101_A0_RX_PAUSE_PASSr_SIZE
typedef BCM53101_A0_RX_PAUSE_PASSr_t RX_PAUSE_PASSr_t;
#define RX_PAUSE_PASSr_CLR BCM53101_A0_RX_PAUSE_PASSr_CLR
#define RX_PAUSE_PASSr_SET BCM53101_A0_RX_PAUSE_PASSr_SET
#define RX_PAUSE_PASSr_GET BCM53101_A0_RX_PAUSE_PASSr_GET
#define RX_PAUSE_PASSr_RX_PAUSE_PASSf_GET BCM53101_A0_RX_PAUSE_PASSr_RX_PAUSE_PASSf_GET
#define RX_PAUSE_PASSr_RX_PAUSE_PASSf_SET BCM53101_A0_RX_PAUSE_PASSr_RX_PAUSE_PASSf_SET
#define RX_PAUSE_PASSr_RESERVEDf_GET BCM53101_A0_RX_PAUSE_PASSr_RESERVEDf_GET
#define RX_PAUSE_PASSr_RESERVEDf_SET BCM53101_A0_RX_PAUSE_PASSr_RESERVEDf_SET
#define READ_RX_PAUSE_PASSr BCM53101_A0_READ_RX_PAUSE_PASSr
#define WRITE_RX_PAUSE_PASSr BCM53101_A0_WRITE_RX_PAUSE_PASSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RX_PAUSE_PASSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RxAlignmentErrors
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Rx Alignment Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_RXALIGNMENTERRORSr 0x00002080

#define BCM53101_A0_RXALIGNMENTERRORSr_SIZE 4

/*
 * This structure should be used to declare and program RxAlignmentErrors.
 *
 */
typedef union BCM53101_A0_RXALIGNMENTERRORSr_s {
	uint32_t v[1];
	uint32_t rxalignmenterrors[1];
	uint32_t _rxalignmenterrors;
} BCM53101_A0_RXALIGNMENTERRORSr_t;

#define BCM53101_A0_RXALIGNMENTERRORSr_CLR(r) (r).rxalignmenterrors[0] = 0
#define BCM53101_A0_RXALIGNMENTERRORSr_SET(r,d) (r).rxalignmenterrors[0] = d
#define BCM53101_A0_RXALIGNMENTERRORSr_GET(r) (r).rxalignmenterrors[0]


/*
 * These macros can be used to access RxAlignmentErrors.
 *
 */
#define BCM53101_A0_READ_RXALIGNMENTERRORSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_RXALIGNMENTERRORSr,(r._rxalignmenterrors),4)
#define BCM53101_A0_WRITE_RXALIGNMENTERRORSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_RXALIGNMENTERRORSr,&(r._rxalignmenterrors),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXALIGNMENTERRORSr BCM53101_A0_RXALIGNMENTERRORSr
#define RXALIGNMENTERRORSr_SIZE BCM53101_A0_RXALIGNMENTERRORSr_SIZE
typedef BCM53101_A0_RXALIGNMENTERRORSr_t RXALIGNMENTERRORSr_t;
#define RXALIGNMENTERRORSr_CLR BCM53101_A0_RXALIGNMENTERRORSr_CLR
#define RXALIGNMENTERRORSr_SET BCM53101_A0_RXALIGNMENTERRORSr_SET
#define RXALIGNMENTERRORSr_GET BCM53101_A0_RXALIGNMENTERRORSr_GET
#define READ_RXALIGNMENTERRORSr BCM53101_A0_READ_RXALIGNMENTERRORSr
#define WRITE_RXALIGNMENTERRORSr BCM53101_A0_WRITE_RXALIGNMENTERRORSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RXALIGNMENTERRORSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RxAlignmentErrors_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Alignment Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_RXALIGNMENTERRORS_IMPr 0x00002880

#define BCM53101_A0_RXALIGNMENTERRORS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RxAlignmentErrors_IMP.
 *
 */
typedef union BCM53101_A0_RXALIGNMENTERRORS_IMPr_s {
	uint32_t v[1];
	uint32_t rxalignmenterrors_imp[1];
	uint32_t _rxalignmenterrors_imp;
} BCM53101_A0_RXALIGNMENTERRORS_IMPr_t;

#define BCM53101_A0_RXALIGNMENTERRORS_IMPr_CLR(r) (r).rxalignmenterrors_imp[0] = 0
#define BCM53101_A0_RXALIGNMENTERRORS_IMPr_SET(r,d) (r).rxalignmenterrors_imp[0] = d
#define BCM53101_A0_RXALIGNMENTERRORS_IMPr_GET(r) (r).rxalignmenterrors_imp[0]


/*
 * These macros can be used to access RxAlignmentErrors_IMP.
 *
 */
#define BCM53101_A0_READ_RXALIGNMENTERRORS_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_RXALIGNMENTERRORS_IMPr,(r._rxalignmenterrors_imp),4)
#define BCM53101_A0_WRITE_RXALIGNMENTERRORS_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_RXALIGNMENTERRORS_IMPr,&(r._rxalignmenterrors_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXALIGNMENTERRORS_IMPr BCM53101_A0_RXALIGNMENTERRORS_IMPr
#define RXALIGNMENTERRORS_IMPr_SIZE BCM53101_A0_RXALIGNMENTERRORS_IMPr_SIZE
typedef BCM53101_A0_RXALIGNMENTERRORS_IMPr_t RXALIGNMENTERRORS_IMPr_t;
#define RXALIGNMENTERRORS_IMPr_CLR BCM53101_A0_RXALIGNMENTERRORS_IMPr_CLR
#define RXALIGNMENTERRORS_IMPr_SET BCM53101_A0_RXALIGNMENTERRORS_IMPr_SET
#define RXALIGNMENTERRORS_IMPr_GET BCM53101_A0_RXALIGNMENTERRORS_IMPr_GET
#define READ_RXALIGNMENTERRORS_IMPr BCM53101_A0_READ_RXALIGNMENTERRORS_IMPr
#define WRITE_RXALIGNMENTERRORS_IMPr BCM53101_A0_WRITE_RXALIGNMENTERRORS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RXALIGNMENTERRORS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RxBroadcastPkt
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Rx Broadcast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_RXBROADCASTPKTr 0x0000209c

#define BCM53101_A0_RXBROADCASTPKTr_SIZE 4

/*
 * This structure should be used to declare and program RxBroadcastPkt.
 *
 */
typedef union BCM53101_A0_RXBROADCASTPKTr_s {
	uint32_t v[1];
	uint32_t rxbroadcastpkt[1];
	uint32_t _rxbroadcastpkt;
} BCM53101_A0_RXBROADCASTPKTr_t;

#define BCM53101_A0_RXBROADCASTPKTr_CLR(r) (r).rxbroadcastpkt[0] = 0
#define BCM53101_A0_RXBROADCASTPKTr_SET(r,d) (r).rxbroadcastpkt[0] = d
#define BCM53101_A0_RXBROADCASTPKTr_GET(r) (r).rxbroadcastpkt[0]


/*
 * These macros can be used to access RxBroadcastPkt.
 *
 */
#define BCM53101_A0_READ_RXBROADCASTPKTr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_RXBROADCASTPKTr,(r._rxbroadcastpkt),4)
#define BCM53101_A0_WRITE_RXBROADCASTPKTr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_RXBROADCASTPKTr,&(r._rxbroadcastpkt),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXBROADCASTPKTr BCM53101_A0_RXBROADCASTPKTr
#define RXBROADCASTPKTr_SIZE BCM53101_A0_RXBROADCASTPKTr_SIZE
typedef BCM53101_A0_RXBROADCASTPKTr_t RXBROADCASTPKTr_t;
#define RXBROADCASTPKTr_CLR BCM53101_A0_RXBROADCASTPKTr_CLR
#define RXBROADCASTPKTr_SET BCM53101_A0_RXBROADCASTPKTr_SET
#define RXBROADCASTPKTr_GET BCM53101_A0_RXBROADCASTPKTr_GET
#define READ_RXBROADCASTPKTr BCM53101_A0_READ_RXBROADCASTPKTr
#define WRITE_RXBROADCASTPKTr BCM53101_A0_WRITE_RXBROADCASTPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RXBROADCASTPKTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RxBroadcastPkt_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Broadcast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_RXBROADCASTPKT_IMPr 0x0000289c

#define BCM53101_A0_RXBROADCASTPKT_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RxBroadcastPkt_IMP.
 *
 */
typedef union BCM53101_A0_RXBROADCASTPKT_IMPr_s {
	uint32_t v[1];
	uint32_t rxbroadcastpkt_imp[1];
	uint32_t _rxbroadcastpkt_imp;
} BCM53101_A0_RXBROADCASTPKT_IMPr_t;

#define BCM53101_A0_RXBROADCASTPKT_IMPr_CLR(r) (r).rxbroadcastpkt_imp[0] = 0
#define BCM53101_A0_RXBROADCASTPKT_IMPr_SET(r,d) (r).rxbroadcastpkt_imp[0] = d
#define BCM53101_A0_RXBROADCASTPKT_IMPr_GET(r) (r).rxbroadcastpkt_imp[0]


/*
 * These macros can be used to access RxBroadcastPkt_IMP.
 *
 */
#define BCM53101_A0_READ_RXBROADCASTPKT_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_RXBROADCASTPKT_IMPr,(r._rxbroadcastpkt_imp),4)
#define BCM53101_A0_WRITE_RXBROADCASTPKT_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_RXBROADCASTPKT_IMPr,&(r._rxbroadcastpkt_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXBROADCASTPKT_IMPr BCM53101_A0_RXBROADCASTPKT_IMPr
#define RXBROADCASTPKT_IMPr_SIZE BCM53101_A0_RXBROADCASTPKT_IMPr_SIZE
typedef BCM53101_A0_RXBROADCASTPKT_IMPr_t RXBROADCASTPKT_IMPr_t;
#define RXBROADCASTPKT_IMPr_CLR BCM53101_A0_RXBROADCASTPKT_IMPr_CLR
#define RXBROADCASTPKT_IMPr_SET BCM53101_A0_RXBROADCASTPKT_IMPr_SET
#define RXBROADCASTPKT_IMPr_GET BCM53101_A0_RXBROADCASTPKT_IMPr_GET
#define READ_RXBROADCASTPKT_IMPr BCM53101_A0_READ_RXBROADCASTPKT_IMPr
#define WRITE_RXBROADCASTPKT_IMPr BCM53101_A0_WRITE_RXBROADCASTPKT_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RXBROADCASTPKT_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RxDropPkts
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Rx Drop Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_RXDROPPKTSr 0x00002090

#define BCM53101_A0_RXDROPPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxDropPkts.
 *
 */
typedef union BCM53101_A0_RXDROPPKTSr_s {
	uint32_t v[1];
	uint32_t rxdroppkts[1];
	uint32_t _rxdroppkts;
} BCM53101_A0_RXDROPPKTSr_t;

#define BCM53101_A0_RXDROPPKTSr_CLR(r) (r).rxdroppkts[0] = 0
#define BCM53101_A0_RXDROPPKTSr_SET(r,d) (r).rxdroppkts[0] = d
#define BCM53101_A0_RXDROPPKTSr_GET(r) (r).rxdroppkts[0]


/*
 * These macros can be used to access RxDropPkts.
 *
 */
#define BCM53101_A0_READ_RXDROPPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_RXDROPPKTSr,(r._rxdroppkts),4)
#define BCM53101_A0_WRITE_RXDROPPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_RXDROPPKTSr,&(r._rxdroppkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXDROPPKTSr BCM53101_A0_RXDROPPKTSr
#define RXDROPPKTSr_SIZE BCM53101_A0_RXDROPPKTSr_SIZE
typedef BCM53101_A0_RXDROPPKTSr_t RXDROPPKTSr_t;
#define RXDROPPKTSr_CLR BCM53101_A0_RXDROPPKTSr_CLR
#define RXDROPPKTSr_SET BCM53101_A0_RXDROPPKTSr_SET
#define RXDROPPKTSr_GET BCM53101_A0_RXDROPPKTSr_GET
#define READ_RXDROPPKTSr BCM53101_A0_READ_RXDROPPKTSr
#define WRITE_RXDROPPKTSr BCM53101_A0_WRITE_RXDROPPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RXDROPPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RxDropPkts_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Drop Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_RXDROPPKTS_IMPr 0x00002890

#define BCM53101_A0_RXDROPPKTS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RxDropPkts_IMP.
 *
 */
typedef union BCM53101_A0_RXDROPPKTS_IMPr_s {
	uint32_t v[1];
	uint32_t rxdroppkts_imp[1];
	uint32_t _rxdroppkts_imp;
} BCM53101_A0_RXDROPPKTS_IMPr_t;

#define BCM53101_A0_RXDROPPKTS_IMPr_CLR(r) (r).rxdroppkts_imp[0] = 0
#define BCM53101_A0_RXDROPPKTS_IMPr_SET(r,d) (r).rxdroppkts_imp[0] = d
#define BCM53101_A0_RXDROPPKTS_IMPr_GET(r) (r).rxdroppkts_imp[0]


/*
 * These macros can be used to access RxDropPkts_IMP.
 *
 */
#define BCM53101_A0_READ_RXDROPPKTS_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_RXDROPPKTS_IMPr,(r._rxdroppkts_imp),4)
#define BCM53101_A0_WRITE_RXDROPPKTS_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_RXDROPPKTS_IMPr,&(r._rxdroppkts_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXDROPPKTS_IMPr BCM53101_A0_RXDROPPKTS_IMPr
#define RXDROPPKTS_IMPr_SIZE BCM53101_A0_RXDROPPKTS_IMPr_SIZE
typedef BCM53101_A0_RXDROPPKTS_IMPr_t RXDROPPKTS_IMPr_t;
#define RXDROPPKTS_IMPr_CLR BCM53101_A0_RXDROPPKTS_IMPr_CLR
#define RXDROPPKTS_IMPr_SET BCM53101_A0_RXDROPPKTS_IMPr_SET
#define RXDROPPKTS_IMPr_GET BCM53101_A0_RXDROPPKTS_IMPr_GET
#define READ_RXDROPPKTS_IMPr BCM53101_A0_READ_RXDROPPKTS_IMPr
#define WRITE_RXDROPPKTS_IMPr BCM53101_A0_WRITE_RXDROPPKTS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RXDROPPKTS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RxFCSErrors
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Rx FCS Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_RXFCSERRORSr 0x00002084

#define BCM53101_A0_RXFCSERRORSr_SIZE 4

/*
 * This structure should be used to declare and program RxFCSErrors.
 *
 */
typedef union BCM53101_A0_RXFCSERRORSr_s {
	uint32_t v[1];
	uint32_t rxfcserrors[1];
	uint32_t _rxfcserrors;
} BCM53101_A0_RXFCSERRORSr_t;

#define BCM53101_A0_RXFCSERRORSr_CLR(r) (r).rxfcserrors[0] = 0
#define BCM53101_A0_RXFCSERRORSr_SET(r,d) (r).rxfcserrors[0] = d
#define BCM53101_A0_RXFCSERRORSr_GET(r) (r).rxfcserrors[0]


/*
 * These macros can be used to access RxFCSErrors.
 *
 */
#define BCM53101_A0_READ_RXFCSERRORSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_RXFCSERRORSr,(r._rxfcserrors),4)
#define BCM53101_A0_WRITE_RXFCSERRORSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_RXFCSERRORSr,&(r._rxfcserrors),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXFCSERRORSr BCM53101_A0_RXFCSERRORSr
#define RXFCSERRORSr_SIZE BCM53101_A0_RXFCSERRORSr_SIZE
typedef BCM53101_A0_RXFCSERRORSr_t RXFCSERRORSr_t;
#define RXFCSERRORSr_CLR BCM53101_A0_RXFCSERRORSr_CLR
#define RXFCSERRORSr_SET BCM53101_A0_RXFCSERRORSr_SET
#define RXFCSERRORSr_GET BCM53101_A0_RXFCSERRORSr_GET
#define READ_RXFCSERRORSr BCM53101_A0_READ_RXFCSERRORSr
#define WRITE_RXFCSERRORSr BCM53101_A0_WRITE_RXFCSERRORSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RXFCSERRORSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RxFCSErrors_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx FCS Error Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_RXFCSERRORS_IMPr 0x00002884

#define BCM53101_A0_RXFCSERRORS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RxFCSErrors_IMP.
 *
 */
typedef union BCM53101_A0_RXFCSERRORS_IMPr_s {
	uint32_t v[1];
	uint32_t rxfcserrors_imp[1];
	uint32_t _rxfcserrors_imp;
} BCM53101_A0_RXFCSERRORS_IMPr_t;

#define BCM53101_A0_RXFCSERRORS_IMPr_CLR(r) (r).rxfcserrors_imp[0] = 0
#define BCM53101_A0_RXFCSERRORS_IMPr_SET(r,d) (r).rxfcserrors_imp[0] = d
#define BCM53101_A0_RXFCSERRORS_IMPr_GET(r) (r).rxfcserrors_imp[0]


/*
 * These macros can be used to access RxFCSErrors_IMP.
 *
 */
#define BCM53101_A0_READ_RXFCSERRORS_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_RXFCSERRORS_IMPr,(r._rxfcserrors_imp),4)
#define BCM53101_A0_WRITE_RXFCSERRORS_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_RXFCSERRORS_IMPr,&(r._rxfcserrors_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXFCSERRORS_IMPr BCM53101_A0_RXFCSERRORS_IMPr
#define RXFCSERRORS_IMPr_SIZE BCM53101_A0_RXFCSERRORS_IMPr_SIZE
typedef BCM53101_A0_RXFCSERRORS_IMPr_t RXFCSERRORS_IMPr_t;
#define RXFCSERRORS_IMPr_CLR BCM53101_A0_RXFCSERRORS_IMPr_CLR
#define RXFCSERRORS_IMPr_SET BCM53101_A0_RXFCSERRORS_IMPr_SET
#define RXFCSERRORS_IMPr_GET BCM53101_A0_RXFCSERRORS_IMPr_GET
#define READ_RXFCSERRORS_IMPr BCM53101_A0_READ_RXFCSERRORS_IMPr
#define WRITE_RXFCSERRORS_IMPr BCM53101_A0_WRITE_RXFCSERRORS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RXFCSERRORS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RxFragments
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Rx Fragment Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_RXFRAGMENTSr 0x000020a4

#define BCM53101_A0_RXFRAGMENTSr_SIZE 4

/*
 * This structure should be used to declare and program RxFragments.
 *
 */
typedef union BCM53101_A0_RXFRAGMENTSr_s {
	uint32_t v[1];
	uint32_t rxfragments[1];
	uint32_t _rxfragments;
} BCM53101_A0_RXFRAGMENTSr_t;

#define BCM53101_A0_RXFRAGMENTSr_CLR(r) (r).rxfragments[0] = 0
#define BCM53101_A0_RXFRAGMENTSr_SET(r,d) (r).rxfragments[0] = d
#define BCM53101_A0_RXFRAGMENTSr_GET(r) (r).rxfragments[0]


/*
 * These macros can be used to access RxFragments.
 *
 */
#define BCM53101_A0_READ_RXFRAGMENTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_RXFRAGMENTSr,(r._rxfragments),4)
#define BCM53101_A0_WRITE_RXFRAGMENTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_RXFRAGMENTSr,&(r._rxfragments),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXFRAGMENTSr BCM53101_A0_RXFRAGMENTSr
#define RXFRAGMENTSr_SIZE BCM53101_A0_RXFRAGMENTSr_SIZE
typedef BCM53101_A0_RXFRAGMENTSr_t RXFRAGMENTSr_t;
#define RXFRAGMENTSr_CLR BCM53101_A0_RXFRAGMENTSr_CLR
#define RXFRAGMENTSr_SET BCM53101_A0_RXFRAGMENTSr_SET
#define RXFRAGMENTSr_GET BCM53101_A0_RXFRAGMENTSr_GET
#define READ_RXFRAGMENTSr BCM53101_A0_READ_RXFRAGMENTSr
#define WRITE_RXFRAGMENTSr BCM53101_A0_WRITE_RXFRAGMENTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RXFRAGMENTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RxFragments_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Fragment Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_RXFRAGMENTS_IMPr 0x000028a4

#define BCM53101_A0_RXFRAGMENTS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RxFragments_IMP.
 *
 */
typedef union BCM53101_A0_RXFRAGMENTS_IMPr_s {
	uint32_t v[1];
	uint32_t rxfragments_imp[1];
	uint32_t _rxfragments_imp;
} BCM53101_A0_RXFRAGMENTS_IMPr_t;

#define BCM53101_A0_RXFRAGMENTS_IMPr_CLR(r) (r).rxfragments_imp[0] = 0
#define BCM53101_A0_RXFRAGMENTS_IMPr_SET(r,d) (r).rxfragments_imp[0] = d
#define BCM53101_A0_RXFRAGMENTS_IMPr_GET(r) (r).rxfragments_imp[0]


/*
 * These macros can be used to access RxFragments_IMP.
 *
 */
#define BCM53101_A0_READ_RXFRAGMENTS_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_RXFRAGMENTS_IMPr,(r._rxfragments_imp),4)
#define BCM53101_A0_WRITE_RXFRAGMENTS_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_RXFRAGMENTS_IMPr,&(r._rxfragments_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXFRAGMENTS_IMPr BCM53101_A0_RXFRAGMENTS_IMPr
#define RXFRAGMENTS_IMPr_SIZE BCM53101_A0_RXFRAGMENTS_IMPr_SIZE
typedef BCM53101_A0_RXFRAGMENTS_IMPr_t RXFRAGMENTS_IMPr_t;
#define RXFRAGMENTS_IMPr_CLR BCM53101_A0_RXFRAGMENTS_IMPr_CLR
#define RXFRAGMENTS_IMPr_SET BCM53101_A0_RXFRAGMENTS_IMPr_SET
#define RXFRAGMENTS_IMPr_GET BCM53101_A0_RXFRAGMENTS_IMPr_GET
#define READ_RXFRAGMENTS_IMPr BCM53101_A0_READ_RXFRAGMENTS_IMPr
#define WRITE_RXFRAGMENTS_IMPr BCM53101_A0_WRITE_RXFRAGMENTS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RXFRAGMENTS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RxGoodOctets
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Rx Good Packet Octet Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM53101_A0_RXGOODOCTETSr 0x00002088

#define BCM53101_A0_RXGOODOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program RxGoodOctets.
 *
 */
typedef union BCM53101_A0_RXGOODOCTETSr_s {
	uint32_t v[2];
	uint32_t rxgoodoctets[2];
	uint32_t _rxgoodoctets;
} BCM53101_A0_RXGOODOCTETSr_t;

#define BCM53101_A0_RXGOODOCTETSr_CLR(r) CDK_MEMSET(&((r)._rxgoodoctets), 0, sizeof(BCM53101_A0_RXGOODOCTETSr_t))
#define BCM53101_A0_RXGOODOCTETSr_SET(r,i,d) (r).rxgoodoctets[i] = d
#define BCM53101_A0_RXGOODOCTETSr_GET(r,i) (r).rxgoodoctets[i]


/*
 * These macros can be used to access RxGoodOctets.
 *
 */
#define BCM53101_A0_READ_RXGOODOCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_RXGOODOCTETSr,(r._rxgoodoctets),8)
#define BCM53101_A0_WRITE_RXGOODOCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_RXGOODOCTETSr,&(r._rxgoodoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXGOODOCTETSr BCM53101_A0_RXGOODOCTETSr
#define RXGOODOCTETSr_SIZE BCM53101_A0_RXGOODOCTETSr_SIZE
typedef BCM53101_A0_RXGOODOCTETSr_t RXGOODOCTETSr_t;
#define RXGOODOCTETSr_CLR BCM53101_A0_RXGOODOCTETSr_CLR
#define RXGOODOCTETSr_SET BCM53101_A0_RXGOODOCTETSr_SET
#define RXGOODOCTETSr_GET BCM53101_A0_RXGOODOCTETSr_GET
#define READ_RXGOODOCTETSr BCM53101_A0_READ_RXGOODOCTETSr
#define WRITE_RXGOODOCTETSr BCM53101_A0_WRITE_RXGOODOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RXGOODOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RxGoodOctets_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Good Packet Octet Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM53101_A0_RXGOODOCTETS_IMPr 0x00002888

#define BCM53101_A0_RXGOODOCTETS_IMPr_SIZE 8

/*
 * This structure should be used to declare and program RxGoodOctets_IMP.
 *
 */
typedef union BCM53101_A0_RXGOODOCTETS_IMPr_s {
	uint32_t v[2];
	uint32_t rxgoodoctets_imp[2];
	uint32_t _rxgoodoctets_imp;
} BCM53101_A0_RXGOODOCTETS_IMPr_t;

#define BCM53101_A0_RXGOODOCTETS_IMPr_CLR(r) CDK_MEMSET(&((r)._rxgoodoctets_imp), 0, sizeof(BCM53101_A0_RXGOODOCTETS_IMPr_t))
#define BCM53101_A0_RXGOODOCTETS_IMPr_SET(r,i,d) (r).rxgoodoctets_imp[i] = d
#define BCM53101_A0_RXGOODOCTETS_IMPr_GET(r,i) (r).rxgoodoctets_imp[i]


/*
 * These macros can be used to access RxGoodOctets_IMP.
 *
 */
#define BCM53101_A0_READ_RXGOODOCTETS_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_RXGOODOCTETS_IMPr,(r._rxgoodoctets_imp),8)
#define BCM53101_A0_WRITE_RXGOODOCTETS_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_RXGOODOCTETS_IMPr,&(r._rxgoodoctets_imp),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXGOODOCTETS_IMPr BCM53101_A0_RXGOODOCTETS_IMPr
#define RXGOODOCTETS_IMPr_SIZE BCM53101_A0_RXGOODOCTETS_IMPr_SIZE
typedef BCM53101_A0_RXGOODOCTETS_IMPr_t RXGOODOCTETS_IMPr_t;
#define RXGOODOCTETS_IMPr_CLR BCM53101_A0_RXGOODOCTETS_IMPr_CLR
#define RXGOODOCTETS_IMPr_SET BCM53101_A0_RXGOODOCTETS_IMPr_SET
#define RXGOODOCTETS_IMPr_GET BCM53101_A0_RXGOODOCTETS_IMPr_GET
#define READ_RXGOODOCTETS_IMPr BCM53101_A0_READ_RXGOODOCTETS_IMPr
#define WRITE_RXGOODOCTETS_IMPr BCM53101_A0_WRITE_RXGOODOCTETS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RXGOODOCTETS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RxJabbers
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Rx Jabber Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_RXJABBERSr 0x0000207c

#define BCM53101_A0_RXJABBERSr_SIZE 4

/*
 * This structure should be used to declare and program RxJabbers.
 *
 */
typedef union BCM53101_A0_RXJABBERSr_s {
	uint32_t v[1];
	uint32_t rxjabbers[1];
	uint32_t _rxjabbers;
} BCM53101_A0_RXJABBERSr_t;

#define BCM53101_A0_RXJABBERSr_CLR(r) (r).rxjabbers[0] = 0
#define BCM53101_A0_RXJABBERSr_SET(r,d) (r).rxjabbers[0] = d
#define BCM53101_A0_RXJABBERSr_GET(r) (r).rxjabbers[0]


/*
 * These macros can be used to access RxJabbers.
 *
 */
#define BCM53101_A0_READ_RXJABBERSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_RXJABBERSr,(r._rxjabbers),4)
#define BCM53101_A0_WRITE_RXJABBERSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_RXJABBERSr,&(r._rxjabbers),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXJABBERSr BCM53101_A0_RXJABBERSr
#define RXJABBERSr_SIZE BCM53101_A0_RXJABBERSr_SIZE
typedef BCM53101_A0_RXJABBERSr_t RXJABBERSr_t;
#define RXJABBERSr_CLR BCM53101_A0_RXJABBERSr_CLR
#define RXJABBERSr_SET BCM53101_A0_RXJABBERSr_SET
#define RXJABBERSr_GET BCM53101_A0_RXJABBERSr_GET
#define READ_RXJABBERSr BCM53101_A0_READ_RXJABBERSr
#define WRITE_RXJABBERSr BCM53101_A0_WRITE_RXJABBERSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RXJABBERSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RxJabbers_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Jabber Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_RXJABBERS_IMPr 0x0000287c

#define BCM53101_A0_RXJABBERS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RxJabbers_IMP.
 *
 */
typedef union BCM53101_A0_RXJABBERS_IMPr_s {
	uint32_t v[1];
	uint32_t rxjabbers_imp[1];
	uint32_t _rxjabbers_imp;
} BCM53101_A0_RXJABBERS_IMPr_t;

#define BCM53101_A0_RXJABBERS_IMPr_CLR(r) (r).rxjabbers_imp[0] = 0
#define BCM53101_A0_RXJABBERS_IMPr_SET(r,d) (r).rxjabbers_imp[0] = d
#define BCM53101_A0_RXJABBERS_IMPr_GET(r) (r).rxjabbers_imp[0]


/*
 * These macros can be used to access RxJabbers_IMP.
 *
 */
#define BCM53101_A0_READ_RXJABBERS_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_RXJABBERS_IMPr,(r._rxjabbers_imp),4)
#define BCM53101_A0_WRITE_RXJABBERS_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_RXJABBERS_IMPr,&(r._rxjabbers_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXJABBERS_IMPr BCM53101_A0_RXJABBERS_IMPr
#define RXJABBERS_IMPr_SIZE BCM53101_A0_RXJABBERS_IMPr_SIZE
typedef BCM53101_A0_RXJABBERS_IMPr_t RXJABBERS_IMPr_t;
#define RXJABBERS_IMPr_CLR BCM53101_A0_RXJABBERS_IMPr_CLR
#define RXJABBERS_IMPr_SET BCM53101_A0_RXJABBERS_IMPr_SET
#define RXJABBERS_IMPr_GET BCM53101_A0_RXJABBERS_IMPr_GET
#define READ_RXJABBERS_IMPr BCM53101_A0_READ_RXJABBERS_IMPr
#define WRITE_RXJABBERS_IMPr BCM53101_A0_WRITE_RXJABBERS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RXJABBERS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RxMulticastPkts
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Rx Multicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_RXMULTICASTPKTSr 0x00002098

#define BCM53101_A0_RXMULTICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxMulticastPkts.
 *
 */
typedef union BCM53101_A0_RXMULTICASTPKTSr_s {
	uint32_t v[1];
	uint32_t rxmulticastpkts[1];
	uint32_t _rxmulticastpkts;
} BCM53101_A0_RXMULTICASTPKTSr_t;

#define BCM53101_A0_RXMULTICASTPKTSr_CLR(r) (r).rxmulticastpkts[0] = 0
#define BCM53101_A0_RXMULTICASTPKTSr_SET(r,d) (r).rxmulticastpkts[0] = d
#define BCM53101_A0_RXMULTICASTPKTSr_GET(r) (r).rxmulticastpkts[0]


/*
 * These macros can be used to access RxMulticastPkts.
 *
 */
#define BCM53101_A0_READ_RXMULTICASTPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_RXMULTICASTPKTSr,(r._rxmulticastpkts),4)
#define BCM53101_A0_WRITE_RXMULTICASTPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_RXMULTICASTPKTSr,&(r._rxmulticastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXMULTICASTPKTSr BCM53101_A0_RXMULTICASTPKTSr
#define RXMULTICASTPKTSr_SIZE BCM53101_A0_RXMULTICASTPKTSr_SIZE
typedef BCM53101_A0_RXMULTICASTPKTSr_t RXMULTICASTPKTSr_t;
#define RXMULTICASTPKTSr_CLR BCM53101_A0_RXMULTICASTPKTSr_CLR
#define RXMULTICASTPKTSr_SET BCM53101_A0_RXMULTICASTPKTSr_SET
#define RXMULTICASTPKTSr_GET BCM53101_A0_RXMULTICASTPKTSr_GET
#define READ_RXMULTICASTPKTSr BCM53101_A0_READ_RXMULTICASTPKTSr
#define WRITE_RXMULTICASTPKTSr BCM53101_A0_WRITE_RXMULTICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RXMULTICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RxMulticastPkts_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Multicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_RXMULTICASTPKTS_IMPr 0x00002898

#define BCM53101_A0_RXMULTICASTPKTS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RxMulticastPkts_IMP.
 *
 */
typedef union BCM53101_A0_RXMULTICASTPKTS_IMPr_s {
	uint32_t v[1];
	uint32_t rxmulticastpkts_imp[1];
	uint32_t _rxmulticastpkts_imp;
} BCM53101_A0_RXMULTICASTPKTS_IMPr_t;

#define BCM53101_A0_RXMULTICASTPKTS_IMPr_CLR(r) (r).rxmulticastpkts_imp[0] = 0
#define BCM53101_A0_RXMULTICASTPKTS_IMPr_SET(r,d) (r).rxmulticastpkts_imp[0] = d
#define BCM53101_A0_RXMULTICASTPKTS_IMPr_GET(r) (r).rxmulticastpkts_imp[0]


/*
 * These macros can be used to access RxMulticastPkts_IMP.
 *
 */
#define BCM53101_A0_READ_RXMULTICASTPKTS_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_RXMULTICASTPKTS_IMPr,(r._rxmulticastpkts_imp),4)
#define BCM53101_A0_WRITE_RXMULTICASTPKTS_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_RXMULTICASTPKTS_IMPr,&(r._rxmulticastpkts_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXMULTICASTPKTS_IMPr BCM53101_A0_RXMULTICASTPKTS_IMPr
#define RXMULTICASTPKTS_IMPr_SIZE BCM53101_A0_RXMULTICASTPKTS_IMPr_SIZE
typedef BCM53101_A0_RXMULTICASTPKTS_IMPr_t RXMULTICASTPKTS_IMPr_t;
#define RXMULTICASTPKTS_IMPr_CLR BCM53101_A0_RXMULTICASTPKTS_IMPr_CLR
#define RXMULTICASTPKTS_IMPr_SET BCM53101_A0_RXMULTICASTPKTS_IMPr_SET
#define RXMULTICASTPKTS_IMPr_GET BCM53101_A0_RXMULTICASTPKTS_IMPr_GET
#define READ_RXMULTICASTPKTS_IMPr BCM53101_A0_READ_RXMULTICASTPKTS_IMPr
#define WRITE_RXMULTICASTPKTS_IMPr BCM53101_A0_WRITE_RXMULTICASTPKTS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RXMULTICASTPKTS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RxOctets
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Rx Packet Octets Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM53101_A0_RXOCTETSr 0x00002050

#define BCM53101_A0_RXOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program RxOctets.
 *
 */
typedef union BCM53101_A0_RXOCTETSr_s {
	uint32_t v[2];
	uint32_t rxoctets[2];
	uint32_t _rxoctets;
} BCM53101_A0_RXOCTETSr_t;

#define BCM53101_A0_RXOCTETSr_CLR(r) CDK_MEMSET(&((r)._rxoctets), 0, sizeof(BCM53101_A0_RXOCTETSr_t))
#define BCM53101_A0_RXOCTETSr_SET(r,i,d) (r).rxoctets[i] = d
#define BCM53101_A0_RXOCTETSr_GET(r,i) (r).rxoctets[i]


/*
 * These macros can be used to access RxOctets.
 *
 */
#define BCM53101_A0_READ_RXOCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_RXOCTETSr,(r._rxoctets),8)
#define BCM53101_A0_WRITE_RXOCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_RXOCTETSr,&(r._rxoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXOCTETSr BCM53101_A0_RXOCTETSr
#define RXOCTETSr_SIZE BCM53101_A0_RXOCTETSr_SIZE
typedef BCM53101_A0_RXOCTETSr_t RXOCTETSr_t;
#define RXOCTETSr_CLR BCM53101_A0_RXOCTETSr_CLR
#define RXOCTETSr_SET BCM53101_A0_RXOCTETSr_SET
#define RXOCTETSr_GET BCM53101_A0_RXOCTETSr_GET
#define READ_RXOCTETSr BCM53101_A0_READ_RXOCTETSr
#define WRITE_RXOCTETSr BCM53101_A0_WRITE_RXOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RXOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RxOctets_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Packet Octets Counter
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM53101_A0_RXOCTETS_IMPr 0x00002850

#define BCM53101_A0_RXOCTETS_IMPr_SIZE 8

/*
 * This structure should be used to declare and program RxOctets_IMP.
 *
 */
typedef union BCM53101_A0_RXOCTETS_IMPr_s {
	uint32_t v[2];
	uint32_t rxoctets_imp[2];
	uint32_t _rxoctets_imp;
} BCM53101_A0_RXOCTETS_IMPr_t;

#define BCM53101_A0_RXOCTETS_IMPr_CLR(r) CDK_MEMSET(&((r)._rxoctets_imp), 0, sizeof(BCM53101_A0_RXOCTETS_IMPr_t))
#define BCM53101_A0_RXOCTETS_IMPr_SET(r,i,d) (r).rxoctets_imp[i] = d
#define BCM53101_A0_RXOCTETS_IMPr_GET(r,i) (r).rxoctets_imp[i]


/*
 * These macros can be used to access RxOctets_IMP.
 *
 */
#define BCM53101_A0_READ_RXOCTETS_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_RXOCTETS_IMPr,(r._rxoctets_imp),8)
#define BCM53101_A0_WRITE_RXOCTETS_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_RXOCTETS_IMPr,&(r._rxoctets_imp),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXOCTETS_IMPr BCM53101_A0_RXOCTETS_IMPr
#define RXOCTETS_IMPr_SIZE BCM53101_A0_RXOCTETS_IMPr_SIZE
typedef BCM53101_A0_RXOCTETS_IMPr_t RXOCTETS_IMPr_t;
#define RXOCTETS_IMPr_CLR BCM53101_A0_RXOCTETS_IMPr_CLR
#define RXOCTETS_IMPr_SET BCM53101_A0_RXOCTETS_IMPr_SET
#define RXOCTETS_IMPr_GET BCM53101_A0_RXOCTETS_IMPr_GET
#define READ_RXOCTETS_IMPr BCM53101_A0_READ_RXOCTETS_IMPr
#define WRITE_RXOCTETS_IMPr BCM53101_A0_WRITE_RXOCTETS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RXOCTETS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RxOversizePkts
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Rx Over Size Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_RXOVERSIZEPKTSr 0x00002078

#define BCM53101_A0_RXOVERSIZEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxOversizePkts.
 *
 */
typedef union BCM53101_A0_RXOVERSIZEPKTSr_s {
	uint32_t v[1];
	uint32_t rxoversizepkts[1];
	uint32_t _rxoversizepkts;
} BCM53101_A0_RXOVERSIZEPKTSr_t;

#define BCM53101_A0_RXOVERSIZEPKTSr_CLR(r) (r).rxoversizepkts[0] = 0
#define BCM53101_A0_RXOVERSIZEPKTSr_SET(r,d) (r).rxoversizepkts[0] = d
#define BCM53101_A0_RXOVERSIZEPKTSr_GET(r) (r).rxoversizepkts[0]


/*
 * These macros can be used to access RxOversizePkts.
 *
 */
#define BCM53101_A0_READ_RXOVERSIZEPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_RXOVERSIZEPKTSr,(r._rxoversizepkts),4)
#define BCM53101_A0_WRITE_RXOVERSIZEPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_RXOVERSIZEPKTSr,&(r._rxoversizepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXOVERSIZEPKTSr BCM53101_A0_RXOVERSIZEPKTSr
#define RXOVERSIZEPKTSr_SIZE BCM53101_A0_RXOVERSIZEPKTSr_SIZE
typedef BCM53101_A0_RXOVERSIZEPKTSr_t RXOVERSIZEPKTSr_t;
#define RXOVERSIZEPKTSr_CLR BCM53101_A0_RXOVERSIZEPKTSr_CLR
#define RXOVERSIZEPKTSr_SET BCM53101_A0_RXOVERSIZEPKTSr_SET
#define RXOVERSIZEPKTSr_GET BCM53101_A0_RXOVERSIZEPKTSr_GET
#define READ_RXOVERSIZEPKTSr BCM53101_A0_READ_RXOVERSIZEPKTSr
#define WRITE_RXOVERSIZEPKTSr BCM53101_A0_WRITE_RXOVERSIZEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RXOVERSIZEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RxOversizePkts_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Over Size Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_RXOVERSIZEPKTS_IMPr 0x00002878

#define BCM53101_A0_RXOVERSIZEPKTS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RxOversizePkts_IMP.
 *
 */
typedef union BCM53101_A0_RXOVERSIZEPKTS_IMPr_s {
	uint32_t v[1];
	uint32_t rxoversizepkts_imp[1];
	uint32_t _rxoversizepkts_imp;
} BCM53101_A0_RXOVERSIZEPKTS_IMPr_t;

#define BCM53101_A0_RXOVERSIZEPKTS_IMPr_CLR(r) (r).rxoversizepkts_imp[0] = 0
#define BCM53101_A0_RXOVERSIZEPKTS_IMPr_SET(r,d) (r).rxoversizepkts_imp[0] = d
#define BCM53101_A0_RXOVERSIZEPKTS_IMPr_GET(r) (r).rxoversizepkts_imp[0]


/*
 * These macros can be used to access RxOversizePkts_IMP.
 *
 */
#define BCM53101_A0_READ_RXOVERSIZEPKTS_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_RXOVERSIZEPKTS_IMPr,(r._rxoversizepkts_imp),4)
#define BCM53101_A0_WRITE_RXOVERSIZEPKTS_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_RXOVERSIZEPKTS_IMPr,&(r._rxoversizepkts_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXOVERSIZEPKTS_IMPr BCM53101_A0_RXOVERSIZEPKTS_IMPr
#define RXOVERSIZEPKTS_IMPr_SIZE BCM53101_A0_RXOVERSIZEPKTS_IMPr_SIZE
typedef BCM53101_A0_RXOVERSIZEPKTS_IMPr_t RXOVERSIZEPKTS_IMPr_t;
#define RXOVERSIZEPKTS_IMPr_CLR BCM53101_A0_RXOVERSIZEPKTS_IMPr_CLR
#define RXOVERSIZEPKTS_IMPr_SET BCM53101_A0_RXOVERSIZEPKTS_IMPr_SET
#define RXOVERSIZEPKTS_IMPr_GET BCM53101_A0_RXOVERSIZEPKTS_IMPr_GET
#define READ_RXOVERSIZEPKTS_IMPr BCM53101_A0_READ_RXOVERSIZEPKTS_IMPr
#define WRITE_RXOVERSIZEPKTS_IMPr BCM53101_A0_WRITE_RXOVERSIZEPKTS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RXOVERSIZEPKTS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RxPausePkts
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Rx Pause Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_RXPAUSEPKTSr 0x0000205c

#define BCM53101_A0_RXPAUSEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxPausePkts.
 *
 */
typedef union BCM53101_A0_RXPAUSEPKTSr_s {
	uint32_t v[1];
	uint32_t rxpausepkts[1];
	uint32_t _rxpausepkts;
} BCM53101_A0_RXPAUSEPKTSr_t;

#define BCM53101_A0_RXPAUSEPKTSr_CLR(r) (r).rxpausepkts[0] = 0
#define BCM53101_A0_RXPAUSEPKTSr_SET(r,d) (r).rxpausepkts[0] = d
#define BCM53101_A0_RXPAUSEPKTSr_GET(r) (r).rxpausepkts[0]


/*
 * These macros can be used to access RxPausePkts.
 *
 */
#define BCM53101_A0_READ_RXPAUSEPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_RXPAUSEPKTSr,(r._rxpausepkts),4)
#define BCM53101_A0_WRITE_RXPAUSEPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_RXPAUSEPKTSr,&(r._rxpausepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXPAUSEPKTSr BCM53101_A0_RXPAUSEPKTSr
#define RXPAUSEPKTSr_SIZE BCM53101_A0_RXPAUSEPKTSr_SIZE
typedef BCM53101_A0_RXPAUSEPKTSr_t RXPAUSEPKTSr_t;
#define RXPAUSEPKTSr_CLR BCM53101_A0_RXPAUSEPKTSr_CLR
#define RXPAUSEPKTSr_SET BCM53101_A0_RXPAUSEPKTSr_SET
#define RXPAUSEPKTSr_GET BCM53101_A0_RXPAUSEPKTSr_GET
#define READ_RXPAUSEPKTSr BCM53101_A0_READ_RXPAUSEPKTSr
#define WRITE_RXPAUSEPKTSr BCM53101_A0_WRITE_RXPAUSEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RXPAUSEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RxPausePkts_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Pause Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_RXPAUSEPKTS_IMPr 0x0000285c

#define BCM53101_A0_RXPAUSEPKTS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RxPausePkts_IMP.
 *
 */
typedef union BCM53101_A0_RXPAUSEPKTS_IMPr_s {
	uint32_t v[1];
	uint32_t rxpausepkts_imp[1];
	uint32_t _rxpausepkts_imp;
} BCM53101_A0_RXPAUSEPKTS_IMPr_t;

#define BCM53101_A0_RXPAUSEPKTS_IMPr_CLR(r) (r).rxpausepkts_imp[0] = 0
#define BCM53101_A0_RXPAUSEPKTS_IMPr_SET(r,d) (r).rxpausepkts_imp[0] = d
#define BCM53101_A0_RXPAUSEPKTS_IMPr_GET(r) (r).rxpausepkts_imp[0]


/*
 * These macros can be used to access RxPausePkts_IMP.
 *
 */
#define BCM53101_A0_READ_RXPAUSEPKTS_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_RXPAUSEPKTS_IMPr,(r._rxpausepkts_imp),4)
#define BCM53101_A0_WRITE_RXPAUSEPKTS_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_RXPAUSEPKTS_IMPr,&(r._rxpausepkts_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXPAUSEPKTS_IMPr BCM53101_A0_RXPAUSEPKTS_IMPr
#define RXPAUSEPKTS_IMPr_SIZE BCM53101_A0_RXPAUSEPKTS_IMPr_SIZE
typedef BCM53101_A0_RXPAUSEPKTS_IMPr_t RXPAUSEPKTS_IMPr_t;
#define RXPAUSEPKTS_IMPr_CLR BCM53101_A0_RXPAUSEPKTS_IMPr_CLR
#define RXPAUSEPKTS_IMPr_SET BCM53101_A0_RXPAUSEPKTS_IMPr_SET
#define RXPAUSEPKTS_IMPr_GET BCM53101_A0_RXPAUSEPKTS_IMPr_GET
#define READ_RXPAUSEPKTS_IMPr BCM53101_A0_READ_RXPAUSEPKTS_IMPr
#define WRITE_RXPAUSEPKTS_IMPr BCM53101_A0_WRITE_RXPAUSEPKTS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RXPAUSEPKTS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RxSAChanges
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Rx SA Change Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_RXSACHANGESr 0x000020a0

#define BCM53101_A0_RXSACHANGESr_SIZE 4

/*
 * This structure should be used to declare and program RxSAChanges.
 *
 */
typedef union BCM53101_A0_RXSACHANGESr_s {
	uint32_t v[1];
	uint32_t rxsachanges[1];
	uint32_t _rxsachanges;
} BCM53101_A0_RXSACHANGESr_t;

#define BCM53101_A0_RXSACHANGESr_CLR(r) (r).rxsachanges[0] = 0
#define BCM53101_A0_RXSACHANGESr_SET(r,d) (r).rxsachanges[0] = d
#define BCM53101_A0_RXSACHANGESr_GET(r) (r).rxsachanges[0]


/*
 * These macros can be used to access RxSAChanges.
 *
 */
#define BCM53101_A0_READ_RXSACHANGESr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_RXSACHANGESr,(r._rxsachanges),4)
#define BCM53101_A0_WRITE_RXSACHANGESr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_RXSACHANGESr,&(r._rxsachanges),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXSACHANGESr BCM53101_A0_RXSACHANGESr
#define RXSACHANGESr_SIZE BCM53101_A0_RXSACHANGESr_SIZE
typedef BCM53101_A0_RXSACHANGESr_t RXSACHANGESr_t;
#define RXSACHANGESr_CLR BCM53101_A0_RXSACHANGESr_CLR
#define RXSACHANGESr_SET BCM53101_A0_RXSACHANGESr_SET
#define RXSACHANGESr_GET BCM53101_A0_RXSACHANGESr_GET
#define READ_RXSACHANGESr BCM53101_A0_READ_RXSACHANGESr
#define WRITE_RXSACHANGESr BCM53101_A0_WRITE_RXSACHANGESr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RXSACHANGESr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RxSAChanges_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx SA Change Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_RXSACHANGES_IMPr 0x000028a0

#define BCM53101_A0_RXSACHANGES_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RxSAChanges_IMP.
 *
 */
typedef union BCM53101_A0_RXSACHANGES_IMPr_s {
	uint32_t v[1];
	uint32_t rxsachanges_imp[1];
	uint32_t _rxsachanges_imp;
} BCM53101_A0_RXSACHANGES_IMPr_t;

#define BCM53101_A0_RXSACHANGES_IMPr_CLR(r) (r).rxsachanges_imp[0] = 0
#define BCM53101_A0_RXSACHANGES_IMPr_SET(r,d) (r).rxsachanges_imp[0] = d
#define BCM53101_A0_RXSACHANGES_IMPr_GET(r) (r).rxsachanges_imp[0]


/*
 * These macros can be used to access RxSAChanges_IMP.
 *
 */
#define BCM53101_A0_READ_RXSACHANGES_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_RXSACHANGES_IMPr,(r._rxsachanges_imp),4)
#define BCM53101_A0_WRITE_RXSACHANGES_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_RXSACHANGES_IMPr,&(r._rxsachanges_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXSACHANGES_IMPr BCM53101_A0_RXSACHANGES_IMPr
#define RXSACHANGES_IMPr_SIZE BCM53101_A0_RXSACHANGES_IMPr_SIZE
typedef BCM53101_A0_RXSACHANGES_IMPr_t RXSACHANGES_IMPr_t;
#define RXSACHANGES_IMPr_CLR BCM53101_A0_RXSACHANGES_IMPr_CLR
#define RXSACHANGES_IMPr_SET BCM53101_A0_RXSACHANGES_IMPr_SET
#define RXSACHANGES_IMPr_GET BCM53101_A0_RXSACHANGES_IMPr_GET
#define READ_RXSACHANGES_IMPr BCM53101_A0_READ_RXSACHANGES_IMPr
#define WRITE_RXSACHANGES_IMPr BCM53101_A0_WRITE_RXSACHANGES_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RXSACHANGES_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RxUndersizePkts
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Rx Under Size Packet Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_RXUNDERSIZEPKTSr 0x00002058

#define BCM53101_A0_RXUNDERSIZEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxUndersizePkts.
 *
 */
typedef union BCM53101_A0_RXUNDERSIZEPKTSr_s {
	uint32_t v[1];
	uint32_t rxundersizepkts[1];
	uint32_t _rxundersizepkts;
} BCM53101_A0_RXUNDERSIZEPKTSr_t;

#define BCM53101_A0_RXUNDERSIZEPKTSr_CLR(r) (r).rxundersizepkts[0] = 0
#define BCM53101_A0_RXUNDERSIZEPKTSr_SET(r,d) (r).rxundersizepkts[0] = d
#define BCM53101_A0_RXUNDERSIZEPKTSr_GET(r) (r).rxundersizepkts[0]


/*
 * These macros can be used to access RxUndersizePkts.
 *
 */
#define BCM53101_A0_READ_RXUNDERSIZEPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_RXUNDERSIZEPKTSr,(r._rxundersizepkts),4)
#define BCM53101_A0_WRITE_RXUNDERSIZEPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_RXUNDERSIZEPKTSr,&(r._rxundersizepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXUNDERSIZEPKTSr BCM53101_A0_RXUNDERSIZEPKTSr
#define RXUNDERSIZEPKTSr_SIZE BCM53101_A0_RXUNDERSIZEPKTSr_SIZE
typedef BCM53101_A0_RXUNDERSIZEPKTSr_t RXUNDERSIZEPKTSr_t;
#define RXUNDERSIZEPKTSr_CLR BCM53101_A0_RXUNDERSIZEPKTSr_CLR
#define RXUNDERSIZEPKTSr_SET BCM53101_A0_RXUNDERSIZEPKTSr_SET
#define RXUNDERSIZEPKTSr_GET BCM53101_A0_RXUNDERSIZEPKTSr_GET
#define READ_RXUNDERSIZEPKTSr BCM53101_A0_READ_RXUNDERSIZEPKTSr
#define WRITE_RXUNDERSIZEPKTSr BCM53101_A0_WRITE_RXUNDERSIZEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RXUNDERSIZEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RxUndersizePkts_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Under Size Packet Octets Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_RXUNDERSIZEPKTS_IMPr 0x00002858

#define BCM53101_A0_RXUNDERSIZEPKTS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RxUndersizePkts_IMP.
 *
 */
typedef union BCM53101_A0_RXUNDERSIZEPKTS_IMPr_s {
	uint32_t v[1];
	uint32_t rxundersizepkts_imp[1];
	uint32_t _rxundersizepkts_imp;
} BCM53101_A0_RXUNDERSIZEPKTS_IMPr_t;

#define BCM53101_A0_RXUNDERSIZEPKTS_IMPr_CLR(r) (r).rxundersizepkts_imp[0] = 0
#define BCM53101_A0_RXUNDERSIZEPKTS_IMPr_SET(r,d) (r).rxundersizepkts_imp[0] = d
#define BCM53101_A0_RXUNDERSIZEPKTS_IMPr_GET(r) (r).rxundersizepkts_imp[0]


/*
 * These macros can be used to access RxUndersizePkts_IMP.
 *
 */
#define BCM53101_A0_READ_RXUNDERSIZEPKTS_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_RXUNDERSIZEPKTS_IMPr,(r._rxundersizepkts_imp),4)
#define BCM53101_A0_WRITE_RXUNDERSIZEPKTS_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_RXUNDERSIZEPKTS_IMPr,&(r._rxundersizepkts_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXUNDERSIZEPKTS_IMPr BCM53101_A0_RXUNDERSIZEPKTS_IMPr
#define RXUNDERSIZEPKTS_IMPr_SIZE BCM53101_A0_RXUNDERSIZEPKTS_IMPr_SIZE
typedef BCM53101_A0_RXUNDERSIZEPKTS_IMPr_t RXUNDERSIZEPKTS_IMPr_t;
#define RXUNDERSIZEPKTS_IMPr_CLR BCM53101_A0_RXUNDERSIZEPKTS_IMPr_CLR
#define RXUNDERSIZEPKTS_IMPr_SET BCM53101_A0_RXUNDERSIZEPKTS_IMPr_SET
#define RXUNDERSIZEPKTS_IMPr_GET BCM53101_A0_RXUNDERSIZEPKTS_IMPr_GET
#define READ_RXUNDERSIZEPKTS_IMPr BCM53101_A0_READ_RXUNDERSIZEPKTS_IMPr
#define WRITE_RXUNDERSIZEPKTS_IMPr BCM53101_A0_WRITE_RXUNDERSIZEPKTS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RXUNDERSIZEPKTS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RxUnicastPkts
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Rx Unicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_RXUNICASTPKTSr 0x00002094

#define BCM53101_A0_RXUNICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program RxUnicastPkts.
 *
 */
typedef union BCM53101_A0_RXUNICASTPKTSr_s {
	uint32_t v[1];
	uint32_t rxunicastpkts[1];
	uint32_t _rxunicastpkts;
} BCM53101_A0_RXUNICASTPKTSr_t;

#define BCM53101_A0_RXUNICASTPKTSr_CLR(r) (r).rxunicastpkts[0] = 0
#define BCM53101_A0_RXUNICASTPKTSr_SET(r,d) (r).rxunicastpkts[0] = d
#define BCM53101_A0_RXUNICASTPKTSr_GET(r) (r).rxunicastpkts[0]


/*
 * These macros can be used to access RxUnicastPkts.
 *
 */
#define BCM53101_A0_READ_RXUNICASTPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_RXUNICASTPKTSr,(r._rxunicastpkts),4)
#define BCM53101_A0_WRITE_RXUNICASTPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_RXUNICASTPKTSr,&(r._rxunicastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXUNICASTPKTSr BCM53101_A0_RXUNICASTPKTSr
#define RXUNICASTPKTSr_SIZE BCM53101_A0_RXUNICASTPKTSr_SIZE
typedef BCM53101_A0_RXUNICASTPKTSr_t RXUNICASTPKTSr_t;
#define RXUNICASTPKTSr_CLR BCM53101_A0_RXUNICASTPKTSr_CLR
#define RXUNICASTPKTSr_SET BCM53101_A0_RXUNICASTPKTSr_SET
#define RXUNICASTPKTSr_GET BCM53101_A0_RXUNICASTPKTSr_GET
#define READ_RXUNICASTPKTSr BCM53101_A0_READ_RXUNICASTPKTSr
#define WRITE_RXUNICASTPKTSr BCM53101_A0_WRITE_RXUNICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RXUNICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  RxUnicastPkts_IMP
 * BLOCKS:   CPIC
 * DESC:     Rx Unicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_RXUNICASTPKTS_IMPr 0x00002894

#define BCM53101_A0_RXUNICASTPKTS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program RxUnicastPkts_IMP.
 *
 */
typedef union BCM53101_A0_RXUNICASTPKTS_IMPr_s {
	uint32_t v[1];
	uint32_t rxunicastpkts_imp[1];
	uint32_t _rxunicastpkts_imp;
} BCM53101_A0_RXUNICASTPKTS_IMPr_t;

#define BCM53101_A0_RXUNICASTPKTS_IMPr_CLR(r) (r).rxunicastpkts_imp[0] = 0
#define BCM53101_A0_RXUNICASTPKTS_IMPr_SET(r,d) (r).rxunicastpkts_imp[0] = d
#define BCM53101_A0_RXUNICASTPKTS_IMPr_GET(r) (r).rxunicastpkts_imp[0]


/*
 * These macros can be used to access RxUnicastPkts_IMP.
 *
 */
#define BCM53101_A0_READ_RXUNICASTPKTS_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_RXUNICASTPKTS_IMPr,(r._rxunicastpkts_imp),4)
#define BCM53101_A0_WRITE_RXUNICASTPKTS_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_RXUNICASTPKTS_IMPr,&(r._rxunicastpkts_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define RXUNICASTPKTS_IMPr BCM53101_A0_RXUNICASTPKTS_IMPr
#define RXUNICASTPKTS_IMPr_SIZE BCM53101_A0_RXUNICASTPKTS_IMPr_SIZE
typedef BCM53101_A0_RXUNICASTPKTS_IMPr_t RXUNICASTPKTS_IMPr_t;
#define RXUNICASTPKTS_IMPr_CLR BCM53101_A0_RXUNICASTPKTS_IMPr_CLR
#define RXUNICASTPKTS_IMPr_SET BCM53101_A0_RXUNICASTPKTS_IMPr_SET
#define RXUNICASTPKTS_IMPr_GET BCM53101_A0_RXUNICASTPKTS_IMPr_GET
#define READ_RXUNICASTPKTS_IMPr BCM53101_A0_READ_RXUNICASTPKTS_IMPr
#define WRITE_RXUNICASTPKTS_IMPr BCM53101_A0_WRITE_RXUNICASTPKTS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_RXUNICASTPKTS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  SFT_LRN_CTL
 * BLOCKS:   SYS
 * DESC:     Software Learning Control
 * SIZE:     16
 * FIELDS:
 *     SW_LEARN_CNTL    bit[8] : Port 8.bit[5:0] : Port 5-0.The behaviors are as follows. a. Forwarding behavior: Incoming packet with unknown SA will be copied to CPU port. b. Learning behavior: Alow S/W to decide whether incoming packet learn or not. In S/W learning mode, the H/W learning mechnism will be disabled automatically. c. Refreshed behavior: Allow refreshed mechnism to operate properly even through the H/W learning had been disabled.This field makes no effect if the disable learning is enable(page 00h, addr 3Ch)It is not allowed to enable software learning for WAN port, since all frames from WAN port are already sent to IMP port.0: Software learning control disabled.Forwarding/Learning/Refreshed behavior to keep hardware operation.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_SFT_LRN_CTLr 0x0000003e

#define BCM53101_A0_SFT_LRN_CTLr_SIZE 2

/*
 * This structure should be used to declare and program SFT_LRN_CTL.
 *
 */
typedef union BCM53101_A0_SFT_LRN_CTLr_s {
	uint32_t v[1];
	uint32_t sft_lrn_ctl[1];
	uint32_t _sft_lrn_ctl;
} BCM53101_A0_SFT_LRN_CTLr_t;

#define BCM53101_A0_SFT_LRN_CTLr_CLR(r) (r).sft_lrn_ctl[0] = 0
#define BCM53101_A0_SFT_LRN_CTLr_SET(r,d) (r).sft_lrn_ctl[0] = d
#define BCM53101_A0_SFT_LRN_CTLr_GET(r) (r).sft_lrn_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_SFT_LRN_CTLr_SW_LEARN_CNTLf_GET(r) (((r).sft_lrn_ctl[0]) & 0x1ff)
#define BCM53101_A0_SFT_LRN_CTLr_SW_LEARN_CNTLf_SET(r,f) (r).sft_lrn_ctl[0]=(((r).sft_lrn_ctl[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_SFT_LRN_CTLr_RESERVEDf_GET(r) ((((r).sft_lrn_ctl[0]) >> 9) & 0x7f)
#define BCM53101_A0_SFT_LRN_CTLr_RESERVEDf_SET(r,f) (r).sft_lrn_ctl[0]=(((r).sft_lrn_ctl[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access SFT_LRN_CTL.
 *
 */
#define BCM53101_A0_READ_SFT_LRN_CTLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_SFT_LRN_CTLr,(r._sft_lrn_ctl),2)
#define BCM53101_A0_WRITE_SFT_LRN_CTLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_SFT_LRN_CTLr,&(r._sft_lrn_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SFT_LRN_CTLr BCM53101_A0_SFT_LRN_CTLr
#define SFT_LRN_CTLr_SIZE BCM53101_A0_SFT_LRN_CTLr_SIZE
typedef BCM53101_A0_SFT_LRN_CTLr_t SFT_LRN_CTLr_t;
#define SFT_LRN_CTLr_CLR BCM53101_A0_SFT_LRN_CTLr_CLR
#define SFT_LRN_CTLr_SET BCM53101_A0_SFT_LRN_CTLr_SET
#define SFT_LRN_CTLr_GET BCM53101_A0_SFT_LRN_CTLr_GET
#define SFT_LRN_CTLr_SW_LEARN_CNTLf_GET BCM53101_A0_SFT_LRN_CTLr_SW_LEARN_CNTLf_GET
#define SFT_LRN_CTLr_SW_LEARN_CNTLf_SET BCM53101_A0_SFT_LRN_CTLr_SW_LEARN_CNTLf_SET
#define SFT_LRN_CTLr_RESERVEDf_GET BCM53101_A0_SFT_LRN_CTLr_RESERVEDf_GET
#define SFT_LRN_CTLr_RESERVEDf_SET BCM53101_A0_SFT_LRN_CTLr_RESERVEDf_SET
#define READ_SFT_LRN_CTLr BCM53101_A0_READ_SFT_LRN_CTLr
#define WRITE_SFT_LRN_CTLr BCM53101_A0_WRITE_SFT_LRN_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_SFT_LRN_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * SWFORMAT:  SOFTWARE_BLOCKMAP
 * BLOCKS:  
 * DESC:     Software Blockmap
 * SIZE:     5
 * FIELDS:
 *     CPIC             Software Block Flag for CPIC
 *     EPIC             Software Block Flag for EPIC
 *     EXP              Software Block Flag for EXP
 *     SPI              Software Block Flag for SPI
 *     SYS              Software Block Flag for SYS
 *
 ******************************************************************************/
#define BCM53101_A0_SOFTWARE_BLOCKMAP 0x00000000

#define BCM53101_A0_SOFTWARE_BLOCKMAP_SIZE 1

/*
 * This structure should be used to declare and program SOFTWARE_BLOCKMAP.
 *
 */
typedef union BCM53101_A0_SOFTWARE_BLOCKMAP_s {
	uint32_t v[1];
	uint32_t software_blockmap[1];
	uint32_t _software_blockmap;
} BCM53101_A0_SOFTWARE_BLOCKMAP_t;

#define BCM53101_A0_SOFTWARE_BLOCKMAP_CLR(r) (r).software_blockmap[0] = 0
#define BCM53101_A0_SOFTWARE_BLOCKMAP_SET(r,d) (r).software_blockmap[0] = d
#define BCM53101_A0_SOFTWARE_BLOCKMAP_GET(r) (r).software_blockmap[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_SOFTWARE_BLOCKMAP_CPICf_GET(r) (((r).software_blockmap[0]) & 0x1)
#define BCM53101_A0_SOFTWARE_BLOCKMAP_CPICf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_SOFTWARE_BLOCKMAP_EPICf_GET(r) ((((r).software_blockmap[0]) >> 1) & 0x1)
#define BCM53101_A0_SOFTWARE_BLOCKMAP_EPICf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_SOFTWARE_BLOCKMAP_EXPf_GET(r) ((((r).software_blockmap[0]) >> 2) & 0x1)
#define BCM53101_A0_SOFTWARE_BLOCKMAP_EXPf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_SOFTWARE_BLOCKMAP_SPIf_GET(r) ((((r).software_blockmap[0]) >> 3) & 0x1)
#define BCM53101_A0_SOFTWARE_BLOCKMAP_SPIf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_SOFTWARE_BLOCKMAP_SYSf_GET(r) ((((r).software_blockmap[0]) >> 4) & 0x1)
#define BCM53101_A0_SOFTWARE_BLOCKMAP_SYSf_SET(r,f) (r).software_blockmap[0]=(((r).software_blockmap[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SOFTWARE_BLOCKMAP BCM53101_A0_SOFTWARE_BLOCKMAP
#define SOFTWARE_BLOCKMAP_SIZE BCM53101_A0_SOFTWARE_BLOCKMAP_SIZE
typedef BCM53101_A0_SOFTWARE_BLOCKMAP_t SOFTWARE_BLOCKMAP_t;
#define SOFTWARE_BLOCKMAP_CLR BCM53101_A0_SOFTWARE_BLOCKMAP_CLR
#define SOFTWARE_BLOCKMAP_SET BCM53101_A0_SOFTWARE_BLOCKMAP_SET
#define SOFTWARE_BLOCKMAP_GET BCM53101_A0_SOFTWARE_BLOCKMAP_GET
#define SOFTWARE_BLOCKMAP_CPICf_GET BCM53101_A0_SOFTWARE_BLOCKMAP_CPICf_GET
#define SOFTWARE_BLOCKMAP_CPICf_SET BCM53101_A0_SOFTWARE_BLOCKMAP_CPICf_SET
#define SOFTWARE_BLOCKMAP_EPICf_GET BCM53101_A0_SOFTWARE_BLOCKMAP_EPICf_GET
#define SOFTWARE_BLOCKMAP_EPICf_SET BCM53101_A0_SOFTWARE_BLOCKMAP_EPICf_SET
#define SOFTWARE_BLOCKMAP_EXPf_GET BCM53101_A0_SOFTWARE_BLOCKMAP_EXPf_GET
#define SOFTWARE_BLOCKMAP_EXPf_SET BCM53101_A0_SOFTWARE_BLOCKMAP_EXPf_SET
#define SOFTWARE_BLOCKMAP_SPIf_GET BCM53101_A0_SOFTWARE_BLOCKMAP_SPIf_GET
#define SOFTWARE_BLOCKMAP_SPIf_SET BCM53101_A0_SOFTWARE_BLOCKMAP_SPIf_SET
#define SOFTWARE_BLOCKMAP_SYSf_GET BCM53101_A0_SOFTWARE_BLOCKMAP_SYSf_GET
#define SOFTWARE_BLOCKMAP_SYSf_SET BCM53101_A0_SOFTWARE_BLOCKMAP_SYSf_SET
#define READ_SOFTWARE_BLOCKMAP BCM53101_A0_READ_SOFTWARE_BLOCKMAP
#define WRITE_SOFTWARE_BLOCKMAP BCM53101_A0_WRITE_SOFTWARE_BLOCKMAP

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_SOFTWARE_BLOCKMAP'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  SPDSTS
 * BLOCKS:   SYS
 * DESC:     Port Speed Summary Register
 * SIZE:     32
 * FIELDS:
 *     PORT_SPD         Port Speed.18 bit field indicating the operating speed for each 10/100/1000BASE-T port.Bit 17:16 = IMP PortBit 11:0 = Port 5 - Port 000 = 10 Mb/s01 = 100 Mb/s10 = 1000 Mb/s
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_SPDSTSr 0x00000104

#define BCM53101_A0_SPDSTSr_SIZE 4

/*
 * This structure should be used to declare and program SPDSTS.
 *
 */
typedef union BCM53101_A0_SPDSTSr_s {
	uint32_t v[1];
	uint32_t spdsts[1];
	uint32_t _spdsts;
} BCM53101_A0_SPDSTSr_t;

#define BCM53101_A0_SPDSTSr_CLR(r) (r).spdsts[0] = 0
#define BCM53101_A0_SPDSTSr_SET(r,d) (r).spdsts[0] = d
#define BCM53101_A0_SPDSTSr_GET(r) (r).spdsts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_SPDSTSr_PORT_SPDf_GET(r) (((r).spdsts[0]) & 0x3ffff)
#define BCM53101_A0_SPDSTSr_PORT_SPDf_SET(r,f) (r).spdsts[0]=(((r).spdsts[0] & ~((uint32_t)0x3ffff)) | (((uint32_t)f) & 0x3ffff))
#define BCM53101_A0_SPDSTSr_RESERVEDf_GET(r) ((((r).spdsts[0]) >> 18) & 0x3fff)
#define BCM53101_A0_SPDSTSr_RESERVEDf_SET(r,f) (r).spdsts[0]=(((r).spdsts[0] & ~((uint32_t)0x3fff << 18)) | ((((uint32_t)f) & 0x3fff) << 18))

/*
 * These macros can be used to access SPDSTS.
 *
 */
#define BCM53101_A0_READ_SPDSTSr(u,r) cdk_robo_reg_read(u,BCM53101_A0_SPDSTSr,(r._spdsts),4)
#define BCM53101_A0_WRITE_SPDSTSr(u,r) cdk_robo_reg_write(u,BCM53101_A0_SPDSTSr,&(r._spdsts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPDSTSr BCM53101_A0_SPDSTSr
#define SPDSTSr_SIZE BCM53101_A0_SPDSTSr_SIZE
typedef BCM53101_A0_SPDSTSr_t SPDSTSr_t;
#define SPDSTSr_CLR BCM53101_A0_SPDSTSr_CLR
#define SPDSTSr_SET BCM53101_A0_SPDSTSr_SET
#define SPDSTSr_GET BCM53101_A0_SPDSTSr_GET
#define SPDSTSr_PORT_SPDf_GET BCM53101_A0_SPDSTSr_PORT_SPDf_GET
#define SPDSTSr_PORT_SPDf_SET BCM53101_A0_SPDSTSr_PORT_SPDf_SET
#define SPDSTSr_RESERVEDf_GET BCM53101_A0_SPDSTSr_RESERVEDf_GET
#define SPDSTSr_RESERVEDf_SET BCM53101_A0_SPDSTSr_RESERVEDf_SET
#define READ_SPDSTSr BCM53101_A0_READ_SPDSTSr
#define WRITE_SPDSTSr BCM53101_A0_WRITE_SPDSTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_SPDSTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  SPIDIO0
 * BLOCKS:   SYS
 * DESC:     SPI Data I/O Registers 0
 * SIZE:     8
 * FIELDS:
 *     RESERVED         SPI Data I/O 0
 *
 ******************************************************************************/
#define BCM53101_A0_SPIDIO0r 0x0000fff0

#define BCM53101_A0_SPIDIO0r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO0.
 *
 */
typedef union BCM53101_A0_SPIDIO0r_s {
	uint32_t v[1];
	uint32_t spidio0[1];
	uint32_t _spidio0;
} BCM53101_A0_SPIDIO0r_t;

#define BCM53101_A0_SPIDIO0r_CLR(r) (r).spidio0[0] = 0
#define BCM53101_A0_SPIDIO0r_SET(r,d) (r).spidio0[0] = d
#define BCM53101_A0_SPIDIO0r_GET(r) (r).spidio0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_SPIDIO0r_RESERVEDf_GET(r) (((r).spidio0[0]) & 0xff)
#define BCM53101_A0_SPIDIO0r_RESERVEDf_SET(r,f) (r).spidio0[0]=(((r).spidio0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO0.
 *
 */
#define BCM53101_A0_READ_SPIDIO0r(u,r) cdk_robo_reg_read(u,BCM53101_A0_SPIDIO0r,(r._spidio0),1)
#define BCM53101_A0_WRITE_SPIDIO0r(u,r) cdk_robo_reg_write(u,BCM53101_A0_SPIDIO0r,&(r._spidio0),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO0r BCM53101_A0_SPIDIO0r
#define SPIDIO0r_SIZE BCM53101_A0_SPIDIO0r_SIZE
typedef BCM53101_A0_SPIDIO0r_t SPIDIO0r_t;
#define SPIDIO0r_CLR BCM53101_A0_SPIDIO0r_CLR
#define SPIDIO0r_SET BCM53101_A0_SPIDIO0r_SET
#define SPIDIO0r_GET BCM53101_A0_SPIDIO0r_GET
#define SPIDIO0r_RESERVEDf_GET BCM53101_A0_SPIDIO0r_RESERVEDf_GET
#define SPIDIO0r_RESERVEDf_SET BCM53101_A0_SPIDIO0r_RESERVEDf_SET
#define READ_SPIDIO0r BCM53101_A0_READ_SPIDIO0r
#define WRITE_SPIDIO0r BCM53101_A0_WRITE_SPIDIO0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_SPIDIO0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  SPIDIO1
 * BLOCKS:   SYS
 * DESC:     SPI Data I/O Registers 1
 * SIZE:     8
 * FIELDS:
 *     RESERVED         SPI Data I/O 1
 *
 ******************************************************************************/
#define BCM53101_A0_SPIDIO1r 0x0000fff1

#define BCM53101_A0_SPIDIO1r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO1.
 *
 */
typedef union BCM53101_A0_SPIDIO1r_s {
	uint32_t v[1];
	uint32_t spidio1[1];
	uint32_t _spidio1;
} BCM53101_A0_SPIDIO1r_t;

#define BCM53101_A0_SPIDIO1r_CLR(r) (r).spidio1[0] = 0
#define BCM53101_A0_SPIDIO1r_SET(r,d) (r).spidio1[0] = d
#define BCM53101_A0_SPIDIO1r_GET(r) (r).spidio1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_SPIDIO1r_RESERVEDf_GET(r) (((r).spidio1[0]) & 0xff)
#define BCM53101_A0_SPIDIO1r_RESERVEDf_SET(r,f) (r).spidio1[0]=(((r).spidio1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO1.
 *
 */
#define BCM53101_A0_READ_SPIDIO1r(u,r) cdk_robo_reg_read(u,BCM53101_A0_SPIDIO1r,(r._spidio1),1)
#define BCM53101_A0_WRITE_SPIDIO1r(u,r) cdk_robo_reg_write(u,BCM53101_A0_SPIDIO1r,&(r._spidio1),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO1r BCM53101_A0_SPIDIO1r
#define SPIDIO1r_SIZE BCM53101_A0_SPIDIO1r_SIZE
typedef BCM53101_A0_SPIDIO1r_t SPIDIO1r_t;
#define SPIDIO1r_CLR BCM53101_A0_SPIDIO1r_CLR
#define SPIDIO1r_SET BCM53101_A0_SPIDIO1r_SET
#define SPIDIO1r_GET BCM53101_A0_SPIDIO1r_GET
#define SPIDIO1r_RESERVEDf_GET BCM53101_A0_SPIDIO1r_RESERVEDf_GET
#define SPIDIO1r_RESERVEDf_SET BCM53101_A0_SPIDIO1r_RESERVEDf_SET
#define READ_SPIDIO1r BCM53101_A0_READ_SPIDIO1r
#define WRITE_SPIDIO1r BCM53101_A0_WRITE_SPIDIO1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_SPIDIO1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  SPIDIO2
 * BLOCKS:   SYS
 * DESC:     SPI Data I/O Registers 2
 * SIZE:     8
 * FIELDS:
 *     RESERVED         SPI Data I/O 2
 *
 ******************************************************************************/
#define BCM53101_A0_SPIDIO2r 0x0000fff2

#define BCM53101_A0_SPIDIO2r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO2.
 *
 */
typedef union BCM53101_A0_SPIDIO2r_s {
	uint32_t v[1];
	uint32_t spidio2[1];
	uint32_t _spidio2;
} BCM53101_A0_SPIDIO2r_t;

#define BCM53101_A0_SPIDIO2r_CLR(r) (r).spidio2[0] = 0
#define BCM53101_A0_SPIDIO2r_SET(r,d) (r).spidio2[0] = d
#define BCM53101_A0_SPIDIO2r_GET(r) (r).spidio2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_SPIDIO2r_RESERVEDf_GET(r) (((r).spidio2[0]) & 0xff)
#define BCM53101_A0_SPIDIO2r_RESERVEDf_SET(r,f) (r).spidio2[0]=(((r).spidio2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO2.
 *
 */
#define BCM53101_A0_READ_SPIDIO2r(u,r) cdk_robo_reg_read(u,BCM53101_A0_SPIDIO2r,(r._spidio2),1)
#define BCM53101_A0_WRITE_SPIDIO2r(u,r) cdk_robo_reg_write(u,BCM53101_A0_SPIDIO2r,&(r._spidio2),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO2r BCM53101_A0_SPIDIO2r
#define SPIDIO2r_SIZE BCM53101_A0_SPIDIO2r_SIZE
typedef BCM53101_A0_SPIDIO2r_t SPIDIO2r_t;
#define SPIDIO2r_CLR BCM53101_A0_SPIDIO2r_CLR
#define SPIDIO2r_SET BCM53101_A0_SPIDIO2r_SET
#define SPIDIO2r_GET BCM53101_A0_SPIDIO2r_GET
#define SPIDIO2r_RESERVEDf_GET BCM53101_A0_SPIDIO2r_RESERVEDf_GET
#define SPIDIO2r_RESERVEDf_SET BCM53101_A0_SPIDIO2r_RESERVEDf_SET
#define READ_SPIDIO2r BCM53101_A0_READ_SPIDIO2r
#define WRITE_SPIDIO2r BCM53101_A0_WRITE_SPIDIO2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_SPIDIO2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  SPIDIO3
 * BLOCKS:   SYS
 * DESC:     SPI Data I/O Registers 3
 * SIZE:     8
 * FIELDS:
 *     RESERVED         SPI Data I/O 3
 *
 ******************************************************************************/
#define BCM53101_A0_SPIDIO3r 0x0000fff3

#define BCM53101_A0_SPIDIO3r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO3.
 *
 */
typedef union BCM53101_A0_SPIDIO3r_s {
	uint32_t v[1];
	uint32_t spidio3[1];
	uint32_t _spidio3;
} BCM53101_A0_SPIDIO3r_t;

#define BCM53101_A0_SPIDIO3r_CLR(r) (r).spidio3[0] = 0
#define BCM53101_A0_SPIDIO3r_SET(r,d) (r).spidio3[0] = d
#define BCM53101_A0_SPIDIO3r_GET(r) (r).spidio3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_SPIDIO3r_RESERVEDf_GET(r) (((r).spidio3[0]) & 0xff)
#define BCM53101_A0_SPIDIO3r_RESERVEDf_SET(r,f) (r).spidio3[0]=(((r).spidio3[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO3.
 *
 */
#define BCM53101_A0_READ_SPIDIO3r(u,r) cdk_robo_reg_read(u,BCM53101_A0_SPIDIO3r,(r._spidio3),1)
#define BCM53101_A0_WRITE_SPIDIO3r(u,r) cdk_robo_reg_write(u,BCM53101_A0_SPIDIO3r,&(r._spidio3),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO3r BCM53101_A0_SPIDIO3r
#define SPIDIO3r_SIZE BCM53101_A0_SPIDIO3r_SIZE
typedef BCM53101_A0_SPIDIO3r_t SPIDIO3r_t;
#define SPIDIO3r_CLR BCM53101_A0_SPIDIO3r_CLR
#define SPIDIO3r_SET BCM53101_A0_SPIDIO3r_SET
#define SPIDIO3r_GET BCM53101_A0_SPIDIO3r_GET
#define SPIDIO3r_RESERVEDf_GET BCM53101_A0_SPIDIO3r_RESERVEDf_GET
#define SPIDIO3r_RESERVEDf_SET BCM53101_A0_SPIDIO3r_RESERVEDf_SET
#define READ_SPIDIO3r BCM53101_A0_READ_SPIDIO3r
#define WRITE_SPIDIO3r BCM53101_A0_WRITE_SPIDIO3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_SPIDIO3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  SPIDIO4
 * BLOCKS:   SYS
 * DESC:     SPI Data I/O Registers 4
 * SIZE:     8
 * FIELDS:
 *     RESERVED         SPI Data I/O 4
 *
 ******************************************************************************/
#define BCM53101_A0_SPIDIO4r 0x0000fff4

#define BCM53101_A0_SPIDIO4r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO4.
 *
 */
typedef union BCM53101_A0_SPIDIO4r_s {
	uint32_t v[1];
	uint32_t spidio4[1];
	uint32_t _spidio4;
} BCM53101_A0_SPIDIO4r_t;

#define BCM53101_A0_SPIDIO4r_CLR(r) (r).spidio4[0] = 0
#define BCM53101_A0_SPIDIO4r_SET(r,d) (r).spidio4[0] = d
#define BCM53101_A0_SPIDIO4r_GET(r) (r).spidio4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_SPIDIO4r_RESERVEDf_GET(r) (((r).spidio4[0]) & 0xff)
#define BCM53101_A0_SPIDIO4r_RESERVEDf_SET(r,f) (r).spidio4[0]=(((r).spidio4[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO4.
 *
 */
#define BCM53101_A0_READ_SPIDIO4r(u,r) cdk_robo_reg_read(u,BCM53101_A0_SPIDIO4r,(r._spidio4),1)
#define BCM53101_A0_WRITE_SPIDIO4r(u,r) cdk_robo_reg_write(u,BCM53101_A0_SPIDIO4r,&(r._spidio4),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO4r BCM53101_A0_SPIDIO4r
#define SPIDIO4r_SIZE BCM53101_A0_SPIDIO4r_SIZE
typedef BCM53101_A0_SPIDIO4r_t SPIDIO4r_t;
#define SPIDIO4r_CLR BCM53101_A0_SPIDIO4r_CLR
#define SPIDIO4r_SET BCM53101_A0_SPIDIO4r_SET
#define SPIDIO4r_GET BCM53101_A0_SPIDIO4r_GET
#define SPIDIO4r_RESERVEDf_GET BCM53101_A0_SPIDIO4r_RESERVEDf_GET
#define SPIDIO4r_RESERVEDf_SET BCM53101_A0_SPIDIO4r_RESERVEDf_SET
#define READ_SPIDIO4r BCM53101_A0_READ_SPIDIO4r
#define WRITE_SPIDIO4r BCM53101_A0_WRITE_SPIDIO4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_SPIDIO4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  SPIDIO5
 * BLOCKS:   SYS
 * DESC:     SPI Data I/O Registers 5
 * SIZE:     8
 * FIELDS:
 *     RESERVED         SPI Data I/O 5
 *
 ******************************************************************************/
#define BCM53101_A0_SPIDIO5r 0x0000fff5

#define BCM53101_A0_SPIDIO5r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO5.
 *
 */
typedef union BCM53101_A0_SPIDIO5r_s {
	uint32_t v[1];
	uint32_t spidio5[1];
	uint32_t _spidio5;
} BCM53101_A0_SPIDIO5r_t;

#define BCM53101_A0_SPIDIO5r_CLR(r) (r).spidio5[0] = 0
#define BCM53101_A0_SPIDIO5r_SET(r,d) (r).spidio5[0] = d
#define BCM53101_A0_SPIDIO5r_GET(r) (r).spidio5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_SPIDIO5r_RESERVEDf_GET(r) (((r).spidio5[0]) & 0xff)
#define BCM53101_A0_SPIDIO5r_RESERVEDf_SET(r,f) (r).spidio5[0]=(((r).spidio5[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO5.
 *
 */
#define BCM53101_A0_READ_SPIDIO5r(u,r) cdk_robo_reg_read(u,BCM53101_A0_SPIDIO5r,(r._spidio5),1)
#define BCM53101_A0_WRITE_SPIDIO5r(u,r) cdk_robo_reg_write(u,BCM53101_A0_SPIDIO5r,&(r._spidio5),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO5r BCM53101_A0_SPIDIO5r
#define SPIDIO5r_SIZE BCM53101_A0_SPIDIO5r_SIZE
typedef BCM53101_A0_SPIDIO5r_t SPIDIO5r_t;
#define SPIDIO5r_CLR BCM53101_A0_SPIDIO5r_CLR
#define SPIDIO5r_SET BCM53101_A0_SPIDIO5r_SET
#define SPIDIO5r_GET BCM53101_A0_SPIDIO5r_GET
#define SPIDIO5r_RESERVEDf_GET BCM53101_A0_SPIDIO5r_RESERVEDf_GET
#define SPIDIO5r_RESERVEDf_SET BCM53101_A0_SPIDIO5r_RESERVEDf_SET
#define READ_SPIDIO5r BCM53101_A0_READ_SPIDIO5r
#define WRITE_SPIDIO5r BCM53101_A0_WRITE_SPIDIO5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_SPIDIO5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  SPIDIO6
 * BLOCKS:   SYS
 * DESC:     SPI Data I/O Registers 6
 * SIZE:     8
 * FIELDS:
 *     RESERVED         SPI Data I/O 6
 *
 ******************************************************************************/
#define BCM53101_A0_SPIDIO6r 0x0000fff6

#define BCM53101_A0_SPIDIO6r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO6.
 *
 */
typedef union BCM53101_A0_SPIDIO6r_s {
	uint32_t v[1];
	uint32_t spidio6[1];
	uint32_t _spidio6;
} BCM53101_A0_SPIDIO6r_t;

#define BCM53101_A0_SPIDIO6r_CLR(r) (r).spidio6[0] = 0
#define BCM53101_A0_SPIDIO6r_SET(r,d) (r).spidio6[0] = d
#define BCM53101_A0_SPIDIO6r_GET(r) (r).spidio6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_SPIDIO6r_RESERVEDf_GET(r) (((r).spidio6[0]) & 0xff)
#define BCM53101_A0_SPIDIO6r_RESERVEDf_SET(r,f) (r).spidio6[0]=(((r).spidio6[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO6.
 *
 */
#define BCM53101_A0_READ_SPIDIO6r(u,r) cdk_robo_reg_read(u,BCM53101_A0_SPIDIO6r,(r._spidio6),1)
#define BCM53101_A0_WRITE_SPIDIO6r(u,r) cdk_robo_reg_write(u,BCM53101_A0_SPIDIO6r,&(r._spidio6),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO6r BCM53101_A0_SPIDIO6r
#define SPIDIO6r_SIZE BCM53101_A0_SPIDIO6r_SIZE
typedef BCM53101_A0_SPIDIO6r_t SPIDIO6r_t;
#define SPIDIO6r_CLR BCM53101_A0_SPIDIO6r_CLR
#define SPIDIO6r_SET BCM53101_A0_SPIDIO6r_SET
#define SPIDIO6r_GET BCM53101_A0_SPIDIO6r_GET
#define SPIDIO6r_RESERVEDf_GET BCM53101_A0_SPIDIO6r_RESERVEDf_GET
#define SPIDIO6r_RESERVEDf_SET BCM53101_A0_SPIDIO6r_RESERVEDf_SET
#define READ_SPIDIO6r BCM53101_A0_READ_SPIDIO6r
#define WRITE_SPIDIO6r BCM53101_A0_WRITE_SPIDIO6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_SPIDIO6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  SPIDIO7
 * BLOCKS:   SYS
 * DESC:     SPI Data I/O Registers 7
 * SIZE:     8
 * FIELDS:
 *     RESERVED         SPI Data I/O 7
 *
 ******************************************************************************/
#define BCM53101_A0_SPIDIO7r 0x0000fff7

#define BCM53101_A0_SPIDIO7r_SIZE 1

/*
 * This structure should be used to declare and program SPIDIO7.
 *
 */
typedef union BCM53101_A0_SPIDIO7r_s {
	uint32_t v[1];
	uint32_t spidio7[1];
	uint32_t _spidio7;
} BCM53101_A0_SPIDIO7r_t;

#define BCM53101_A0_SPIDIO7r_CLR(r) (r).spidio7[0] = 0
#define BCM53101_A0_SPIDIO7r_SET(r,d) (r).spidio7[0] = d
#define BCM53101_A0_SPIDIO7r_GET(r) (r).spidio7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_SPIDIO7r_RESERVEDf_GET(r) (((r).spidio7[0]) & 0xff)
#define BCM53101_A0_SPIDIO7r_RESERVEDf_SET(r,f) (r).spidio7[0]=(((r).spidio7[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPIDIO7.
 *
 */
#define BCM53101_A0_READ_SPIDIO7r(u,r) cdk_robo_reg_read(u,BCM53101_A0_SPIDIO7r,(r._spidio7),1)
#define BCM53101_A0_WRITE_SPIDIO7r(u,r) cdk_robo_reg_write(u,BCM53101_A0_SPIDIO7r,&(r._spidio7),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPIDIO7r BCM53101_A0_SPIDIO7r
#define SPIDIO7r_SIZE BCM53101_A0_SPIDIO7r_SIZE
typedef BCM53101_A0_SPIDIO7r_t SPIDIO7r_t;
#define SPIDIO7r_CLR BCM53101_A0_SPIDIO7r_CLR
#define SPIDIO7r_SET BCM53101_A0_SPIDIO7r_SET
#define SPIDIO7r_GET BCM53101_A0_SPIDIO7r_GET
#define SPIDIO7r_RESERVEDf_GET BCM53101_A0_SPIDIO7r_RESERVEDf_GET
#define SPIDIO7r_RESERVEDf_SET BCM53101_A0_SPIDIO7r_RESERVEDf_SET
#define READ_SPIDIO7r BCM53101_A0_READ_SPIDIO7r
#define WRITE_SPIDIO7r BCM53101_A0_WRITE_SPIDIO7r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_SPIDIO7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  SPISTS
 * BLOCKS:   SYS
 * DESC:     SPI Control Registers
 * SIZE:     8
 * FIELDS:
 *     RESERVED         SPI Status Register
 *
 ******************************************************************************/
#define BCM53101_A0_SPISTSr 0x0000fffe

#define BCM53101_A0_SPISTSr_SIZE 1

/*
 * This structure should be used to declare and program SPISTS.
 *
 */
typedef union BCM53101_A0_SPISTSr_s {
	uint32_t v[1];
	uint32_t spists[1];
	uint32_t _spists;
} BCM53101_A0_SPISTSr_t;

#define BCM53101_A0_SPISTSr_CLR(r) (r).spists[0] = 0
#define BCM53101_A0_SPISTSr_SET(r,d) (r).spists[0] = d
#define BCM53101_A0_SPISTSr_GET(r) (r).spists[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_SPISTSr_RESERVEDf_GET(r) (((r).spists[0]) & 0xff)
#define BCM53101_A0_SPISTSr_RESERVEDf_SET(r,f) (r).spists[0]=(((r).spists[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff))

/*
 * These macros can be used to access SPISTS.
 *
 */
#define BCM53101_A0_READ_SPISTSr(u,r) cdk_robo_reg_read(u,BCM53101_A0_SPISTSr,(r._spists),1)
#define BCM53101_A0_WRITE_SPISTSr(u,r) cdk_robo_reg_write(u,BCM53101_A0_SPISTSr,&(r._spists),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPISTSr BCM53101_A0_SPISTSr
#define SPISTSr_SIZE BCM53101_A0_SPISTSr_SIZE
typedef BCM53101_A0_SPISTSr_t SPISTSr_t;
#define SPISTSr_CLR BCM53101_A0_SPISTSr_CLR
#define SPISTSr_SET BCM53101_A0_SPISTSr_SET
#define SPISTSr_GET BCM53101_A0_SPISTSr_GET
#define SPISTSr_RESERVEDf_GET BCM53101_A0_SPISTSr_RESERVEDf_GET
#define SPISTSr_RESERVEDf_SET BCM53101_A0_SPISTSr_RESERVEDf_SET
#define READ_SPISTSr BCM53101_A0_READ_SPISTSr
#define WRITE_SPISTSr BCM53101_A0_WRITE_SPISTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_SPISTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  SPTAGT
 * BLOCKS:   SYS
 * DESC:     Aging Time Control Register
 * SIZE:     32
 * FIELDS:
 *     AGE_TIME         Specifies the aging time in 0.5 seconds for dynamicallylearned address. Maximum age time is 524,287s. Note that while 802.1D specifies a range of values of 10 - 1,000,000 s, this register does not enforce this range. Setting the AGE_TIME to zero disables the aging process.
 *     AGE_CHANGE_EN    Set 1 to Change Aging Timer by AGE_TIME[19:0].
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_SPTAGTr 0x00000206

#define BCM53101_A0_SPTAGTr_SIZE 4

/*
 * This structure should be used to declare and program SPTAGT.
 *
 */
typedef union BCM53101_A0_SPTAGTr_s {
	uint32_t v[1];
	uint32_t sptagt[1];
	uint32_t _sptagt;
} BCM53101_A0_SPTAGTr_t;

#define BCM53101_A0_SPTAGTr_CLR(r) (r).sptagt[0] = 0
#define BCM53101_A0_SPTAGTr_SET(r,d) (r).sptagt[0] = d
#define BCM53101_A0_SPTAGTr_GET(r) (r).sptagt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_SPTAGTr_AGE_TIMEf_GET(r) (((r).sptagt[0]) & 0xfffff)
#define BCM53101_A0_SPTAGTr_AGE_TIMEf_SET(r,f) (r).sptagt[0]=(((r).sptagt[0] & ~((uint32_t)0xfffff)) | (((uint32_t)f) & 0xfffff))
#define BCM53101_A0_SPTAGTr_AGE_CHANGE_ENf_GET(r) ((((r).sptagt[0]) >> 20) & 0x1)
#define BCM53101_A0_SPTAGTr_AGE_CHANGE_ENf_SET(r,f) (r).sptagt[0]=(((r).sptagt[0] & ~((uint32_t)0x1 << 20)) | ((((uint32_t)f) & 0x1) << 20))
#define BCM53101_A0_SPTAGTr_RESERVEDf_GET(r) ((((r).sptagt[0]) >> 21) & 0x7ff)
#define BCM53101_A0_SPTAGTr_RESERVEDf_SET(r,f) (r).sptagt[0]=(((r).sptagt[0] & ~((uint32_t)0x7ff << 21)) | ((((uint32_t)f) & 0x7ff) << 21))

/*
 * These macros can be used to access SPTAGT.
 *
 */
#define BCM53101_A0_READ_SPTAGTr(u,r) cdk_robo_reg_read(u,BCM53101_A0_SPTAGTr,(r._sptagt),4)
#define BCM53101_A0_WRITE_SPTAGTr(u,r) cdk_robo_reg_write(u,BCM53101_A0_SPTAGTr,&(r._sptagt),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPTAGTr BCM53101_A0_SPTAGTr
#define SPTAGTr_SIZE BCM53101_A0_SPTAGTr_SIZE
typedef BCM53101_A0_SPTAGTr_t SPTAGTr_t;
#define SPTAGTr_CLR BCM53101_A0_SPTAGTr_CLR
#define SPTAGTr_SET BCM53101_A0_SPTAGTr_SET
#define SPTAGTr_GET BCM53101_A0_SPTAGTr_GET
#define SPTAGTr_AGE_TIMEf_GET BCM53101_A0_SPTAGTr_AGE_TIMEf_GET
#define SPTAGTr_AGE_TIMEf_SET BCM53101_A0_SPTAGTr_AGE_TIMEf_SET
#define SPTAGTr_AGE_CHANGE_ENf_GET BCM53101_A0_SPTAGTr_AGE_CHANGE_ENf_GET
#define SPTAGTr_AGE_CHANGE_ENf_SET BCM53101_A0_SPTAGTr_AGE_CHANGE_ENf_SET
#define SPTAGTr_RESERVEDf_GET BCM53101_A0_SPTAGTr_RESERVEDf_GET
#define SPTAGTr_RESERVEDf_SET BCM53101_A0_SPTAGTr_RESERVEDf_SET
#define READ_SPTAGTr BCM53101_A0_READ_SPTAGTr
#define WRITE_SPTAGTr BCM53101_A0_WRITE_SPTAGTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_SPTAGTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  SPT_MULTI_ADDR_BPS_CTRL
 * BLOCKS:   SYS
 * DESC:     STP Multiport Address Bypass Control Register
 * SIZE:     16
 * FIELDS:
 *     EN_MPORT0_BYPASS_SPT 1'b0: The MPORT_ADD0 will not be checked by SPT Status1'b1: The MPORT_ADD0 will  be checked by SPT Status
 *     EN_MPORT1_BYPASS_SPT 1'b0: The MPORT_ADD1 will not be checked by SPT Status1'b1: The MPORT_ADD1 will  be checked by SPT Status
 *     EN_MPORT2_BYPASS_SPT 1'b0: The MPORT_ADD2 will not be checked by SPT Status1'b1: The MPORT_ADD2 will  be checked by SPT Status
 *     EN_MPORT3_BYPASS_SPT 1'b0: The MPORT_ADD3 will not be checked by SPT Status1'b1: The MPORT_ADD3 will  be checked by SPT Status
 *     EN_MPORT4_BYPASS_SPT 1'b0: The MPORT_ADD4 will not be checked by SPT Status1'b1: The MPORT_ADD4 will  be checked by SPT Status
 *     EN_MPORT5_BYPASS_SPT 1'b0: The MPORT_ADD5 will not be checked by SPT Status1'b1: The MPORT_ADD5 will  be checked by SPT Status
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr 0x00004350

#define BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr_SIZE 2

/*
 * This structure should be used to declare and program SPT_MULTI_ADDR_BPS_CTRL.
 *
 */
typedef union BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr_s {
	uint32_t v[1];
	uint32_t spt_multi_addr_bps_ctrl[1];
	uint32_t _spt_multi_addr_bps_ctrl;
} BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr_t;

#define BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr_CLR(r) (r).spt_multi_addr_bps_ctrl[0] = 0
#define BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr_SET(r,d) (r).spt_multi_addr_bps_ctrl[0] = d
#define BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr_GET(r) (r).spt_multi_addr_bps_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT0_BYPASS_SPTf_GET(r) (((r).spt_multi_addr_bps_ctrl[0]) & 0x1)
#define BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT0_BYPASS_SPTf_SET(r,f) (r).spt_multi_addr_bps_ctrl[0]=(((r).spt_multi_addr_bps_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT1_BYPASS_SPTf_GET(r) ((((r).spt_multi_addr_bps_ctrl[0]) >> 1) & 0x1)
#define BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT1_BYPASS_SPTf_SET(r,f) (r).spt_multi_addr_bps_ctrl[0]=(((r).spt_multi_addr_bps_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT2_BYPASS_SPTf_GET(r) ((((r).spt_multi_addr_bps_ctrl[0]) >> 2) & 0x1)
#define BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT2_BYPASS_SPTf_SET(r,f) (r).spt_multi_addr_bps_ctrl[0]=(((r).spt_multi_addr_bps_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT3_BYPASS_SPTf_GET(r) ((((r).spt_multi_addr_bps_ctrl[0]) >> 3) & 0x1)
#define BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT3_BYPASS_SPTf_SET(r,f) (r).spt_multi_addr_bps_ctrl[0]=(((r).spt_multi_addr_bps_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT4_BYPASS_SPTf_GET(r) ((((r).spt_multi_addr_bps_ctrl[0]) >> 4) & 0x1)
#define BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT4_BYPASS_SPTf_SET(r,f) (r).spt_multi_addr_bps_ctrl[0]=(((r).spt_multi_addr_bps_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT5_BYPASS_SPTf_GET(r) ((((r).spt_multi_addr_bps_ctrl[0]) >> 5) & 0x1)
#define BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT5_BYPASS_SPTf_SET(r,f) (r).spt_multi_addr_bps_ctrl[0]=(((r).spt_multi_addr_bps_ctrl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr_RESERVEDf_GET(r) ((((r).spt_multi_addr_bps_ctrl[0]) >> 6) & 0x3ff)
#define BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr_RESERVEDf_SET(r,f) (r).spt_multi_addr_bps_ctrl[0]=(((r).spt_multi_addr_bps_ctrl[0] & ~((uint32_t)0x3ff << 6)) | ((((uint32_t)f) & 0x3ff) << 6))

/*
 * These macros can be used to access SPT_MULTI_ADDR_BPS_CTRL.
 *
 */
#define BCM53101_A0_READ_SPT_MULTI_ADDR_BPS_CTRLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr,(r._spt_multi_addr_bps_ctrl),2)
#define BCM53101_A0_WRITE_SPT_MULTI_ADDR_BPS_CTRLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr,&(r._spt_multi_addr_bps_ctrl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SPT_MULTI_ADDR_BPS_CTRLr BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr
#define SPT_MULTI_ADDR_BPS_CTRLr_SIZE BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr_SIZE
typedef BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr_t SPT_MULTI_ADDR_BPS_CTRLr_t;
#define SPT_MULTI_ADDR_BPS_CTRLr_CLR BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr_CLR
#define SPT_MULTI_ADDR_BPS_CTRLr_SET BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr_SET
#define SPT_MULTI_ADDR_BPS_CTRLr_GET BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr_GET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT0_BYPASS_SPTf_GET BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT0_BYPASS_SPTf_GET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT0_BYPASS_SPTf_SET BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT0_BYPASS_SPTf_SET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT1_BYPASS_SPTf_GET BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT1_BYPASS_SPTf_GET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT1_BYPASS_SPTf_SET BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT1_BYPASS_SPTf_SET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT2_BYPASS_SPTf_GET BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT2_BYPASS_SPTf_GET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT2_BYPASS_SPTf_SET BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT2_BYPASS_SPTf_SET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT3_BYPASS_SPTf_GET BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT3_BYPASS_SPTf_GET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT3_BYPASS_SPTf_SET BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT3_BYPASS_SPTf_SET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT4_BYPASS_SPTf_GET BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT4_BYPASS_SPTf_GET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT4_BYPASS_SPTf_SET BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT4_BYPASS_SPTf_SET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT5_BYPASS_SPTf_GET BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT5_BYPASS_SPTf_GET
#define SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT5_BYPASS_SPTf_SET BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr_EN_MPORT5_BYPASS_SPTf_SET
#define SPT_MULTI_ADDR_BPS_CTRLr_RESERVEDf_GET BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr_RESERVEDf_GET
#define SPT_MULTI_ADDR_BPS_CTRLr_RESERVEDf_SET BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr_RESERVEDf_SET
#define READ_SPT_MULTI_ADDR_BPS_CTRLr BCM53101_A0_READ_SPT_MULTI_ADDR_BPS_CTRLr
#define WRITE_SPT_MULTI_ADDR_BPS_CTRLr BCM53101_A0_WRITE_SPT_MULTI_ADDR_BPS_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_SPT_MULTI_ADDR_BPS_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  SRCADRCHG
 * BLOCKS:   SYS
 * DESC:     Source Address Change Register
 * SIZE:     16
 * FIELDS:
 *     SRC_ADDR_CHANGE  Source Address Change.9 bit field indicating that the value loaded into the Last Source Address register was not the same 48-bit value as the previous value. A 1 value indicates a dedicated link degment, a value greater than 1 generally indicates a mixing (repeatered) segment. Upon change of SA, a bit remains set until cleared by a read operation.0 = Source Address Constant1 = Source Address Changed
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_SRCADRCHGr 0x0000010e

#define BCM53101_A0_SRCADRCHGr_SIZE 2

/*
 * This structure should be used to declare and program SRCADRCHG.
 *
 */
typedef union BCM53101_A0_SRCADRCHGr_s {
	uint32_t v[1];
	uint32_t srcadrchg[1];
	uint32_t _srcadrchg;
} BCM53101_A0_SRCADRCHGr_t;

#define BCM53101_A0_SRCADRCHGr_CLR(r) (r).srcadrchg[0] = 0
#define BCM53101_A0_SRCADRCHGr_SET(r,d) (r).srcadrchg[0] = d
#define BCM53101_A0_SRCADRCHGr_GET(r) (r).srcadrchg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_SRCADRCHGr_SRC_ADDR_CHANGEf_GET(r) (((r).srcadrchg[0]) & 0x1ff)
#define BCM53101_A0_SRCADRCHGr_SRC_ADDR_CHANGEf_SET(r,f) (r).srcadrchg[0]=(((r).srcadrchg[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_SRCADRCHGr_RESERVEDf_GET(r) ((((r).srcadrchg[0]) >> 9) & 0x7f)
#define BCM53101_A0_SRCADRCHGr_RESERVEDf_SET(r,f) (r).srcadrchg[0]=(((r).srcadrchg[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access SRCADRCHG.
 *
 */
#define BCM53101_A0_READ_SRCADRCHGr(u,r) cdk_robo_reg_read(u,BCM53101_A0_SRCADRCHGr,(r._srcadrchg),2)
#define BCM53101_A0_WRITE_SRCADRCHGr(u,r) cdk_robo_reg_write(u,BCM53101_A0_SRCADRCHGr,&(r._srcadrchg),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SRCADRCHGr BCM53101_A0_SRCADRCHGr
#define SRCADRCHGr_SIZE BCM53101_A0_SRCADRCHGr_SIZE
typedef BCM53101_A0_SRCADRCHGr_t SRCADRCHGr_t;
#define SRCADRCHGr_CLR BCM53101_A0_SRCADRCHGr_CLR
#define SRCADRCHGr_SET BCM53101_A0_SRCADRCHGr_SET
#define SRCADRCHGr_GET BCM53101_A0_SRCADRCHGr_GET
#define SRCADRCHGr_SRC_ADDR_CHANGEf_GET BCM53101_A0_SRCADRCHGr_SRC_ADDR_CHANGEf_GET
#define SRCADRCHGr_SRC_ADDR_CHANGEf_SET BCM53101_A0_SRCADRCHGr_SRC_ADDR_CHANGEf_SET
#define SRCADRCHGr_RESERVEDf_GET BCM53101_A0_SRCADRCHGr_RESERVEDf_GET
#define SRCADRCHGr_RESERVEDf_SET BCM53101_A0_SRCADRCHGr_RESERVEDf_SET
#define READ_SRCADRCHGr BCM53101_A0_READ_SRCADRCHGr
#define WRITE_SRCADRCHGr BCM53101_A0_WRITE_SRCADRCHGr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_SRCADRCHGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  STRAP_VALUE
 * BLOCKS:   SYS
 * DESC:     Strap Value Register
 * SIZE:     48
 * FIELDS:
 *     HW_FWDG_EN_B     hw_fwdg_en_strap,
 *     CPU_EPROM        cpu_eprom_sel,
 *     SYSFREQ          sysclk frequence.
 *     MII1_MODE        MII1 mode strap.
 *     SKIP_SRAMBIST    skip_srambist strap
 *     MII2_MODE        MII2 mode strap
 *     LEDMODE          ledmode[2:0],
 *     ENEXTCLK_B       enextclk strap,
 *     RESERVED_0       Reserved
 *     FINAL_MII1_MODE  Final MII1 mode according to bonding optins
 *     FINAL_MII2_MODE  Final MII2 mode according to bonding optins
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_STRAP_VALUEr 0x00000170

#define BCM53101_A0_STRAP_VALUEr_SIZE 6

/*
 * This structure should be used to declare and program STRAP_VALUE.
 *
 */
typedef union BCM53101_A0_STRAP_VALUEr_s {
	uint32_t v[2];
	uint32_t strap_value[2];
	uint32_t _strap_value;
} BCM53101_A0_STRAP_VALUEr_t;

#define BCM53101_A0_STRAP_VALUEr_CLR(r) CDK_MEMSET(&((r)._strap_value), 0, sizeof(BCM53101_A0_STRAP_VALUEr_t))
#define BCM53101_A0_STRAP_VALUEr_SET(r,i,d) (r).strap_value[i] = d
#define BCM53101_A0_STRAP_VALUEr_GET(r,i) (r).strap_value[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_STRAP_VALUEr_HW_FWDG_EN_Bf_GET(r) (((r).strap_value[0]) & 0x1)
#define BCM53101_A0_STRAP_VALUEr_HW_FWDG_EN_Bf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_STRAP_VALUEr_CPU_EPROMf_GET(r) ((((r).strap_value[0]) >> 1) & 0x1)
#define BCM53101_A0_STRAP_VALUEr_CPU_EPROMf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_STRAP_VALUEr_SYSFREQf_GET(r) ((((r).strap_value[0]) >> 2) & 0x3)
#define BCM53101_A0_STRAP_VALUEr_SYSFREQf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53101_A0_STRAP_VALUEr_MII1_MODEf_GET(r) ((((r).strap_value[0]) >> 4) & 0x7)
#define BCM53101_A0_STRAP_VALUEr_MII1_MODEf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4))
#define BCM53101_A0_STRAP_VALUEr_SKIP_SRAMBISTf_GET(r) ((((r).strap_value[0]) >> 7) & 0x1)
#define BCM53101_A0_STRAP_VALUEr_SKIP_SRAMBISTf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53101_A0_STRAP_VALUEr_MII2_MODEf_GET(r) ((((r).strap_value[0]) >> 8) & 0x3)
#define BCM53101_A0_STRAP_VALUEr_MII2_MODEf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM53101_A0_STRAP_VALUEr_LEDMODEf_GET(r) ((((r).strap_value[0]) >> 10) & 0x3)
#define BCM53101_A0_STRAP_VALUEr_LEDMODEf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM53101_A0_STRAP_VALUEr_ENEXTCLK_Bf_GET(r) ((((r).strap_value[0]) >> 12) & 0x1)
#define BCM53101_A0_STRAP_VALUEr_ENEXTCLK_Bf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12))
#define BCM53101_A0_STRAP_VALUEr_RESERVED_0f_GET(r) ((((r).strap_value[0]) >> 13) & 0x7)
#define BCM53101_A0_STRAP_VALUEr_RESERVED_0f_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13))
#define BCM53101_A0_STRAP_VALUEr_FINAL_MII1_MODEf_GET(r) ((((r).strap_value[0]) >> 16) & 0x7)
#define BCM53101_A0_STRAP_VALUEr_FINAL_MII1_MODEf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x7 << 16)) | ((((uint32_t)f) & 0x7) << 16))
#define BCM53101_A0_STRAP_VALUEr_FINAL_MII2_MODEf_GET(r) ((((r).strap_value[0]) >> 19) & 0x3)
#define BCM53101_A0_STRAP_VALUEr_FINAL_MII2_MODEf_SET(r,f) (r).strap_value[0]=(((r).strap_value[0] & ~((uint32_t)0x3 << 19)) | ((((uint32_t)f) & 0x3) << 19))
#define BCM53101_A0_STRAP_VALUEr_RESERVED_1f_GET(r) cdk_field32_get((r).strap_value,21,47)
#define BCM53101_A0_STRAP_VALUEr_RESERVED_1f_SET(r,f) cdk_field32_set((r).strap_value,21,47,f)

/*
 * These macros can be used to access STRAP_VALUE.
 *
 */
#define BCM53101_A0_READ_STRAP_VALUEr(u,r) cdk_robo_reg_read(u,BCM53101_A0_STRAP_VALUEr,(r._strap_value),6)
#define BCM53101_A0_WRITE_STRAP_VALUEr(u,r) cdk_robo_reg_write(u,BCM53101_A0_STRAP_VALUEr,&(r._strap_value),6)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define STRAP_VALUEr BCM53101_A0_STRAP_VALUEr
#define STRAP_VALUEr_SIZE BCM53101_A0_STRAP_VALUEr_SIZE
typedef BCM53101_A0_STRAP_VALUEr_t STRAP_VALUEr_t;
#define STRAP_VALUEr_CLR BCM53101_A0_STRAP_VALUEr_CLR
#define STRAP_VALUEr_SET BCM53101_A0_STRAP_VALUEr_SET
#define STRAP_VALUEr_GET BCM53101_A0_STRAP_VALUEr_GET
#define STRAP_VALUEr_HW_FWDG_EN_Bf_GET BCM53101_A0_STRAP_VALUEr_HW_FWDG_EN_Bf_GET
#define STRAP_VALUEr_HW_FWDG_EN_Bf_SET BCM53101_A0_STRAP_VALUEr_HW_FWDG_EN_Bf_SET
#define STRAP_VALUEr_CPU_EPROMf_GET BCM53101_A0_STRAP_VALUEr_CPU_EPROMf_GET
#define STRAP_VALUEr_CPU_EPROMf_SET BCM53101_A0_STRAP_VALUEr_CPU_EPROMf_SET
#define STRAP_VALUEr_SYSFREQf_GET BCM53101_A0_STRAP_VALUEr_SYSFREQf_GET
#define STRAP_VALUEr_SYSFREQf_SET BCM53101_A0_STRAP_VALUEr_SYSFREQf_SET
#define STRAP_VALUEr_MII1_MODEf_GET BCM53101_A0_STRAP_VALUEr_MII1_MODEf_GET
#define STRAP_VALUEr_MII1_MODEf_SET BCM53101_A0_STRAP_VALUEr_MII1_MODEf_SET
#define STRAP_VALUEr_SKIP_SRAMBISTf_GET BCM53101_A0_STRAP_VALUEr_SKIP_SRAMBISTf_GET
#define STRAP_VALUEr_SKIP_SRAMBISTf_SET BCM53101_A0_STRAP_VALUEr_SKIP_SRAMBISTf_SET
#define STRAP_VALUEr_MII2_MODEf_GET BCM53101_A0_STRAP_VALUEr_MII2_MODEf_GET
#define STRAP_VALUEr_MII2_MODEf_SET BCM53101_A0_STRAP_VALUEr_MII2_MODEf_SET
#define STRAP_VALUEr_LEDMODEf_GET BCM53101_A0_STRAP_VALUEr_LEDMODEf_GET
#define STRAP_VALUEr_LEDMODEf_SET BCM53101_A0_STRAP_VALUEr_LEDMODEf_SET
#define STRAP_VALUEr_ENEXTCLK_Bf_GET BCM53101_A0_STRAP_VALUEr_ENEXTCLK_Bf_GET
#define STRAP_VALUEr_ENEXTCLK_Bf_SET BCM53101_A0_STRAP_VALUEr_ENEXTCLK_Bf_SET
#define STRAP_VALUEr_RESERVED_0f_GET BCM53101_A0_STRAP_VALUEr_RESERVED_0f_GET
#define STRAP_VALUEr_RESERVED_0f_SET BCM53101_A0_STRAP_VALUEr_RESERVED_0f_SET
#define STRAP_VALUEr_FINAL_MII1_MODEf_GET BCM53101_A0_STRAP_VALUEr_FINAL_MII1_MODEf_GET
#define STRAP_VALUEr_FINAL_MII1_MODEf_SET BCM53101_A0_STRAP_VALUEr_FINAL_MII1_MODEf_SET
#define STRAP_VALUEr_FINAL_MII2_MODEf_GET BCM53101_A0_STRAP_VALUEr_FINAL_MII2_MODEf_GET
#define STRAP_VALUEr_FINAL_MII2_MODEf_SET BCM53101_A0_STRAP_VALUEr_FINAL_MII2_MODEf_SET
#define STRAP_VALUEr_RESERVED_1f_GET BCM53101_A0_STRAP_VALUEr_RESERVED_1f_GET
#define STRAP_VALUEr_RESERVED_1f_SET BCM53101_A0_STRAP_VALUEr_RESERVED_1f_SET
#define READ_STRAP_VALUEr BCM53101_A0_READ_STRAP_VALUEr
#define WRITE_STRAP_VALUEr BCM53101_A0_WRITE_STRAP_VALUEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_STRAP_VALUEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  STS_OVERRIDE_GMIIP
 * BLOCKS:   EPIC0
 * DESC:     Port N GMII Port States Override Register
 * SIZE:     8
 * FIELDS:
 *     LINK_STS         1: Link Up0: Link Down
 *     DUPLX_MODE       Software Duplex Mode Setting0: Half Duplex1: Full Duplex
 *     SPEED            Software Port Speed setting2'b10 : 1000M2'b01: 100M2'b00 : 10M
 *     RXFLOW_CNTL      Software Rx Flow Control Enable
 *     TXFLOW_CNTL      Software Tx Flow Control Enable
 *     SW_OVERRIDE      CPU set software Override bit to 1 to make bit [5:0] affected.PHY scan register will be override.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_STS_OVERRIDE_GMIIPr 0x00000058

#define BCM53101_A0_STS_OVERRIDE_GMIIPr_SIZE 1

/*
 * This structure should be used to declare and program STS_OVERRIDE_GMIIP.
 *
 */
typedef union BCM53101_A0_STS_OVERRIDE_GMIIPr_s {
	uint32_t v[1];
	uint32_t sts_override_gmiip[1];
	uint32_t _sts_override_gmiip;
} BCM53101_A0_STS_OVERRIDE_GMIIPr_t;

#define BCM53101_A0_STS_OVERRIDE_GMIIPr_CLR(r) (r).sts_override_gmiip[0] = 0
#define BCM53101_A0_STS_OVERRIDE_GMIIPr_SET(r,d) (r).sts_override_gmiip[0] = d
#define BCM53101_A0_STS_OVERRIDE_GMIIPr_GET(r) (r).sts_override_gmiip[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_STS_OVERRIDE_GMIIPr_LINK_STSf_GET(r) (((r).sts_override_gmiip[0]) & 0x1)
#define BCM53101_A0_STS_OVERRIDE_GMIIPr_LINK_STSf_SET(r,f) (r).sts_override_gmiip[0]=(((r).sts_override_gmiip[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_STS_OVERRIDE_GMIIPr_DUPLX_MODEf_GET(r) ((((r).sts_override_gmiip[0]) >> 1) & 0x1)
#define BCM53101_A0_STS_OVERRIDE_GMIIPr_DUPLX_MODEf_SET(r,f) (r).sts_override_gmiip[0]=(((r).sts_override_gmiip[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_STS_OVERRIDE_GMIIPr_SPEEDf_GET(r) ((((r).sts_override_gmiip[0]) >> 2) & 0x3)
#define BCM53101_A0_STS_OVERRIDE_GMIIPr_SPEEDf_SET(r,f) (r).sts_override_gmiip[0]=(((r).sts_override_gmiip[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53101_A0_STS_OVERRIDE_GMIIPr_RXFLOW_CNTLf_GET(r) ((((r).sts_override_gmiip[0]) >> 4) & 0x1)
#define BCM53101_A0_STS_OVERRIDE_GMIIPr_RXFLOW_CNTLf_SET(r,f) (r).sts_override_gmiip[0]=(((r).sts_override_gmiip[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_STS_OVERRIDE_GMIIPr_TXFLOW_CNTLf_GET(r) ((((r).sts_override_gmiip[0]) >> 5) & 0x1)
#define BCM53101_A0_STS_OVERRIDE_GMIIPr_TXFLOW_CNTLf_SET(r,f) (r).sts_override_gmiip[0]=(((r).sts_override_gmiip[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_STS_OVERRIDE_GMIIPr_SW_OVERRIDEf_GET(r) ((((r).sts_override_gmiip[0]) >> 6) & 0x1)
#define BCM53101_A0_STS_OVERRIDE_GMIIPr_SW_OVERRIDEf_SET(r,f) (r).sts_override_gmiip[0]=(((r).sts_override_gmiip[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_STS_OVERRIDE_GMIIPr_RESERVED_1f_GET(r) ((((r).sts_override_gmiip[0]) >> 7) & 0x1)
#define BCM53101_A0_STS_OVERRIDE_GMIIPr_RESERVED_1f_SET(r,f) (r).sts_override_gmiip[0]=(((r).sts_override_gmiip[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access STS_OVERRIDE_GMIIP.
 *
 */
#define BCM53101_A0_READ_STS_OVERRIDE_GMIIPr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_STS_OVERRIDE_GMIIPr,(r._sts_override_gmiip),1)
#define BCM53101_A0_WRITE_STS_OVERRIDE_GMIIPr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_STS_OVERRIDE_GMIIPr,&(r._sts_override_gmiip),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define STS_OVERRIDE_GMIIPr BCM53101_A0_STS_OVERRIDE_GMIIPr
#define STS_OVERRIDE_GMIIPr_SIZE BCM53101_A0_STS_OVERRIDE_GMIIPr_SIZE
typedef BCM53101_A0_STS_OVERRIDE_GMIIPr_t STS_OVERRIDE_GMIIPr_t;
#define STS_OVERRIDE_GMIIPr_CLR BCM53101_A0_STS_OVERRIDE_GMIIPr_CLR
#define STS_OVERRIDE_GMIIPr_SET BCM53101_A0_STS_OVERRIDE_GMIIPr_SET
#define STS_OVERRIDE_GMIIPr_GET BCM53101_A0_STS_OVERRIDE_GMIIPr_GET
#define STS_OVERRIDE_GMIIPr_LINK_STSf_GET BCM53101_A0_STS_OVERRIDE_GMIIPr_LINK_STSf_GET
#define STS_OVERRIDE_GMIIPr_LINK_STSf_SET BCM53101_A0_STS_OVERRIDE_GMIIPr_LINK_STSf_SET
#define STS_OVERRIDE_GMIIPr_DUPLX_MODEf_GET BCM53101_A0_STS_OVERRIDE_GMIIPr_DUPLX_MODEf_GET
#define STS_OVERRIDE_GMIIPr_DUPLX_MODEf_SET BCM53101_A0_STS_OVERRIDE_GMIIPr_DUPLX_MODEf_SET
#define STS_OVERRIDE_GMIIPr_SPEEDf_GET BCM53101_A0_STS_OVERRIDE_GMIIPr_SPEEDf_GET
#define STS_OVERRIDE_GMIIPr_SPEEDf_SET BCM53101_A0_STS_OVERRIDE_GMIIPr_SPEEDf_SET
#define STS_OVERRIDE_GMIIPr_RXFLOW_CNTLf_GET BCM53101_A0_STS_OVERRIDE_GMIIPr_RXFLOW_CNTLf_GET
#define STS_OVERRIDE_GMIIPr_RXFLOW_CNTLf_SET BCM53101_A0_STS_OVERRIDE_GMIIPr_RXFLOW_CNTLf_SET
#define STS_OVERRIDE_GMIIPr_TXFLOW_CNTLf_GET BCM53101_A0_STS_OVERRIDE_GMIIPr_TXFLOW_CNTLf_GET
#define STS_OVERRIDE_GMIIPr_TXFLOW_CNTLf_SET BCM53101_A0_STS_OVERRIDE_GMIIPr_TXFLOW_CNTLf_SET
#define STS_OVERRIDE_GMIIPr_SW_OVERRIDEf_GET BCM53101_A0_STS_OVERRIDE_GMIIPr_SW_OVERRIDEf_GET
#define STS_OVERRIDE_GMIIPr_SW_OVERRIDEf_SET BCM53101_A0_STS_OVERRIDE_GMIIPr_SW_OVERRIDEf_SET
#define STS_OVERRIDE_GMIIPr_RESERVED_1f_GET BCM53101_A0_STS_OVERRIDE_GMIIPr_RESERVED_1f_GET
#define STS_OVERRIDE_GMIIPr_RESERVED_1f_SET BCM53101_A0_STS_OVERRIDE_GMIIPr_RESERVED_1f_SET
#define READ_STS_OVERRIDE_GMIIPr BCM53101_A0_READ_STS_OVERRIDE_GMIIPr
#define WRITE_STS_OVERRIDE_GMIIPr BCM53101_A0_WRITE_STS_OVERRIDE_GMIIPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_STS_OVERRIDE_GMIIPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  STS_OVERRIDE_IMP
 * BLOCKS:   CPIC
 * DESC:     IMP Port States Override Register
 * SIZE:     8
 * FIELDS:
 *     LINK_STS         Link Status0: Link fail1: Link pass
 *     DUPLX_MODE       Software Duplex Mode Setting0: Half Duplex1: Full Duplex
 *     SPEED            Speed00: 10 Mbps01: 100 Mbps10: 1000Mbps
 *     RXFLOW_CNTL      Link Partner Flow Control Capability0: Not PAUSE capable1: PAUSE capable
 *     TXFLOW_CNTL      Link Partner Flow Control Capability0: Not PAUSE capable1: PAUSE capable
 *     RESERVED_1       Reserved
 *     MII_SW_OR        MII Software Override0: Use MII hardware pin status1: Use contents of this register
 *
 ******************************************************************************/
#define BCM53101_A0_STS_OVERRIDE_IMPr 0x0000000e

#define BCM53101_A0_STS_OVERRIDE_IMPr_SIZE 1

/*
 * This structure should be used to declare and program STS_OVERRIDE_IMP.
 *
 */
typedef union BCM53101_A0_STS_OVERRIDE_IMPr_s {
	uint32_t v[1];
	uint32_t sts_override_imp[1];
	uint32_t _sts_override_imp;
} BCM53101_A0_STS_OVERRIDE_IMPr_t;

#define BCM53101_A0_STS_OVERRIDE_IMPr_CLR(r) (r).sts_override_imp[0] = 0
#define BCM53101_A0_STS_OVERRIDE_IMPr_SET(r,d) (r).sts_override_imp[0] = d
#define BCM53101_A0_STS_OVERRIDE_IMPr_GET(r) (r).sts_override_imp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_STS_OVERRIDE_IMPr_LINK_STSf_GET(r) (((r).sts_override_imp[0]) & 0x1)
#define BCM53101_A0_STS_OVERRIDE_IMPr_LINK_STSf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_STS_OVERRIDE_IMPr_DUPLX_MODEf_GET(r) ((((r).sts_override_imp[0]) >> 1) & 0x1)
#define BCM53101_A0_STS_OVERRIDE_IMPr_DUPLX_MODEf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_STS_OVERRIDE_IMPr_SPEEDf_GET(r) ((((r).sts_override_imp[0]) >> 2) & 0x3)
#define BCM53101_A0_STS_OVERRIDE_IMPr_SPEEDf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53101_A0_STS_OVERRIDE_IMPr_RXFLOW_CNTLf_GET(r) ((((r).sts_override_imp[0]) >> 4) & 0x1)
#define BCM53101_A0_STS_OVERRIDE_IMPr_RXFLOW_CNTLf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_STS_OVERRIDE_IMPr_TXFLOW_CNTLf_GET(r) ((((r).sts_override_imp[0]) >> 5) & 0x1)
#define BCM53101_A0_STS_OVERRIDE_IMPr_TXFLOW_CNTLf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_STS_OVERRIDE_IMPr_RESERVED_1f_GET(r) ((((r).sts_override_imp[0]) >> 6) & 0x1)
#define BCM53101_A0_STS_OVERRIDE_IMPr_RESERVED_1f_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_STS_OVERRIDE_IMPr_MII_SW_ORf_GET(r) ((((r).sts_override_imp[0]) >> 7) & 0x1)
#define BCM53101_A0_STS_OVERRIDE_IMPr_MII_SW_ORf_SET(r,f) (r).sts_override_imp[0]=(((r).sts_override_imp[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access STS_OVERRIDE_IMP.
 *
 */
#define BCM53101_A0_READ_STS_OVERRIDE_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_STS_OVERRIDE_IMPr,(r._sts_override_imp),1)
#define BCM53101_A0_WRITE_STS_OVERRIDE_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_STS_OVERRIDE_IMPr,&(r._sts_override_imp),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define STS_OVERRIDE_IMPr BCM53101_A0_STS_OVERRIDE_IMPr
#define STS_OVERRIDE_IMPr_SIZE BCM53101_A0_STS_OVERRIDE_IMPr_SIZE
typedef BCM53101_A0_STS_OVERRIDE_IMPr_t STS_OVERRIDE_IMPr_t;
#define STS_OVERRIDE_IMPr_CLR BCM53101_A0_STS_OVERRIDE_IMPr_CLR
#define STS_OVERRIDE_IMPr_SET BCM53101_A0_STS_OVERRIDE_IMPr_SET
#define STS_OVERRIDE_IMPr_GET BCM53101_A0_STS_OVERRIDE_IMPr_GET
#define STS_OVERRIDE_IMPr_LINK_STSf_GET BCM53101_A0_STS_OVERRIDE_IMPr_LINK_STSf_GET
#define STS_OVERRIDE_IMPr_LINK_STSf_SET BCM53101_A0_STS_OVERRIDE_IMPr_LINK_STSf_SET
#define STS_OVERRIDE_IMPr_DUPLX_MODEf_GET BCM53101_A0_STS_OVERRIDE_IMPr_DUPLX_MODEf_GET
#define STS_OVERRIDE_IMPr_DUPLX_MODEf_SET BCM53101_A0_STS_OVERRIDE_IMPr_DUPLX_MODEf_SET
#define STS_OVERRIDE_IMPr_SPEEDf_GET BCM53101_A0_STS_OVERRIDE_IMPr_SPEEDf_GET
#define STS_OVERRIDE_IMPr_SPEEDf_SET BCM53101_A0_STS_OVERRIDE_IMPr_SPEEDf_SET
#define STS_OVERRIDE_IMPr_RXFLOW_CNTLf_GET BCM53101_A0_STS_OVERRIDE_IMPr_RXFLOW_CNTLf_GET
#define STS_OVERRIDE_IMPr_RXFLOW_CNTLf_SET BCM53101_A0_STS_OVERRIDE_IMPr_RXFLOW_CNTLf_SET
#define STS_OVERRIDE_IMPr_TXFLOW_CNTLf_GET BCM53101_A0_STS_OVERRIDE_IMPr_TXFLOW_CNTLf_GET
#define STS_OVERRIDE_IMPr_TXFLOW_CNTLf_SET BCM53101_A0_STS_OVERRIDE_IMPr_TXFLOW_CNTLf_SET
#define STS_OVERRIDE_IMPr_RESERVED_1f_GET BCM53101_A0_STS_OVERRIDE_IMPr_RESERVED_1f_GET
#define STS_OVERRIDE_IMPr_RESERVED_1f_SET BCM53101_A0_STS_OVERRIDE_IMPr_RESERVED_1f_SET
#define STS_OVERRIDE_IMPr_MII_SW_ORf_GET BCM53101_A0_STS_OVERRIDE_IMPr_MII_SW_ORf_GET
#define STS_OVERRIDE_IMPr_MII_SW_ORf_SET BCM53101_A0_STS_OVERRIDE_IMPr_MII_SW_ORf_SET
#define READ_STS_OVERRIDE_IMPr BCM53101_A0_READ_STS_OVERRIDE_IMPr
#define WRITE_STS_OVERRIDE_IMPr BCM53101_A0_WRITE_STS_OVERRIDE_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_STS_OVERRIDE_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  SWITCH_CTRL
 * BLOCKS:   SYS
 * DESC:     Switch Control Register
 * SIZE:     8
 * FIELDS:
 *     MII_DUMB_FWD_EN  Enable mii1 port 8 to be a candidate of destination port in dumb mode
 *     DISABLE_MII1_OUTPUT Disable mii1 output
 *     DISABLE_MII2_OUTPUT Disable mii2 output
 *     MII1_VOL_SEL     Mii1 voltage select0 : 3.3V(others)1 : 2.5V(when mii1_mode = RGMII)
 *     MII2_VOL_SEL     Mii2 voltage select0 : 3.3V(default)1 : 2.5V
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_SWITCH_CTRLr 0x00000020

#define BCM53101_A0_SWITCH_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program SWITCH_CTRL.
 *
 */
typedef union BCM53101_A0_SWITCH_CTRLr_s {
	uint32_t v[1];
	uint32_t switch_ctrl[1];
	uint32_t _switch_ctrl;
} BCM53101_A0_SWITCH_CTRLr_t;

#define BCM53101_A0_SWITCH_CTRLr_CLR(r) (r).switch_ctrl[0] = 0
#define BCM53101_A0_SWITCH_CTRLr_SET(r,d) (r).switch_ctrl[0] = d
#define BCM53101_A0_SWITCH_CTRLr_GET(r) (r).switch_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_SWITCH_CTRLr_MII_DUMB_FWD_ENf_GET(r) (((r).switch_ctrl[0]) & 0x1)
#define BCM53101_A0_SWITCH_CTRLr_MII_DUMB_FWD_ENf_SET(r,f) (r).switch_ctrl[0]=(((r).switch_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_SWITCH_CTRLr_DISABLE_MII1_OUTPUTf_GET(r) ((((r).switch_ctrl[0]) >> 1) & 0x1)
#define BCM53101_A0_SWITCH_CTRLr_DISABLE_MII1_OUTPUTf_SET(r,f) (r).switch_ctrl[0]=(((r).switch_ctrl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_SWITCH_CTRLr_DISABLE_MII2_OUTPUTf_GET(r) ((((r).switch_ctrl[0]) >> 2) & 0x1)
#define BCM53101_A0_SWITCH_CTRLr_DISABLE_MII2_OUTPUTf_SET(r,f) (r).switch_ctrl[0]=(((r).switch_ctrl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_SWITCH_CTRLr_MII1_VOL_SELf_GET(r) ((((r).switch_ctrl[0]) >> 3) & 0x1)
#define BCM53101_A0_SWITCH_CTRLr_MII1_VOL_SELf_SET(r,f) (r).switch_ctrl[0]=(((r).switch_ctrl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_SWITCH_CTRLr_MII2_VOL_SELf_GET(r) ((((r).switch_ctrl[0]) >> 4) & 0x1)
#define BCM53101_A0_SWITCH_CTRLr_MII2_VOL_SELf_SET(r,f) (r).switch_ctrl[0]=(((r).switch_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_SWITCH_CTRLr_RESERVEDf_GET(r) ((((r).switch_ctrl[0]) >> 5) & 0x7)
#define BCM53101_A0_SWITCH_CTRLr_RESERVEDf_SET(r,f) (r).switch_ctrl[0]=(((r).switch_ctrl[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access SWITCH_CTRL.
 *
 */
#define BCM53101_A0_READ_SWITCH_CTRLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_SWITCH_CTRLr,(r._switch_ctrl),1)
#define BCM53101_A0_WRITE_SWITCH_CTRLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_SWITCH_CTRLr,&(r._switch_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SWITCH_CTRLr BCM53101_A0_SWITCH_CTRLr
#define SWITCH_CTRLr_SIZE BCM53101_A0_SWITCH_CTRLr_SIZE
typedef BCM53101_A0_SWITCH_CTRLr_t SWITCH_CTRLr_t;
#define SWITCH_CTRLr_CLR BCM53101_A0_SWITCH_CTRLr_CLR
#define SWITCH_CTRLr_SET BCM53101_A0_SWITCH_CTRLr_SET
#define SWITCH_CTRLr_GET BCM53101_A0_SWITCH_CTRLr_GET
#define SWITCH_CTRLr_MII_DUMB_FWD_ENf_GET BCM53101_A0_SWITCH_CTRLr_MII_DUMB_FWD_ENf_GET
#define SWITCH_CTRLr_MII_DUMB_FWD_ENf_SET BCM53101_A0_SWITCH_CTRLr_MII_DUMB_FWD_ENf_SET
#define SWITCH_CTRLr_DISABLE_MII1_OUTPUTf_GET BCM53101_A0_SWITCH_CTRLr_DISABLE_MII1_OUTPUTf_GET
#define SWITCH_CTRLr_DISABLE_MII1_OUTPUTf_SET BCM53101_A0_SWITCH_CTRLr_DISABLE_MII1_OUTPUTf_SET
#define SWITCH_CTRLr_DISABLE_MII2_OUTPUTf_GET BCM53101_A0_SWITCH_CTRLr_DISABLE_MII2_OUTPUTf_GET
#define SWITCH_CTRLr_DISABLE_MII2_OUTPUTf_SET BCM53101_A0_SWITCH_CTRLr_DISABLE_MII2_OUTPUTf_SET
#define SWITCH_CTRLr_MII1_VOL_SELf_GET BCM53101_A0_SWITCH_CTRLr_MII1_VOL_SELf_GET
#define SWITCH_CTRLr_MII1_VOL_SELf_SET BCM53101_A0_SWITCH_CTRLr_MII1_VOL_SELf_SET
#define SWITCH_CTRLr_MII2_VOL_SELf_GET BCM53101_A0_SWITCH_CTRLr_MII2_VOL_SELf_GET
#define SWITCH_CTRLr_MII2_VOL_SELf_SET BCM53101_A0_SWITCH_CTRLr_MII2_VOL_SELf_SET
#define SWITCH_CTRLr_RESERVEDf_GET BCM53101_A0_SWITCH_CTRLr_RESERVEDf_GET
#define SWITCH_CTRLr_RESERVEDf_SET BCM53101_A0_SWITCH_CTRLr_RESERVEDf_SET
#define READ_SWITCH_CTRLr BCM53101_A0_READ_SWITCH_CTRLr
#define WRITE_SWITCH_CTRLr BCM53101_A0_WRITE_SWITCH_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_SWITCH_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  SWMODE
 * BLOCKS:   SYS
 * DESC:     Switch Mode Register
 * SIZE:     8
 * FIELDS:
 *     SW_FWDG_MODE     Software Forwarding Mode.Strapped from the inverse of the HW_FWDG_EN pin at power-on. Can be overwritten subsequently.0 = Unmanaged Mode.1 = Managed ModeThe ARL treats Reserved Multicast addresses differently dependent on this selection. See Table 3 for a precise definition.
 *     SW_FWDG_EN       Software Forwarding EnableSW_FWDG_EN=1: Frame forwarding is enabled.SW_FWDG_EN=0: Frame forwarding is disabled.Read from HW_FWDG_EN pin on power-on. Can be overwritten subsequently. For managed switch implementations (Lotus5388 mode), the switch should be configured to disable forwarding on power-on, to allow the processor to configure the internal address table and other parameters, before frame forwarding is enabled.
 *     PTRY_LMT_DIS     Retry Limit DisableWhen set, disables the Retry limit on all MAC ports (10/100BASE-T and MII ports). Causes a MAC port in half duplex operation, to continue to retry the same packet regardless of the number of collision attempts.
 *     FAST_TXDESC_RERURN Controls which algorithm is used to release packets when a link goes down.
 *     NOBLKCD          Always not to block carrier detected signal.1'b1: Not to block. txport will always defer to crs.1'b0: Block CD(compatiable with BCM5328).
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_SWMODEr 0x0000000b

#define BCM53101_A0_SWMODEr_SIZE 1

/*
 * This structure should be used to declare and program SWMODE.
 *
 */
typedef union BCM53101_A0_SWMODEr_s {
	uint32_t v[1];
	uint32_t swmode[1];
	uint32_t _swmode;
} BCM53101_A0_SWMODEr_t;

#define BCM53101_A0_SWMODEr_CLR(r) (r).swmode[0] = 0
#define BCM53101_A0_SWMODEr_SET(r,d) (r).swmode[0] = d
#define BCM53101_A0_SWMODEr_GET(r) (r).swmode[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_SWMODEr_SW_FWDG_MODEf_GET(r) (((r).swmode[0]) & 0x1)
#define BCM53101_A0_SWMODEr_SW_FWDG_MODEf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_SWMODEr_SW_FWDG_ENf_GET(r) ((((r).swmode[0]) >> 1) & 0x1)
#define BCM53101_A0_SWMODEr_SW_FWDG_ENf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_SWMODEr_PTRY_LMT_DISf_GET(r) ((((r).swmode[0]) >> 2) & 0x1)
#define BCM53101_A0_SWMODEr_PTRY_LMT_DISf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_SWMODEr_FAST_TXDESC_RERURNf_GET(r) ((((r).swmode[0]) >> 3) & 0x1)
#define BCM53101_A0_SWMODEr_FAST_TXDESC_RERURNf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_SWMODEr_NOBLKCDf_GET(r) ((((r).swmode[0]) >> 4) & 0x1)
#define BCM53101_A0_SWMODEr_NOBLKCDf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_SWMODEr_RESERVEDf_GET(r) ((((r).swmode[0]) >> 5) & 0x7)
#define BCM53101_A0_SWMODEr_RESERVEDf_SET(r,f) (r).swmode[0]=(((r).swmode[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access SWMODE.
 *
 */
#define BCM53101_A0_READ_SWMODEr(u,r) cdk_robo_reg_read(u,BCM53101_A0_SWMODEr,(r._swmode),1)
#define BCM53101_A0_WRITE_SWMODEr(u,r) cdk_robo_reg_write(u,BCM53101_A0_SWMODEr,&(r._swmode),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define SWMODEr BCM53101_A0_SWMODEr
#define SWMODEr_SIZE BCM53101_A0_SWMODEr_SIZE
typedef BCM53101_A0_SWMODEr_t SWMODEr_t;
#define SWMODEr_CLR BCM53101_A0_SWMODEr_CLR
#define SWMODEr_SET BCM53101_A0_SWMODEr_SET
#define SWMODEr_GET BCM53101_A0_SWMODEr_GET
#define SWMODEr_SW_FWDG_MODEf_GET BCM53101_A0_SWMODEr_SW_FWDG_MODEf_GET
#define SWMODEr_SW_FWDG_MODEf_SET BCM53101_A0_SWMODEr_SW_FWDG_MODEf_SET
#define SWMODEr_SW_FWDG_ENf_GET BCM53101_A0_SWMODEr_SW_FWDG_ENf_GET
#define SWMODEr_SW_FWDG_ENf_SET BCM53101_A0_SWMODEr_SW_FWDG_ENf_SET
#define SWMODEr_PTRY_LMT_DISf_GET BCM53101_A0_SWMODEr_PTRY_LMT_DISf_GET
#define SWMODEr_PTRY_LMT_DISf_SET BCM53101_A0_SWMODEr_PTRY_LMT_DISf_SET
#define SWMODEr_FAST_TXDESC_RERURNf_GET BCM53101_A0_SWMODEr_FAST_TXDESC_RERURNf_GET
#define SWMODEr_FAST_TXDESC_RERURNf_SET BCM53101_A0_SWMODEr_FAST_TXDESC_RERURNf_SET
#define SWMODEr_NOBLKCDf_GET BCM53101_A0_SWMODEr_NOBLKCDf_GET
#define SWMODEr_NOBLKCDf_SET BCM53101_A0_SWMODEr_NOBLKCDf_SET
#define SWMODEr_RESERVEDf_GET BCM53101_A0_SWMODEr_RESERVEDf_GET
#define SWMODEr_RESERVEDf_SET BCM53101_A0_SWMODEr_RESERVEDf_SET
#define READ_SWMODEr BCM53101_A0_READ_SWMODEr
#define WRITE_SWMODEr BCM53101_A0_WRITE_SWMODEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_SWMODEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_InRangeErrCount
 * BLOCKS:   SYS
 * DESC:     InRangeErrCount Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_INRANGEERRCOUNTr 0x000071b0

#define BCM53101_A0_S_INRANGEERRCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program S_InRangeErrCount.
 *
 */
typedef union BCM53101_A0_S_INRANGEERRCOUNTr_s {
	uint32_t v[1];
	uint32_t s_inrangeerrcount[1];
	uint32_t _s_inrangeerrcount;
} BCM53101_A0_S_INRANGEERRCOUNTr_t;

#define BCM53101_A0_S_INRANGEERRCOUNTr_CLR(r) (r).s_inrangeerrcount[0] = 0
#define BCM53101_A0_S_INRANGEERRCOUNTr_SET(r,d) (r).s_inrangeerrcount[0] = d
#define BCM53101_A0_S_INRANGEERRCOUNTr_GET(r) (r).s_inrangeerrcount[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_INRANGEERRCOUNTr_COUNTf_GET(r) ((r).s_inrangeerrcount[0])
#define BCM53101_A0_S_INRANGEERRCOUNTr_COUNTf_SET(r,f) (r).s_inrangeerrcount[0]=((uint32_t)f)

/*
 * These macros can be used to access S_InRangeErrCount.
 *
 */
#define BCM53101_A0_READ_S_INRANGEERRCOUNTr(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_INRANGEERRCOUNTr,(r._s_inrangeerrcount),4)
#define BCM53101_A0_WRITE_S_INRANGEERRCOUNTr(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_INRANGEERRCOUNTr,&(r._s_inrangeerrcount),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_INRANGEERRCOUNTr BCM53101_A0_S_INRANGEERRCOUNTr
#define S_INRANGEERRCOUNTr_SIZE BCM53101_A0_S_INRANGEERRCOUNTr_SIZE
typedef BCM53101_A0_S_INRANGEERRCOUNTr_t S_INRANGEERRCOUNTr_t;
#define S_INRANGEERRCOUNTr_CLR BCM53101_A0_S_INRANGEERRCOUNTr_CLR
#define S_INRANGEERRCOUNTr_SET BCM53101_A0_S_INRANGEERRCOUNTr_SET
#define S_INRANGEERRCOUNTr_GET BCM53101_A0_S_INRANGEERRCOUNTr_GET
#define S_INRANGEERRCOUNTr_COUNTf_GET BCM53101_A0_S_INRANGEERRCOUNTr_COUNTf_GET
#define S_INRANGEERRCOUNTr_COUNTf_SET BCM53101_A0_S_INRANGEERRCOUNTr_COUNTf_SET
#define READ_S_INRANGEERRCOUNTr BCM53101_A0_READ_S_INRANGEERRCOUNTr
#define WRITE_S_INRANGEERRCOUNTr BCM53101_A0_WRITE_S_INRANGEERRCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_INRANGEERRCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_JumboPkt
 * BLOCKS:   SYS
 * DESC:     Jumbo Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_JUMBOPKTr 0x000071a8

#define BCM53101_A0_S_JUMBOPKTr_SIZE 4

/*
 * This structure should be used to declare and program S_JumboPkt.
 *
 */
typedef union BCM53101_A0_S_JUMBOPKTr_s {
	uint32_t v[1];
	uint32_t s_jumbopkt[1];
	uint32_t _s_jumbopkt;
} BCM53101_A0_S_JUMBOPKTr_t;

#define BCM53101_A0_S_JUMBOPKTr_CLR(r) (r).s_jumbopkt[0] = 0
#define BCM53101_A0_S_JUMBOPKTr_SET(r,d) (r).s_jumbopkt[0] = d
#define BCM53101_A0_S_JUMBOPKTr_GET(r) (r).s_jumbopkt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_JUMBOPKTr_COUNTf_GET(r) ((r).s_jumbopkt[0])
#define BCM53101_A0_S_JUMBOPKTr_COUNTf_SET(r,f) (r).s_jumbopkt[0]=((uint32_t)f)

/*
 * These macros can be used to access S_JumboPkt.
 *
 */
#define BCM53101_A0_READ_S_JUMBOPKTr(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_JUMBOPKTr,(r._s_jumbopkt),4)
#define BCM53101_A0_WRITE_S_JUMBOPKTr(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_JUMBOPKTr,&(r._s_jumbopkt),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_JUMBOPKTr BCM53101_A0_S_JUMBOPKTr
#define S_JUMBOPKTr_SIZE BCM53101_A0_S_JUMBOPKTr_SIZE
typedef BCM53101_A0_S_JUMBOPKTr_t S_JUMBOPKTr_t;
#define S_JUMBOPKTr_CLR BCM53101_A0_S_JUMBOPKTr_CLR
#define S_JUMBOPKTr_SET BCM53101_A0_S_JUMBOPKTr_SET
#define S_JUMBOPKTr_GET BCM53101_A0_S_JUMBOPKTr_GET
#define S_JUMBOPKTr_COUNTf_GET BCM53101_A0_S_JUMBOPKTr_COUNTf_GET
#define S_JUMBOPKTr_COUNTf_SET BCM53101_A0_S_JUMBOPKTr_COUNTf_SET
#define READ_S_JUMBOPKTr BCM53101_A0_READ_S_JUMBOPKTr
#define WRITE_S_JUMBOPKTr BCM53101_A0_WRITE_S_JUMBOPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_JUMBOPKTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_OutRangeErrCount
 * BLOCKS:   SYS
 * DESC:     OutRangeErrCount Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_OUTRANGEERRCOUNTr 0x000071b4

#define BCM53101_A0_S_OUTRANGEERRCOUNTr_SIZE 4

/*
 * This structure should be used to declare and program S_OutRangeErrCount.
 *
 */
typedef union BCM53101_A0_S_OUTRANGEERRCOUNTr_s {
	uint32_t v[1];
	uint32_t s_outrangeerrcount[1];
	uint32_t _s_outrangeerrcount;
} BCM53101_A0_S_OUTRANGEERRCOUNTr_t;

#define BCM53101_A0_S_OUTRANGEERRCOUNTr_CLR(r) (r).s_outrangeerrcount[0] = 0
#define BCM53101_A0_S_OUTRANGEERRCOUNTr_SET(r,d) (r).s_outrangeerrcount[0] = d
#define BCM53101_A0_S_OUTRANGEERRCOUNTr_GET(r) (r).s_outrangeerrcount[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_OUTRANGEERRCOUNTr_COUNTf_GET(r) ((r).s_outrangeerrcount[0])
#define BCM53101_A0_S_OUTRANGEERRCOUNTr_COUNTf_SET(r,f) (r).s_outrangeerrcount[0]=((uint32_t)f)

/*
 * These macros can be used to access S_OutRangeErrCount.
 *
 */
#define BCM53101_A0_READ_S_OUTRANGEERRCOUNTr(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_OUTRANGEERRCOUNTr,(r._s_outrangeerrcount),4)
#define BCM53101_A0_WRITE_S_OUTRANGEERRCOUNTr(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_OUTRANGEERRCOUNTr,&(r._s_outrangeerrcount),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_OUTRANGEERRCOUNTr BCM53101_A0_S_OUTRANGEERRCOUNTr
#define S_OUTRANGEERRCOUNTr_SIZE BCM53101_A0_S_OUTRANGEERRCOUNTr_SIZE
typedef BCM53101_A0_S_OUTRANGEERRCOUNTr_t S_OUTRANGEERRCOUNTr_t;
#define S_OUTRANGEERRCOUNTr_CLR BCM53101_A0_S_OUTRANGEERRCOUNTr_CLR
#define S_OUTRANGEERRCOUNTr_SET BCM53101_A0_S_OUTRANGEERRCOUNTr_SET
#define S_OUTRANGEERRCOUNTr_GET BCM53101_A0_S_OUTRANGEERRCOUNTr_GET
#define S_OUTRANGEERRCOUNTr_COUNTf_GET BCM53101_A0_S_OUTRANGEERRCOUNTr_COUNTf_GET
#define S_OUTRANGEERRCOUNTr_COUNTf_SET BCM53101_A0_S_OUTRANGEERRCOUNTr_COUNTf_SET
#define READ_S_OUTRANGEERRCOUNTr BCM53101_A0_READ_S_OUTRANGEERRCOUNTr
#define WRITE_S_OUTRANGEERRCOUNTr BCM53101_A0_WRITE_S_OUTRANGEERRCOUNTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_OUTRANGEERRCOUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_Pkts1024toMaxPktOctets
 * BLOCKS:   SYS
 * DESC:     Rx 1024 to MaxPkt Bytes Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_PKTS1024TOMAXPKTOCTETSr 0x00007174

#define BCM53101_A0_S_PKTS1024TOMAXPKTOCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts1024toMaxPktOctets.
 *
 */
typedef union BCM53101_A0_S_PKTS1024TOMAXPKTOCTETSr_s {
	uint32_t v[1];
	uint32_t s_pkts1024tomaxpktoctets[1];
	uint32_t _s_pkts1024tomaxpktoctets;
} BCM53101_A0_S_PKTS1024TOMAXPKTOCTETSr_t;

#define BCM53101_A0_S_PKTS1024TOMAXPKTOCTETSr_CLR(r) (r).s_pkts1024tomaxpktoctets[0] = 0
#define BCM53101_A0_S_PKTS1024TOMAXPKTOCTETSr_SET(r,d) (r).s_pkts1024tomaxpktoctets[0] = d
#define BCM53101_A0_S_PKTS1024TOMAXPKTOCTETSr_GET(r) (r).s_pkts1024tomaxpktoctets[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_PKTS1024TOMAXPKTOCTETSr_COUNTf_GET(r) ((r).s_pkts1024tomaxpktoctets[0])
#define BCM53101_A0_S_PKTS1024TOMAXPKTOCTETSr_COUNTf_SET(r,f) (r).s_pkts1024tomaxpktoctets[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts1024toMaxPktOctets.
 *
 */
#define BCM53101_A0_READ_S_PKTS1024TOMAXPKTOCTETSr(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_PKTS1024TOMAXPKTOCTETSr,(r._s_pkts1024tomaxpktoctets),4)
#define BCM53101_A0_WRITE_S_PKTS1024TOMAXPKTOCTETSr(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_PKTS1024TOMAXPKTOCTETSr,&(r._s_pkts1024tomaxpktoctets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS1024TOMAXPKTOCTETSr BCM53101_A0_S_PKTS1024TOMAXPKTOCTETSr
#define S_PKTS1024TOMAXPKTOCTETSr_SIZE BCM53101_A0_S_PKTS1024TOMAXPKTOCTETSr_SIZE
typedef BCM53101_A0_S_PKTS1024TOMAXPKTOCTETSr_t S_PKTS1024TOMAXPKTOCTETSr_t;
#define S_PKTS1024TOMAXPKTOCTETSr_CLR BCM53101_A0_S_PKTS1024TOMAXPKTOCTETSr_CLR
#define S_PKTS1024TOMAXPKTOCTETSr_SET BCM53101_A0_S_PKTS1024TOMAXPKTOCTETSr_SET
#define S_PKTS1024TOMAXPKTOCTETSr_GET BCM53101_A0_S_PKTS1024TOMAXPKTOCTETSr_GET
#define S_PKTS1024TOMAXPKTOCTETSr_COUNTf_GET BCM53101_A0_S_PKTS1024TOMAXPKTOCTETSr_COUNTf_GET
#define S_PKTS1024TOMAXPKTOCTETSr_COUNTf_SET BCM53101_A0_S_PKTS1024TOMAXPKTOCTETSr_COUNTf_SET
#define READ_S_PKTS1024TOMAXPKTOCTETSr BCM53101_A0_READ_S_PKTS1024TOMAXPKTOCTETSr
#define WRITE_S_PKTS1024TOMAXPKTOCTETSr BCM53101_A0_WRITE_S_PKTS1024TOMAXPKTOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_PKTS1024TOMAXPKTOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_Pkts128to255Octets
 * BLOCKS:   SYS
 * DESC:     Rx 128 to 255 Bytes Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_PKTS128TO255OCTETSr 0x00007168

#define BCM53101_A0_S_PKTS128TO255OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts128to255Octets.
 *
 */
typedef union BCM53101_A0_S_PKTS128TO255OCTETSr_s {
	uint32_t v[1];
	uint32_t s_pkts128to255octets[1];
	uint32_t _s_pkts128to255octets;
} BCM53101_A0_S_PKTS128TO255OCTETSr_t;

#define BCM53101_A0_S_PKTS128TO255OCTETSr_CLR(r) (r).s_pkts128to255octets[0] = 0
#define BCM53101_A0_S_PKTS128TO255OCTETSr_SET(r,d) (r).s_pkts128to255octets[0] = d
#define BCM53101_A0_S_PKTS128TO255OCTETSr_GET(r) (r).s_pkts128to255octets[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_PKTS128TO255OCTETSr_COUNTf_GET(r) ((r).s_pkts128to255octets[0])
#define BCM53101_A0_S_PKTS128TO255OCTETSr_COUNTf_SET(r,f) (r).s_pkts128to255octets[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts128to255Octets.
 *
 */
#define BCM53101_A0_READ_S_PKTS128TO255OCTETSr(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_PKTS128TO255OCTETSr,(r._s_pkts128to255octets),4)
#define BCM53101_A0_WRITE_S_PKTS128TO255OCTETSr(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_PKTS128TO255OCTETSr,&(r._s_pkts128to255octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS128TO255OCTETSr BCM53101_A0_S_PKTS128TO255OCTETSr
#define S_PKTS128TO255OCTETSr_SIZE BCM53101_A0_S_PKTS128TO255OCTETSr_SIZE
typedef BCM53101_A0_S_PKTS128TO255OCTETSr_t S_PKTS128TO255OCTETSr_t;
#define S_PKTS128TO255OCTETSr_CLR BCM53101_A0_S_PKTS128TO255OCTETSr_CLR
#define S_PKTS128TO255OCTETSr_SET BCM53101_A0_S_PKTS128TO255OCTETSr_SET
#define S_PKTS128TO255OCTETSr_GET BCM53101_A0_S_PKTS128TO255OCTETSr_GET
#define S_PKTS128TO255OCTETSr_COUNTf_GET BCM53101_A0_S_PKTS128TO255OCTETSr_COUNTf_GET
#define S_PKTS128TO255OCTETSr_COUNTf_SET BCM53101_A0_S_PKTS128TO255OCTETSr_COUNTf_SET
#define READ_S_PKTS128TO255OCTETSr BCM53101_A0_READ_S_PKTS128TO255OCTETSr
#define WRITE_S_PKTS128TO255OCTETSr BCM53101_A0_WRITE_S_PKTS128TO255OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_PKTS128TO255OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_Pkts256to511Octets
 * BLOCKS:   SYS
 * DESC:     Rx 256 to 511 Bytes Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_PKTS256TO511OCTETSr 0x0000716c

#define BCM53101_A0_S_PKTS256TO511OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts256to511Octets.
 *
 */
typedef union BCM53101_A0_S_PKTS256TO511OCTETSr_s {
	uint32_t v[1];
	uint32_t s_pkts256to511octets[1];
	uint32_t _s_pkts256to511octets;
} BCM53101_A0_S_PKTS256TO511OCTETSr_t;

#define BCM53101_A0_S_PKTS256TO511OCTETSr_CLR(r) (r).s_pkts256to511octets[0] = 0
#define BCM53101_A0_S_PKTS256TO511OCTETSr_SET(r,d) (r).s_pkts256to511octets[0] = d
#define BCM53101_A0_S_PKTS256TO511OCTETSr_GET(r) (r).s_pkts256to511octets[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_PKTS256TO511OCTETSr_COUNTf_GET(r) ((r).s_pkts256to511octets[0])
#define BCM53101_A0_S_PKTS256TO511OCTETSr_COUNTf_SET(r,f) (r).s_pkts256to511octets[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts256to511Octets.
 *
 */
#define BCM53101_A0_READ_S_PKTS256TO511OCTETSr(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_PKTS256TO511OCTETSr,(r._s_pkts256to511octets),4)
#define BCM53101_A0_WRITE_S_PKTS256TO511OCTETSr(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_PKTS256TO511OCTETSr,&(r._s_pkts256to511octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS256TO511OCTETSr BCM53101_A0_S_PKTS256TO511OCTETSr
#define S_PKTS256TO511OCTETSr_SIZE BCM53101_A0_S_PKTS256TO511OCTETSr_SIZE
typedef BCM53101_A0_S_PKTS256TO511OCTETSr_t S_PKTS256TO511OCTETSr_t;
#define S_PKTS256TO511OCTETSr_CLR BCM53101_A0_S_PKTS256TO511OCTETSr_CLR
#define S_PKTS256TO511OCTETSr_SET BCM53101_A0_S_PKTS256TO511OCTETSr_SET
#define S_PKTS256TO511OCTETSr_GET BCM53101_A0_S_PKTS256TO511OCTETSr_GET
#define S_PKTS256TO511OCTETSr_COUNTf_GET BCM53101_A0_S_PKTS256TO511OCTETSr_COUNTf_GET
#define S_PKTS256TO511OCTETSr_COUNTf_SET BCM53101_A0_S_PKTS256TO511OCTETSr_COUNTf_SET
#define READ_S_PKTS256TO511OCTETSr BCM53101_A0_READ_S_PKTS256TO511OCTETSr
#define WRITE_S_PKTS256TO511OCTETSr BCM53101_A0_WRITE_S_PKTS256TO511OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_PKTS256TO511OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_Pkts512to1023Octets
 * BLOCKS:   SYS
 * DESC:     Rx 512 to 1023 Bytes Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_PKTS512TO1023OCTETSr 0x00007170

#define BCM53101_A0_S_PKTS512TO1023OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts512to1023Octets.
 *
 */
typedef union BCM53101_A0_S_PKTS512TO1023OCTETSr_s {
	uint32_t v[1];
	uint32_t s_pkts512to1023octets[1];
	uint32_t _s_pkts512to1023octets;
} BCM53101_A0_S_PKTS512TO1023OCTETSr_t;

#define BCM53101_A0_S_PKTS512TO1023OCTETSr_CLR(r) (r).s_pkts512to1023octets[0] = 0
#define BCM53101_A0_S_PKTS512TO1023OCTETSr_SET(r,d) (r).s_pkts512to1023octets[0] = d
#define BCM53101_A0_S_PKTS512TO1023OCTETSr_GET(r) (r).s_pkts512to1023octets[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_PKTS512TO1023OCTETSr_COUNTf_GET(r) ((r).s_pkts512to1023octets[0])
#define BCM53101_A0_S_PKTS512TO1023OCTETSr_COUNTf_SET(r,f) (r).s_pkts512to1023octets[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts512to1023Octets.
 *
 */
#define BCM53101_A0_READ_S_PKTS512TO1023OCTETSr(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_PKTS512TO1023OCTETSr,(r._s_pkts512to1023octets),4)
#define BCM53101_A0_WRITE_S_PKTS512TO1023OCTETSr(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_PKTS512TO1023OCTETSr,&(r._s_pkts512to1023octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS512TO1023OCTETSr BCM53101_A0_S_PKTS512TO1023OCTETSr
#define S_PKTS512TO1023OCTETSr_SIZE BCM53101_A0_S_PKTS512TO1023OCTETSr_SIZE
typedef BCM53101_A0_S_PKTS512TO1023OCTETSr_t S_PKTS512TO1023OCTETSr_t;
#define S_PKTS512TO1023OCTETSr_CLR BCM53101_A0_S_PKTS512TO1023OCTETSr_CLR
#define S_PKTS512TO1023OCTETSr_SET BCM53101_A0_S_PKTS512TO1023OCTETSr_SET
#define S_PKTS512TO1023OCTETSr_GET BCM53101_A0_S_PKTS512TO1023OCTETSr_GET
#define S_PKTS512TO1023OCTETSr_COUNTf_GET BCM53101_A0_S_PKTS512TO1023OCTETSr_COUNTf_GET
#define S_PKTS512TO1023OCTETSr_COUNTf_SET BCM53101_A0_S_PKTS512TO1023OCTETSr_COUNTf_SET
#define READ_S_PKTS512TO1023OCTETSr BCM53101_A0_READ_S_PKTS512TO1023OCTETSr
#define WRITE_S_PKTS512TO1023OCTETSr BCM53101_A0_WRITE_S_PKTS512TO1023OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_PKTS512TO1023OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_Pkts64Octets
 * BLOCKS:   SYS
 * DESC:     Rx 64 Bytes Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_PKTS64OCTETSr 0x00007160

#define BCM53101_A0_S_PKTS64OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts64Octets.
 *
 */
typedef union BCM53101_A0_S_PKTS64OCTETSr_s {
	uint32_t v[1];
	uint32_t s_pkts64octets[1];
	uint32_t _s_pkts64octets;
} BCM53101_A0_S_PKTS64OCTETSr_t;

#define BCM53101_A0_S_PKTS64OCTETSr_CLR(r) (r).s_pkts64octets[0] = 0
#define BCM53101_A0_S_PKTS64OCTETSr_SET(r,d) (r).s_pkts64octets[0] = d
#define BCM53101_A0_S_PKTS64OCTETSr_GET(r) (r).s_pkts64octets[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_PKTS64OCTETSr_COUNTf_GET(r) ((r).s_pkts64octets[0])
#define BCM53101_A0_S_PKTS64OCTETSr_COUNTf_SET(r,f) (r).s_pkts64octets[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts64Octets.
 *
 */
#define BCM53101_A0_READ_S_PKTS64OCTETSr(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_PKTS64OCTETSr,(r._s_pkts64octets),4)
#define BCM53101_A0_WRITE_S_PKTS64OCTETSr(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_PKTS64OCTETSr,&(r._s_pkts64octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS64OCTETSr BCM53101_A0_S_PKTS64OCTETSr
#define S_PKTS64OCTETSr_SIZE BCM53101_A0_S_PKTS64OCTETSr_SIZE
typedef BCM53101_A0_S_PKTS64OCTETSr_t S_PKTS64OCTETSr_t;
#define S_PKTS64OCTETSr_CLR BCM53101_A0_S_PKTS64OCTETSr_CLR
#define S_PKTS64OCTETSr_SET BCM53101_A0_S_PKTS64OCTETSr_SET
#define S_PKTS64OCTETSr_GET BCM53101_A0_S_PKTS64OCTETSr_GET
#define S_PKTS64OCTETSr_COUNTf_GET BCM53101_A0_S_PKTS64OCTETSr_COUNTf_GET
#define S_PKTS64OCTETSr_COUNTf_SET BCM53101_A0_S_PKTS64OCTETSr_COUNTf_SET
#define READ_S_PKTS64OCTETSr BCM53101_A0_READ_S_PKTS64OCTETSr
#define WRITE_S_PKTS64OCTETSr BCM53101_A0_WRITE_S_PKTS64OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_PKTS64OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_Pkts65to127Octets
 * BLOCKS:   SYS
 * DESC:     Rx 65 to 127 Bytes Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_PKTS65TO127OCTETSr 0x00007164

#define BCM53101_A0_S_PKTS65TO127OCTETSr_SIZE 4

/*
 * This structure should be used to declare and program S_Pkts65to127Octets.
 *
 */
typedef union BCM53101_A0_S_PKTS65TO127OCTETSr_s {
	uint32_t v[1];
	uint32_t s_pkts65to127octets[1];
	uint32_t _s_pkts65to127octets;
} BCM53101_A0_S_PKTS65TO127OCTETSr_t;

#define BCM53101_A0_S_PKTS65TO127OCTETSr_CLR(r) (r).s_pkts65to127octets[0] = 0
#define BCM53101_A0_S_PKTS65TO127OCTETSr_SET(r,d) (r).s_pkts65to127octets[0] = d
#define BCM53101_A0_S_PKTS65TO127OCTETSr_GET(r) (r).s_pkts65to127octets[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_PKTS65TO127OCTETSr_COUNTf_GET(r) ((r).s_pkts65to127octets[0])
#define BCM53101_A0_S_PKTS65TO127OCTETSr_COUNTf_SET(r,f) (r).s_pkts65to127octets[0]=((uint32_t)f)

/*
 * These macros can be used to access S_Pkts65to127Octets.
 *
 */
#define BCM53101_A0_READ_S_PKTS65TO127OCTETSr(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_PKTS65TO127OCTETSr,(r._s_pkts65to127octets),4)
#define BCM53101_A0_WRITE_S_PKTS65TO127OCTETSr(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_PKTS65TO127OCTETSr,&(r._s_pkts65to127octets),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_PKTS65TO127OCTETSr BCM53101_A0_S_PKTS65TO127OCTETSr
#define S_PKTS65TO127OCTETSr_SIZE BCM53101_A0_S_PKTS65TO127OCTETSr_SIZE
typedef BCM53101_A0_S_PKTS65TO127OCTETSr_t S_PKTS65TO127OCTETSr_t;
#define S_PKTS65TO127OCTETSr_CLR BCM53101_A0_S_PKTS65TO127OCTETSr_CLR
#define S_PKTS65TO127OCTETSr_SET BCM53101_A0_S_PKTS65TO127OCTETSr_SET
#define S_PKTS65TO127OCTETSr_GET BCM53101_A0_S_PKTS65TO127OCTETSr_GET
#define S_PKTS65TO127OCTETSr_COUNTf_GET BCM53101_A0_S_PKTS65TO127OCTETSr_COUNTf_GET
#define S_PKTS65TO127OCTETSr_COUNTf_SET BCM53101_A0_S_PKTS65TO127OCTETSr_COUNTf_SET
#define READ_S_PKTS65TO127OCTETSr BCM53101_A0_READ_S_PKTS65TO127OCTETSr
#define WRITE_S_PKTS65TO127OCTETSr BCM53101_A0_WRITE_S_PKTS65TO127OCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_PKTS65TO127OCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_RXDISCARD
 * BLOCKS:   SYS
 * DESC:     Rx Discard Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_RXDISCARDr 0x000071c0

#define BCM53101_A0_S_RXDISCARDr_SIZE 4

/*
 * This structure should be used to declare and program S_RXDISCARD.
 *
 */
typedef union BCM53101_A0_S_RXDISCARDr_s {
	uint32_t v[1];
	uint32_t s_rxdiscard[1];
	uint32_t _s_rxdiscard;
} BCM53101_A0_S_RXDISCARDr_t;

#define BCM53101_A0_S_RXDISCARDr_CLR(r) (r).s_rxdiscard[0] = 0
#define BCM53101_A0_S_RXDISCARDr_SET(r,d) (r).s_rxdiscard[0] = d
#define BCM53101_A0_S_RXDISCARDr_GET(r) (r).s_rxdiscard[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_RXDISCARDr_COUNTf_GET(r) ((r).s_rxdiscard[0])
#define BCM53101_A0_S_RXDISCARDr_COUNTf_SET(r,f) (r).s_rxdiscard[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RXDISCARD.
 *
 */
#define BCM53101_A0_READ_S_RXDISCARDr(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_RXDISCARDr,(r._s_rxdiscard),4)
#define BCM53101_A0_WRITE_S_RXDISCARDr(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_RXDISCARDr,&(r._s_rxdiscard),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXDISCARDr BCM53101_A0_S_RXDISCARDr
#define S_RXDISCARDr_SIZE BCM53101_A0_S_RXDISCARDr_SIZE
typedef BCM53101_A0_S_RXDISCARDr_t S_RXDISCARDr_t;
#define S_RXDISCARDr_CLR BCM53101_A0_S_RXDISCARDr_CLR
#define S_RXDISCARDr_SET BCM53101_A0_S_RXDISCARDr_SET
#define S_RXDISCARDr_GET BCM53101_A0_S_RXDISCARDr_GET
#define S_RXDISCARDr_COUNTf_GET BCM53101_A0_S_RXDISCARDr_COUNTf_GET
#define S_RXDISCARDr_COUNTf_SET BCM53101_A0_S_RXDISCARDr_COUNTf_SET
#define READ_S_RXDISCARDr BCM53101_A0_READ_S_RXDISCARDr
#define WRITE_S_RXDISCARDr BCM53101_A0_WRITE_S_RXDISCARDr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_RXDISCARDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_RXSymblErr
 * BLOCKS:   SYS
 * DESC:     Rx Symbol Error Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_RXSYMBLERRr 0x000071ac

#define BCM53101_A0_S_RXSYMBLERRr_SIZE 4

/*
 * This structure should be used to declare and program S_RXSymblErr.
 *
 */
typedef union BCM53101_A0_S_RXSYMBLERRr_s {
	uint32_t v[1];
	uint32_t s_rxsymblerr[1];
	uint32_t _s_rxsymblerr;
} BCM53101_A0_S_RXSYMBLERRr_t;

#define BCM53101_A0_S_RXSYMBLERRr_CLR(r) (r).s_rxsymblerr[0] = 0
#define BCM53101_A0_S_RXSYMBLERRr_SET(r,d) (r).s_rxsymblerr[0] = d
#define BCM53101_A0_S_RXSYMBLERRr_GET(r) (r).s_rxsymblerr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_RXSYMBLERRr_COUNTf_GET(r) ((r).s_rxsymblerr[0])
#define BCM53101_A0_S_RXSYMBLERRr_COUNTf_SET(r,f) (r).s_rxsymblerr[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RXSymblErr.
 *
 */
#define BCM53101_A0_READ_S_RXSYMBLERRr(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_RXSYMBLERRr,(r._s_rxsymblerr),4)
#define BCM53101_A0_WRITE_S_RXSYMBLERRr(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_RXSYMBLERRr,&(r._s_rxsymblerr),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXSYMBLERRr BCM53101_A0_S_RXSYMBLERRr
#define S_RXSYMBLERRr_SIZE BCM53101_A0_S_RXSYMBLERRr_SIZE
typedef BCM53101_A0_S_RXSYMBLERRr_t S_RXSYMBLERRr_t;
#define S_RXSYMBLERRr_CLR BCM53101_A0_S_RXSYMBLERRr_CLR
#define S_RXSYMBLERRr_SET BCM53101_A0_S_RXSYMBLERRr_SET
#define S_RXSYMBLERRr_GET BCM53101_A0_S_RXSYMBLERRr_GET
#define S_RXSYMBLERRr_COUNTf_GET BCM53101_A0_S_RXSYMBLERRr_COUNTf_GET
#define S_RXSYMBLERRr_COUNTf_SET BCM53101_A0_S_RXSYMBLERRr_COUNTf_SET
#define READ_S_RXSYMBLERRr BCM53101_A0_READ_S_RXSYMBLERRr
#define WRITE_S_RXSYMBLERRr BCM53101_A0_WRITE_S_RXSYMBLERRr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_RXSYMBLERRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_RxAlignmentErrors
 * BLOCKS:   SYS
 * DESC:     Rx Alignment Error Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_RXALIGNMENTERRORSr 0x00007180

#define BCM53101_A0_S_RXALIGNMENTERRORSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxAlignmentErrors.
 *
 */
typedef union BCM53101_A0_S_RXALIGNMENTERRORSr_s {
	uint32_t v[1];
	uint32_t s_rxalignmenterrors[1];
	uint32_t _s_rxalignmenterrors;
} BCM53101_A0_S_RXALIGNMENTERRORSr_t;

#define BCM53101_A0_S_RXALIGNMENTERRORSr_CLR(r) (r).s_rxalignmenterrors[0] = 0
#define BCM53101_A0_S_RXALIGNMENTERRORSr_SET(r,d) (r).s_rxalignmenterrors[0] = d
#define BCM53101_A0_S_RXALIGNMENTERRORSr_GET(r) (r).s_rxalignmenterrors[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_RXALIGNMENTERRORSr_COUNTf_GET(r) ((r).s_rxalignmenterrors[0])
#define BCM53101_A0_S_RXALIGNMENTERRORSr_COUNTf_SET(r,f) (r).s_rxalignmenterrors[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxAlignmentErrors.
 *
 */
#define BCM53101_A0_READ_S_RXALIGNMENTERRORSr(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_RXALIGNMENTERRORSr,(r._s_rxalignmenterrors),4)
#define BCM53101_A0_WRITE_S_RXALIGNMENTERRORSr(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_RXALIGNMENTERRORSr,&(r._s_rxalignmenterrors),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXALIGNMENTERRORSr BCM53101_A0_S_RXALIGNMENTERRORSr
#define S_RXALIGNMENTERRORSr_SIZE BCM53101_A0_S_RXALIGNMENTERRORSr_SIZE
typedef BCM53101_A0_S_RXALIGNMENTERRORSr_t S_RXALIGNMENTERRORSr_t;
#define S_RXALIGNMENTERRORSr_CLR BCM53101_A0_S_RXALIGNMENTERRORSr_CLR
#define S_RXALIGNMENTERRORSr_SET BCM53101_A0_S_RXALIGNMENTERRORSr_SET
#define S_RXALIGNMENTERRORSr_GET BCM53101_A0_S_RXALIGNMENTERRORSr_GET
#define S_RXALIGNMENTERRORSr_COUNTf_GET BCM53101_A0_S_RXALIGNMENTERRORSr_COUNTf_GET
#define S_RXALIGNMENTERRORSr_COUNTf_SET BCM53101_A0_S_RXALIGNMENTERRORSr_COUNTf_SET
#define READ_S_RXALIGNMENTERRORSr BCM53101_A0_READ_S_RXALIGNMENTERRORSr
#define WRITE_S_RXALIGNMENTERRORSr BCM53101_A0_WRITE_S_RXALIGNMENTERRORSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_RXALIGNMENTERRORSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_RxBroadcastPkt
 * BLOCKS:   SYS
 * DESC:     Rx Broadcast Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_RXBROADCASTPKTr 0x0000719c

#define BCM53101_A0_S_RXBROADCASTPKTr_SIZE 4

/*
 * This structure should be used to declare and program S_RxBroadcastPkt.
 *
 */
typedef union BCM53101_A0_S_RXBROADCASTPKTr_s {
	uint32_t v[1];
	uint32_t s_rxbroadcastpkt[1];
	uint32_t _s_rxbroadcastpkt;
} BCM53101_A0_S_RXBROADCASTPKTr_t;

#define BCM53101_A0_S_RXBROADCASTPKTr_CLR(r) (r).s_rxbroadcastpkt[0] = 0
#define BCM53101_A0_S_RXBROADCASTPKTr_SET(r,d) (r).s_rxbroadcastpkt[0] = d
#define BCM53101_A0_S_RXBROADCASTPKTr_GET(r) (r).s_rxbroadcastpkt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_RXBROADCASTPKTr_COUNTf_GET(r) ((r).s_rxbroadcastpkt[0])
#define BCM53101_A0_S_RXBROADCASTPKTr_COUNTf_SET(r,f) (r).s_rxbroadcastpkt[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxBroadcastPkt.
 *
 */
#define BCM53101_A0_READ_S_RXBROADCASTPKTr(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_RXBROADCASTPKTr,(r._s_rxbroadcastpkt),4)
#define BCM53101_A0_WRITE_S_RXBROADCASTPKTr(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_RXBROADCASTPKTr,&(r._s_rxbroadcastpkt),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXBROADCASTPKTr BCM53101_A0_S_RXBROADCASTPKTr
#define S_RXBROADCASTPKTr_SIZE BCM53101_A0_S_RXBROADCASTPKTr_SIZE
typedef BCM53101_A0_S_RXBROADCASTPKTr_t S_RXBROADCASTPKTr_t;
#define S_RXBROADCASTPKTr_CLR BCM53101_A0_S_RXBROADCASTPKTr_CLR
#define S_RXBROADCASTPKTr_SET BCM53101_A0_S_RXBROADCASTPKTr_SET
#define S_RXBROADCASTPKTr_GET BCM53101_A0_S_RXBROADCASTPKTr_GET
#define S_RXBROADCASTPKTr_COUNTf_GET BCM53101_A0_S_RXBROADCASTPKTr_COUNTf_GET
#define S_RXBROADCASTPKTr_COUNTf_SET BCM53101_A0_S_RXBROADCASTPKTr_COUNTf_SET
#define READ_S_RXBROADCASTPKTr BCM53101_A0_READ_S_RXBROADCASTPKTr
#define WRITE_S_RXBROADCASTPKTr BCM53101_A0_WRITE_S_RXBROADCASTPKTr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_RXBROADCASTPKTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_RxDropPkts
 * BLOCKS:   SYS
 * DESC:     Rx Drop Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_RXDROPPKTSr 0x00007190

#define BCM53101_A0_S_RXDROPPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxDropPkts.
 *
 */
typedef union BCM53101_A0_S_RXDROPPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxdroppkts[1];
	uint32_t _s_rxdroppkts;
} BCM53101_A0_S_RXDROPPKTSr_t;

#define BCM53101_A0_S_RXDROPPKTSr_CLR(r) (r).s_rxdroppkts[0] = 0
#define BCM53101_A0_S_RXDROPPKTSr_SET(r,d) (r).s_rxdroppkts[0] = d
#define BCM53101_A0_S_RXDROPPKTSr_GET(r) (r).s_rxdroppkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_RXDROPPKTSr_COUNTf_GET(r) ((r).s_rxdroppkts[0])
#define BCM53101_A0_S_RXDROPPKTSr_COUNTf_SET(r,f) (r).s_rxdroppkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxDropPkts.
 *
 */
#define BCM53101_A0_READ_S_RXDROPPKTSr(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_RXDROPPKTSr,(r._s_rxdroppkts),4)
#define BCM53101_A0_WRITE_S_RXDROPPKTSr(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_RXDROPPKTSr,&(r._s_rxdroppkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXDROPPKTSr BCM53101_A0_S_RXDROPPKTSr
#define S_RXDROPPKTSr_SIZE BCM53101_A0_S_RXDROPPKTSr_SIZE
typedef BCM53101_A0_S_RXDROPPKTSr_t S_RXDROPPKTSr_t;
#define S_RXDROPPKTSr_CLR BCM53101_A0_S_RXDROPPKTSr_CLR
#define S_RXDROPPKTSr_SET BCM53101_A0_S_RXDROPPKTSr_SET
#define S_RXDROPPKTSr_GET BCM53101_A0_S_RXDROPPKTSr_GET
#define S_RXDROPPKTSr_COUNTf_GET BCM53101_A0_S_RXDROPPKTSr_COUNTf_GET
#define S_RXDROPPKTSr_COUNTf_SET BCM53101_A0_S_RXDROPPKTSr_COUNTf_SET
#define READ_S_RXDROPPKTSr BCM53101_A0_READ_S_RXDROPPKTSr
#define WRITE_S_RXDROPPKTSr BCM53101_A0_WRITE_S_RXDROPPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_RXDROPPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_RxFCSErrors
 * BLOCKS:   SYS
 * DESC:     Rx FCS Error Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_RXFCSERRORSr 0x00007184

#define BCM53101_A0_S_RXFCSERRORSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxFCSErrors.
 *
 */
typedef union BCM53101_A0_S_RXFCSERRORSr_s {
	uint32_t v[1];
	uint32_t s_rxfcserrors[1];
	uint32_t _s_rxfcserrors;
} BCM53101_A0_S_RXFCSERRORSr_t;

#define BCM53101_A0_S_RXFCSERRORSr_CLR(r) (r).s_rxfcserrors[0] = 0
#define BCM53101_A0_S_RXFCSERRORSr_SET(r,d) (r).s_rxfcserrors[0] = d
#define BCM53101_A0_S_RXFCSERRORSr_GET(r) (r).s_rxfcserrors[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_RXFCSERRORSr_COUNTf_GET(r) ((r).s_rxfcserrors[0])
#define BCM53101_A0_S_RXFCSERRORSr_COUNTf_SET(r,f) (r).s_rxfcserrors[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxFCSErrors.
 *
 */
#define BCM53101_A0_READ_S_RXFCSERRORSr(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_RXFCSERRORSr,(r._s_rxfcserrors),4)
#define BCM53101_A0_WRITE_S_RXFCSERRORSr(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_RXFCSERRORSr,&(r._s_rxfcserrors),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXFCSERRORSr BCM53101_A0_S_RXFCSERRORSr
#define S_RXFCSERRORSr_SIZE BCM53101_A0_S_RXFCSERRORSr_SIZE
typedef BCM53101_A0_S_RXFCSERRORSr_t S_RXFCSERRORSr_t;
#define S_RXFCSERRORSr_CLR BCM53101_A0_S_RXFCSERRORSr_CLR
#define S_RXFCSERRORSr_SET BCM53101_A0_S_RXFCSERRORSr_SET
#define S_RXFCSERRORSr_GET BCM53101_A0_S_RXFCSERRORSr_GET
#define S_RXFCSERRORSr_COUNTf_GET BCM53101_A0_S_RXFCSERRORSr_COUNTf_GET
#define S_RXFCSERRORSr_COUNTf_SET BCM53101_A0_S_RXFCSERRORSr_COUNTf_SET
#define READ_S_RXFCSERRORSr BCM53101_A0_READ_S_RXFCSERRORSr
#define WRITE_S_RXFCSERRORSr BCM53101_A0_WRITE_S_RXFCSERRORSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_RXFCSERRORSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_RxFragments
 * BLOCKS:   SYS
 * DESC:     Rx Fragment Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_RXFRAGMENTSr 0x000071a4

#define BCM53101_A0_S_RXFRAGMENTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxFragments.
 *
 */
typedef union BCM53101_A0_S_RXFRAGMENTSr_s {
	uint32_t v[1];
	uint32_t s_rxfragments[1];
	uint32_t _s_rxfragments;
} BCM53101_A0_S_RXFRAGMENTSr_t;

#define BCM53101_A0_S_RXFRAGMENTSr_CLR(r) (r).s_rxfragments[0] = 0
#define BCM53101_A0_S_RXFRAGMENTSr_SET(r,d) (r).s_rxfragments[0] = d
#define BCM53101_A0_S_RXFRAGMENTSr_GET(r) (r).s_rxfragments[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_RXFRAGMENTSr_COUNTf_GET(r) ((r).s_rxfragments[0])
#define BCM53101_A0_S_RXFRAGMENTSr_COUNTf_SET(r,f) (r).s_rxfragments[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxFragments.
 *
 */
#define BCM53101_A0_READ_S_RXFRAGMENTSr(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_RXFRAGMENTSr,(r._s_rxfragments),4)
#define BCM53101_A0_WRITE_S_RXFRAGMENTSr(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_RXFRAGMENTSr,&(r._s_rxfragments),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXFRAGMENTSr BCM53101_A0_S_RXFRAGMENTSr
#define S_RXFRAGMENTSr_SIZE BCM53101_A0_S_RXFRAGMENTSr_SIZE
typedef BCM53101_A0_S_RXFRAGMENTSr_t S_RXFRAGMENTSr_t;
#define S_RXFRAGMENTSr_CLR BCM53101_A0_S_RXFRAGMENTSr_CLR
#define S_RXFRAGMENTSr_SET BCM53101_A0_S_RXFRAGMENTSr_SET
#define S_RXFRAGMENTSr_GET BCM53101_A0_S_RXFRAGMENTSr_GET
#define S_RXFRAGMENTSr_COUNTf_GET BCM53101_A0_S_RXFRAGMENTSr_COUNTf_GET
#define S_RXFRAGMENTSr_COUNTf_SET BCM53101_A0_S_RXFRAGMENTSr_COUNTf_SET
#define READ_S_RXFRAGMENTSr BCM53101_A0_READ_S_RXFRAGMENTSr
#define WRITE_S_RXFRAGMENTSr BCM53101_A0_WRITE_S_RXFRAGMENTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_RXFRAGMENTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_RxGoodOctets
 * BLOCKS:   SYS
 * DESC:     Rx Good Packet Octet Counter
 * SIZE:     64
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_RXGOODOCTETSr 0x00007188

#define BCM53101_A0_S_RXGOODOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program S_RxGoodOctets.
 *
 */
typedef union BCM53101_A0_S_RXGOODOCTETSr_s {
	uint32_t v[2];
	uint32_t s_rxgoodoctets[2];
	uint32_t _s_rxgoodoctets;
} BCM53101_A0_S_RXGOODOCTETSr_t;

#define BCM53101_A0_S_RXGOODOCTETSr_CLR(r) CDK_MEMSET(&((r)._s_rxgoodoctets), 0, sizeof(BCM53101_A0_S_RXGOODOCTETSr_t))
#define BCM53101_A0_S_RXGOODOCTETSr_SET(r,i,d) (r).s_rxgoodoctets[i] = d
#define BCM53101_A0_S_RXGOODOCTETSr_GET(r,i) (r).s_rxgoodoctets[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_RXGOODOCTETSr_COUNTf_GET(r,a) cdk_field_get((r).s_rxgoodoctets,0,63,a)
#define BCM53101_A0_S_RXGOODOCTETSr_COUNTf_SET(r,a) cdk_field_set((r).s_rxgoodoctets,0,63,a)

/*
 * These macros can be used to access S_RxGoodOctets.
 *
 */
#define BCM53101_A0_READ_S_RXGOODOCTETSr(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_RXGOODOCTETSr,(r._s_rxgoodoctets),8)
#define BCM53101_A0_WRITE_S_RXGOODOCTETSr(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_RXGOODOCTETSr,&(r._s_rxgoodoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXGOODOCTETSr BCM53101_A0_S_RXGOODOCTETSr
#define S_RXGOODOCTETSr_SIZE BCM53101_A0_S_RXGOODOCTETSr_SIZE
typedef BCM53101_A0_S_RXGOODOCTETSr_t S_RXGOODOCTETSr_t;
#define S_RXGOODOCTETSr_CLR BCM53101_A0_S_RXGOODOCTETSr_CLR
#define S_RXGOODOCTETSr_SET BCM53101_A0_S_RXGOODOCTETSr_SET
#define S_RXGOODOCTETSr_GET BCM53101_A0_S_RXGOODOCTETSr_GET
#define S_RXGOODOCTETSr_COUNTf_GET BCM53101_A0_S_RXGOODOCTETSr_COUNTf_GET
#define S_RXGOODOCTETSr_COUNTf_SET BCM53101_A0_S_RXGOODOCTETSr_COUNTf_SET
#define READ_S_RXGOODOCTETSr BCM53101_A0_READ_S_RXGOODOCTETSr
#define WRITE_S_RXGOODOCTETSr BCM53101_A0_WRITE_S_RXGOODOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_RXGOODOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_RxJabbers
 * BLOCKS:   SYS
 * DESC:     Rx Jabber Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_RXJABBERSr 0x0000717c

#define BCM53101_A0_S_RXJABBERSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxJabbers.
 *
 */
typedef union BCM53101_A0_S_RXJABBERSr_s {
	uint32_t v[1];
	uint32_t s_rxjabbers[1];
	uint32_t _s_rxjabbers;
} BCM53101_A0_S_RXJABBERSr_t;

#define BCM53101_A0_S_RXJABBERSr_CLR(r) (r).s_rxjabbers[0] = 0
#define BCM53101_A0_S_RXJABBERSr_SET(r,d) (r).s_rxjabbers[0] = d
#define BCM53101_A0_S_RXJABBERSr_GET(r) (r).s_rxjabbers[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_RXJABBERSr_COUNTf_GET(r) ((r).s_rxjabbers[0])
#define BCM53101_A0_S_RXJABBERSr_COUNTf_SET(r,f) (r).s_rxjabbers[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxJabbers.
 *
 */
#define BCM53101_A0_READ_S_RXJABBERSr(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_RXJABBERSr,(r._s_rxjabbers),4)
#define BCM53101_A0_WRITE_S_RXJABBERSr(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_RXJABBERSr,&(r._s_rxjabbers),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXJABBERSr BCM53101_A0_S_RXJABBERSr
#define S_RXJABBERSr_SIZE BCM53101_A0_S_RXJABBERSr_SIZE
typedef BCM53101_A0_S_RXJABBERSr_t S_RXJABBERSr_t;
#define S_RXJABBERSr_CLR BCM53101_A0_S_RXJABBERSr_CLR
#define S_RXJABBERSr_SET BCM53101_A0_S_RXJABBERSr_SET
#define S_RXJABBERSr_GET BCM53101_A0_S_RXJABBERSr_GET
#define S_RXJABBERSr_COUNTf_GET BCM53101_A0_S_RXJABBERSr_COUNTf_GET
#define S_RXJABBERSr_COUNTf_SET BCM53101_A0_S_RXJABBERSr_COUNTf_SET
#define READ_S_RXJABBERSr BCM53101_A0_READ_S_RXJABBERSr
#define WRITE_S_RXJABBERSr BCM53101_A0_WRITE_S_RXJABBERSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_RXJABBERSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_RxMulticastPkts
 * BLOCKS:   SYS
 * DESC:     Rx Multicast Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_RXMULTICASTPKTSr 0x00007198

#define BCM53101_A0_S_RXMULTICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxMulticastPkts.
 *
 */
typedef union BCM53101_A0_S_RXMULTICASTPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxmulticastpkts[1];
	uint32_t _s_rxmulticastpkts;
} BCM53101_A0_S_RXMULTICASTPKTSr_t;

#define BCM53101_A0_S_RXMULTICASTPKTSr_CLR(r) (r).s_rxmulticastpkts[0] = 0
#define BCM53101_A0_S_RXMULTICASTPKTSr_SET(r,d) (r).s_rxmulticastpkts[0] = d
#define BCM53101_A0_S_RXMULTICASTPKTSr_GET(r) (r).s_rxmulticastpkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_RXMULTICASTPKTSr_COUNTf_GET(r) ((r).s_rxmulticastpkts[0])
#define BCM53101_A0_S_RXMULTICASTPKTSr_COUNTf_SET(r,f) (r).s_rxmulticastpkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxMulticastPkts.
 *
 */
#define BCM53101_A0_READ_S_RXMULTICASTPKTSr(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_RXMULTICASTPKTSr,(r._s_rxmulticastpkts),4)
#define BCM53101_A0_WRITE_S_RXMULTICASTPKTSr(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_RXMULTICASTPKTSr,&(r._s_rxmulticastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXMULTICASTPKTSr BCM53101_A0_S_RXMULTICASTPKTSr
#define S_RXMULTICASTPKTSr_SIZE BCM53101_A0_S_RXMULTICASTPKTSr_SIZE
typedef BCM53101_A0_S_RXMULTICASTPKTSr_t S_RXMULTICASTPKTSr_t;
#define S_RXMULTICASTPKTSr_CLR BCM53101_A0_S_RXMULTICASTPKTSr_CLR
#define S_RXMULTICASTPKTSr_SET BCM53101_A0_S_RXMULTICASTPKTSr_SET
#define S_RXMULTICASTPKTSr_GET BCM53101_A0_S_RXMULTICASTPKTSr_GET
#define S_RXMULTICASTPKTSr_COUNTf_GET BCM53101_A0_S_RXMULTICASTPKTSr_COUNTf_GET
#define S_RXMULTICASTPKTSr_COUNTf_SET BCM53101_A0_S_RXMULTICASTPKTSr_COUNTf_SET
#define READ_S_RXMULTICASTPKTSr BCM53101_A0_READ_S_RXMULTICASTPKTSr
#define WRITE_S_RXMULTICASTPKTSr BCM53101_A0_WRITE_S_RXMULTICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_RXMULTICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_RxOctets
 * BLOCKS:   SYS
 * DESC:     Rx Packet Octets Counter
 * SIZE:     64
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_RXOCTETSr 0x00007150

#define BCM53101_A0_S_RXOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program S_RxOctets.
 *
 */
typedef union BCM53101_A0_S_RXOCTETSr_s {
	uint32_t v[2];
	uint32_t s_rxoctets[2];
	uint32_t _s_rxoctets;
} BCM53101_A0_S_RXOCTETSr_t;

#define BCM53101_A0_S_RXOCTETSr_CLR(r) CDK_MEMSET(&((r)._s_rxoctets), 0, sizeof(BCM53101_A0_S_RXOCTETSr_t))
#define BCM53101_A0_S_RXOCTETSr_SET(r,i,d) (r).s_rxoctets[i] = d
#define BCM53101_A0_S_RXOCTETSr_GET(r,i) (r).s_rxoctets[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_RXOCTETSr_COUNTf_GET(r,a) cdk_field_get((r).s_rxoctets,0,63,a)
#define BCM53101_A0_S_RXOCTETSr_COUNTf_SET(r,a) cdk_field_set((r).s_rxoctets,0,63,a)

/*
 * These macros can be used to access S_RxOctets.
 *
 */
#define BCM53101_A0_READ_S_RXOCTETSr(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_RXOCTETSr,(r._s_rxoctets),8)
#define BCM53101_A0_WRITE_S_RXOCTETSr(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_RXOCTETSr,&(r._s_rxoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXOCTETSr BCM53101_A0_S_RXOCTETSr
#define S_RXOCTETSr_SIZE BCM53101_A0_S_RXOCTETSr_SIZE
typedef BCM53101_A0_S_RXOCTETSr_t S_RXOCTETSr_t;
#define S_RXOCTETSr_CLR BCM53101_A0_S_RXOCTETSr_CLR
#define S_RXOCTETSr_SET BCM53101_A0_S_RXOCTETSr_SET
#define S_RXOCTETSr_GET BCM53101_A0_S_RXOCTETSr_GET
#define S_RXOCTETSr_COUNTf_GET BCM53101_A0_S_RXOCTETSr_COUNTf_GET
#define S_RXOCTETSr_COUNTf_SET BCM53101_A0_S_RXOCTETSr_COUNTf_SET
#define READ_S_RXOCTETSr BCM53101_A0_READ_S_RXOCTETSr
#define WRITE_S_RXOCTETSr BCM53101_A0_WRITE_S_RXOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_RXOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_RxOversizePkts
 * BLOCKS:   SYS
 * DESC:     Rx Over Size Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_RXOVERSIZEPKTSr 0x00007178

#define BCM53101_A0_S_RXOVERSIZEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxOversizePkts.
 *
 */
typedef union BCM53101_A0_S_RXOVERSIZEPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxoversizepkts[1];
	uint32_t _s_rxoversizepkts;
} BCM53101_A0_S_RXOVERSIZEPKTSr_t;

#define BCM53101_A0_S_RXOVERSIZEPKTSr_CLR(r) (r).s_rxoversizepkts[0] = 0
#define BCM53101_A0_S_RXOVERSIZEPKTSr_SET(r,d) (r).s_rxoversizepkts[0] = d
#define BCM53101_A0_S_RXOVERSIZEPKTSr_GET(r) (r).s_rxoversizepkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_RXOVERSIZEPKTSr_COUNTf_GET(r) ((r).s_rxoversizepkts[0])
#define BCM53101_A0_S_RXOVERSIZEPKTSr_COUNTf_SET(r,f) (r).s_rxoversizepkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxOversizePkts.
 *
 */
#define BCM53101_A0_READ_S_RXOVERSIZEPKTSr(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_RXOVERSIZEPKTSr,(r._s_rxoversizepkts),4)
#define BCM53101_A0_WRITE_S_RXOVERSIZEPKTSr(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_RXOVERSIZEPKTSr,&(r._s_rxoversizepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXOVERSIZEPKTSr BCM53101_A0_S_RXOVERSIZEPKTSr
#define S_RXOVERSIZEPKTSr_SIZE BCM53101_A0_S_RXOVERSIZEPKTSr_SIZE
typedef BCM53101_A0_S_RXOVERSIZEPKTSr_t S_RXOVERSIZEPKTSr_t;
#define S_RXOVERSIZEPKTSr_CLR BCM53101_A0_S_RXOVERSIZEPKTSr_CLR
#define S_RXOVERSIZEPKTSr_SET BCM53101_A0_S_RXOVERSIZEPKTSr_SET
#define S_RXOVERSIZEPKTSr_GET BCM53101_A0_S_RXOVERSIZEPKTSr_GET
#define S_RXOVERSIZEPKTSr_COUNTf_GET BCM53101_A0_S_RXOVERSIZEPKTSr_COUNTf_GET
#define S_RXOVERSIZEPKTSr_COUNTf_SET BCM53101_A0_S_RXOVERSIZEPKTSr_COUNTf_SET
#define READ_S_RXOVERSIZEPKTSr BCM53101_A0_READ_S_RXOVERSIZEPKTSr
#define WRITE_S_RXOVERSIZEPKTSr BCM53101_A0_WRITE_S_RXOVERSIZEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_RXOVERSIZEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_RxPausePkts
 * BLOCKS:   SYS
 * DESC:     Rx Pause Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_RXPAUSEPKTSr 0x0000715c

#define BCM53101_A0_S_RXPAUSEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxPausePkts.
 *
 */
typedef union BCM53101_A0_S_RXPAUSEPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxpausepkts[1];
	uint32_t _s_rxpausepkts;
} BCM53101_A0_S_RXPAUSEPKTSr_t;

#define BCM53101_A0_S_RXPAUSEPKTSr_CLR(r) (r).s_rxpausepkts[0] = 0
#define BCM53101_A0_S_RXPAUSEPKTSr_SET(r,d) (r).s_rxpausepkts[0] = d
#define BCM53101_A0_S_RXPAUSEPKTSr_GET(r) (r).s_rxpausepkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_RXPAUSEPKTSr_COUNTf_GET(r) ((r).s_rxpausepkts[0])
#define BCM53101_A0_S_RXPAUSEPKTSr_COUNTf_SET(r,f) (r).s_rxpausepkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxPausePkts.
 *
 */
#define BCM53101_A0_READ_S_RXPAUSEPKTSr(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_RXPAUSEPKTSr,(r._s_rxpausepkts),4)
#define BCM53101_A0_WRITE_S_RXPAUSEPKTSr(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_RXPAUSEPKTSr,&(r._s_rxpausepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXPAUSEPKTSr BCM53101_A0_S_RXPAUSEPKTSr
#define S_RXPAUSEPKTSr_SIZE BCM53101_A0_S_RXPAUSEPKTSr_SIZE
typedef BCM53101_A0_S_RXPAUSEPKTSr_t S_RXPAUSEPKTSr_t;
#define S_RXPAUSEPKTSr_CLR BCM53101_A0_S_RXPAUSEPKTSr_CLR
#define S_RXPAUSEPKTSr_SET BCM53101_A0_S_RXPAUSEPKTSr_SET
#define S_RXPAUSEPKTSr_GET BCM53101_A0_S_RXPAUSEPKTSr_GET
#define S_RXPAUSEPKTSr_COUNTf_GET BCM53101_A0_S_RXPAUSEPKTSr_COUNTf_GET
#define S_RXPAUSEPKTSr_COUNTf_SET BCM53101_A0_S_RXPAUSEPKTSr_COUNTf_SET
#define READ_S_RXPAUSEPKTSr BCM53101_A0_READ_S_RXPAUSEPKTSr
#define WRITE_S_RXPAUSEPKTSr BCM53101_A0_WRITE_S_RXPAUSEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_RXPAUSEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_RxSAChanges
 * BLOCKS:   SYS
 * DESC:     Rx SA Change Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_RXSACHANGESr 0x000071a0

#define BCM53101_A0_S_RXSACHANGESr_SIZE 4

/*
 * This structure should be used to declare and program S_RxSAChanges.
 *
 */
typedef union BCM53101_A0_S_RXSACHANGESr_s {
	uint32_t v[1];
	uint32_t s_rxsachanges[1];
	uint32_t _s_rxsachanges;
} BCM53101_A0_S_RXSACHANGESr_t;

#define BCM53101_A0_S_RXSACHANGESr_CLR(r) (r).s_rxsachanges[0] = 0
#define BCM53101_A0_S_RXSACHANGESr_SET(r,d) (r).s_rxsachanges[0] = d
#define BCM53101_A0_S_RXSACHANGESr_GET(r) (r).s_rxsachanges[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_RXSACHANGESr_COUNTf_GET(r) ((r).s_rxsachanges[0])
#define BCM53101_A0_S_RXSACHANGESr_COUNTf_SET(r,f) (r).s_rxsachanges[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxSAChanges.
 *
 */
#define BCM53101_A0_READ_S_RXSACHANGESr(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_RXSACHANGESr,(r._s_rxsachanges),4)
#define BCM53101_A0_WRITE_S_RXSACHANGESr(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_RXSACHANGESr,&(r._s_rxsachanges),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXSACHANGESr BCM53101_A0_S_RXSACHANGESr
#define S_RXSACHANGESr_SIZE BCM53101_A0_S_RXSACHANGESr_SIZE
typedef BCM53101_A0_S_RXSACHANGESr_t S_RXSACHANGESr_t;
#define S_RXSACHANGESr_CLR BCM53101_A0_S_RXSACHANGESr_CLR
#define S_RXSACHANGESr_SET BCM53101_A0_S_RXSACHANGESr_SET
#define S_RXSACHANGESr_GET BCM53101_A0_S_RXSACHANGESr_GET
#define S_RXSACHANGESr_COUNTf_GET BCM53101_A0_S_RXSACHANGESr_COUNTf_GET
#define S_RXSACHANGESr_COUNTf_SET BCM53101_A0_S_RXSACHANGESr_COUNTf_SET
#define READ_S_RXSACHANGESr BCM53101_A0_READ_S_RXSACHANGESr
#define WRITE_S_RXSACHANGESr BCM53101_A0_WRITE_S_RXSACHANGESr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_RXSACHANGESr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_RxUndersizePkts
 * BLOCKS:   SYS
 * DESC:     Rx Under Size Packet Octets Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_RXUNDERSIZEPKTSr 0x00007158

#define BCM53101_A0_S_RXUNDERSIZEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxUndersizePkts.
 *
 */
typedef union BCM53101_A0_S_RXUNDERSIZEPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxundersizepkts[1];
	uint32_t _s_rxundersizepkts;
} BCM53101_A0_S_RXUNDERSIZEPKTSr_t;

#define BCM53101_A0_S_RXUNDERSIZEPKTSr_CLR(r) (r).s_rxundersizepkts[0] = 0
#define BCM53101_A0_S_RXUNDERSIZEPKTSr_SET(r,d) (r).s_rxundersizepkts[0] = d
#define BCM53101_A0_S_RXUNDERSIZEPKTSr_GET(r) (r).s_rxundersizepkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_RXUNDERSIZEPKTSr_COUNTf_GET(r) ((r).s_rxundersizepkts[0])
#define BCM53101_A0_S_RXUNDERSIZEPKTSr_COUNTf_SET(r,f) (r).s_rxundersizepkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxUndersizePkts.
 *
 */
#define BCM53101_A0_READ_S_RXUNDERSIZEPKTSr(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_RXUNDERSIZEPKTSr,(r._s_rxundersizepkts),4)
#define BCM53101_A0_WRITE_S_RXUNDERSIZEPKTSr(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_RXUNDERSIZEPKTSr,&(r._s_rxundersizepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXUNDERSIZEPKTSr BCM53101_A0_S_RXUNDERSIZEPKTSr
#define S_RXUNDERSIZEPKTSr_SIZE BCM53101_A0_S_RXUNDERSIZEPKTSr_SIZE
typedef BCM53101_A0_S_RXUNDERSIZEPKTSr_t S_RXUNDERSIZEPKTSr_t;
#define S_RXUNDERSIZEPKTSr_CLR BCM53101_A0_S_RXUNDERSIZEPKTSr_CLR
#define S_RXUNDERSIZEPKTSr_SET BCM53101_A0_S_RXUNDERSIZEPKTSr_SET
#define S_RXUNDERSIZEPKTSr_GET BCM53101_A0_S_RXUNDERSIZEPKTSr_GET
#define S_RXUNDERSIZEPKTSr_COUNTf_GET BCM53101_A0_S_RXUNDERSIZEPKTSr_COUNTf_GET
#define S_RXUNDERSIZEPKTSr_COUNTf_SET BCM53101_A0_S_RXUNDERSIZEPKTSr_COUNTf_SET
#define READ_S_RXUNDERSIZEPKTSr BCM53101_A0_READ_S_RXUNDERSIZEPKTSr
#define WRITE_S_RXUNDERSIZEPKTSr BCM53101_A0_WRITE_S_RXUNDERSIZEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_RXUNDERSIZEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_RxUnicastPkts
 * BLOCKS:   SYS
 * DESC:     Rx Unicast Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_RXUNICASTPKTSr 0x00007194

#define BCM53101_A0_S_RXUNICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_RxUnicastPkts.
 *
 */
typedef union BCM53101_A0_S_RXUNICASTPKTSr_s {
	uint32_t v[1];
	uint32_t s_rxunicastpkts[1];
	uint32_t _s_rxunicastpkts;
} BCM53101_A0_S_RXUNICASTPKTSr_t;

#define BCM53101_A0_S_RXUNICASTPKTSr_CLR(r) (r).s_rxunicastpkts[0] = 0
#define BCM53101_A0_S_RXUNICASTPKTSr_SET(r,d) (r).s_rxunicastpkts[0] = d
#define BCM53101_A0_S_RXUNICASTPKTSr_GET(r) (r).s_rxunicastpkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_RXUNICASTPKTSr_COUNTf_GET(r) ((r).s_rxunicastpkts[0])
#define BCM53101_A0_S_RXUNICASTPKTSr_COUNTf_SET(r,f) (r).s_rxunicastpkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_RxUnicastPkts.
 *
 */
#define BCM53101_A0_READ_S_RXUNICASTPKTSr(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_RXUNICASTPKTSr,(r._s_rxunicastpkts),4)
#define BCM53101_A0_WRITE_S_RXUNICASTPKTSr(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_RXUNICASTPKTSr,&(r._s_rxunicastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_RXUNICASTPKTSr BCM53101_A0_S_RXUNICASTPKTSr
#define S_RXUNICASTPKTSr_SIZE BCM53101_A0_S_RXUNICASTPKTSr_SIZE
typedef BCM53101_A0_S_RXUNICASTPKTSr_t S_RXUNICASTPKTSr_t;
#define S_RXUNICASTPKTSr_CLR BCM53101_A0_S_RXUNICASTPKTSr_CLR
#define S_RXUNICASTPKTSr_SET BCM53101_A0_S_RXUNICASTPKTSr_SET
#define S_RXUNICASTPKTSr_GET BCM53101_A0_S_RXUNICASTPKTSr_GET
#define S_RXUNICASTPKTSr_COUNTf_GET BCM53101_A0_S_RXUNICASTPKTSr_COUNTf_GET
#define S_RXUNICASTPKTSr_COUNTf_SET BCM53101_A0_S_RXUNICASTPKTSr_COUNTf_SET
#define READ_S_RXUNICASTPKTSr BCM53101_A0_READ_S_RXUNICASTPKTSr
#define WRITE_S_RXUNICASTPKTSr BCM53101_A0_WRITE_S_RXUNICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_RXUNICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_TxBroadcastPkts
 * BLOCKS:   SYS
 * DESC:     Tx Broadcast Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_TXBROADCASTPKTSr 0x00007110

#define BCM53101_A0_S_TXBROADCASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxBroadcastPkts.
 *
 */
typedef union BCM53101_A0_S_TXBROADCASTPKTSr_s {
	uint32_t v[1];
	uint32_t s_txbroadcastpkts[1];
	uint32_t _s_txbroadcastpkts;
} BCM53101_A0_S_TXBROADCASTPKTSr_t;

#define BCM53101_A0_S_TXBROADCASTPKTSr_CLR(r) (r).s_txbroadcastpkts[0] = 0
#define BCM53101_A0_S_TXBROADCASTPKTSr_SET(r,d) (r).s_txbroadcastpkts[0] = d
#define BCM53101_A0_S_TXBROADCASTPKTSr_GET(r) (r).s_txbroadcastpkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_TXBROADCASTPKTSr_COUNTf_GET(r) ((r).s_txbroadcastpkts[0])
#define BCM53101_A0_S_TXBROADCASTPKTSr_COUNTf_SET(r,f) (r).s_txbroadcastpkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxBroadcastPkts.
 *
 */
#define BCM53101_A0_READ_S_TXBROADCASTPKTSr(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_TXBROADCASTPKTSr,(r._s_txbroadcastpkts),4)
#define BCM53101_A0_WRITE_S_TXBROADCASTPKTSr(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_TXBROADCASTPKTSr,&(r._s_txbroadcastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXBROADCASTPKTSr BCM53101_A0_S_TXBROADCASTPKTSr
#define S_TXBROADCASTPKTSr_SIZE BCM53101_A0_S_TXBROADCASTPKTSr_SIZE
typedef BCM53101_A0_S_TXBROADCASTPKTSr_t S_TXBROADCASTPKTSr_t;
#define S_TXBROADCASTPKTSr_CLR BCM53101_A0_S_TXBROADCASTPKTSr_CLR
#define S_TXBROADCASTPKTSr_SET BCM53101_A0_S_TXBROADCASTPKTSr_SET
#define S_TXBROADCASTPKTSr_GET BCM53101_A0_S_TXBROADCASTPKTSr_GET
#define S_TXBROADCASTPKTSr_COUNTf_GET BCM53101_A0_S_TXBROADCASTPKTSr_COUNTf_GET
#define S_TXBROADCASTPKTSr_COUNTf_SET BCM53101_A0_S_TXBROADCASTPKTSr_COUNTf_SET
#define READ_S_TXBROADCASTPKTSr BCM53101_A0_READ_S_TXBROADCASTPKTSr
#define WRITE_S_TXBROADCASTPKTSr BCM53101_A0_WRITE_S_TXBROADCASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_TXBROADCASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_TxCollisions
 * BLOCKS:   SYS
 * DESC:     Tx Collision Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_TXCOLLISIONSr 0x0000711c

#define BCM53101_A0_S_TXCOLLISIONSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxCollisions.
 *
 */
typedef union BCM53101_A0_S_TXCOLLISIONSr_s {
	uint32_t v[1];
	uint32_t s_txcollisions[1];
	uint32_t _s_txcollisions;
} BCM53101_A0_S_TXCOLLISIONSr_t;

#define BCM53101_A0_S_TXCOLLISIONSr_CLR(r) (r).s_txcollisions[0] = 0
#define BCM53101_A0_S_TXCOLLISIONSr_SET(r,d) (r).s_txcollisions[0] = d
#define BCM53101_A0_S_TXCOLLISIONSr_GET(r) (r).s_txcollisions[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_TXCOLLISIONSr_COUNTf_GET(r) ((r).s_txcollisions[0])
#define BCM53101_A0_S_TXCOLLISIONSr_COUNTf_SET(r,f) (r).s_txcollisions[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxCollisions.
 *
 */
#define BCM53101_A0_READ_S_TXCOLLISIONSr(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_TXCOLLISIONSr,(r._s_txcollisions),4)
#define BCM53101_A0_WRITE_S_TXCOLLISIONSr(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_TXCOLLISIONSr,&(r._s_txcollisions),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXCOLLISIONSr BCM53101_A0_S_TXCOLLISIONSr
#define S_TXCOLLISIONSr_SIZE BCM53101_A0_S_TXCOLLISIONSr_SIZE
typedef BCM53101_A0_S_TXCOLLISIONSr_t S_TXCOLLISIONSr_t;
#define S_TXCOLLISIONSr_CLR BCM53101_A0_S_TXCOLLISIONSr_CLR
#define S_TXCOLLISIONSr_SET BCM53101_A0_S_TXCOLLISIONSr_SET
#define S_TXCOLLISIONSr_GET BCM53101_A0_S_TXCOLLISIONSr_GET
#define S_TXCOLLISIONSr_COUNTf_GET BCM53101_A0_S_TXCOLLISIONSr_COUNTf_GET
#define S_TXCOLLISIONSr_COUNTf_SET BCM53101_A0_S_TXCOLLISIONSr_COUNTf_SET
#define READ_S_TXCOLLISIONSr BCM53101_A0_READ_S_TXCOLLISIONSr
#define WRITE_S_TXCOLLISIONSr BCM53101_A0_WRITE_S_TXCOLLISIONSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_TXCOLLISIONSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_TxDeferredTransmit
 * BLOCKS:   SYS
 * DESC:     Tx Deferred Transmit Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_TXDEFERREDTRANSMITr 0x00007128

#define BCM53101_A0_S_TXDEFERREDTRANSMITr_SIZE 4

/*
 * This structure should be used to declare and program S_TxDeferredTransmit.
 *
 */
typedef union BCM53101_A0_S_TXDEFERREDTRANSMITr_s {
	uint32_t v[1];
	uint32_t s_txdeferredtransmit[1];
	uint32_t _s_txdeferredtransmit;
} BCM53101_A0_S_TXDEFERREDTRANSMITr_t;

#define BCM53101_A0_S_TXDEFERREDTRANSMITr_CLR(r) (r).s_txdeferredtransmit[0] = 0
#define BCM53101_A0_S_TXDEFERREDTRANSMITr_SET(r,d) (r).s_txdeferredtransmit[0] = d
#define BCM53101_A0_S_TXDEFERREDTRANSMITr_GET(r) (r).s_txdeferredtransmit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_TXDEFERREDTRANSMITr_COUNTf_GET(r) ((r).s_txdeferredtransmit[0])
#define BCM53101_A0_S_TXDEFERREDTRANSMITr_COUNTf_SET(r,f) (r).s_txdeferredtransmit[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxDeferredTransmit.
 *
 */
#define BCM53101_A0_READ_S_TXDEFERREDTRANSMITr(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_TXDEFERREDTRANSMITr,(r._s_txdeferredtransmit),4)
#define BCM53101_A0_WRITE_S_TXDEFERREDTRANSMITr(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_TXDEFERREDTRANSMITr,&(r._s_txdeferredtransmit),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXDEFERREDTRANSMITr BCM53101_A0_S_TXDEFERREDTRANSMITr
#define S_TXDEFERREDTRANSMITr_SIZE BCM53101_A0_S_TXDEFERREDTRANSMITr_SIZE
typedef BCM53101_A0_S_TXDEFERREDTRANSMITr_t S_TXDEFERREDTRANSMITr_t;
#define S_TXDEFERREDTRANSMITr_CLR BCM53101_A0_S_TXDEFERREDTRANSMITr_CLR
#define S_TXDEFERREDTRANSMITr_SET BCM53101_A0_S_TXDEFERREDTRANSMITr_SET
#define S_TXDEFERREDTRANSMITr_GET BCM53101_A0_S_TXDEFERREDTRANSMITr_GET
#define S_TXDEFERREDTRANSMITr_COUNTf_GET BCM53101_A0_S_TXDEFERREDTRANSMITr_COUNTf_GET
#define S_TXDEFERREDTRANSMITr_COUNTf_SET BCM53101_A0_S_TXDEFERREDTRANSMITr_COUNTf_SET
#define READ_S_TXDEFERREDTRANSMITr BCM53101_A0_READ_S_TXDEFERREDTRANSMITr
#define WRITE_S_TXDEFERREDTRANSMITr BCM53101_A0_WRITE_S_TXDEFERREDTRANSMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_TXDEFERREDTRANSMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_TxDropPkts
 * BLOCKS:   SYS
 * DESC:     Tx Drop Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_TXDROPPKTSr 0x00007108

#define BCM53101_A0_S_TXDROPPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxDropPkts.
 *
 */
typedef union BCM53101_A0_S_TXDROPPKTSr_s {
	uint32_t v[1];
	uint32_t s_txdroppkts[1];
	uint32_t _s_txdroppkts;
} BCM53101_A0_S_TXDROPPKTSr_t;

#define BCM53101_A0_S_TXDROPPKTSr_CLR(r) (r).s_txdroppkts[0] = 0
#define BCM53101_A0_S_TXDROPPKTSr_SET(r,d) (r).s_txdroppkts[0] = d
#define BCM53101_A0_S_TXDROPPKTSr_GET(r) (r).s_txdroppkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_TXDROPPKTSr_COUNTf_GET(r) ((r).s_txdroppkts[0])
#define BCM53101_A0_S_TXDROPPKTSr_COUNTf_SET(r,f) (r).s_txdroppkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxDropPkts.
 *
 */
#define BCM53101_A0_READ_S_TXDROPPKTSr(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_TXDROPPKTSr,(r._s_txdroppkts),4)
#define BCM53101_A0_WRITE_S_TXDROPPKTSr(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_TXDROPPKTSr,&(r._s_txdroppkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXDROPPKTSr BCM53101_A0_S_TXDROPPKTSr
#define S_TXDROPPKTSr_SIZE BCM53101_A0_S_TXDROPPKTSr_SIZE
typedef BCM53101_A0_S_TXDROPPKTSr_t S_TXDROPPKTSr_t;
#define S_TXDROPPKTSr_CLR BCM53101_A0_S_TXDROPPKTSr_CLR
#define S_TXDROPPKTSr_SET BCM53101_A0_S_TXDROPPKTSr_SET
#define S_TXDROPPKTSr_GET BCM53101_A0_S_TXDROPPKTSr_GET
#define S_TXDROPPKTSr_COUNTf_GET BCM53101_A0_S_TXDROPPKTSr_COUNTf_GET
#define S_TXDROPPKTSr_COUNTf_SET BCM53101_A0_S_TXDROPPKTSr_COUNTf_SET
#define READ_S_TXDROPPKTSr BCM53101_A0_READ_S_TXDROPPKTSr
#define WRITE_S_TXDROPPKTSr BCM53101_A0_WRITE_S_TXDROPPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_TXDROPPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_TxExcessiveCollision
 * BLOCKS:   SYS
 * DESC:     Tx Excessive Collision Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_TXEXCESSIVECOLLISIONr 0x00007130

#define BCM53101_A0_S_TXEXCESSIVECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program S_TxExcessiveCollision.
 *
 */
typedef union BCM53101_A0_S_TXEXCESSIVECOLLISIONr_s {
	uint32_t v[1];
	uint32_t s_txexcessivecollision[1];
	uint32_t _s_txexcessivecollision;
} BCM53101_A0_S_TXEXCESSIVECOLLISIONr_t;

#define BCM53101_A0_S_TXEXCESSIVECOLLISIONr_CLR(r) (r).s_txexcessivecollision[0] = 0
#define BCM53101_A0_S_TXEXCESSIVECOLLISIONr_SET(r,d) (r).s_txexcessivecollision[0] = d
#define BCM53101_A0_S_TXEXCESSIVECOLLISIONr_GET(r) (r).s_txexcessivecollision[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_TXEXCESSIVECOLLISIONr_COUNTf_GET(r) ((r).s_txexcessivecollision[0])
#define BCM53101_A0_S_TXEXCESSIVECOLLISIONr_COUNTf_SET(r,f) (r).s_txexcessivecollision[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxExcessiveCollision.
 *
 */
#define BCM53101_A0_READ_S_TXEXCESSIVECOLLISIONr(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_TXEXCESSIVECOLLISIONr,(r._s_txexcessivecollision),4)
#define BCM53101_A0_WRITE_S_TXEXCESSIVECOLLISIONr(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_TXEXCESSIVECOLLISIONr,&(r._s_txexcessivecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXEXCESSIVECOLLISIONr BCM53101_A0_S_TXEXCESSIVECOLLISIONr
#define S_TXEXCESSIVECOLLISIONr_SIZE BCM53101_A0_S_TXEXCESSIVECOLLISIONr_SIZE
typedef BCM53101_A0_S_TXEXCESSIVECOLLISIONr_t S_TXEXCESSIVECOLLISIONr_t;
#define S_TXEXCESSIVECOLLISIONr_CLR BCM53101_A0_S_TXEXCESSIVECOLLISIONr_CLR
#define S_TXEXCESSIVECOLLISIONr_SET BCM53101_A0_S_TXEXCESSIVECOLLISIONr_SET
#define S_TXEXCESSIVECOLLISIONr_GET BCM53101_A0_S_TXEXCESSIVECOLLISIONr_GET
#define S_TXEXCESSIVECOLLISIONr_COUNTf_GET BCM53101_A0_S_TXEXCESSIVECOLLISIONr_COUNTf_GET
#define S_TXEXCESSIVECOLLISIONr_COUNTf_SET BCM53101_A0_S_TXEXCESSIVECOLLISIONr_COUNTf_SET
#define READ_S_TXEXCESSIVECOLLISIONr BCM53101_A0_READ_S_TXEXCESSIVECOLLISIONr
#define WRITE_S_TXEXCESSIVECOLLISIONr BCM53101_A0_WRITE_S_TXEXCESSIVECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_TXEXCESSIVECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_TxFrameInDisc
 * BLOCKS:   SYS
 * DESC:     Tx Fram IN Disc Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_TXFRAMEINDISCr 0x00007134

#define BCM53101_A0_S_TXFRAMEINDISCr_SIZE 4

/*
 * This structure should be used to declare and program S_TxFrameInDisc.
 *
 */
typedef union BCM53101_A0_S_TXFRAMEINDISCr_s {
	uint32_t v[1];
	uint32_t s_txframeindisc[1];
	uint32_t _s_txframeindisc;
} BCM53101_A0_S_TXFRAMEINDISCr_t;

#define BCM53101_A0_S_TXFRAMEINDISCr_CLR(r) (r).s_txframeindisc[0] = 0
#define BCM53101_A0_S_TXFRAMEINDISCr_SET(r,d) (r).s_txframeindisc[0] = d
#define BCM53101_A0_S_TXFRAMEINDISCr_GET(r) (r).s_txframeindisc[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_TXFRAMEINDISCr_COUNTf_GET(r) ((r).s_txframeindisc[0])
#define BCM53101_A0_S_TXFRAMEINDISCr_COUNTf_SET(r,f) (r).s_txframeindisc[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxFrameInDisc.
 *
 */
#define BCM53101_A0_READ_S_TXFRAMEINDISCr(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_TXFRAMEINDISCr,(r._s_txframeindisc),4)
#define BCM53101_A0_WRITE_S_TXFRAMEINDISCr(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_TXFRAMEINDISCr,&(r._s_txframeindisc),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXFRAMEINDISCr BCM53101_A0_S_TXFRAMEINDISCr
#define S_TXFRAMEINDISCr_SIZE BCM53101_A0_S_TXFRAMEINDISCr_SIZE
typedef BCM53101_A0_S_TXFRAMEINDISCr_t S_TXFRAMEINDISCr_t;
#define S_TXFRAMEINDISCr_CLR BCM53101_A0_S_TXFRAMEINDISCr_CLR
#define S_TXFRAMEINDISCr_SET BCM53101_A0_S_TXFRAMEINDISCr_SET
#define S_TXFRAMEINDISCr_GET BCM53101_A0_S_TXFRAMEINDISCr_GET
#define S_TXFRAMEINDISCr_COUNTf_GET BCM53101_A0_S_TXFRAMEINDISCr_COUNTf_GET
#define S_TXFRAMEINDISCr_COUNTf_SET BCM53101_A0_S_TXFRAMEINDISCr_COUNTf_SET
#define READ_S_TXFRAMEINDISCr BCM53101_A0_READ_S_TXFRAMEINDISCr
#define WRITE_S_TXFRAMEINDISCr BCM53101_A0_WRITE_S_TXFRAMEINDISCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_TXFRAMEINDISCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_TxLateCollision
 * BLOCKS:   SYS
 * DESC:     Tx Late Collision Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_TXLATECOLLISIONr 0x0000712c

#define BCM53101_A0_S_TXLATECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program S_TxLateCollision.
 *
 */
typedef union BCM53101_A0_S_TXLATECOLLISIONr_s {
	uint32_t v[1];
	uint32_t s_txlatecollision[1];
	uint32_t _s_txlatecollision;
} BCM53101_A0_S_TXLATECOLLISIONr_t;

#define BCM53101_A0_S_TXLATECOLLISIONr_CLR(r) (r).s_txlatecollision[0] = 0
#define BCM53101_A0_S_TXLATECOLLISIONr_SET(r,d) (r).s_txlatecollision[0] = d
#define BCM53101_A0_S_TXLATECOLLISIONr_GET(r) (r).s_txlatecollision[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_TXLATECOLLISIONr_COUNTf_GET(r) ((r).s_txlatecollision[0])
#define BCM53101_A0_S_TXLATECOLLISIONr_COUNTf_SET(r,f) (r).s_txlatecollision[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxLateCollision.
 *
 */
#define BCM53101_A0_READ_S_TXLATECOLLISIONr(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_TXLATECOLLISIONr,(r._s_txlatecollision),4)
#define BCM53101_A0_WRITE_S_TXLATECOLLISIONr(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_TXLATECOLLISIONr,&(r._s_txlatecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXLATECOLLISIONr BCM53101_A0_S_TXLATECOLLISIONr
#define S_TXLATECOLLISIONr_SIZE BCM53101_A0_S_TXLATECOLLISIONr_SIZE
typedef BCM53101_A0_S_TXLATECOLLISIONr_t S_TXLATECOLLISIONr_t;
#define S_TXLATECOLLISIONr_CLR BCM53101_A0_S_TXLATECOLLISIONr_CLR
#define S_TXLATECOLLISIONr_SET BCM53101_A0_S_TXLATECOLLISIONr_SET
#define S_TXLATECOLLISIONr_GET BCM53101_A0_S_TXLATECOLLISIONr_GET
#define S_TXLATECOLLISIONr_COUNTf_GET BCM53101_A0_S_TXLATECOLLISIONr_COUNTf_GET
#define S_TXLATECOLLISIONr_COUNTf_SET BCM53101_A0_S_TXLATECOLLISIONr_COUNTf_SET
#define READ_S_TXLATECOLLISIONr BCM53101_A0_READ_S_TXLATECOLLISIONr
#define WRITE_S_TXLATECOLLISIONr BCM53101_A0_WRITE_S_TXLATECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_TXLATECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_TxMulticastPkts
 * BLOCKS:   SYS
 * DESC:     Tx Multicast Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_TXMULTICASTPKTSr 0x00007114

#define BCM53101_A0_S_TXMULTICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxMulticastPkts.
 *
 */
typedef union BCM53101_A0_S_TXMULTICASTPKTSr_s {
	uint32_t v[1];
	uint32_t s_txmulticastpkts[1];
	uint32_t _s_txmulticastpkts;
} BCM53101_A0_S_TXMULTICASTPKTSr_t;

#define BCM53101_A0_S_TXMULTICASTPKTSr_CLR(r) (r).s_txmulticastpkts[0] = 0
#define BCM53101_A0_S_TXMULTICASTPKTSr_SET(r,d) (r).s_txmulticastpkts[0] = d
#define BCM53101_A0_S_TXMULTICASTPKTSr_GET(r) (r).s_txmulticastpkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_TXMULTICASTPKTSr_COUNTf_GET(r) ((r).s_txmulticastpkts[0])
#define BCM53101_A0_S_TXMULTICASTPKTSr_COUNTf_SET(r,f) (r).s_txmulticastpkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxMulticastPkts.
 *
 */
#define BCM53101_A0_READ_S_TXMULTICASTPKTSr(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_TXMULTICASTPKTSr,(r._s_txmulticastpkts),4)
#define BCM53101_A0_WRITE_S_TXMULTICASTPKTSr(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_TXMULTICASTPKTSr,&(r._s_txmulticastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXMULTICASTPKTSr BCM53101_A0_S_TXMULTICASTPKTSr
#define S_TXMULTICASTPKTSr_SIZE BCM53101_A0_S_TXMULTICASTPKTSr_SIZE
typedef BCM53101_A0_S_TXMULTICASTPKTSr_t S_TXMULTICASTPKTSr_t;
#define S_TXMULTICASTPKTSr_CLR BCM53101_A0_S_TXMULTICASTPKTSr_CLR
#define S_TXMULTICASTPKTSr_SET BCM53101_A0_S_TXMULTICASTPKTSr_SET
#define S_TXMULTICASTPKTSr_GET BCM53101_A0_S_TXMULTICASTPKTSr_GET
#define S_TXMULTICASTPKTSr_COUNTf_GET BCM53101_A0_S_TXMULTICASTPKTSr_COUNTf_GET
#define S_TXMULTICASTPKTSr_COUNTf_SET BCM53101_A0_S_TXMULTICASTPKTSr_COUNTf_SET
#define READ_S_TXMULTICASTPKTSr BCM53101_A0_READ_S_TXMULTICASTPKTSr
#define WRITE_S_TXMULTICASTPKTSr BCM53101_A0_WRITE_S_TXMULTICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_TXMULTICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_TxMultipleCollision
 * BLOCKS:   SYS
 * DESC:     Tx Multiple collsion Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_TXMULTIPLECOLLISIONr 0x00007124

#define BCM53101_A0_S_TXMULTIPLECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program S_TxMultipleCollision.
 *
 */
typedef union BCM53101_A0_S_TXMULTIPLECOLLISIONr_s {
	uint32_t v[1];
	uint32_t s_txmultiplecollision[1];
	uint32_t _s_txmultiplecollision;
} BCM53101_A0_S_TXMULTIPLECOLLISIONr_t;

#define BCM53101_A0_S_TXMULTIPLECOLLISIONr_CLR(r) (r).s_txmultiplecollision[0] = 0
#define BCM53101_A0_S_TXMULTIPLECOLLISIONr_SET(r,d) (r).s_txmultiplecollision[0] = d
#define BCM53101_A0_S_TXMULTIPLECOLLISIONr_GET(r) (r).s_txmultiplecollision[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_TXMULTIPLECOLLISIONr_COUNTf_GET(r) ((r).s_txmultiplecollision[0])
#define BCM53101_A0_S_TXMULTIPLECOLLISIONr_COUNTf_SET(r,f) (r).s_txmultiplecollision[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxMultipleCollision.
 *
 */
#define BCM53101_A0_READ_S_TXMULTIPLECOLLISIONr(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_TXMULTIPLECOLLISIONr,(r._s_txmultiplecollision),4)
#define BCM53101_A0_WRITE_S_TXMULTIPLECOLLISIONr(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_TXMULTIPLECOLLISIONr,&(r._s_txmultiplecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXMULTIPLECOLLISIONr BCM53101_A0_S_TXMULTIPLECOLLISIONr
#define S_TXMULTIPLECOLLISIONr_SIZE BCM53101_A0_S_TXMULTIPLECOLLISIONr_SIZE
typedef BCM53101_A0_S_TXMULTIPLECOLLISIONr_t S_TXMULTIPLECOLLISIONr_t;
#define S_TXMULTIPLECOLLISIONr_CLR BCM53101_A0_S_TXMULTIPLECOLLISIONr_CLR
#define S_TXMULTIPLECOLLISIONr_SET BCM53101_A0_S_TXMULTIPLECOLLISIONr_SET
#define S_TXMULTIPLECOLLISIONr_GET BCM53101_A0_S_TXMULTIPLECOLLISIONr_GET
#define S_TXMULTIPLECOLLISIONr_COUNTf_GET BCM53101_A0_S_TXMULTIPLECOLLISIONr_COUNTf_GET
#define S_TXMULTIPLECOLLISIONr_COUNTf_SET BCM53101_A0_S_TXMULTIPLECOLLISIONr_COUNTf_SET
#define READ_S_TXMULTIPLECOLLISIONr BCM53101_A0_READ_S_TXMULTIPLECOLLISIONr
#define WRITE_S_TXMULTIPLECOLLISIONr BCM53101_A0_WRITE_S_TXMULTIPLECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_TXMULTIPLECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_TxOctets
 * BLOCKS:   SYS
 * DESC:     Tx Octets
 * SIZE:     64
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_TXOCTETSr 0x00007100

#define BCM53101_A0_S_TXOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program S_TxOctets.
 *
 */
typedef union BCM53101_A0_S_TXOCTETSr_s {
	uint32_t v[2];
	uint32_t s_txoctets[2];
	uint32_t _s_txoctets;
} BCM53101_A0_S_TXOCTETSr_t;

#define BCM53101_A0_S_TXOCTETSr_CLR(r) CDK_MEMSET(&((r)._s_txoctets), 0, sizeof(BCM53101_A0_S_TXOCTETSr_t))
#define BCM53101_A0_S_TXOCTETSr_SET(r,i,d) (r).s_txoctets[i] = d
#define BCM53101_A0_S_TXOCTETSr_GET(r,i) (r).s_txoctets[i]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_TXOCTETSr_COUNTf_GET(r,a) cdk_field_get((r).s_txoctets,0,63,a)
#define BCM53101_A0_S_TXOCTETSr_COUNTf_SET(r,a) cdk_field_set((r).s_txoctets,0,63,a)

/*
 * These macros can be used to access S_TxOctets.
 *
 */
#define BCM53101_A0_READ_S_TXOCTETSr(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_TXOCTETSr,(r._s_txoctets),8)
#define BCM53101_A0_WRITE_S_TXOCTETSr(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_TXOCTETSr,&(r._s_txoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXOCTETSr BCM53101_A0_S_TXOCTETSr
#define S_TXOCTETSr_SIZE BCM53101_A0_S_TXOCTETSr_SIZE
typedef BCM53101_A0_S_TXOCTETSr_t S_TXOCTETSr_t;
#define S_TXOCTETSr_CLR BCM53101_A0_S_TXOCTETSr_CLR
#define S_TXOCTETSr_SET BCM53101_A0_S_TXOCTETSr_SET
#define S_TXOCTETSr_GET BCM53101_A0_S_TXOCTETSr_GET
#define S_TXOCTETSr_COUNTf_GET BCM53101_A0_S_TXOCTETSr_COUNTf_GET
#define S_TXOCTETSr_COUNTf_SET BCM53101_A0_S_TXOCTETSr_COUNTf_SET
#define READ_S_TXOCTETSr BCM53101_A0_READ_S_TXOCTETSr
#define WRITE_S_TXOCTETSr BCM53101_A0_WRITE_S_TXOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_TXOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_TxPausePkts
 * BLOCKS:   SYS
 * DESC:     Tx Pause Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_TXPAUSEPKTSr 0x00007138

#define BCM53101_A0_S_TXPAUSEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxPausePkts.
 *
 */
typedef union BCM53101_A0_S_TXPAUSEPKTSr_s {
	uint32_t v[1];
	uint32_t s_txpausepkts[1];
	uint32_t _s_txpausepkts;
} BCM53101_A0_S_TXPAUSEPKTSr_t;

#define BCM53101_A0_S_TXPAUSEPKTSr_CLR(r) (r).s_txpausepkts[0] = 0
#define BCM53101_A0_S_TXPAUSEPKTSr_SET(r,d) (r).s_txpausepkts[0] = d
#define BCM53101_A0_S_TXPAUSEPKTSr_GET(r) (r).s_txpausepkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_TXPAUSEPKTSr_COUNTf_GET(r) ((r).s_txpausepkts[0])
#define BCM53101_A0_S_TXPAUSEPKTSr_COUNTf_SET(r,f) (r).s_txpausepkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxPausePkts.
 *
 */
#define BCM53101_A0_READ_S_TXPAUSEPKTSr(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_TXPAUSEPKTSr,(r._s_txpausepkts),4)
#define BCM53101_A0_WRITE_S_TXPAUSEPKTSr(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_TXPAUSEPKTSr,&(r._s_txpausepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXPAUSEPKTSr BCM53101_A0_S_TXPAUSEPKTSr
#define S_TXPAUSEPKTSr_SIZE BCM53101_A0_S_TXPAUSEPKTSr_SIZE
typedef BCM53101_A0_S_TXPAUSEPKTSr_t S_TXPAUSEPKTSr_t;
#define S_TXPAUSEPKTSr_CLR BCM53101_A0_S_TXPAUSEPKTSr_CLR
#define S_TXPAUSEPKTSr_SET BCM53101_A0_S_TXPAUSEPKTSr_SET
#define S_TXPAUSEPKTSr_GET BCM53101_A0_S_TXPAUSEPKTSr_GET
#define S_TXPAUSEPKTSr_COUNTf_GET BCM53101_A0_S_TXPAUSEPKTSr_COUNTf_GET
#define S_TXPAUSEPKTSr_COUNTf_SET BCM53101_A0_S_TXPAUSEPKTSr_COUNTf_SET
#define READ_S_TXPAUSEPKTSr BCM53101_A0_READ_S_TXPAUSEPKTSr
#define WRITE_S_TXPAUSEPKTSr BCM53101_A0_WRITE_S_TXPAUSEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_TXPAUSEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_TxQPKTQ0
 * BLOCKS:   SYS
 * DESC:     Tx Q0 Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_TXQPKTQ0r 0x0000710c

#define BCM53101_A0_S_TXQPKTQ0r_SIZE 4

/*
 * This structure should be used to declare and program S_TxQPKTQ0.
 *
 */
typedef union BCM53101_A0_S_TXQPKTQ0r_s {
	uint32_t v[1];
	uint32_t s_txqpktq0[1];
	uint32_t _s_txqpktq0;
} BCM53101_A0_S_TXQPKTQ0r_t;

#define BCM53101_A0_S_TXQPKTQ0r_CLR(r) (r).s_txqpktq0[0] = 0
#define BCM53101_A0_S_TXQPKTQ0r_SET(r,d) (r).s_txqpktq0[0] = d
#define BCM53101_A0_S_TXQPKTQ0r_GET(r) (r).s_txqpktq0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_TXQPKTQ0r_COUNTf_GET(r) ((r).s_txqpktq0[0])
#define BCM53101_A0_S_TXQPKTQ0r_COUNTf_SET(r,f) (r).s_txqpktq0[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxQPKTQ0.
 *
 */
#define BCM53101_A0_READ_S_TXQPKTQ0r(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_TXQPKTQ0r,(r._s_txqpktq0),4)
#define BCM53101_A0_WRITE_S_TXQPKTQ0r(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_TXQPKTQ0r,&(r._s_txqpktq0),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQPKTQ0r BCM53101_A0_S_TXQPKTQ0r
#define S_TXQPKTQ0r_SIZE BCM53101_A0_S_TXQPKTQ0r_SIZE
typedef BCM53101_A0_S_TXQPKTQ0r_t S_TXQPKTQ0r_t;
#define S_TXQPKTQ0r_CLR BCM53101_A0_S_TXQPKTQ0r_CLR
#define S_TXQPKTQ0r_SET BCM53101_A0_S_TXQPKTQ0r_SET
#define S_TXQPKTQ0r_GET BCM53101_A0_S_TXQPKTQ0r_GET
#define S_TXQPKTQ0r_COUNTf_GET BCM53101_A0_S_TXQPKTQ0r_COUNTf_GET
#define S_TXQPKTQ0r_COUNTf_SET BCM53101_A0_S_TXQPKTQ0r_COUNTf_SET
#define READ_S_TXQPKTQ0r BCM53101_A0_READ_S_TXQPKTQ0r
#define WRITE_S_TXQPKTQ0r BCM53101_A0_WRITE_S_TXQPKTQ0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_TXQPKTQ0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_TxQPKTQ1
 * BLOCKS:   SYS
 * DESC:     Tx Q1 Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_TXQPKTQ1r 0x0000713c

#define BCM53101_A0_S_TXQPKTQ1r_SIZE 4

/*
 * This structure should be used to declare and program S_TxQPKTQ1.
 *
 */
typedef union BCM53101_A0_S_TXQPKTQ1r_s {
	uint32_t v[1];
	uint32_t s_txqpktq1[1];
	uint32_t _s_txqpktq1;
} BCM53101_A0_S_TXQPKTQ1r_t;

#define BCM53101_A0_S_TXQPKTQ1r_CLR(r) (r).s_txqpktq1[0] = 0
#define BCM53101_A0_S_TXQPKTQ1r_SET(r,d) (r).s_txqpktq1[0] = d
#define BCM53101_A0_S_TXQPKTQ1r_GET(r) (r).s_txqpktq1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_TXQPKTQ1r_COUNTf_GET(r) ((r).s_txqpktq1[0])
#define BCM53101_A0_S_TXQPKTQ1r_COUNTf_SET(r,f) (r).s_txqpktq1[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxQPKTQ1.
 *
 */
#define BCM53101_A0_READ_S_TXQPKTQ1r(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_TXQPKTQ1r,(r._s_txqpktq1),4)
#define BCM53101_A0_WRITE_S_TXQPKTQ1r(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_TXQPKTQ1r,&(r._s_txqpktq1),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQPKTQ1r BCM53101_A0_S_TXQPKTQ1r
#define S_TXQPKTQ1r_SIZE BCM53101_A0_S_TXQPKTQ1r_SIZE
typedef BCM53101_A0_S_TXQPKTQ1r_t S_TXQPKTQ1r_t;
#define S_TXQPKTQ1r_CLR BCM53101_A0_S_TXQPKTQ1r_CLR
#define S_TXQPKTQ1r_SET BCM53101_A0_S_TXQPKTQ1r_SET
#define S_TXQPKTQ1r_GET BCM53101_A0_S_TXQPKTQ1r_GET
#define S_TXQPKTQ1r_COUNTf_GET BCM53101_A0_S_TXQPKTQ1r_COUNTf_GET
#define S_TXQPKTQ1r_COUNTf_SET BCM53101_A0_S_TXQPKTQ1r_COUNTf_SET
#define READ_S_TXQPKTQ1r BCM53101_A0_READ_S_TXQPKTQ1r
#define WRITE_S_TXQPKTQ1r BCM53101_A0_WRITE_S_TXQPKTQ1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_TXQPKTQ1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_TxQPKTQ2
 * BLOCKS:   SYS
 * DESC:     Tx Q2 Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_TXQPKTQ2r 0x00007140

#define BCM53101_A0_S_TXQPKTQ2r_SIZE 4

/*
 * This structure should be used to declare and program S_TxQPKTQ2.
 *
 */
typedef union BCM53101_A0_S_TXQPKTQ2r_s {
	uint32_t v[1];
	uint32_t s_txqpktq2[1];
	uint32_t _s_txqpktq2;
} BCM53101_A0_S_TXQPKTQ2r_t;

#define BCM53101_A0_S_TXQPKTQ2r_CLR(r) (r).s_txqpktq2[0] = 0
#define BCM53101_A0_S_TXQPKTQ2r_SET(r,d) (r).s_txqpktq2[0] = d
#define BCM53101_A0_S_TXQPKTQ2r_GET(r) (r).s_txqpktq2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_TXQPKTQ2r_COUNTf_GET(r) ((r).s_txqpktq2[0])
#define BCM53101_A0_S_TXQPKTQ2r_COUNTf_SET(r,f) (r).s_txqpktq2[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxQPKTQ2.
 *
 */
#define BCM53101_A0_READ_S_TXQPKTQ2r(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_TXQPKTQ2r,(r._s_txqpktq2),4)
#define BCM53101_A0_WRITE_S_TXQPKTQ2r(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_TXQPKTQ2r,&(r._s_txqpktq2),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQPKTQ2r BCM53101_A0_S_TXQPKTQ2r
#define S_TXQPKTQ2r_SIZE BCM53101_A0_S_TXQPKTQ2r_SIZE
typedef BCM53101_A0_S_TXQPKTQ2r_t S_TXQPKTQ2r_t;
#define S_TXQPKTQ2r_CLR BCM53101_A0_S_TXQPKTQ2r_CLR
#define S_TXQPKTQ2r_SET BCM53101_A0_S_TXQPKTQ2r_SET
#define S_TXQPKTQ2r_GET BCM53101_A0_S_TXQPKTQ2r_GET
#define S_TXQPKTQ2r_COUNTf_GET BCM53101_A0_S_TXQPKTQ2r_COUNTf_GET
#define S_TXQPKTQ2r_COUNTf_SET BCM53101_A0_S_TXQPKTQ2r_COUNTf_SET
#define READ_S_TXQPKTQ2r BCM53101_A0_READ_S_TXQPKTQ2r
#define WRITE_S_TXQPKTQ2r BCM53101_A0_WRITE_S_TXQPKTQ2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_TXQPKTQ2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_TxQPKTQ3
 * BLOCKS:   SYS
 * DESC:     Tx Q3 Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_TXQPKTQ3r 0x00007144

#define BCM53101_A0_S_TXQPKTQ3r_SIZE 4

/*
 * This structure should be used to declare and program S_TxQPKTQ3.
 *
 */
typedef union BCM53101_A0_S_TXQPKTQ3r_s {
	uint32_t v[1];
	uint32_t s_txqpktq3[1];
	uint32_t _s_txqpktq3;
} BCM53101_A0_S_TXQPKTQ3r_t;

#define BCM53101_A0_S_TXQPKTQ3r_CLR(r) (r).s_txqpktq3[0] = 0
#define BCM53101_A0_S_TXQPKTQ3r_SET(r,d) (r).s_txqpktq3[0] = d
#define BCM53101_A0_S_TXQPKTQ3r_GET(r) (r).s_txqpktq3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_TXQPKTQ3r_COUNTf_GET(r) ((r).s_txqpktq3[0])
#define BCM53101_A0_S_TXQPKTQ3r_COUNTf_SET(r,f) (r).s_txqpktq3[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxQPKTQ3.
 *
 */
#define BCM53101_A0_READ_S_TXQPKTQ3r(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_TXQPKTQ3r,(r._s_txqpktq3),4)
#define BCM53101_A0_WRITE_S_TXQPKTQ3r(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_TXQPKTQ3r,&(r._s_txqpktq3),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQPKTQ3r BCM53101_A0_S_TXQPKTQ3r
#define S_TXQPKTQ3r_SIZE BCM53101_A0_S_TXQPKTQ3r_SIZE
typedef BCM53101_A0_S_TXQPKTQ3r_t S_TXQPKTQ3r_t;
#define S_TXQPKTQ3r_CLR BCM53101_A0_S_TXQPKTQ3r_CLR
#define S_TXQPKTQ3r_SET BCM53101_A0_S_TXQPKTQ3r_SET
#define S_TXQPKTQ3r_GET BCM53101_A0_S_TXQPKTQ3r_GET
#define S_TXQPKTQ3r_COUNTf_GET BCM53101_A0_S_TXQPKTQ3r_COUNTf_GET
#define S_TXQPKTQ3r_COUNTf_SET BCM53101_A0_S_TXQPKTQ3r_COUNTf_SET
#define READ_S_TXQPKTQ3r BCM53101_A0_READ_S_TXQPKTQ3r
#define WRITE_S_TXQPKTQ3r BCM53101_A0_WRITE_S_TXQPKTQ3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_TXQPKTQ3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_TxQPKTQ4
 * BLOCKS:   SYS
 * DESC:     Tx Q4 Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_TXQPKTQ4r 0x00007148

#define BCM53101_A0_S_TXQPKTQ4r_SIZE 4

/*
 * This structure should be used to declare and program S_TxQPKTQ4.
 *
 */
typedef union BCM53101_A0_S_TXQPKTQ4r_s {
	uint32_t v[1];
	uint32_t s_txqpktq4[1];
	uint32_t _s_txqpktq4;
} BCM53101_A0_S_TXQPKTQ4r_t;

#define BCM53101_A0_S_TXQPKTQ4r_CLR(r) (r).s_txqpktq4[0] = 0
#define BCM53101_A0_S_TXQPKTQ4r_SET(r,d) (r).s_txqpktq4[0] = d
#define BCM53101_A0_S_TXQPKTQ4r_GET(r) (r).s_txqpktq4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_TXQPKTQ4r_COUNTf_GET(r) ((r).s_txqpktq4[0])
#define BCM53101_A0_S_TXQPKTQ4r_COUNTf_SET(r,f) (r).s_txqpktq4[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxQPKTQ4.
 *
 */
#define BCM53101_A0_READ_S_TXQPKTQ4r(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_TXQPKTQ4r,(r._s_txqpktq4),4)
#define BCM53101_A0_WRITE_S_TXQPKTQ4r(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_TXQPKTQ4r,&(r._s_txqpktq4),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQPKTQ4r BCM53101_A0_S_TXQPKTQ4r
#define S_TXQPKTQ4r_SIZE BCM53101_A0_S_TXQPKTQ4r_SIZE
typedef BCM53101_A0_S_TXQPKTQ4r_t S_TXQPKTQ4r_t;
#define S_TXQPKTQ4r_CLR BCM53101_A0_S_TXQPKTQ4r_CLR
#define S_TXQPKTQ4r_SET BCM53101_A0_S_TXQPKTQ4r_SET
#define S_TXQPKTQ4r_GET BCM53101_A0_S_TXQPKTQ4r_GET
#define S_TXQPKTQ4r_COUNTf_GET BCM53101_A0_S_TXQPKTQ4r_COUNTf_GET
#define S_TXQPKTQ4r_COUNTf_SET BCM53101_A0_S_TXQPKTQ4r_COUNTf_SET
#define READ_S_TXQPKTQ4r BCM53101_A0_READ_S_TXQPKTQ4r
#define WRITE_S_TXQPKTQ4r BCM53101_A0_WRITE_S_TXQPKTQ4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_TXQPKTQ4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_TxQPKTQ5
 * BLOCKS:   SYS
 * DESC:     Tx Q5 Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_TXQPKTQ5r 0x0000714c

#define BCM53101_A0_S_TXQPKTQ5r_SIZE 4

/*
 * This structure should be used to declare and program S_TxQPKTQ5.
 *
 */
typedef union BCM53101_A0_S_TXQPKTQ5r_s {
	uint32_t v[1];
	uint32_t s_txqpktq5[1];
	uint32_t _s_txqpktq5;
} BCM53101_A0_S_TXQPKTQ5r_t;

#define BCM53101_A0_S_TXQPKTQ5r_CLR(r) (r).s_txqpktq5[0] = 0
#define BCM53101_A0_S_TXQPKTQ5r_SET(r,d) (r).s_txqpktq5[0] = d
#define BCM53101_A0_S_TXQPKTQ5r_GET(r) (r).s_txqpktq5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_TXQPKTQ5r_COUNTf_GET(r) ((r).s_txqpktq5[0])
#define BCM53101_A0_S_TXQPKTQ5r_COUNTf_SET(r,f) (r).s_txqpktq5[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxQPKTQ5.
 *
 */
#define BCM53101_A0_READ_S_TXQPKTQ5r(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_TXQPKTQ5r,(r._s_txqpktq5),4)
#define BCM53101_A0_WRITE_S_TXQPKTQ5r(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_TXQPKTQ5r,&(r._s_txqpktq5),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXQPKTQ5r BCM53101_A0_S_TXQPKTQ5r
#define S_TXQPKTQ5r_SIZE BCM53101_A0_S_TXQPKTQ5r_SIZE
typedef BCM53101_A0_S_TXQPKTQ5r_t S_TXQPKTQ5r_t;
#define S_TXQPKTQ5r_CLR BCM53101_A0_S_TXQPKTQ5r_CLR
#define S_TXQPKTQ5r_SET BCM53101_A0_S_TXQPKTQ5r_SET
#define S_TXQPKTQ5r_GET BCM53101_A0_S_TXQPKTQ5r_GET
#define S_TXQPKTQ5r_COUNTf_GET BCM53101_A0_S_TXQPKTQ5r_COUNTf_GET
#define S_TXQPKTQ5r_COUNTf_SET BCM53101_A0_S_TXQPKTQ5r_COUNTf_SET
#define READ_S_TXQPKTQ5r BCM53101_A0_READ_S_TXQPKTQ5r
#define WRITE_S_TXQPKTQ5r BCM53101_A0_WRITE_S_TXQPKTQ5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_TXQPKTQ5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_TxSingleCollision
 * BLOCKS:   SYS
 * DESC:     Tx Single Collision Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_TXSINGLECOLLISIONr 0x00007120

#define BCM53101_A0_S_TXSINGLECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program S_TxSingleCollision.
 *
 */
typedef union BCM53101_A0_S_TXSINGLECOLLISIONr_s {
	uint32_t v[1];
	uint32_t s_txsinglecollision[1];
	uint32_t _s_txsinglecollision;
} BCM53101_A0_S_TXSINGLECOLLISIONr_t;

#define BCM53101_A0_S_TXSINGLECOLLISIONr_CLR(r) (r).s_txsinglecollision[0] = 0
#define BCM53101_A0_S_TXSINGLECOLLISIONr_SET(r,d) (r).s_txsinglecollision[0] = d
#define BCM53101_A0_S_TXSINGLECOLLISIONr_GET(r) (r).s_txsinglecollision[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_TXSINGLECOLLISIONr_COUNTf_GET(r) ((r).s_txsinglecollision[0])
#define BCM53101_A0_S_TXSINGLECOLLISIONr_COUNTf_SET(r,f) (r).s_txsinglecollision[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxSingleCollision.
 *
 */
#define BCM53101_A0_READ_S_TXSINGLECOLLISIONr(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_TXSINGLECOLLISIONr,(r._s_txsinglecollision),4)
#define BCM53101_A0_WRITE_S_TXSINGLECOLLISIONr(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_TXSINGLECOLLISIONr,&(r._s_txsinglecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXSINGLECOLLISIONr BCM53101_A0_S_TXSINGLECOLLISIONr
#define S_TXSINGLECOLLISIONr_SIZE BCM53101_A0_S_TXSINGLECOLLISIONr_SIZE
typedef BCM53101_A0_S_TXSINGLECOLLISIONr_t S_TXSINGLECOLLISIONr_t;
#define S_TXSINGLECOLLISIONr_CLR BCM53101_A0_S_TXSINGLECOLLISIONr_CLR
#define S_TXSINGLECOLLISIONr_SET BCM53101_A0_S_TXSINGLECOLLISIONr_SET
#define S_TXSINGLECOLLISIONr_GET BCM53101_A0_S_TXSINGLECOLLISIONr_GET
#define S_TXSINGLECOLLISIONr_COUNTf_GET BCM53101_A0_S_TXSINGLECOLLISIONr_COUNTf_GET
#define S_TXSINGLECOLLISIONr_COUNTf_SET BCM53101_A0_S_TXSINGLECOLLISIONr_COUNTf_SET
#define READ_S_TXSINGLECOLLISIONr BCM53101_A0_READ_S_TXSINGLECOLLISIONr
#define WRITE_S_TXSINGLECOLLISIONr BCM53101_A0_WRITE_S_TXSINGLECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_TXSINGLECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  S_TxUnicastPkts
 * BLOCKS:   SYS
 * DESC:     Tx Unicast Packet Counter
 * SIZE:     32
 * FIELDS:
 *     COUNT            MIB Counter Value
 *
 ******************************************************************************/
#define BCM53101_A0_S_TXUNICASTPKTSr 0x00007118

#define BCM53101_A0_S_TXUNICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program S_TxUnicastPkts.
 *
 */
typedef union BCM53101_A0_S_TXUNICASTPKTSr_s {
	uint32_t v[1];
	uint32_t s_txunicastpkts[1];
	uint32_t _s_txunicastpkts;
} BCM53101_A0_S_TXUNICASTPKTSr_t;

#define BCM53101_A0_S_TXUNICASTPKTSr_CLR(r) (r).s_txunicastpkts[0] = 0
#define BCM53101_A0_S_TXUNICASTPKTSr_SET(r,d) (r).s_txunicastpkts[0] = d
#define BCM53101_A0_S_TXUNICASTPKTSr_GET(r) (r).s_txunicastpkts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_S_TXUNICASTPKTSr_COUNTf_GET(r) ((r).s_txunicastpkts[0])
#define BCM53101_A0_S_TXUNICASTPKTSr_COUNTf_SET(r,f) (r).s_txunicastpkts[0]=((uint32_t)f)

/*
 * These macros can be used to access S_TxUnicastPkts.
 *
 */
#define BCM53101_A0_READ_S_TXUNICASTPKTSr(u,r) cdk_robo_reg_read(u,BCM53101_A0_S_TXUNICASTPKTSr,(r._s_txunicastpkts),4)
#define BCM53101_A0_WRITE_S_TXUNICASTPKTSr(u,r) cdk_robo_reg_write(u,BCM53101_A0_S_TXUNICASTPKTSr,&(r._s_txunicastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define S_TXUNICASTPKTSr BCM53101_A0_S_TXUNICASTPKTSr
#define S_TXUNICASTPKTSr_SIZE BCM53101_A0_S_TXUNICASTPKTSr_SIZE
typedef BCM53101_A0_S_TXUNICASTPKTSr_t S_TXUNICASTPKTSr_t;
#define S_TXUNICASTPKTSr_CLR BCM53101_A0_S_TXUNICASTPKTSr_CLR
#define S_TXUNICASTPKTSr_SET BCM53101_A0_S_TXUNICASTPKTSr_SET
#define S_TXUNICASTPKTSr_GET BCM53101_A0_S_TXUNICASTPKTSr_GET
#define S_TXUNICASTPKTSr_COUNTf_GET BCM53101_A0_S_TXUNICASTPKTSr_COUNTf_GET
#define S_TXUNICASTPKTSr_COUNTf_SET BCM53101_A0_S_TXUNICASTPKTSr_COUNTf_SET
#define READ_S_TXUNICASTPKTSr BCM53101_A0_READ_S_TXUNICASTPKTSr
#define WRITE_S_TXUNICASTPKTSr BCM53101_A0_WRITE_S_TXUNICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_S_TXUNICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TC2COS_MAP
 * BLOCKS:   SYS
 * DESC:     TC to COS Mapping Register
 * SIZE:     16
 * FIELDS:
 *     PRT000_TO_QID    Priority ID 000 mapped to TX Queue ID.if (N ==0~3 && strap qos_en) 2'b11 else2'b00
 *     PRT001_TO_QID    Priority ID 001 mapped to TX Queue ID.if (N ==0~3 && strap qos_en) 2'b11 else2'b00
 *     PRT010_TO_QID    Priority ID 010 mapped to TX Queue ID.if (N ==0~3 && strap qos_en) 2'b11 else2'b00
 *     PRT011_TO_QID    Priority ID 011 mapped to TX Queue ID.if (N ==0~3 && strap qos_en) 2'b11 else2'b00
 *     PRT100_TO_QID    Priority ID 100 mapped to TX Queue ID.if (N ==0~3 && strap qos_en) 2'b11 else2'b00
 *     PRT101_TO_QID    Priority ID 101 mapped to TX Queue ID.if (N ==0~3 && strap qos_en) 2'b11 else2'b00
 *     PRT110_TO_QID    Priority ID 110 mapped to TX Queue ID.if (N ==0~3 && strap qos_en) 2'b11 else2'b00
 *     PRT111_TO_QID    Priority ID 111 mapped to TX Queue ID.if (N ==0~3 && strap qos_en) 2'b11 else2'b00
 *
 ******************************************************************************/
#define BCM53101_A0_TC2COS_MAPr 0x00003062

#define BCM53101_A0_TC2COS_MAPr_SIZE 2

/*
 * This structure should be used to declare and program TC2COS_MAP.
 *
 */
typedef union BCM53101_A0_TC2COS_MAPr_s {
	uint32_t v[1];
	uint32_t tc2cos_map[1];
	uint32_t _tc2cos_map;
} BCM53101_A0_TC2COS_MAPr_t;

#define BCM53101_A0_TC2COS_MAPr_CLR(r) (r).tc2cos_map[0] = 0
#define BCM53101_A0_TC2COS_MAPr_SET(r,d) (r).tc2cos_map[0] = d
#define BCM53101_A0_TC2COS_MAPr_GET(r) (r).tc2cos_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_TC2COS_MAPr_PRT000_TO_QIDf_GET(r) (((r).tc2cos_map[0]) & 0x3)
#define BCM53101_A0_TC2COS_MAPr_PRT000_TO_QIDf_SET(r,f) (r).tc2cos_map[0]=(((r).tc2cos_map[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53101_A0_TC2COS_MAPr_PRT001_TO_QIDf_GET(r) ((((r).tc2cos_map[0]) >> 2) & 0x3)
#define BCM53101_A0_TC2COS_MAPr_PRT001_TO_QIDf_SET(r,f) (r).tc2cos_map[0]=(((r).tc2cos_map[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2))
#define BCM53101_A0_TC2COS_MAPr_PRT010_TO_QIDf_GET(r) ((((r).tc2cos_map[0]) >> 4) & 0x3)
#define BCM53101_A0_TC2COS_MAPr_PRT010_TO_QIDf_SET(r,f) (r).tc2cos_map[0]=(((r).tc2cos_map[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4))
#define BCM53101_A0_TC2COS_MAPr_PRT011_TO_QIDf_GET(r) ((((r).tc2cos_map[0]) >> 6) & 0x3)
#define BCM53101_A0_TC2COS_MAPr_PRT011_TO_QIDf_SET(r,f) (r).tc2cos_map[0]=(((r).tc2cos_map[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))
#define BCM53101_A0_TC2COS_MAPr_PRT100_TO_QIDf_GET(r) ((((r).tc2cos_map[0]) >> 8) & 0x3)
#define BCM53101_A0_TC2COS_MAPr_PRT100_TO_QIDf_SET(r,f) (r).tc2cos_map[0]=(((r).tc2cos_map[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8))
#define BCM53101_A0_TC2COS_MAPr_PRT101_TO_QIDf_GET(r) ((((r).tc2cos_map[0]) >> 10) & 0x3)
#define BCM53101_A0_TC2COS_MAPr_PRT101_TO_QIDf_SET(r,f) (r).tc2cos_map[0]=(((r).tc2cos_map[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10))
#define BCM53101_A0_TC2COS_MAPr_PRT110_TO_QIDf_GET(r) ((((r).tc2cos_map[0]) >> 12) & 0x3)
#define BCM53101_A0_TC2COS_MAPr_PRT110_TO_QIDf_SET(r,f) (r).tc2cos_map[0]=(((r).tc2cos_map[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12))
#define BCM53101_A0_TC2COS_MAPr_PRT111_TO_QIDf_GET(r) ((((r).tc2cos_map[0]) >> 14) & 0x3)
#define BCM53101_A0_TC2COS_MAPr_PRT111_TO_QIDf_SET(r,f) (r).tc2cos_map[0]=(((r).tc2cos_map[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14))

/*
 * These macros can be used to access TC2COS_MAP.
 *
 */
#define BCM53101_A0_READ_TC2COS_MAPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_TC2COS_MAPr,(r._tc2cos_map),2)
#define BCM53101_A0_WRITE_TC2COS_MAPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_TC2COS_MAPr,&(r._tc2cos_map),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TC2COS_MAPr BCM53101_A0_TC2COS_MAPr
#define TC2COS_MAPr_SIZE BCM53101_A0_TC2COS_MAPr_SIZE
typedef BCM53101_A0_TC2COS_MAPr_t TC2COS_MAPr_t;
#define TC2COS_MAPr_CLR BCM53101_A0_TC2COS_MAPr_CLR
#define TC2COS_MAPr_SET BCM53101_A0_TC2COS_MAPr_SET
#define TC2COS_MAPr_GET BCM53101_A0_TC2COS_MAPr_GET
#define TC2COS_MAPr_PRT000_TO_QIDf_GET BCM53101_A0_TC2COS_MAPr_PRT000_TO_QIDf_GET
#define TC2COS_MAPr_PRT000_TO_QIDf_SET BCM53101_A0_TC2COS_MAPr_PRT000_TO_QIDf_SET
#define TC2COS_MAPr_PRT001_TO_QIDf_GET BCM53101_A0_TC2COS_MAPr_PRT001_TO_QIDf_GET
#define TC2COS_MAPr_PRT001_TO_QIDf_SET BCM53101_A0_TC2COS_MAPr_PRT001_TO_QIDf_SET
#define TC2COS_MAPr_PRT010_TO_QIDf_GET BCM53101_A0_TC2COS_MAPr_PRT010_TO_QIDf_GET
#define TC2COS_MAPr_PRT010_TO_QIDf_SET BCM53101_A0_TC2COS_MAPr_PRT010_TO_QIDf_SET
#define TC2COS_MAPr_PRT011_TO_QIDf_GET BCM53101_A0_TC2COS_MAPr_PRT011_TO_QIDf_GET
#define TC2COS_MAPr_PRT011_TO_QIDf_SET BCM53101_A0_TC2COS_MAPr_PRT011_TO_QIDf_SET
#define TC2COS_MAPr_PRT100_TO_QIDf_GET BCM53101_A0_TC2COS_MAPr_PRT100_TO_QIDf_GET
#define TC2COS_MAPr_PRT100_TO_QIDf_SET BCM53101_A0_TC2COS_MAPr_PRT100_TO_QIDf_SET
#define TC2COS_MAPr_PRT101_TO_QIDf_GET BCM53101_A0_TC2COS_MAPr_PRT101_TO_QIDf_GET
#define TC2COS_MAPr_PRT101_TO_QIDf_SET BCM53101_A0_TC2COS_MAPr_PRT101_TO_QIDf_SET
#define TC2COS_MAPr_PRT110_TO_QIDf_GET BCM53101_A0_TC2COS_MAPr_PRT110_TO_QIDf_GET
#define TC2COS_MAPr_PRT110_TO_QIDf_SET BCM53101_A0_TC2COS_MAPr_PRT110_TO_QIDf_SET
#define TC2COS_MAPr_PRT111_TO_QIDf_GET BCM53101_A0_TC2COS_MAPr_PRT111_TO_QIDf_GET
#define TC2COS_MAPr_PRT111_TO_QIDf_SET BCM53101_A0_TC2COS_MAPr_PRT111_TO_QIDf_SET
#define READ_TC2COS_MAPr BCM53101_A0_READ_TC2COS_MAPr
#define WRITE_TC2COS_MAPr BCM53101_A0_WRITE_TC2COS_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TC2COS_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TEMP_MON_CAL
 * BLOCKS:   SYS
 * DESC:     Temperature Monitor Calibration Registers(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     TEMP_DATA_25C    Temperature measure code at 25oC. The default value is loaded from OTPmemory and the value is changeable if required.Note: Temperature(oC) = (measure code - TEMP_DATA_25)*(-0.69)+25oC.(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM53101_A0_TEMP_MON_CALr 0x00000f06

#define BCM53101_A0_TEMP_MON_CALr_SIZE 2

/*
 * This structure should be used to declare and program TEMP_MON_CAL.
 *
 */
typedef union BCM53101_A0_TEMP_MON_CALr_s {
	uint32_t v[1];
	uint32_t temp_mon_cal[1];
	uint32_t _temp_mon_cal;
} BCM53101_A0_TEMP_MON_CALr_t;

#define BCM53101_A0_TEMP_MON_CALr_CLR(r) (r).temp_mon_cal[0] = 0
#define BCM53101_A0_TEMP_MON_CALr_SET(r,d) (r).temp_mon_cal[0] = d
#define BCM53101_A0_TEMP_MON_CALr_GET(r) (r).temp_mon_cal[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_TEMP_MON_CALr_TEMP_DATA_25Cf_GET(r) (((r).temp_mon_cal[0]) & 0x1ff)
#define BCM53101_A0_TEMP_MON_CALr_TEMP_DATA_25Cf_SET(r,f) (r).temp_mon_cal[0]=(((r).temp_mon_cal[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_TEMP_MON_CALr_RESERVEDf_GET(r) ((((r).temp_mon_cal[0]) >> 9) & 0x7f)
#define BCM53101_A0_TEMP_MON_CALr_RESERVEDf_SET(r,f) (r).temp_mon_cal[0]=(((r).temp_mon_cal[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access TEMP_MON_CAL.
 *
 */
#define BCM53101_A0_READ_TEMP_MON_CALr(u,r) cdk_robo_reg_read(u,BCM53101_A0_TEMP_MON_CALr,(r._temp_mon_cal),2)
#define BCM53101_A0_WRITE_TEMP_MON_CALr(u,r) cdk_robo_reg_write(u,BCM53101_A0_TEMP_MON_CALr,&(r._temp_mon_cal),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TEMP_MON_CALr BCM53101_A0_TEMP_MON_CALr
#define TEMP_MON_CALr_SIZE BCM53101_A0_TEMP_MON_CALr_SIZE
typedef BCM53101_A0_TEMP_MON_CALr_t TEMP_MON_CALr_t;
#define TEMP_MON_CALr_CLR BCM53101_A0_TEMP_MON_CALr_CLR
#define TEMP_MON_CALr_SET BCM53101_A0_TEMP_MON_CALr_SET
#define TEMP_MON_CALr_GET BCM53101_A0_TEMP_MON_CALr_GET
#define TEMP_MON_CALr_TEMP_DATA_25Cf_GET BCM53101_A0_TEMP_MON_CALr_TEMP_DATA_25Cf_GET
#define TEMP_MON_CALr_TEMP_DATA_25Cf_SET BCM53101_A0_TEMP_MON_CALr_TEMP_DATA_25Cf_SET
#define TEMP_MON_CALr_RESERVEDf_GET BCM53101_A0_TEMP_MON_CALr_RESERVEDf_GET
#define TEMP_MON_CALr_RESERVEDf_SET BCM53101_A0_TEMP_MON_CALr_RESERVEDf_SET
#define READ_TEMP_MON_CALr BCM53101_A0_READ_TEMP_MON_CALr
#define WRITE_TEMP_MON_CALr BCM53101_A0_WRITE_TEMP_MON_CALr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TEMP_MON_CALr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TEMP_MON_CTL
 * BLOCKS:   SYS
 * DESC:     Temperature Monitor Control Registers(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     ADC_TEST_EN      1 = Temp monitor normal mode.0 = SAR ADC test mode.(Not2Release)
 *     BIAS_ADJUST      Analog bias adjustments.(Not2Release)
 *
 ******************************************************************************/
#define BCM53101_A0_TEMP_MON_CTLr 0x00000f00

#define BCM53101_A0_TEMP_MON_CTLr_SIZE 1

/*
 * This structure should be used to declare and program TEMP_MON_CTL.
 *
 */
typedef union BCM53101_A0_TEMP_MON_CTLr_s {
	uint32_t v[1];
	uint32_t temp_mon_ctl[1];
	uint32_t _temp_mon_ctl;
} BCM53101_A0_TEMP_MON_CTLr_t;

#define BCM53101_A0_TEMP_MON_CTLr_CLR(r) (r).temp_mon_ctl[0] = 0
#define BCM53101_A0_TEMP_MON_CTLr_SET(r,d) (r).temp_mon_ctl[0] = d
#define BCM53101_A0_TEMP_MON_CTLr_GET(r) (r).temp_mon_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_TEMP_MON_CTLr_ADC_TEST_ENf_GET(r) (((r).temp_mon_ctl[0]) & 0x1)
#define BCM53101_A0_TEMP_MON_CTLr_ADC_TEST_ENf_SET(r,f) (r).temp_mon_ctl[0]=(((r).temp_mon_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_TEMP_MON_CTLr_BIAS_ADJUSTf_GET(r) ((((r).temp_mon_ctl[0]) >> 1) & 0x7f)
#define BCM53101_A0_TEMP_MON_CTLr_BIAS_ADJUSTf_SET(r,f) (r).temp_mon_ctl[0]=(((r).temp_mon_ctl[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access TEMP_MON_CTL.
 *
 */
#define BCM53101_A0_READ_TEMP_MON_CTLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_TEMP_MON_CTLr,(r._temp_mon_ctl),1)
#define BCM53101_A0_WRITE_TEMP_MON_CTLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_TEMP_MON_CTLr,&(r._temp_mon_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TEMP_MON_CTLr BCM53101_A0_TEMP_MON_CTLr
#define TEMP_MON_CTLr_SIZE BCM53101_A0_TEMP_MON_CTLr_SIZE
typedef BCM53101_A0_TEMP_MON_CTLr_t TEMP_MON_CTLr_t;
#define TEMP_MON_CTLr_CLR BCM53101_A0_TEMP_MON_CTLr_CLR
#define TEMP_MON_CTLr_SET BCM53101_A0_TEMP_MON_CTLr_SET
#define TEMP_MON_CTLr_GET BCM53101_A0_TEMP_MON_CTLr_GET
#define TEMP_MON_CTLr_ADC_TEST_ENf_GET BCM53101_A0_TEMP_MON_CTLr_ADC_TEST_ENf_GET
#define TEMP_MON_CTLr_ADC_TEST_ENf_SET BCM53101_A0_TEMP_MON_CTLr_ADC_TEST_ENf_SET
#define TEMP_MON_CTLr_BIAS_ADJUSTf_GET BCM53101_A0_TEMP_MON_CTLr_BIAS_ADJUSTf_GET
#define TEMP_MON_CTLr_BIAS_ADJUSTf_SET BCM53101_A0_TEMP_MON_CTLr_BIAS_ADJUSTf_SET
#define READ_TEMP_MON_CTLr BCM53101_A0_READ_TEMP_MON_CTLr
#define WRITE_TEMP_MON_CTLr BCM53101_A0_WRITE_TEMP_MON_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TEMP_MON_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TEMP_MON_RESU
 * BLOCKS:   SYS
 * DESC:     Temperature Monitor Result Registers(Not2Release)
 * SIZE:     16
 * FIELDS:
 *     TEMP_DATA        Temperature monitor result. When the temperature is higher, the measure code is lower.(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM53101_A0_TEMP_MON_RESUr 0x00000f02

#define BCM53101_A0_TEMP_MON_RESUr_SIZE 2

/*
 * This structure should be used to declare and program TEMP_MON_RESU.
 *
 */
typedef union BCM53101_A0_TEMP_MON_RESUr_s {
	uint32_t v[1];
	uint32_t temp_mon_resu[1];
	uint32_t _temp_mon_resu;
} BCM53101_A0_TEMP_MON_RESUr_t;

#define BCM53101_A0_TEMP_MON_RESUr_CLR(r) (r).temp_mon_resu[0] = 0
#define BCM53101_A0_TEMP_MON_RESUr_SET(r,d) (r).temp_mon_resu[0] = d
#define BCM53101_A0_TEMP_MON_RESUr_GET(r) (r).temp_mon_resu[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_TEMP_MON_RESUr_TEMP_DATAf_GET(r) (((r).temp_mon_resu[0]) & 0x1ff)
#define BCM53101_A0_TEMP_MON_RESUr_TEMP_DATAf_SET(r,f) (r).temp_mon_resu[0]=(((r).temp_mon_resu[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_TEMP_MON_RESUr_RESERVEDf_GET(r) ((((r).temp_mon_resu[0]) >> 9) & 0x7f)
#define BCM53101_A0_TEMP_MON_RESUr_RESERVEDf_SET(r,f) (r).temp_mon_resu[0]=(((r).temp_mon_resu[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access TEMP_MON_RESU.
 *
 */
#define BCM53101_A0_READ_TEMP_MON_RESUr(u,r) cdk_robo_reg_read(u,BCM53101_A0_TEMP_MON_RESUr,(r._temp_mon_resu),2)
#define BCM53101_A0_WRITE_TEMP_MON_RESUr(u,r) cdk_robo_reg_write(u,BCM53101_A0_TEMP_MON_RESUr,&(r._temp_mon_resu),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TEMP_MON_RESUr BCM53101_A0_TEMP_MON_RESUr
#define TEMP_MON_RESUr_SIZE BCM53101_A0_TEMP_MON_RESUr_SIZE
typedef BCM53101_A0_TEMP_MON_RESUr_t TEMP_MON_RESUr_t;
#define TEMP_MON_RESUr_CLR BCM53101_A0_TEMP_MON_RESUr_CLR
#define TEMP_MON_RESUr_SET BCM53101_A0_TEMP_MON_RESUr_SET
#define TEMP_MON_RESUr_GET BCM53101_A0_TEMP_MON_RESUr_GET
#define TEMP_MON_RESUr_TEMP_DATAf_GET BCM53101_A0_TEMP_MON_RESUr_TEMP_DATAf_GET
#define TEMP_MON_RESUr_TEMP_DATAf_SET BCM53101_A0_TEMP_MON_RESUr_TEMP_DATAf_SET
#define TEMP_MON_RESUr_RESERVEDf_GET BCM53101_A0_TEMP_MON_RESUr_RESERVEDf_GET
#define TEMP_MON_RESUr_RESERVEDf_SET BCM53101_A0_TEMP_MON_RESUr_RESERVEDf_SET
#define READ_TEMP_MON_RESUr BCM53101_A0_READ_TEMP_MON_RESUr
#define WRITE_TEMP_MON_RESUr BCM53101_A0_WRITE_TEMP_MON_RESUr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TEMP_MON_RESUr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TEMP_MON_SPEC_CTL
 * BLOCKS:   SYS
 * DESC:     Temperature Monitor Special Control Registers(Not2Release)
 * SIZE:     8
 * FIELDS:
 *     TEMP_PWRDN       1=Set temperature monitor in power down condition.(Not2Release)
 *     RESERVED         Reserved(Not2Release)
 *
 ******************************************************************************/
#define BCM53101_A0_TEMP_MON_SPEC_CTLr 0x00000f08

#define BCM53101_A0_TEMP_MON_SPEC_CTLr_SIZE 1

/*
 * This structure should be used to declare and program TEMP_MON_SPEC_CTL.
 *
 */
typedef union BCM53101_A0_TEMP_MON_SPEC_CTLr_s {
	uint32_t v[1];
	uint32_t temp_mon_spec_ctl[1];
	uint32_t _temp_mon_spec_ctl;
} BCM53101_A0_TEMP_MON_SPEC_CTLr_t;

#define BCM53101_A0_TEMP_MON_SPEC_CTLr_CLR(r) (r).temp_mon_spec_ctl[0] = 0
#define BCM53101_A0_TEMP_MON_SPEC_CTLr_SET(r,d) (r).temp_mon_spec_ctl[0] = d
#define BCM53101_A0_TEMP_MON_SPEC_CTLr_GET(r) (r).temp_mon_spec_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_TEMP_MON_SPEC_CTLr_TEMP_PWRDNf_GET(r) (((r).temp_mon_spec_ctl[0]) & 0x1)
#define BCM53101_A0_TEMP_MON_SPEC_CTLr_TEMP_PWRDNf_SET(r,f) (r).temp_mon_spec_ctl[0]=(((r).temp_mon_spec_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_TEMP_MON_SPEC_CTLr_RESERVEDf_GET(r) ((((r).temp_mon_spec_ctl[0]) >> 1) & 0x7f)
#define BCM53101_A0_TEMP_MON_SPEC_CTLr_RESERVEDf_SET(r,f) (r).temp_mon_spec_ctl[0]=(((r).temp_mon_spec_ctl[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access TEMP_MON_SPEC_CTL.
 *
 */
#define BCM53101_A0_READ_TEMP_MON_SPEC_CTLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_TEMP_MON_SPEC_CTLr,(r._temp_mon_spec_ctl),1)
#define BCM53101_A0_WRITE_TEMP_MON_SPEC_CTLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_TEMP_MON_SPEC_CTLr,&(r._temp_mon_spec_ctl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TEMP_MON_SPEC_CTLr BCM53101_A0_TEMP_MON_SPEC_CTLr
#define TEMP_MON_SPEC_CTLr_SIZE BCM53101_A0_TEMP_MON_SPEC_CTLr_SIZE
typedef BCM53101_A0_TEMP_MON_SPEC_CTLr_t TEMP_MON_SPEC_CTLr_t;
#define TEMP_MON_SPEC_CTLr_CLR BCM53101_A0_TEMP_MON_SPEC_CTLr_CLR
#define TEMP_MON_SPEC_CTLr_SET BCM53101_A0_TEMP_MON_SPEC_CTLr_SET
#define TEMP_MON_SPEC_CTLr_GET BCM53101_A0_TEMP_MON_SPEC_CTLr_GET
#define TEMP_MON_SPEC_CTLr_TEMP_PWRDNf_GET BCM53101_A0_TEMP_MON_SPEC_CTLr_TEMP_PWRDNf_GET
#define TEMP_MON_SPEC_CTLr_TEMP_PWRDNf_SET BCM53101_A0_TEMP_MON_SPEC_CTLr_TEMP_PWRDNf_SET
#define TEMP_MON_SPEC_CTLr_RESERVEDf_GET BCM53101_A0_TEMP_MON_SPEC_CTLr_RESERVEDf_GET
#define TEMP_MON_SPEC_CTLr_RESERVEDf_SET BCM53101_A0_TEMP_MON_SPEC_CTLr_RESERVEDf_SET
#define READ_TEMP_MON_SPEC_CTLr BCM53101_A0_READ_TEMP_MON_SPEC_CTLr
#define WRITE_TEMP_MON_SPEC_CTLr BCM53101_A0_WRITE_TEMP_MON_SPEC_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TEMP_MON_SPEC_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TM_STAMP_RPT_CTRL
 * BLOCKS:   SYS
 * DESC:     ResE Time Stamp Report Control Register
 * SIZE:     8
 * FIELDS:
 *     TSRPT_PKT_EN     tsrpt_pkt_enThis field is to allow "Time Stamp Reporting Packet" to IMP when the time sync. packet transmitted on egress port .
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_TM_STAMP_RPT_CTRLr 0x00009002

#define BCM53101_A0_TM_STAMP_RPT_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program TM_STAMP_RPT_CTRL.
 *
 */
typedef union BCM53101_A0_TM_STAMP_RPT_CTRLr_s {
	uint32_t v[1];
	uint32_t tm_stamp_rpt_ctrl[1];
	uint32_t _tm_stamp_rpt_ctrl;
} BCM53101_A0_TM_STAMP_RPT_CTRLr_t;

#define BCM53101_A0_TM_STAMP_RPT_CTRLr_CLR(r) (r).tm_stamp_rpt_ctrl[0] = 0
#define BCM53101_A0_TM_STAMP_RPT_CTRLr_SET(r,d) (r).tm_stamp_rpt_ctrl[0] = d
#define BCM53101_A0_TM_STAMP_RPT_CTRLr_GET(r) (r).tm_stamp_rpt_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_TM_STAMP_RPT_CTRLr_TSRPT_PKT_ENf_GET(r) (((r).tm_stamp_rpt_ctrl[0]) & 0x1)
#define BCM53101_A0_TM_STAMP_RPT_CTRLr_TSRPT_PKT_ENf_SET(r,f) (r).tm_stamp_rpt_ctrl[0]=(((r).tm_stamp_rpt_ctrl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_TM_STAMP_RPT_CTRLr_RESERVEDf_GET(r) ((((r).tm_stamp_rpt_ctrl[0]) >> 1) & 0x7f)
#define BCM53101_A0_TM_STAMP_RPT_CTRLr_RESERVEDf_SET(r,f) (r).tm_stamp_rpt_ctrl[0]=(((r).tm_stamp_rpt_ctrl[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1))

/*
 * These macros can be used to access TM_STAMP_RPT_CTRL.
 *
 */
#define BCM53101_A0_READ_TM_STAMP_RPT_CTRLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_TM_STAMP_RPT_CTRLr,(r._tm_stamp_rpt_ctrl),1)
#define BCM53101_A0_WRITE_TM_STAMP_RPT_CTRLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_TM_STAMP_RPT_CTRLr,&(r._tm_stamp_rpt_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TM_STAMP_RPT_CTRLr BCM53101_A0_TM_STAMP_RPT_CTRLr
#define TM_STAMP_RPT_CTRLr_SIZE BCM53101_A0_TM_STAMP_RPT_CTRLr_SIZE
typedef BCM53101_A0_TM_STAMP_RPT_CTRLr_t TM_STAMP_RPT_CTRLr_t;
#define TM_STAMP_RPT_CTRLr_CLR BCM53101_A0_TM_STAMP_RPT_CTRLr_CLR
#define TM_STAMP_RPT_CTRLr_SET BCM53101_A0_TM_STAMP_RPT_CTRLr_SET
#define TM_STAMP_RPT_CTRLr_GET BCM53101_A0_TM_STAMP_RPT_CTRLr_GET
#define TM_STAMP_RPT_CTRLr_TSRPT_PKT_ENf_GET BCM53101_A0_TM_STAMP_RPT_CTRLr_TSRPT_PKT_ENf_GET
#define TM_STAMP_RPT_CTRLr_TSRPT_PKT_ENf_SET BCM53101_A0_TM_STAMP_RPT_CTRLr_TSRPT_PKT_ENf_SET
#define TM_STAMP_RPT_CTRLr_RESERVEDf_GET BCM53101_A0_TM_STAMP_RPT_CTRLr_RESERVEDf_GET
#define TM_STAMP_RPT_CTRLr_RESERVEDf_SET BCM53101_A0_TM_STAMP_RPT_CTRLr_RESERVEDf_SET
#define READ_TM_STAMP_RPT_CTRLr BCM53101_A0_READ_TM_STAMP_RPT_CTRLr
#define WRITE_TM_STAMP_RPT_CTRLr BCM53101_A0_WRITE_TM_STAMP_RPT_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TM_STAMP_RPT_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TM_STAMP_STATUS
 * BLOCKS:   SYS
 * DESC:     ResE Egress Time Stamp Status Register
 * SIZE:     8
 * FIELDS:
 *     VALID_STATUS     Valid Status5 bit field indicating  the Valid Status for each Time Stamp Register.  Once ResE Egress Time Stamp Register  read out by SPI, the Valid Status will be cleared respectively.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_TM_STAMP_STATUSr 0x000090af

#define BCM53101_A0_TM_STAMP_STATUSr_SIZE 1

/*
 * This structure should be used to declare and program TM_STAMP_STATUS.
 *
 */
typedef union BCM53101_A0_TM_STAMP_STATUSr_s {
	uint32_t v[1];
	uint32_t tm_stamp_status[1];
	uint32_t _tm_stamp_status;
} BCM53101_A0_TM_STAMP_STATUSr_t;

#define BCM53101_A0_TM_STAMP_STATUSr_CLR(r) (r).tm_stamp_status[0] = 0
#define BCM53101_A0_TM_STAMP_STATUSr_SET(r,d) (r).tm_stamp_status[0] = d
#define BCM53101_A0_TM_STAMP_STATUSr_GET(r) (r).tm_stamp_status[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_TM_STAMP_STATUSr_VALID_STATUSf_GET(r) (((r).tm_stamp_status[0]) & 0x3f)
#define BCM53101_A0_TM_STAMP_STATUSr_VALID_STATUSf_SET(r,f) (r).tm_stamp_status[0]=(((r).tm_stamp_status[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53101_A0_TM_STAMP_STATUSr_RESERVEDf_GET(r) ((((r).tm_stamp_status[0]) >> 6) & 0x3)
#define BCM53101_A0_TM_STAMP_STATUSr_RESERVEDf_SET(r,f) (r).tm_stamp_status[0]=(((r).tm_stamp_status[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access TM_STAMP_STATUS.
 *
 */
#define BCM53101_A0_READ_TM_STAMP_STATUSr(u,r) cdk_robo_reg_read(u,BCM53101_A0_TM_STAMP_STATUSr,(r._tm_stamp_status),1)
#define BCM53101_A0_WRITE_TM_STAMP_STATUSr(u,r) cdk_robo_reg_write(u,BCM53101_A0_TM_STAMP_STATUSr,&(r._tm_stamp_status),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TM_STAMP_STATUSr BCM53101_A0_TM_STAMP_STATUSr
#define TM_STAMP_STATUSr_SIZE BCM53101_A0_TM_STAMP_STATUSr_SIZE
typedef BCM53101_A0_TM_STAMP_STATUSr_t TM_STAMP_STATUSr_t;
#define TM_STAMP_STATUSr_CLR BCM53101_A0_TM_STAMP_STATUSr_CLR
#define TM_STAMP_STATUSr_SET BCM53101_A0_TM_STAMP_STATUSr_SET
#define TM_STAMP_STATUSr_GET BCM53101_A0_TM_STAMP_STATUSr_GET
#define TM_STAMP_STATUSr_VALID_STATUSf_GET BCM53101_A0_TM_STAMP_STATUSr_VALID_STATUSf_GET
#define TM_STAMP_STATUSr_VALID_STATUSf_SET BCM53101_A0_TM_STAMP_STATUSr_VALID_STATUSf_SET
#define TM_STAMP_STATUSr_RESERVEDf_GET BCM53101_A0_TM_STAMP_STATUSr_RESERVEDf_GET
#define TM_STAMP_STATUSr_RESERVEDf_SET BCM53101_A0_TM_STAMP_STATUSr_RESERVEDf_SET
#define READ_TM_STAMP_STATUSr BCM53101_A0_READ_TM_STAMP_STATUSr
#define WRITE_TM_STAMP_STATUSr BCM53101_A0_WRITE_TM_STAMP_STATUSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TM_STAMP_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TRREG_CTRL
 * BLOCKS:   SYS
 * DESC:     Traffic Remarking Control Register
 * SIZE:     32
 * FIELDS:
 *     RESERVED_2       
 *     PCP_RMK_EN       PCP Remarking EnableThis signal enable the PCP remarking function.Bit[24]: P8(IMP port)Bit[21:16]: P5-P0
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_TRREG_CTRLr 0x00009100

#define BCM53101_A0_TRREG_CTRLr_SIZE 4

/*
 * This structure should be used to declare and program TRREG_CTRL.
 *
 */
typedef union BCM53101_A0_TRREG_CTRLr_s {
	uint32_t v[1];
	uint32_t trreg_ctrl[1];
	uint32_t _trreg_ctrl;
} BCM53101_A0_TRREG_CTRLr_t;

#define BCM53101_A0_TRREG_CTRLr_CLR(r) (r).trreg_ctrl[0] = 0
#define BCM53101_A0_TRREG_CTRLr_SET(r,d) (r).trreg_ctrl[0] = d
#define BCM53101_A0_TRREG_CTRLr_GET(r) (r).trreg_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_TRREG_CTRLr_RESERVED_2f_GET(r) (((r).trreg_ctrl[0]) & 0x1ff)
#define BCM53101_A0_TRREG_CTRLr_RESERVED_2f_SET(r,f) (r).trreg_ctrl[0]=(((r).trreg_ctrl[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_TRREG_CTRLr_PCP_RMK_ENf_GET(r) ((((r).trreg_ctrl[0]) >> 16) & 0x1ff)
#define BCM53101_A0_TRREG_CTRLr_PCP_RMK_ENf_SET(r,f) (r).trreg_ctrl[0]=(((r).trreg_ctrl[0] & ~((uint32_t)0x1ff << 16)) | ((((uint32_t)f) & 0x1ff) << 16))
#define BCM53101_A0_TRREG_CTRLr_RESERVED_1f_GET(r) ((((r).trreg_ctrl[0]) >> 25) & 0x7f)
#define BCM53101_A0_TRREG_CTRLr_RESERVED_1f_SET(r,f) (r).trreg_ctrl[0]=(((r).trreg_ctrl[0] & ~((uint32_t)0x7f << 25)) | ((((uint32_t)f) & 0x7f) << 25))

/*
 * These macros can be used to access TRREG_CTRL.
 *
 */
#define BCM53101_A0_READ_TRREG_CTRLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_TRREG_CTRLr,(r._trreg_ctrl),4)
#define BCM53101_A0_WRITE_TRREG_CTRLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_TRREG_CTRLr,&(r._trreg_ctrl),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRREG_CTRLr BCM53101_A0_TRREG_CTRLr
#define TRREG_CTRLr_SIZE BCM53101_A0_TRREG_CTRLr_SIZE
typedef BCM53101_A0_TRREG_CTRLr_t TRREG_CTRLr_t;
#define TRREG_CTRLr_CLR BCM53101_A0_TRREG_CTRLr_CLR
#define TRREG_CTRLr_SET BCM53101_A0_TRREG_CTRLr_SET
#define TRREG_CTRLr_GET BCM53101_A0_TRREG_CTRLr_GET
#define TRREG_CTRLr_RESERVED_2f_GET BCM53101_A0_TRREG_CTRLr_RESERVED_2f_GET
#define TRREG_CTRLr_RESERVED_2f_SET BCM53101_A0_TRREG_CTRLr_RESERVED_2f_SET
#define TRREG_CTRLr_PCP_RMK_ENf_GET BCM53101_A0_TRREG_CTRLr_PCP_RMK_ENf_GET
#define TRREG_CTRLr_PCP_RMK_ENf_SET BCM53101_A0_TRREG_CTRLr_PCP_RMK_ENf_SET
#define TRREG_CTRLr_RESERVED_1f_GET BCM53101_A0_TRREG_CTRLr_RESERVED_1f_GET
#define TRREG_CTRLr_RESERVED_1f_SET BCM53101_A0_TRREG_CTRLr_RESERVED_1f_SET
#define READ_TRREG_CTRLr BCM53101_A0_READ_TRREG_CTRLr
#define WRITE_TRREG_CTRLr BCM53101_A0_WRITE_TRREG_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TRREG_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TRUNK_GRP_CTL
 * BLOCKS:   SYS
 * DESC:     Trunk Group Control Register
 * SIZE:     16
 * FIELDS:
 *     EN_TRUNK_GRP     Trunk Group Enable1 = Enable trunk group.0 = Disable trunk_groupBit 8: IMP port.For Lotus bits[5:0] correspond to ports [5:0], respectively.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_TRUNK_GRP_CTLr 0x00003210

#define BCM53101_A0_TRUNK_GRP_CTLr_SIZE 2

/*
 * This structure should be used to declare and program TRUNK_GRP_CTL.
 *
 */
typedef union BCM53101_A0_TRUNK_GRP_CTLr_s {
	uint32_t v[1];
	uint32_t trunk_grp_ctl[1];
	uint32_t _trunk_grp_ctl;
} BCM53101_A0_TRUNK_GRP_CTLr_t;

#define BCM53101_A0_TRUNK_GRP_CTLr_CLR(r) (r).trunk_grp_ctl[0] = 0
#define BCM53101_A0_TRUNK_GRP_CTLr_SET(r,d) (r).trunk_grp_ctl[0] = d
#define BCM53101_A0_TRUNK_GRP_CTLr_GET(r) (r).trunk_grp_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_TRUNK_GRP_CTLr_EN_TRUNK_GRPf_GET(r) (((r).trunk_grp_ctl[0]) & 0x1ff)
#define BCM53101_A0_TRUNK_GRP_CTLr_EN_TRUNK_GRPf_SET(r,f) (r).trunk_grp_ctl[0]=(((r).trunk_grp_ctl[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_TRUNK_GRP_CTLr_RESERVEDf_GET(r) ((((r).trunk_grp_ctl[0]) >> 9) & 0x7f)
#define BCM53101_A0_TRUNK_GRP_CTLr_RESERVEDf_SET(r,f) (r).trunk_grp_ctl[0]=(((r).trunk_grp_ctl[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access TRUNK_GRP_CTL.
 *
 */
#define BCM53101_A0_READ_TRUNK_GRP_CTLr(u,i,r) cdk_robo_reg_read(u,BCM53101_A0_TRUNK_GRP_CTLr+(2*(i)),(r._trunk_grp_ctl),2)
#define BCM53101_A0_WRITE_TRUNK_GRP_CTLr(u,i,r) cdk_robo_reg_write(u,BCM53101_A0_TRUNK_GRP_CTLr+(2*(i)),&(r._trunk_grp_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TRUNK_GRP_CTLr BCM53101_A0_TRUNK_GRP_CTLr
#define TRUNK_GRP_CTLr_SIZE BCM53101_A0_TRUNK_GRP_CTLr_SIZE
typedef BCM53101_A0_TRUNK_GRP_CTLr_t TRUNK_GRP_CTLr_t;
#define TRUNK_GRP_CTLr_CLR BCM53101_A0_TRUNK_GRP_CTLr_CLR
#define TRUNK_GRP_CTLr_SET BCM53101_A0_TRUNK_GRP_CTLr_SET
#define TRUNK_GRP_CTLr_GET BCM53101_A0_TRUNK_GRP_CTLr_GET
#define TRUNK_GRP_CTLr_EN_TRUNK_GRPf_GET BCM53101_A0_TRUNK_GRP_CTLr_EN_TRUNK_GRPf_GET
#define TRUNK_GRP_CTLr_EN_TRUNK_GRPf_SET BCM53101_A0_TRUNK_GRP_CTLr_EN_TRUNK_GRPf_SET
#define TRUNK_GRP_CTLr_RESERVEDf_GET BCM53101_A0_TRUNK_GRP_CTLr_RESERVEDf_GET
#define TRUNK_GRP_CTLr_RESERVEDf_SET BCM53101_A0_TRUNK_GRP_CTLr_RESERVEDf_SET
#define READ_TRUNK_GRP_CTLr BCM53101_A0_READ_TRUNK_GRP_CTLr
#define WRITE_TRUNK_GRP_CTLr BCM53101_A0_WRITE_TRUNK_GRP_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TRUNK_GRP_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TXQ_FLUSH_MODE
 * BLOCKS:   SYS
 * DESC:     TxQ Flush Mode Control Registrer
 * SIZE:     8
 * FIELDS:
 *     BYPASS_FASTTXDSC_PATH Bypass Fast Txdsc Path.
 *     DIS_NEW_TXDIS    Disable new tx disable.
 *     EN_LCOL_FLUSH    Enable Lcol Flush.
 *     EN_RELOAD_ERR_PATH Enable Reload Error Path.
 *     EN_LCOL_TXFM_MASK bit[4] = enable_lcol_txfm_mask (default = 0)Description:- When enabled, Lotus drops the TX frame upon a latecollision.  (collisions detected beyond 64th byte including the preamble)- When disabled, Lotus transmits TX frames regardless of late-collision occurrence.
 *     EN_ECOL_TXFM_MASK bit[5] = enable_ecol_txfm_mask (default = 1)This bit affect the behavior of the register Retry_Lmt_Dis (Switch Mode reg 00:0Bh bit2) as follows:- When Retry_Lmt_Dis = 1 and enable_ecol_txfm_mask = 1,TX frame is persistently retried forever, while the back off counter increments from 0 to 15 and stay at 15 until the next normal frame transmission.- When Retry_Lmt_Dis = 1 and enable_ecol_txfm_mask = 0,TX frame is persistently retried forever, while the back off counter increments from 0 to 15 and loops back to 0and repeats this until the next normal frame transmission.When Retry_Lmt_Dis = 0 and enable_ecol_txfm_mask = 1,TX frame is retried up to 15 times, and the frame gets dropped upon the 16th consecutive early collision.When Retry_Lmt_Dis = 0 and enable_ecol_txfm_mask = 0,This mode is only engineering purpose, and prohibited for customers (ENGINEERING NOTE: This mode sets Lotus to the old mode, where we observed the tx ports hang. Don't show this in the customer datasheet).
 *     EN_LATECOL65_DROP enable_latecol65_drop.Enable old frame drop when a late collision occurs at 65th byte from start of preamble. When enabled, Lotus goes back to old mode by turning off the fix for Cisco TX Hang.Default is 0NOTE: Engineering only. Do not release this reg to customers.
 *     EN_NEW_BOFF_SEED 1'b1:backoff seed refer to port mumber.1'b0:backoff seed used default fix mumber.
 *
 ******************************************************************************/
#define BCM53101_A0_TXQ_FLUSH_MODEr 0x00000031

#define BCM53101_A0_TXQ_FLUSH_MODEr_SIZE 1

/*
 * This structure should be used to declare and program TXQ_FLUSH_MODE.
 *
 */
typedef union BCM53101_A0_TXQ_FLUSH_MODEr_s {
	uint32_t v[1];
	uint32_t txq_flush_mode[1];
	uint32_t _txq_flush_mode;
} BCM53101_A0_TXQ_FLUSH_MODEr_t;

#define BCM53101_A0_TXQ_FLUSH_MODEr_CLR(r) (r).txq_flush_mode[0] = 0
#define BCM53101_A0_TXQ_FLUSH_MODEr_SET(r,d) (r).txq_flush_mode[0] = d
#define BCM53101_A0_TXQ_FLUSH_MODEr_GET(r) (r).txq_flush_mode[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_TXQ_FLUSH_MODEr_BYPASS_FASTTXDSC_PATHf_GET(r) (((r).txq_flush_mode[0]) & 0x1)
#define BCM53101_A0_TXQ_FLUSH_MODEr_BYPASS_FASTTXDSC_PATHf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_TXQ_FLUSH_MODEr_DIS_NEW_TXDISf_GET(r) ((((r).txq_flush_mode[0]) >> 1) & 0x1)
#define BCM53101_A0_TXQ_FLUSH_MODEr_DIS_NEW_TXDISf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_TXQ_FLUSH_MODEr_EN_LCOL_FLUSHf_GET(r) ((((r).txq_flush_mode[0]) >> 2) & 0x1)
#define BCM53101_A0_TXQ_FLUSH_MODEr_EN_LCOL_FLUSHf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_TXQ_FLUSH_MODEr_EN_RELOAD_ERR_PATHf_GET(r) ((((r).txq_flush_mode[0]) >> 3) & 0x1)
#define BCM53101_A0_TXQ_FLUSH_MODEr_EN_RELOAD_ERR_PATHf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_TXQ_FLUSH_MODEr_EN_LCOL_TXFM_MASKf_GET(r) ((((r).txq_flush_mode[0]) >> 4) & 0x1)
#define BCM53101_A0_TXQ_FLUSH_MODEr_EN_LCOL_TXFM_MASKf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_TXQ_FLUSH_MODEr_EN_ECOL_TXFM_MASKf_GET(r) ((((r).txq_flush_mode[0]) >> 5) & 0x1)
#define BCM53101_A0_TXQ_FLUSH_MODEr_EN_ECOL_TXFM_MASKf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_TXQ_FLUSH_MODEr_EN_LATECOL65_DROPf_GET(r) ((((r).txq_flush_mode[0]) >> 6) & 0x1)
#define BCM53101_A0_TXQ_FLUSH_MODEr_EN_LATECOL65_DROPf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_TXQ_FLUSH_MODEr_EN_NEW_BOFF_SEEDf_GET(r) ((((r).txq_flush_mode[0]) >> 7) & 0x1)
#define BCM53101_A0_TXQ_FLUSH_MODEr_EN_NEW_BOFF_SEEDf_SET(r,f) (r).txq_flush_mode[0]=(((r).txq_flush_mode[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access TXQ_FLUSH_MODE.
 *
 */
#define BCM53101_A0_READ_TXQ_FLUSH_MODEr(u,r) cdk_robo_reg_read(u,BCM53101_A0_TXQ_FLUSH_MODEr,(r._txq_flush_mode),1)
#define BCM53101_A0_WRITE_TXQ_FLUSH_MODEr(u,r) cdk_robo_reg_write(u,BCM53101_A0_TXQ_FLUSH_MODEr,&(r._txq_flush_mode),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQ_FLUSH_MODEr BCM53101_A0_TXQ_FLUSH_MODEr
#define TXQ_FLUSH_MODEr_SIZE BCM53101_A0_TXQ_FLUSH_MODEr_SIZE
typedef BCM53101_A0_TXQ_FLUSH_MODEr_t TXQ_FLUSH_MODEr_t;
#define TXQ_FLUSH_MODEr_CLR BCM53101_A0_TXQ_FLUSH_MODEr_CLR
#define TXQ_FLUSH_MODEr_SET BCM53101_A0_TXQ_FLUSH_MODEr_SET
#define TXQ_FLUSH_MODEr_GET BCM53101_A0_TXQ_FLUSH_MODEr_GET
#define TXQ_FLUSH_MODEr_BYPASS_FASTTXDSC_PATHf_GET BCM53101_A0_TXQ_FLUSH_MODEr_BYPASS_FASTTXDSC_PATHf_GET
#define TXQ_FLUSH_MODEr_BYPASS_FASTTXDSC_PATHf_SET BCM53101_A0_TXQ_FLUSH_MODEr_BYPASS_FASTTXDSC_PATHf_SET
#define TXQ_FLUSH_MODEr_DIS_NEW_TXDISf_GET BCM53101_A0_TXQ_FLUSH_MODEr_DIS_NEW_TXDISf_GET
#define TXQ_FLUSH_MODEr_DIS_NEW_TXDISf_SET BCM53101_A0_TXQ_FLUSH_MODEr_DIS_NEW_TXDISf_SET
#define TXQ_FLUSH_MODEr_EN_LCOL_FLUSHf_GET BCM53101_A0_TXQ_FLUSH_MODEr_EN_LCOL_FLUSHf_GET
#define TXQ_FLUSH_MODEr_EN_LCOL_FLUSHf_SET BCM53101_A0_TXQ_FLUSH_MODEr_EN_LCOL_FLUSHf_SET
#define TXQ_FLUSH_MODEr_EN_RELOAD_ERR_PATHf_GET BCM53101_A0_TXQ_FLUSH_MODEr_EN_RELOAD_ERR_PATHf_GET
#define TXQ_FLUSH_MODEr_EN_RELOAD_ERR_PATHf_SET BCM53101_A0_TXQ_FLUSH_MODEr_EN_RELOAD_ERR_PATHf_SET
#define TXQ_FLUSH_MODEr_EN_LCOL_TXFM_MASKf_GET BCM53101_A0_TXQ_FLUSH_MODEr_EN_LCOL_TXFM_MASKf_GET
#define TXQ_FLUSH_MODEr_EN_LCOL_TXFM_MASKf_SET BCM53101_A0_TXQ_FLUSH_MODEr_EN_LCOL_TXFM_MASKf_SET
#define TXQ_FLUSH_MODEr_EN_ECOL_TXFM_MASKf_GET BCM53101_A0_TXQ_FLUSH_MODEr_EN_ECOL_TXFM_MASKf_GET
#define TXQ_FLUSH_MODEr_EN_ECOL_TXFM_MASKf_SET BCM53101_A0_TXQ_FLUSH_MODEr_EN_ECOL_TXFM_MASKf_SET
#define TXQ_FLUSH_MODEr_EN_LATECOL65_DROPf_GET BCM53101_A0_TXQ_FLUSH_MODEr_EN_LATECOL65_DROPf_GET
#define TXQ_FLUSH_MODEr_EN_LATECOL65_DROPf_SET BCM53101_A0_TXQ_FLUSH_MODEr_EN_LATECOL65_DROPf_SET
#define TXQ_FLUSH_MODEr_EN_NEW_BOFF_SEEDf_GET BCM53101_A0_TXQ_FLUSH_MODEr_EN_NEW_BOFF_SEEDf_GET
#define TXQ_FLUSH_MODEr_EN_NEW_BOFF_SEEDf_SET BCM53101_A0_TXQ_FLUSH_MODEr_EN_NEW_BOFF_SEEDf_SET
#define READ_TXQ_FLUSH_MODEr BCM53101_A0_READ_TXQ_FLUSH_MODEr
#define WRITE_TXQ_FLUSH_MODEr BCM53101_A0_WRITE_TXQ_FLUSH_MODEr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TXQ_FLUSH_MODEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TX_PAUSE_PASS
 * BLOCKS:   SYS
 * DESC:     Pause pass Through for TX Registrer
 * SIZE:     16
 * FIELDS:
 *     TX_PAUSE_PASS    TX pause pass through map.bit[8] : Port 8.bit[5:0] : Port 5-01 : ignore 802.3x.0 :comply with 802.3x pause frame receiving.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_TX_PAUSE_PASSr 0x0000003a

#define BCM53101_A0_TX_PAUSE_PASSr_SIZE 2

/*
 * This structure should be used to declare and program TX_PAUSE_PASS.
 *
 */
typedef union BCM53101_A0_TX_PAUSE_PASSr_s {
	uint32_t v[1];
	uint32_t tx_pause_pass[1];
	uint32_t _tx_pause_pass;
} BCM53101_A0_TX_PAUSE_PASSr_t;

#define BCM53101_A0_TX_PAUSE_PASSr_CLR(r) (r).tx_pause_pass[0] = 0
#define BCM53101_A0_TX_PAUSE_PASSr_SET(r,d) (r).tx_pause_pass[0] = d
#define BCM53101_A0_TX_PAUSE_PASSr_GET(r) (r).tx_pause_pass[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_TX_PAUSE_PASSr_TX_PAUSE_PASSf_GET(r) (((r).tx_pause_pass[0]) & 0x1ff)
#define BCM53101_A0_TX_PAUSE_PASSr_TX_PAUSE_PASSf_SET(r,f) (r).tx_pause_pass[0]=(((r).tx_pause_pass[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_TX_PAUSE_PASSr_RESERVEDf_GET(r) ((((r).tx_pause_pass[0]) >> 9) & 0x7f)
#define BCM53101_A0_TX_PAUSE_PASSr_RESERVEDf_SET(r,f) (r).tx_pause_pass[0]=(((r).tx_pause_pass[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access TX_PAUSE_PASS.
 *
 */
#define BCM53101_A0_READ_TX_PAUSE_PASSr(u,r) cdk_robo_reg_read(u,BCM53101_A0_TX_PAUSE_PASSr,(r._tx_pause_pass),2)
#define BCM53101_A0_WRITE_TX_PAUSE_PASSr(u,r) cdk_robo_reg_write(u,BCM53101_A0_TX_PAUSE_PASSr,&(r._tx_pause_pass),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TX_PAUSE_PASSr BCM53101_A0_TX_PAUSE_PASSr
#define TX_PAUSE_PASSr_SIZE BCM53101_A0_TX_PAUSE_PASSr_SIZE
typedef BCM53101_A0_TX_PAUSE_PASSr_t TX_PAUSE_PASSr_t;
#define TX_PAUSE_PASSr_CLR BCM53101_A0_TX_PAUSE_PASSr_CLR
#define TX_PAUSE_PASSr_SET BCM53101_A0_TX_PAUSE_PASSr_SET
#define TX_PAUSE_PASSr_GET BCM53101_A0_TX_PAUSE_PASSr_GET
#define TX_PAUSE_PASSr_TX_PAUSE_PASSf_GET BCM53101_A0_TX_PAUSE_PASSr_TX_PAUSE_PASSf_GET
#define TX_PAUSE_PASSr_TX_PAUSE_PASSf_SET BCM53101_A0_TX_PAUSE_PASSr_TX_PAUSE_PASSf_SET
#define TX_PAUSE_PASSr_RESERVEDf_GET BCM53101_A0_TX_PAUSE_PASSr_RESERVEDf_GET
#define TX_PAUSE_PASSr_RESERVEDf_SET BCM53101_A0_TX_PAUSE_PASSr_RESERVEDf_SET
#define READ_TX_PAUSE_PASSr BCM53101_A0_READ_TX_PAUSE_PASSr
#define WRITE_TX_PAUSE_PASSr BCM53101_A0_WRITE_TX_PAUSE_PASSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TX_PAUSE_PASSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TxBroadcastPkts
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Tx Broadcast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_TXBROADCASTPKTSr 0x00002010

#define BCM53101_A0_TXBROADCASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program TxBroadcastPkts.
 *
 */
typedef union BCM53101_A0_TXBROADCASTPKTSr_s {
	uint32_t v[1];
	uint32_t txbroadcastpkts[1];
	uint32_t _txbroadcastpkts;
} BCM53101_A0_TXBROADCASTPKTSr_t;

#define BCM53101_A0_TXBROADCASTPKTSr_CLR(r) (r).txbroadcastpkts[0] = 0
#define BCM53101_A0_TXBROADCASTPKTSr_SET(r,d) (r).txbroadcastpkts[0] = d
#define BCM53101_A0_TXBROADCASTPKTSr_GET(r) (r).txbroadcastpkts[0]


/*
 * These macros can be used to access TxBroadcastPkts.
 *
 */
#define BCM53101_A0_READ_TXBROADCASTPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_TXBROADCASTPKTSr,(r._txbroadcastpkts),4)
#define BCM53101_A0_WRITE_TXBROADCASTPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_TXBROADCASTPKTSr,&(r._txbroadcastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXBROADCASTPKTSr BCM53101_A0_TXBROADCASTPKTSr
#define TXBROADCASTPKTSr_SIZE BCM53101_A0_TXBROADCASTPKTSr_SIZE
typedef BCM53101_A0_TXBROADCASTPKTSr_t TXBROADCASTPKTSr_t;
#define TXBROADCASTPKTSr_CLR BCM53101_A0_TXBROADCASTPKTSr_CLR
#define TXBROADCASTPKTSr_SET BCM53101_A0_TXBROADCASTPKTSr_SET
#define TXBROADCASTPKTSr_GET BCM53101_A0_TXBROADCASTPKTSr_GET
#define READ_TXBROADCASTPKTSr BCM53101_A0_READ_TXBROADCASTPKTSr
#define WRITE_TXBROADCASTPKTSr BCM53101_A0_WRITE_TXBROADCASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TXBROADCASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TxBroadcastPkts_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Broadcast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_TXBROADCASTPKTS_IMPr 0x00002810

#define BCM53101_A0_TXBROADCASTPKTS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxBroadcastPkts_IMP.
 *
 */
typedef union BCM53101_A0_TXBROADCASTPKTS_IMPr_s {
	uint32_t v[1];
	uint32_t txbroadcastpkts_imp[1];
	uint32_t _txbroadcastpkts_imp;
} BCM53101_A0_TXBROADCASTPKTS_IMPr_t;

#define BCM53101_A0_TXBROADCASTPKTS_IMPr_CLR(r) (r).txbroadcastpkts_imp[0] = 0
#define BCM53101_A0_TXBROADCASTPKTS_IMPr_SET(r,d) (r).txbroadcastpkts_imp[0] = d
#define BCM53101_A0_TXBROADCASTPKTS_IMPr_GET(r) (r).txbroadcastpkts_imp[0]


/*
 * These macros can be used to access TxBroadcastPkts_IMP.
 *
 */
#define BCM53101_A0_READ_TXBROADCASTPKTS_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_TXBROADCASTPKTS_IMPr,(r._txbroadcastpkts_imp),4)
#define BCM53101_A0_WRITE_TXBROADCASTPKTS_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_TXBROADCASTPKTS_IMPr,&(r._txbroadcastpkts_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXBROADCASTPKTS_IMPr BCM53101_A0_TXBROADCASTPKTS_IMPr
#define TXBROADCASTPKTS_IMPr_SIZE BCM53101_A0_TXBROADCASTPKTS_IMPr_SIZE
typedef BCM53101_A0_TXBROADCASTPKTS_IMPr_t TXBROADCASTPKTS_IMPr_t;
#define TXBROADCASTPKTS_IMPr_CLR BCM53101_A0_TXBROADCASTPKTS_IMPr_CLR
#define TXBROADCASTPKTS_IMPr_SET BCM53101_A0_TXBROADCASTPKTS_IMPr_SET
#define TXBROADCASTPKTS_IMPr_GET BCM53101_A0_TXBROADCASTPKTS_IMPr_GET
#define READ_TXBROADCASTPKTS_IMPr BCM53101_A0_READ_TXBROADCASTPKTS_IMPr
#define WRITE_TXBROADCASTPKTS_IMPr BCM53101_A0_WRITE_TXBROADCASTPKTS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TXBROADCASTPKTS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TxCollisions
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Tx Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_TXCOLLISIONSr 0x0000201c

#define BCM53101_A0_TXCOLLISIONSr_SIZE 4

/*
 * This structure should be used to declare and program TxCollisions.
 *
 */
typedef union BCM53101_A0_TXCOLLISIONSr_s {
	uint32_t v[1];
	uint32_t txcollisions[1];
	uint32_t _txcollisions;
} BCM53101_A0_TXCOLLISIONSr_t;

#define BCM53101_A0_TXCOLLISIONSr_CLR(r) (r).txcollisions[0] = 0
#define BCM53101_A0_TXCOLLISIONSr_SET(r,d) (r).txcollisions[0] = d
#define BCM53101_A0_TXCOLLISIONSr_GET(r) (r).txcollisions[0]


/*
 * These macros can be used to access TxCollisions.
 *
 */
#define BCM53101_A0_READ_TXCOLLISIONSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_TXCOLLISIONSr,(r._txcollisions),4)
#define BCM53101_A0_WRITE_TXCOLLISIONSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_TXCOLLISIONSr,&(r._txcollisions),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXCOLLISIONSr BCM53101_A0_TXCOLLISIONSr
#define TXCOLLISIONSr_SIZE BCM53101_A0_TXCOLLISIONSr_SIZE
typedef BCM53101_A0_TXCOLLISIONSr_t TXCOLLISIONSr_t;
#define TXCOLLISIONSr_CLR BCM53101_A0_TXCOLLISIONSr_CLR
#define TXCOLLISIONSr_SET BCM53101_A0_TXCOLLISIONSr_SET
#define TXCOLLISIONSr_GET BCM53101_A0_TXCOLLISIONSr_GET
#define READ_TXCOLLISIONSr BCM53101_A0_READ_TXCOLLISIONSr
#define WRITE_TXCOLLISIONSr BCM53101_A0_WRITE_TXCOLLISIONSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TXCOLLISIONSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TxCollisions_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_TXCOLLISIONS_IMPr 0x0000281c

#define BCM53101_A0_TXCOLLISIONS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxCollisions_IMP.
 *
 */
typedef union BCM53101_A0_TXCOLLISIONS_IMPr_s {
	uint32_t v[1];
	uint32_t txcollisions_imp[1];
	uint32_t _txcollisions_imp;
} BCM53101_A0_TXCOLLISIONS_IMPr_t;

#define BCM53101_A0_TXCOLLISIONS_IMPr_CLR(r) (r).txcollisions_imp[0] = 0
#define BCM53101_A0_TXCOLLISIONS_IMPr_SET(r,d) (r).txcollisions_imp[0] = d
#define BCM53101_A0_TXCOLLISIONS_IMPr_GET(r) (r).txcollisions_imp[0]


/*
 * These macros can be used to access TxCollisions_IMP.
 *
 */
#define BCM53101_A0_READ_TXCOLLISIONS_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_TXCOLLISIONS_IMPr,(r._txcollisions_imp),4)
#define BCM53101_A0_WRITE_TXCOLLISIONS_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_TXCOLLISIONS_IMPr,&(r._txcollisions_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXCOLLISIONS_IMPr BCM53101_A0_TXCOLLISIONS_IMPr
#define TXCOLLISIONS_IMPr_SIZE BCM53101_A0_TXCOLLISIONS_IMPr_SIZE
typedef BCM53101_A0_TXCOLLISIONS_IMPr_t TXCOLLISIONS_IMPr_t;
#define TXCOLLISIONS_IMPr_CLR BCM53101_A0_TXCOLLISIONS_IMPr_CLR
#define TXCOLLISIONS_IMPr_SET BCM53101_A0_TXCOLLISIONS_IMPr_SET
#define TXCOLLISIONS_IMPr_GET BCM53101_A0_TXCOLLISIONS_IMPr_GET
#define READ_TXCOLLISIONS_IMPr BCM53101_A0_READ_TXCOLLISIONS_IMPr
#define WRITE_TXCOLLISIONS_IMPr BCM53101_A0_WRITE_TXCOLLISIONS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TXCOLLISIONS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TxDeferredTransmit
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Tx Deferred Transmit Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_TXDEFERREDTRANSMITr 0x00002028

#define BCM53101_A0_TXDEFERREDTRANSMITr_SIZE 4

/*
 * This structure should be used to declare and program TxDeferredTransmit.
 *
 */
typedef union BCM53101_A0_TXDEFERREDTRANSMITr_s {
	uint32_t v[1];
	uint32_t txdeferredtransmit[1];
	uint32_t _txdeferredtransmit;
} BCM53101_A0_TXDEFERREDTRANSMITr_t;

#define BCM53101_A0_TXDEFERREDTRANSMITr_CLR(r) (r).txdeferredtransmit[0] = 0
#define BCM53101_A0_TXDEFERREDTRANSMITr_SET(r,d) (r).txdeferredtransmit[0] = d
#define BCM53101_A0_TXDEFERREDTRANSMITr_GET(r) (r).txdeferredtransmit[0]


/*
 * These macros can be used to access TxDeferredTransmit.
 *
 */
#define BCM53101_A0_READ_TXDEFERREDTRANSMITr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_TXDEFERREDTRANSMITr,(r._txdeferredtransmit),4)
#define BCM53101_A0_WRITE_TXDEFERREDTRANSMITr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_TXDEFERREDTRANSMITr,&(r._txdeferredtransmit),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXDEFERREDTRANSMITr BCM53101_A0_TXDEFERREDTRANSMITr
#define TXDEFERREDTRANSMITr_SIZE BCM53101_A0_TXDEFERREDTRANSMITr_SIZE
typedef BCM53101_A0_TXDEFERREDTRANSMITr_t TXDEFERREDTRANSMITr_t;
#define TXDEFERREDTRANSMITr_CLR BCM53101_A0_TXDEFERREDTRANSMITr_CLR
#define TXDEFERREDTRANSMITr_SET BCM53101_A0_TXDEFERREDTRANSMITr_SET
#define TXDEFERREDTRANSMITr_GET BCM53101_A0_TXDEFERREDTRANSMITr_GET
#define READ_TXDEFERREDTRANSMITr BCM53101_A0_READ_TXDEFERREDTRANSMITr
#define WRITE_TXDEFERREDTRANSMITr BCM53101_A0_WRITE_TXDEFERREDTRANSMITr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TXDEFERREDTRANSMITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TxDeferredTransmit_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Deferred Transmit Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_TXDEFERREDTRANSMIT_IMPr 0x00002828

#define BCM53101_A0_TXDEFERREDTRANSMIT_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxDeferredTransmit_IMP.
 *
 */
typedef union BCM53101_A0_TXDEFERREDTRANSMIT_IMPr_s {
	uint32_t v[1];
	uint32_t txdeferredtransmit_imp[1];
	uint32_t _txdeferredtransmit_imp;
} BCM53101_A0_TXDEFERREDTRANSMIT_IMPr_t;

#define BCM53101_A0_TXDEFERREDTRANSMIT_IMPr_CLR(r) (r).txdeferredtransmit_imp[0] = 0
#define BCM53101_A0_TXDEFERREDTRANSMIT_IMPr_SET(r,d) (r).txdeferredtransmit_imp[0] = d
#define BCM53101_A0_TXDEFERREDTRANSMIT_IMPr_GET(r) (r).txdeferredtransmit_imp[0]


/*
 * These macros can be used to access TxDeferredTransmit_IMP.
 *
 */
#define BCM53101_A0_READ_TXDEFERREDTRANSMIT_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_TXDEFERREDTRANSMIT_IMPr,(r._txdeferredtransmit_imp),4)
#define BCM53101_A0_WRITE_TXDEFERREDTRANSMIT_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_TXDEFERREDTRANSMIT_IMPr,&(r._txdeferredtransmit_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXDEFERREDTRANSMIT_IMPr BCM53101_A0_TXDEFERREDTRANSMIT_IMPr
#define TXDEFERREDTRANSMIT_IMPr_SIZE BCM53101_A0_TXDEFERREDTRANSMIT_IMPr_SIZE
typedef BCM53101_A0_TXDEFERREDTRANSMIT_IMPr_t TXDEFERREDTRANSMIT_IMPr_t;
#define TXDEFERREDTRANSMIT_IMPr_CLR BCM53101_A0_TXDEFERREDTRANSMIT_IMPr_CLR
#define TXDEFERREDTRANSMIT_IMPr_SET BCM53101_A0_TXDEFERREDTRANSMIT_IMPr_SET
#define TXDEFERREDTRANSMIT_IMPr_GET BCM53101_A0_TXDEFERREDTRANSMIT_IMPr_GET
#define READ_TXDEFERREDTRANSMIT_IMPr BCM53101_A0_READ_TXDEFERREDTRANSMIT_IMPr
#define WRITE_TXDEFERREDTRANSMIT_IMPr BCM53101_A0_WRITE_TXDEFERREDTRANSMIT_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TXDEFERREDTRANSMIT_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TxDropPkts
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Tx Drop Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_TXDROPPKTSr 0x00002008

#define BCM53101_A0_TXDROPPKTSr_SIZE 4

/*
 * This structure should be used to declare and program TxDropPkts.
 *
 */
typedef union BCM53101_A0_TXDROPPKTSr_s {
	uint32_t v[1];
	uint32_t txdroppkts[1];
	uint32_t _txdroppkts;
} BCM53101_A0_TXDROPPKTSr_t;

#define BCM53101_A0_TXDROPPKTSr_CLR(r) (r).txdroppkts[0] = 0
#define BCM53101_A0_TXDROPPKTSr_SET(r,d) (r).txdroppkts[0] = d
#define BCM53101_A0_TXDROPPKTSr_GET(r) (r).txdroppkts[0]


/*
 * These macros can be used to access TxDropPkts.
 *
 */
#define BCM53101_A0_READ_TXDROPPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_TXDROPPKTSr,(r._txdroppkts),4)
#define BCM53101_A0_WRITE_TXDROPPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_TXDROPPKTSr,&(r._txdroppkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXDROPPKTSr BCM53101_A0_TXDROPPKTSr
#define TXDROPPKTSr_SIZE BCM53101_A0_TXDROPPKTSr_SIZE
typedef BCM53101_A0_TXDROPPKTSr_t TXDROPPKTSr_t;
#define TXDROPPKTSr_CLR BCM53101_A0_TXDROPPKTSr_CLR
#define TXDROPPKTSr_SET BCM53101_A0_TXDROPPKTSr_SET
#define TXDROPPKTSr_GET BCM53101_A0_TXDROPPKTSr_GET
#define READ_TXDROPPKTSr BCM53101_A0_READ_TXDROPPKTSr
#define WRITE_TXDROPPKTSr BCM53101_A0_WRITE_TXDROPPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TXDROPPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TxDropPkts_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Drop Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_TXDROPPKTS_IMPr 0x00002808

#define BCM53101_A0_TXDROPPKTS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxDropPkts_IMP.
 *
 */
typedef union BCM53101_A0_TXDROPPKTS_IMPr_s {
	uint32_t v[1];
	uint32_t txdroppkts_imp[1];
	uint32_t _txdroppkts_imp;
} BCM53101_A0_TXDROPPKTS_IMPr_t;

#define BCM53101_A0_TXDROPPKTS_IMPr_CLR(r) (r).txdroppkts_imp[0] = 0
#define BCM53101_A0_TXDROPPKTS_IMPr_SET(r,d) (r).txdroppkts_imp[0] = d
#define BCM53101_A0_TXDROPPKTS_IMPr_GET(r) (r).txdroppkts_imp[0]


/*
 * These macros can be used to access TxDropPkts_IMP.
 *
 */
#define BCM53101_A0_READ_TXDROPPKTS_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_TXDROPPKTS_IMPr,(r._txdroppkts_imp),4)
#define BCM53101_A0_WRITE_TXDROPPKTS_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_TXDROPPKTS_IMPr,&(r._txdroppkts_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXDROPPKTS_IMPr BCM53101_A0_TXDROPPKTS_IMPr
#define TXDROPPKTS_IMPr_SIZE BCM53101_A0_TXDROPPKTS_IMPr_SIZE
typedef BCM53101_A0_TXDROPPKTS_IMPr_t TXDROPPKTS_IMPr_t;
#define TXDROPPKTS_IMPr_CLR BCM53101_A0_TXDROPPKTS_IMPr_CLR
#define TXDROPPKTS_IMPr_SET BCM53101_A0_TXDROPPKTS_IMPr_SET
#define TXDROPPKTS_IMPr_GET BCM53101_A0_TXDROPPKTS_IMPr_GET
#define READ_TXDROPPKTS_IMPr BCM53101_A0_READ_TXDROPPKTS_IMPr
#define WRITE_TXDROPPKTS_IMPr BCM53101_A0_WRITE_TXDROPPKTS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TXDROPPKTS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TxExcessiveCollision
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Tx Excessive Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_TXEXCESSIVECOLLISIONr 0x00002030

#define BCM53101_A0_TXEXCESSIVECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program TxExcessiveCollision.
 *
 */
typedef union BCM53101_A0_TXEXCESSIVECOLLISIONr_s {
	uint32_t v[1];
	uint32_t txexcessivecollision[1];
	uint32_t _txexcessivecollision;
} BCM53101_A0_TXEXCESSIVECOLLISIONr_t;

#define BCM53101_A0_TXEXCESSIVECOLLISIONr_CLR(r) (r).txexcessivecollision[0] = 0
#define BCM53101_A0_TXEXCESSIVECOLLISIONr_SET(r,d) (r).txexcessivecollision[0] = d
#define BCM53101_A0_TXEXCESSIVECOLLISIONr_GET(r) (r).txexcessivecollision[0]


/*
 * These macros can be used to access TxExcessiveCollision.
 *
 */
#define BCM53101_A0_READ_TXEXCESSIVECOLLISIONr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_TXEXCESSIVECOLLISIONr,(r._txexcessivecollision),4)
#define BCM53101_A0_WRITE_TXEXCESSIVECOLLISIONr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_TXEXCESSIVECOLLISIONr,&(r._txexcessivecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXEXCESSIVECOLLISIONr BCM53101_A0_TXEXCESSIVECOLLISIONr
#define TXEXCESSIVECOLLISIONr_SIZE BCM53101_A0_TXEXCESSIVECOLLISIONr_SIZE
typedef BCM53101_A0_TXEXCESSIVECOLLISIONr_t TXEXCESSIVECOLLISIONr_t;
#define TXEXCESSIVECOLLISIONr_CLR BCM53101_A0_TXEXCESSIVECOLLISIONr_CLR
#define TXEXCESSIVECOLLISIONr_SET BCM53101_A0_TXEXCESSIVECOLLISIONr_SET
#define TXEXCESSIVECOLLISIONr_GET BCM53101_A0_TXEXCESSIVECOLLISIONr_GET
#define READ_TXEXCESSIVECOLLISIONr BCM53101_A0_READ_TXEXCESSIVECOLLISIONr
#define WRITE_TXEXCESSIVECOLLISIONr BCM53101_A0_WRITE_TXEXCESSIVECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TXEXCESSIVECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TxExcessiveCollision_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Excessive Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_TXEXCESSIVECOLLISION_IMPr 0x00002830

#define BCM53101_A0_TXEXCESSIVECOLLISION_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxExcessiveCollision_IMP.
 *
 */
typedef union BCM53101_A0_TXEXCESSIVECOLLISION_IMPr_s {
	uint32_t v[1];
	uint32_t txexcessivecollision_imp[1];
	uint32_t _txexcessivecollision_imp;
} BCM53101_A0_TXEXCESSIVECOLLISION_IMPr_t;

#define BCM53101_A0_TXEXCESSIVECOLLISION_IMPr_CLR(r) (r).txexcessivecollision_imp[0] = 0
#define BCM53101_A0_TXEXCESSIVECOLLISION_IMPr_SET(r,d) (r).txexcessivecollision_imp[0] = d
#define BCM53101_A0_TXEXCESSIVECOLLISION_IMPr_GET(r) (r).txexcessivecollision_imp[0]


/*
 * These macros can be used to access TxExcessiveCollision_IMP.
 *
 */
#define BCM53101_A0_READ_TXEXCESSIVECOLLISION_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_TXEXCESSIVECOLLISION_IMPr,(r._txexcessivecollision_imp),4)
#define BCM53101_A0_WRITE_TXEXCESSIVECOLLISION_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_TXEXCESSIVECOLLISION_IMPr,&(r._txexcessivecollision_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXEXCESSIVECOLLISION_IMPr BCM53101_A0_TXEXCESSIVECOLLISION_IMPr
#define TXEXCESSIVECOLLISION_IMPr_SIZE BCM53101_A0_TXEXCESSIVECOLLISION_IMPr_SIZE
typedef BCM53101_A0_TXEXCESSIVECOLLISION_IMPr_t TXEXCESSIVECOLLISION_IMPr_t;
#define TXEXCESSIVECOLLISION_IMPr_CLR BCM53101_A0_TXEXCESSIVECOLLISION_IMPr_CLR
#define TXEXCESSIVECOLLISION_IMPr_SET BCM53101_A0_TXEXCESSIVECOLLISION_IMPr_SET
#define TXEXCESSIVECOLLISION_IMPr_GET BCM53101_A0_TXEXCESSIVECOLLISION_IMPr_GET
#define READ_TXEXCESSIVECOLLISION_IMPr BCM53101_A0_READ_TXEXCESSIVECOLLISION_IMPr
#define WRITE_TXEXCESSIVECOLLISION_IMPr BCM53101_A0_WRITE_TXEXCESSIVECOLLISION_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TXEXCESSIVECOLLISION_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TxFrameInDisc
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Tx Fram IN Disc Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_TXFRAMEINDISCr 0x00002034

#define BCM53101_A0_TXFRAMEINDISCr_SIZE 4

/*
 * This structure should be used to declare and program TxFrameInDisc.
 *
 */
typedef union BCM53101_A0_TXFRAMEINDISCr_s {
	uint32_t v[1];
	uint32_t txframeindisc[1];
	uint32_t _txframeindisc;
} BCM53101_A0_TXFRAMEINDISCr_t;

#define BCM53101_A0_TXFRAMEINDISCr_CLR(r) (r).txframeindisc[0] = 0
#define BCM53101_A0_TXFRAMEINDISCr_SET(r,d) (r).txframeindisc[0] = d
#define BCM53101_A0_TXFRAMEINDISCr_GET(r) (r).txframeindisc[0]


/*
 * These macros can be used to access TxFrameInDisc.
 *
 */
#define BCM53101_A0_READ_TXFRAMEINDISCr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_TXFRAMEINDISCr,(r._txframeindisc),4)
#define BCM53101_A0_WRITE_TXFRAMEINDISCr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_TXFRAMEINDISCr,&(r._txframeindisc),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXFRAMEINDISCr BCM53101_A0_TXFRAMEINDISCr
#define TXFRAMEINDISCr_SIZE BCM53101_A0_TXFRAMEINDISCr_SIZE
typedef BCM53101_A0_TXFRAMEINDISCr_t TXFRAMEINDISCr_t;
#define TXFRAMEINDISCr_CLR BCM53101_A0_TXFRAMEINDISCr_CLR
#define TXFRAMEINDISCr_SET BCM53101_A0_TXFRAMEINDISCr_SET
#define TXFRAMEINDISCr_GET BCM53101_A0_TXFRAMEINDISCr_GET
#define READ_TXFRAMEINDISCr BCM53101_A0_READ_TXFRAMEINDISCr
#define WRITE_TXFRAMEINDISCr BCM53101_A0_WRITE_TXFRAMEINDISCr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TXFRAMEINDISCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TxFrameInDisc_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Fram IN Disc Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_TXFRAMEINDISC_IMPr 0x00002834

#define BCM53101_A0_TXFRAMEINDISC_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxFrameInDisc_IMP.
 *
 */
typedef union BCM53101_A0_TXFRAMEINDISC_IMPr_s {
	uint32_t v[1];
	uint32_t txframeindisc_imp[1];
	uint32_t _txframeindisc_imp;
} BCM53101_A0_TXFRAMEINDISC_IMPr_t;

#define BCM53101_A0_TXFRAMEINDISC_IMPr_CLR(r) (r).txframeindisc_imp[0] = 0
#define BCM53101_A0_TXFRAMEINDISC_IMPr_SET(r,d) (r).txframeindisc_imp[0] = d
#define BCM53101_A0_TXFRAMEINDISC_IMPr_GET(r) (r).txframeindisc_imp[0]


/*
 * These macros can be used to access TxFrameInDisc_IMP.
 *
 */
#define BCM53101_A0_READ_TXFRAMEINDISC_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_TXFRAMEINDISC_IMPr,(r._txframeindisc_imp),4)
#define BCM53101_A0_WRITE_TXFRAMEINDISC_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_TXFRAMEINDISC_IMPr,&(r._txframeindisc_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXFRAMEINDISC_IMPr BCM53101_A0_TXFRAMEINDISC_IMPr
#define TXFRAMEINDISC_IMPr_SIZE BCM53101_A0_TXFRAMEINDISC_IMPr_SIZE
typedef BCM53101_A0_TXFRAMEINDISC_IMPr_t TXFRAMEINDISC_IMPr_t;
#define TXFRAMEINDISC_IMPr_CLR BCM53101_A0_TXFRAMEINDISC_IMPr_CLR
#define TXFRAMEINDISC_IMPr_SET BCM53101_A0_TXFRAMEINDISC_IMPr_SET
#define TXFRAMEINDISC_IMPr_GET BCM53101_A0_TXFRAMEINDISC_IMPr_GET
#define READ_TXFRAMEINDISC_IMPr BCM53101_A0_READ_TXFRAMEINDISC_IMPr
#define WRITE_TXFRAMEINDISC_IMPr BCM53101_A0_WRITE_TXFRAMEINDISC_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TXFRAMEINDISC_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TxLateCollision
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Tx Late Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_TXLATECOLLISIONr 0x0000202c

#define BCM53101_A0_TXLATECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program TxLateCollision.
 *
 */
typedef union BCM53101_A0_TXLATECOLLISIONr_s {
	uint32_t v[1];
	uint32_t txlatecollision[1];
	uint32_t _txlatecollision;
} BCM53101_A0_TXLATECOLLISIONr_t;

#define BCM53101_A0_TXLATECOLLISIONr_CLR(r) (r).txlatecollision[0] = 0
#define BCM53101_A0_TXLATECOLLISIONr_SET(r,d) (r).txlatecollision[0] = d
#define BCM53101_A0_TXLATECOLLISIONr_GET(r) (r).txlatecollision[0]


/*
 * These macros can be used to access TxLateCollision.
 *
 */
#define BCM53101_A0_READ_TXLATECOLLISIONr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_TXLATECOLLISIONr,(r._txlatecollision),4)
#define BCM53101_A0_WRITE_TXLATECOLLISIONr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_TXLATECOLLISIONr,&(r._txlatecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXLATECOLLISIONr BCM53101_A0_TXLATECOLLISIONr
#define TXLATECOLLISIONr_SIZE BCM53101_A0_TXLATECOLLISIONr_SIZE
typedef BCM53101_A0_TXLATECOLLISIONr_t TXLATECOLLISIONr_t;
#define TXLATECOLLISIONr_CLR BCM53101_A0_TXLATECOLLISIONr_CLR
#define TXLATECOLLISIONr_SET BCM53101_A0_TXLATECOLLISIONr_SET
#define TXLATECOLLISIONr_GET BCM53101_A0_TXLATECOLLISIONr_GET
#define READ_TXLATECOLLISIONr BCM53101_A0_READ_TXLATECOLLISIONr
#define WRITE_TXLATECOLLISIONr BCM53101_A0_WRITE_TXLATECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TXLATECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TxLateCollision_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Late Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_TXLATECOLLISION_IMPr 0x0000282c

#define BCM53101_A0_TXLATECOLLISION_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxLateCollision_IMP.
 *
 */
typedef union BCM53101_A0_TXLATECOLLISION_IMPr_s {
	uint32_t v[1];
	uint32_t txlatecollision_imp[1];
	uint32_t _txlatecollision_imp;
} BCM53101_A0_TXLATECOLLISION_IMPr_t;

#define BCM53101_A0_TXLATECOLLISION_IMPr_CLR(r) (r).txlatecollision_imp[0] = 0
#define BCM53101_A0_TXLATECOLLISION_IMPr_SET(r,d) (r).txlatecollision_imp[0] = d
#define BCM53101_A0_TXLATECOLLISION_IMPr_GET(r) (r).txlatecollision_imp[0]


/*
 * These macros can be used to access TxLateCollision_IMP.
 *
 */
#define BCM53101_A0_READ_TXLATECOLLISION_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_TXLATECOLLISION_IMPr,(r._txlatecollision_imp),4)
#define BCM53101_A0_WRITE_TXLATECOLLISION_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_TXLATECOLLISION_IMPr,&(r._txlatecollision_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXLATECOLLISION_IMPr BCM53101_A0_TXLATECOLLISION_IMPr
#define TXLATECOLLISION_IMPr_SIZE BCM53101_A0_TXLATECOLLISION_IMPr_SIZE
typedef BCM53101_A0_TXLATECOLLISION_IMPr_t TXLATECOLLISION_IMPr_t;
#define TXLATECOLLISION_IMPr_CLR BCM53101_A0_TXLATECOLLISION_IMPr_CLR
#define TXLATECOLLISION_IMPr_SET BCM53101_A0_TXLATECOLLISION_IMPr_SET
#define TXLATECOLLISION_IMPr_GET BCM53101_A0_TXLATECOLLISION_IMPr_GET
#define READ_TXLATECOLLISION_IMPr BCM53101_A0_READ_TXLATECOLLISION_IMPr
#define WRITE_TXLATECOLLISION_IMPr BCM53101_A0_WRITE_TXLATECOLLISION_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TXLATECOLLISION_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TxMulticastPkts
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Tx Multicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_TXMULTICASTPKTSr 0x00002014

#define BCM53101_A0_TXMULTICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program TxMulticastPkts.
 *
 */
typedef union BCM53101_A0_TXMULTICASTPKTSr_s {
	uint32_t v[1];
	uint32_t txmulticastpkts[1];
	uint32_t _txmulticastpkts;
} BCM53101_A0_TXMULTICASTPKTSr_t;

#define BCM53101_A0_TXMULTICASTPKTSr_CLR(r) (r).txmulticastpkts[0] = 0
#define BCM53101_A0_TXMULTICASTPKTSr_SET(r,d) (r).txmulticastpkts[0] = d
#define BCM53101_A0_TXMULTICASTPKTSr_GET(r) (r).txmulticastpkts[0]


/*
 * These macros can be used to access TxMulticastPkts.
 *
 */
#define BCM53101_A0_READ_TXMULTICASTPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_TXMULTICASTPKTSr,(r._txmulticastpkts),4)
#define BCM53101_A0_WRITE_TXMULTICASTPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_TXMULTICASTPKTSr,&(r._txmulticastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXMULTICASTPKTSr BCM53101_A0_TXMULTICASTPKTSr
#define TXMULTICASTPKTSr_SIZE BCM53101_A0_TXMULTICASTPKTSr_SIZE
typedef BCM53101_A0_TXMULTICASTPKTSr_t TXMULTICASTPKTSr_t;
#define TXMULTICASTPKTSr_CLR BCM53101_A0_TXMULTICASTPKTSr_CLR
#define TXMULTICASTPKTSr_SET BCM53101_A0_TXMULTICASTPKTSr_SET
#define TXMULTICASTPKTSr_GET BCM53101_A0_TXMULTICASTPKTSr_GET
#define READ_TXMULTICASTPKTSr BCM53101_A0_READ_TXMULTICASTPKTSr
#define WRITE_TXMULTICASTPKTSr BCM53101_A0_WRITE_TXMULTICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TXMULTICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TxMulticastPkts_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Multicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_TXMULTICASTPKTS_IMPr 0x00002814

#define BCM53101_A0_TXMULTICASTPKTS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxMulticastPkts_IMP.
 *
 */
typedef union BCM53101_A0_TXMULTICASTPKTS_IMPr_s {
	uint32_t v[1];
	uint32_t txmulticastpkts_imp[1];
	uint32_t _txmulticastpkts_imp;
} BCM53101_A0_TXMULTICASTPKTS_IMPr_t;

#define BCM53101_A0_TXMULTICASTPKTS_IMPr_CLR(r) (r).txmulticastpkts_imp[0] = 0
#define BCM53101_A0_TXMULTICASTPKTS_IMPr_SET(r,d) (r).txmulticastpkts_imp[0] = d
#define BCM53101_A0_TXMULTICASTPKTS_IMPr_GET(r) (r).txmulticastpkts_imp[0]


/*
 * These macros can be used to access TxMulticastPkts_IMP.
 *
 */
#define BCM53101_A0_READ_TXMULTICASTPKTS_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_TXMULTICASTPKTS_IMPr,(r._txmulticastpkts_imp),4)
#define BCM53101_A0_WRITE_TXMULTICASTPKTS_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_TXMULTICASTPKTS_IMPr,&(r._txmulticastpkts_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXMULTICASTPKTS_IMPr BCM53101_A0_TXMULTICASTPKTS_IMPr
#define TXMULTICASTPKTS_IMPr_SIZE BCM53101_A0_TXMULTICASTPKTS_IMPr_SIZE
typedef BCM53101_A0_TXMULTICASTPKTS_IMPr_t TXMULTICASTPKTS_IMPr_t;
#define TXMULTICASTPKTS_IMPr_CLR BCM53101_A0_TXMULTICASTPKTS_IMPr_CLR
#define TXMULTICASTPKTS_IMPr_SET BCM53101_A0_TXMULTICASTPKTS_IMPr_SET
#define TXMULTICASTPKTS_IMPr_GET BCM53101_A0_TXMULTICASTPKTS_IMPr_GET
#define READ_TXMULTICASTPKTS_IMPr BCM53101_A0_READ_TXMULTICASTPKTS_IMPr
#define WRITE_TXMULTICASTPKTS_IMPr BCM53101_A0_WRITE_TXMULTICASTPKTS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TXMULTICASTPKTS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TxMultipleCollision
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Tx Multiple collsion Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_TXMULTIPLECOLLISIONr 0x00002024

#define BCM53101_A0_TXMULTIPLECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program TxMultipleCollision.
 *
 */
typedef union BCM53101_A0_TXMULTIPLECOLLISIONr_s {
	uint32_t v[1];
	uint32_t txmultiplecollision[1];
	uint32_t _txmultiplecollision;
} BCM53101_A0_TXMULTIPLECOLLISIONr_t;

#define BCM53101_A0_TXMULTIPLECOLLISIONr_CLR(r) (r).txmultiplecollision[0] = 0
#define BCM53101_A0_TXMULTIPLECOLLISIONr_SET(r,d) (r).txmultiplecollision[0] = d
#define BCM53101_A0_TXMULTIPLECOLLISIONr_GET(r) (r).txmultiplecollision[0]


/*
 * These macros can be used to access TxMultipleCollision.
 *
 */
#define BCM53101_A0_READ_TXMULTIPLECOLLISIONr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_TXMULTIPLECOLLISIONr,(r._txmultiplecollision),4)
#define BCM53101_A0_WRITE_TXMULTIPLECOLLISIONr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_TXMULTIPLECOLLISIONr,&(r._txmultiplecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXMULTIPLECOLLISIONr BCM53101_A0_TXMULTIPLECOLLISIONr
#define TXMULTIPLECOLLISIONr_SIZE BCM53101_A0_TXMULTIPLECOLLISIONr_SIZE
typedef BCM53101_A0_TXMULTIPLECOLLISIONr_t TXMULTIPLECOLLISIONr_t;
#define TXMULTIPLECOLLISIONr_CLR BCM53101_A0_TXMULTIPLECOLLISIONr_CLR
#define TXMULTIPLECOLLISIONr_SET BCM53101_A0_TXMULTIPLECOLLISIONr_SET
#define TXMULTIPLECOLLISIONr_GET BCM53101_A0_TXMULTIPLECOLLISIONr_GET
#define READ_TXMULTIPLECOLLISIONr BCM53101_A0_READ_TXMULTIPLECOLLISIONr
#define WRITE_TXMULTIPLECOLLISIONr BCM53101_A0_WRITE_TXMULTIPLECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TXMULTIPLECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TxMultipleCollision_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Multiple collsion Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_TXMULTIPLECOLLISION_IMPr 0x00002824

#define BCM53101_A0_TXMULTIPLECOLLISION_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxMultipleCollision_IMP.
 *
 */
typedef union BCM53101_A0_TXMULTIPLECOLLISION_IMPr_s {
	uint32_t v[1];
	uint32_t txmultiplecollision_imp[1];
	uint32_t _txmultiplecollision_imp;
} BCM53101_A0_TXMULTIPLECOLLISION_IMPr_t;

#define BCM53101_A0_TXMULTIPLECOLLISION_IMPr_CLR(r) (r).txmultiplecollision_imp[0] = 0
#define BCM53101_A0_TXMULTIPLECOLLISION_IMPr_SET(r,d) (r).txmultiplecollision_imp[0] = d
#define BCM53101_A0_TXMULTIPLECOLLISION_IMPr_GET(r) (r).txmultiplecollision_imp[0]


/*
 * These macros can be used to access TxMultipleCollision_IMP.
 *
 */
#define BCM53101_A0_READ_TXMULTIPLECOLLISION_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_TXMULTIPLECOLLISION_IMPr,(r._txmultiplecollision_imp),4)
#define BCM53101_A0_WRITE_TXMULTIPLECOLLISION_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_TXMULTIPLECOLLISION_IMPr,&(r._txmultiplecollision_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXMULTIPLECOLLISION_IMPr BCM53101_A0_TXMULTIPLECOLLISION_IMPr
#define TXMULTIPLECOLLISION_IMPr_SIZE BCM53101_A0_TXMULTIPLECOLLISION_IMPr_SIZE
typedef BCM53101_A0_TXMULTIPLECOLLISION_IMPr_t TXMULTIPLECOLLISION_IMPr_t;
#define TXMULTIPLECOLLISION_IMPr_CLR BCM53101_A0_TXMULTIPLECOLLISION_IMPr_CLR
#define TXMULTIPLECOLLISION_IMPr_SET BCM53101_A0_TXMULTIPLECOLLISION_IMPr_SET
#define TXMULTIPLECOLLISION_IMPr_GET BCM53101_A0_TXMULTIPLECOLLISION_IMPr_GET
#define READ_TXMULTIPLECOLLISION_IMPr BCM53101_A0_READ_TXMULTIPLECOLLISION_IMPr
#define WRITE_TXMULTIPLECOLLISION_IMPr BCM53101_A0_WRITE_TXMULTIPLECOLLISION_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TXMULTIPLECOLLISION_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TxOctets
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Tx Octets
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM53101_A0_TXOCTETSr 0x00002000

#define BCM53101_A0_TXOCTETSr_SIZE 8

/*
 * This structure should be used to declare and program TxOctets.
 *
 */
typedef union BCM53101_A0_TXOCTETSr_s {
	uint32_t v[2];
	uint32_t txoctets[2];
	uint32_t _txoctets;
} BCM53101_A0_TXOCTETSr_t;

#define BCM53101_A0_TXOCTETSr_CLR(r) CDK_MEMSET(&((r)._txoctets), 0, sizeof(BCM53101_A0_TXOCTETSr_t))
#define BCM53101_A0_TXOCTETSr_SET(r,i,d) (r).txoctets[i] = d
#define BCM53101_A0_TXOCTETSr_GET(r,i) (r).txoctets[i]


/*
 * These macros can be used to access TxOctets.
 *
 */
#define BCM53101_A0_READ_TXOCTETSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_TXOCTETSr,(r._txoctets),8)
#define BCM53101_A0_WRITE_TXOCTETSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_TXOCTETSr,&(r._txoctets),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXOCTETSr BCM53101_A0_TXOCTETSr
#define TXOCTETSr_SIZE BCM53101_A0_TXOCTETSr_SIZE
typedef BCM53101_A0_TXOCTETSr_t TXOCTETSr_t;
#define TXOCTETSr_CLR BCM53101_A0_TXOCTETSr_CLR
#define TXOCTETSr_SET BCM53101_A0_TXOCTETSr_SET
#define TXOCTETSr_GET BCM53101_A0_TXOCTETSr_GET
#define READ_TXOCTETSr BCM53101_A0_READ_TXOCTETSr
#define WRITE_TXOCTETSr BCM53101_A0_WRITE_TXOCTETSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TXOCTETSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TxOctets_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Octets
 * SIZE:     64
 *
 ******************************************************************************/
#define BCM53101_A0_TXOCTETS_IMPr 0x00002800

#define BCM53101_A0_TXOCTETS_IMPr_SIZE 8

/*
 * This structure should be used to declare and program TxOctets_IMP.
 *
 */
typedef union BCM53101_A0_TXOCTETS_IMPr_s {
	uint32_t v[2];
	uint32_t txoctets_imp[2];
	uint32_t _txoctets_imp;
} BCM53101_A0_TXOCTETS_IMPr_t;

#define BCM53101_A0_TXOCTETS_IMPr_CLR(r) CDK_MEMSET(&((r)._txoctets_imp), 0, sizeof(BCM53101_A0_TXOCTETS_IMPr_t))
#define BCM53101_A0_TXOCTETS_IMPr_SET(r,i,d) (r).txoctets_imp[i] = d
#define BCM53101_A0_TXOCTETS_IMPr_GET(r,i) (r).txoctets_imp[i]


/*
 * These macros can be used to access TxOctets_IMP.
 *
 */
#define BCM53101_A0_READ_TXOCTETS_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_TXOCTETS_IMPr,(r._txoctets_imp),8)
#define BCM53101_A0_WRITE_TXOCTETS_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_TXOCTETS_IMPr,&(r._txoctets_imp),8)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXOCTETS_IMPr BCM53101_A0_TXOCTETS_IMPr
#define TXOCTETS_IMPr_SIZE BCM53101_A0_TXOCTETS_IMPr_SIZE
typedef BCM53101_A0_TXOCTETS_IMPr_t TXOCTETS_IMPr_t;
#define TXOCTETS_IMPr_CLR BCM53101_A0_TXOCTETS_IMPr_CLR
#define TXOCTETS_IMPr_SET BCM53101_A0_TXOCTETS_IMPr_SET
#define TXOCTETS_IMPr_GET BCM53101_A0_TXOCTETS_IMPr_GET
#define READ_TXOCTETS_IMPr BCM53101_A0_READ_TXOCTETS_IMPr
#define WRITE_TXOCTETS_IMPr BCM53101_A0_WRITE_TXOCTETS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TXOCTETS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TxPausePkts
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Tx Pause Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_TXPAUSEPKTSr 0x00002038

#define BCM53101_A0_TXPAUSEPKTSr_SIZE 4

/*
 * This structure should be used to declare and program TxPausePkts.
 *
 */
typedef union BCM53101_A0_TXPAUSEPKTSr_s {
	uint32_t v[1];
	uint32_t txpausepkts[1];
	uint32_t _txpausepkts;
} BCM53101_A0_TXPAUSEPKTSr_t;

#define BCM53101_A0_TXPAUSEPKTSr_CLR(r) (r).txpausepkts[0] = 0
#define BCM53101_A0_TXPAUSEPKTSr_SET(r,d) (r).txpausepkts[0] = d
#define BCM53101_A0_TXPAUSEPKTSr_GET(r) (r).txpausepkts[0]


/*
 * These macros can be used to access TxPausePkts.
 *
 */
#define BCM53101_A0_READ_TXPAUSEPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_TXPAUSEPKTSr,(r._txpausepkts),4)
#define BCM53101_A0_WRITE_TXPAUSEPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_TXPAUSEPKTSr,&(r._txpausepkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXPAUSEPKTSr BCM53101_A0_TXPAUSEPKTSr
#define TXPAUSEPKTSr_SIZE BCM53101_A0_TXPAUSEPKTSr_SIZE
typedef BCM53101_A0_TXPAUSEPKTSr_t TXPAUSEPKTSr_t;
#define TXPAUSEPKTSr_CLR BCM53101_A0_TXPAUSEPKTSr_CLR
#define TXPAUSEPKTSr_SET BCM53101_A0_TXPAUSEPKTSr_SET
#define TXPAUSEPKTSr_GET BCM53101_A0_TXPAUSEPKTSr_GET
#define READ_TXPAUSEPKTSr BCM53101_A0_READ_TXPAUSEPKTSr
#define WRITE_TXPAUSEPKTSr BCM53101_A0_WRITE_TXPAUSEPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TXPAUSEPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TxPausePkts_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Pause Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_TXPAUSEPKTS_IMPr 0x00002838

#define BCM53101_A0_TXPAUSEPKTS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxPausePkts_IMP.
 *
 */
typedef union BCM53101_A0_TXPAUSEPKTS_IMPr_s {
	uint32_t v[1];
	uint32_t txpausepkts_imp[1];
	uint32_t _txpausepkts_imp;
} BCM53101_A0_TXPAUSEPKTS_IMPr_t;

#define BCM53101_A0_TXPAUSEPKTS_IMPr_CLR(r) (r).txpausepkts_imp[0] = 0
#define BCM53101_A0_TXPAUSEPKTS_IMPr_SET(r,d) (r).txpausepkts_imp[0] = d
#define BCM53101_A0_TXPAUSEPKTS_IMPr_GET(r) (r).txpausepkts_imp[0]


/*
 * These macros can be used to access TxPausePkts_IMP.
 *
 */
#define BCM53101_A0_READ_TXPAUSEPKTS_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_TXPAUSEPKTS_IMPr,(r._txpausepkts_imp),4)
#define BCM53101_A0_WRITE_TXPAUSEPKTS_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_TXPAUSEPKTS_IMPr,&(r._txpausepkts_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXPAUSEPKTS_IMPr BCM53101_A0_TXPAUSEPKTS_IMPr
#define TXPAUSEPKTS_IMPr_SIZE BCM53101_A0_TXPAUSEPKTS_IMPr_SIZE
typedef BCM53101_A0_TXPAUSEPKTS_IMPr_t TXPAUSEPKTS_IMPr_t;
#define TXPAUSEPKTS_IMPr_CLR BCM53101_A0_TXPAUSEPKTS_IMPr_CLR
#define TXPAUSEPKTS_IMPr_SET BCM53101_A0_TXPAUSEPKTS_IMPr_SET
#define TXPAUSEPKTS_IMPr_GET BCM53101_A0_TXPAUSEPKTS_IMPr_GET
#define READ_TXPAUSEPKTS_IMPr BCM53101_A0_READ_TXPAUSEPKTS_IMPr
#define WRITE_TXPAUSEPKTS_IMPr BCM53101_A0_WRITE_TXPAUSEPKTS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TXPAUSEPKTS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TxQPKTQ0
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Tx Q0 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_TXQPKTQ0r 0x0000200c

#define BCM53101_A0_TXQPKTQ0r_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ0.
 *
 */
typedef union BCM53101_A0_TXQPKTQ0r_s {
	uint32_t v[1];
	uint32_t txqpktq0[1];
	uint32_t _txqpktq0;
} BCM53101_A0_TXQPKTQ0r_t;

#define BCM53101_A0_TXQPKTQ0r_CLR(r) (r).txqpktq0[0] = 0
#define BCM53101_A0_TXQPKTQ0r_SET(r,d) (r).txqpktq0[0] = d
#define BCM53101_A0_TXQPKTQ0r_GET(r) (r).txqpktq0[0]


/*
 * These macros can be used to access TxQPKTQ0.
 *
 */
#define BCM53101_A0_READ_TXQPKTQ0r(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_TXQPKTQ0r,(r._txqpktq0),4)
#define BCM53101_A0_WRITE_TXQPKTQ0r(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_TXQPKTQ0r,&(r._txqpktq0),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ0r BCM53101_A0_TXQPKTQ0r
#define TXQPKTQ0r_SIZE BCM53101_A0_TXQPKTQ0r_SIZE
typedef BCM53101_A0_TXQPKTQ0r_t TXQPKTQ0r_t;
#define TXQPKTQ0r_CLR BCM53101_A0_TXQPKTQ0r_CLR
#define TXQPKTQ0r_SET BCM53101_A0_TXQPKTQ0r_SET
#define TXQPKTQ0r_GET BCM53101_A0_TXQPKTQ0r_GET
#define READ_TXQPKTQ0r BCM53101_A0_READ_TXQPKTQ0r
#define WRITE_TXQPKTQ0r BCM53101_A0_WRITE_TXQPKTQ0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TXQPKTQ0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TxQPKTQ0_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Q0 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_TXQPKTQ0_IMPr 0x0000280c

#define BCM53101_A0_TXQPKTQ0_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ0_IMP.
 *
 */
typedef union BCM53101_A0_TXQPKTQ0_IMPr_s {
	uint32_t v[1];
	uint32_t txqpktq0_imp[1];
	uint32_t _txqpktq0_imp;
} BCM53101_A0_TXQPKTQ0_IMPr_t;

#define BCM53101_A0_TXQPKTQ0_IMPr_CLR(r) (r).txqpktq0_imp[0] = 0
#define BCM53101_A0_TXQPKTQ0_IMPr_SET(r,d) (r).txqpktq0_imp[0] = d
#define BCM53101_A0_TXQPKTQ0_IMPr_GET(r) (r).txqpktq0_imp[0]


/*
 * These macros can be used to access TxQPKTQ0_IMP.
 *
 */
#define BCM53101_A0_READ_TXQPKTQ0_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_TXQPKTQ0_IMPr,(r._txqpktq0_imp),4)
#define BCM53101_A0_WRITE_TXQPKTQ0_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_TXQPKTQ0_IMPr,&(r._txqpktq0_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ0_IMPr BCM53101_A0_TXQPKTQ0_IMPr
#define TXQPKTQ0_IMPr_SIZE BCM53101_A0_TXQPKTQ0_IMPr_SIZE
typedef BCM53101_A0_TXQPKTQ0_IMPr_t TXQPKTQ0_IMPr_t;
#define TXQPKTQ0_IMPr_CLR BCM53101_A0_TXQPKTQ0_IMPr_CLR
#define TXQPKTQ0_IMPr_SET BCM53101_A0_TXQPKTQ0_IMPr_SET
#define TXQPKTQ0_IMPr_GET BCM53101_A0_TXQPKTQ0_IMPr_GET
#define READ_TXQPKTQ0_IMPr BCM53101_A0_READ_TXQPKTQ0_IMPr
#define WRITE_TXQPKTQ0_IMPr BCM53101_A0_WRITE_TXQPKTQ0_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TXQPKTQ0_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TxQPKTQ1
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Tx Q1 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_TXQPKTQ1r 0x0000203c

#define BCM53101_A0_TXQPKTQ1r_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ1.
 *
 */
typedef union BCM53101_A0_TXQPKTQ1r_s {
	uint32_t v[1];
	uint32_t txqpktq1[1];
	uint32_t _txqpktq1;
} BCM53101_A0_TXQPKTQ1r_t;

#define BCM53101_A0_TXQPKTQ1r_CLR(r) (r).txqpktq1[0] = 0
#define BCM53101_A0_TXQPKTQ1r_SET(r,d) (r).txqpktq1[0] = d
#define BCM53101_A0_TXQPKTQ1r_GET(r) (r).txqpktq1[0]


/*
 * These macros can be used to access TxQPKTQ1.
 *
 */
#define BCM53101_A0_READ_TXQPKTQ1r(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_TXQPKTQ1r,(r._txqpktq1),4)
#define BCM53101_A0_WRITE_TXQPKTQ1r(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_TXQPKTQ1r,&(r._txqpktq1),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ1r BCM53101_A0_TXQPKTQ1r
#define TXQPKTQ1r_SIZE BCM53101_A0_TXQPKTQ1r_SIZE
typedef BCM53101_A0_TXQPKTQ1r_t TXQPKTQ1r_t;
#define TXQPKTQ1r_CLR BCM53101_A0_TXQPKTQ1r_CLR
#define TXQPKTQ1r_SET BCM53101_A0_TXQPKTQ1r_SET
#define TXQPKTQ1r_GET BCM53101_A0_TXQPKTQ1r_GET
#define READ_TXQPKTQ1r BCM53101_A0_READ_TXQPKTQ1r
#define WRITE_TXQPKTQ1r BCM53101_A0_WRITE_TXQPKTQ1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TXQPKTQ1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TxQPKTQ1_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Q1 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_TXQPKTQ1_IMPr 0x0000283c

#define BCM53101_A0_TXQPKTQ1_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ1_IMP.
 *
 */
typedef union BCM53101_A0_TXQPKTQ1_IMPr_s {
	uint32_t v[1];
	uint32_t txqpktq1_imp[1];
	uint32_t _txqpktq1_imp;
} BCM53101_A0_TXQPKTQ1_IMPr_t;

#define BCM53101_A0_TXQPKTQ1_IMPr_CLR(r) (r).txqpktq1_imp[0] = 0
#define BCM53101_A0_TXQPKTQ1_IMPr_SET(r,d) (r).txqpktq1_imp[0] = d
#define BCM53101_A0_TXQPKTQ1_IMPr_GET(r) (r).txqpktq1_imp[0]


/*
 * These macros can be used to access TxQPKTQ1_IMP.
 *
 */
#define BCM53101_A0_READ_TXQPKTQ1_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_TXQPKTQ1_IMPr,(r._txqpktq1_imp),4)
#define BCM53101_A0_WRITE_TXQPKTQ1_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_TXQPKTQ1_IMPr,&(r._txqpktq1_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ1_IMPr BCM53101_A0_TXQPKTQ1_IMPr
#define TXQPKTQ1_IMPr_SIZE BCM53101_A0_TXQPKTQ1_IMPr_SIZE
typedef BCM53101_A0_TXQPKTQ1_IMPr_t TXQPKTQ1_IMPr_t;
#define TXQPKTQ1_IMPr_CLR BCM53101_A0_TXQPKTQ1_IMPr_CLR
#define TXQPKTQ1_IMPr_SET BCM53101_A0_TXQPKTQ1_IMPr_SET
#define TXQPKTQ1_IMPr_GET BCM53101_A0_TXQPKTQ1_IMPr_GET
#define READ_TXQPKTQ1_IMPr BCM53101_A0_READ_TXQPKTQ1_IMPr
#define WRITE_TXQPKTQ1_IMPr BCM53101_A0_WRITE_TXQPKTQ1_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TXQPKTQ1_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TxQPKTQ2
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Tx Q2 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_TXQPKTQ2r 0x00002040

#define BCM53101_A0_TXQPKTQ2r_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ2.
 *
 */
typedef union BCM53101_A0_TXQPKTQ2r_s {
	uint32_t v[1];
	uint32_t txqpktq2[1];
	uint32_t _txqpktq2;
} BCM53101_A0_TXQPKTQ2r_t;

#define BCM53101_A0_TXQPKTQ2r_CLR(r) (r).txqpktq2[0] = 0
#define BCM53101_A0_TXQPKTQ2r_SET(r,d) (r).txqpktq2[0] = d
#define BCM53101_A0_TXQPKTQ2r_GET(r) (r).txqpktq2[0]


/*
 * These macros can be used to access TxQPKTQ2.
 *
 */
#define BCM53101_A0_READ_TXQPKTQ2r(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_TXQPKTQ2r,(r._txqpktq2),4)
#define BCM53101_A0_WRITE_TXQPKTQ2r(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_TXQPKTQ2r,&(r._txqpktq2),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ2r BCM53101_A0_TXQPKTQ2r
#define TXQPKTQ2r_SIZE BCM53101_A0_TXQPKTQ2r_SIZE
typedef BCM53101_A0_TXQPKTQ2r_t TXQPKTQ2r_t;
#define TXQPKTQ2r_CLR BCM53101_A0_TXQPKTQ2r_CLR
#define TXQPKTQ2r_SET BCM53101_A0_TXQPKTQ2r_SET
#define TXQPKTQ2r_GET BCM53101_A0_TXQPKTQ2r_GET
#define READ_TXQPKTQ2r BCM53101_A0_READ_TXQPKTQ2r
#define WRITE_TXQPKTQ2r BCM53101_A0_WRITE_TXQPKTQ2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TXQPKTQ2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TxQPKTQ2_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Q2 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_TXQPKTQ2_IMPr 0x00002840

#define BCM53101_A0_TXQPKTQ2_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ2_IMP.
 *
 */
typedef union BCM53101_A0_TXQPKTQ2_IMPr_s {
	uint32_t v[1];
	uint32_t txqpktq2_imp[1];
	uint32_t _txqpktq2_imp;
} BCM53101_A0_TXQPKTQ2_IMPr_t;

#define BCM53101_A0_TXQPKTQ2_IMPr_CLR(r) (r).txqpktq2_imp[0] = 0
#define BCM53101_A0_TXQPKTQ2_IMPr_SET(r,d) (r).txqpktq2_imp[0] = d
#define BCM53101_A0_TXQPKTQ2_IMPr_GET(r) (r).txqpktq2_imp[0]


/*
 * These macros can be used to access TxQPKTQ2_IMP.
 *
 */
#define BCM53101_A0_READ_TXQPKTQ2_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_TXQPKTQ2_IMPr,(r._txqpktq2_imp),4)
#define BCM53101_A0_WRITE_TXQPKTQ2_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_TXQPKTQ2_IMPr,&(r._txqpktq2_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ2_IMPr BCM53101_A0_TXQPKTQ2_IMPr
#define TXQPKTQ2_IMPr_SIZE BCM53101_A0_TXQPKTQ2_IMPr_SIZE
typedef BCM53101_A0_TXQPKTQ2_IMPr_t TXQPKTQ2_IMPr_t;
#define TXQPKTQ2_IMPr_CLR BCM53101_A0_TXQPKTQ2_IMPr_CLR
#define TXQPKTQ2_IMPr_SET BCM53101_A0_TXQPKTQ2_IMPr_SET
#define TXQPKTQ2_IMPr_GET BCM53101_A0_TXQPKTQ2_IMPr_GET
#define READ_TXQPKTQ2_IMPr BCM53101_A0_READ_TXQPKTQ2_IMPr
#define WRITE_TXQPKTQ2_IMPr BCM53101_A0_WRITE_TXQPKTQ2_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TXQPKTQ2_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TxQPKTQ3
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Tx Q3 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_TXQPKTQ3r 0x00002044

#define BCM53101_A0_TXQPKTQ3r_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ3.
 *
 */
typedef union BCM53101_A0_TXQPKTQ3r_s {
	uint32_t v[1];
	uint32_t txqpktq3[1];
	uint32_t _txqpktq3;
} BCM53101_A0_TXQPKTQ3r_t;

#define BCM53101_A0_TXQPKTQ3r_CLR(r) (r).txqpktq3[0] = 0
#define BCM53101_A0_TXQPKTQ3r_SET(r,d) (r).txqpktq3[0] = d
#define BCM53101_A0_TXQPKTQ3r_GET(r) (r).txqpktq3[0]


/*
 * These macros can be used to access TxQPKTQ3.
 *
 */
#define BCM53101_A0_READ_TXQPKTQ3r(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_TXQPKTQ3r,(r._txqpktq3),4)
#define BCM53101_A0_WRITE_TXQPKTQ3r(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_TXQPKTQ3r,&(r._txqpktq3),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ3r BCM53101_A0_TXQPKTQ3r
#define TXQPKTQ3r_SIZE BCM53101_A0_TXQPKTQ3r_SIZE
typedef BCM53101_A0_TXQPKTQ3r_t TXQPKTQ3r_t;
#define TXQPKTQ3r_CLR BCM53101_A0_TXQPKTQ3r_CLR
#define TXQPKTQ3r_SET BCM53101_A0_TXQPKTQ3r_SET
#define TXQPKTQ3r_GET BCM53101_A0_TXQPKTQ3r_GET
#define READ_TXQPKTQ3r BCM53101_A0_READ_TXQPKTQ3r
#define WRITE_TXQPKTQ3r BCM53101_A0_WRITE_TXQPKTQ3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TXQPKTQ3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TxQPKTQ3_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Q3 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_TXQPKTQ3_IMPr 0x00002844

#define BCM53101_A0_TXQPKTQ3_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ3_IMP.
 *
 */
typedef union BCM53101_A0_TXQPKTQ3_IMPr_s {
	uint32_t v[1];
	uint32_t txqpktq3_imp[1];
	uint32_t _txqpktq3_imp;
} BCM53101_A0_TXQPKTQ3_IMPr_t;

#define BCM53101_A0_TXQPKTQ3_IMPr_CLR(r) (r).txqpktq3_imp[0] = 0
#define BCM53101_A0_TXQPKTQ3_IMPr_SET(r,d) (r).txqpktq3_imp[0] = d
#define BCM53101_A0_TXQPKTQ3_IMPr_GET(r) (r).txqpktq3_imp[0]


/*
 * These macros can be used to access TxQPKTQ3_IMP.
 *
 */
#define BCM53101_A0_READ_TXQPKTQ3_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_TXQPKTQ3_IMPr,(r._txqpktq3_imp),4)
#define BCM53101_A0_WRITE_TXQPKTQ3_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_TXQPKTQ3_IMPr,&(r._txqpktq3_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ3_IMPr BCM53101_A0_TXQPKTQ3_IMPr
#define TXQPKTQ3_IMPr_SIZE BCM53101_A0_TXQPKTQ3_IMPr_SIZE
typedef BCM53101_A0_TXQPKTQ3_IMPr_t TXQPKTQ3_IMPr_t;
#define TXQPKTQ3_IMPr_CLR BCM53101_A0_TXQPKTQ3_IMPr_CLR
#define TXQPKTQ3_IMPr_SET BCM53101_A0_TXQPKTQ3_IMPr_SET
#define TXQPKTQ3_IMPr_GET BCM53101_A0_TXQPKTQ3_IMPr_GET
#define READ_TXQPKTQ3_IMPr BCM53101_A0_READ_TXQPKTQ3_IMPr
#define WRITE_TXQPKTQ3_IMPr BCM53101_A0_WRITE_TXQPKTQ3_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TXQPKTQ3_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TxQPKTQ4
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Tx Q4 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_TXQPKTQ4r 0x00002048

#define BCM53101_A0_TXQPKTQ4r_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ4.
 *
 */
typedef union BCM53101_A0_TXQPKTQ4r_s {
	uint32_t v[1];
	uint32_t txqpktq4[1];
	uint32_t _txqpktq4;
} BCM53101_A0_TXQPKTQ4r_t;

#define BCM53101_A0_TXQPKTQ4r_CLR(r) (r).txqpktq4[0] = 0
#define BCM53101_A0_TXQPKTQ4r_SET(r,d) (r).txqpktq4[0] = d
#define BCM53101_A0_TXQPKTQ4r_GET(r) (r).txqpktq4[0]


/*
 * These macros can be used to access TxQPKTQ4.
 *
 */
#define BCM53101_A0_READ_TXQPKTQ4r(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_TXQPKTQ4r,(r._txqpktq4),4)
#define BCM53101_A0_WRITE_TXQPKTQ4r(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_TXQPKTQ4r,&(r._txqpktq4),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ4r BCM53101_A0_TXQPKTQ4r
#define TXQPKTQ4r_SIZE BCM53101_A0_TXQPKTQ4r_SIZE
typedef BCM53101_A0_TXQPKTQ4r_t TXQPKTQ4r_t;
#define TXQPKTQ4r_CLR BCM53101_A0_TXQPKTQ4r_CLR
#define TXQPKTQ4r_SET BCM53101_A0_TXQPKTQ4r_SET
#define TXQPKTQ4r_GET BCM53101_A0_TXQPKTQ4r_GET
#define READ_TXQPKTQ4r BCM53101_A0_READ_TXQPKTQ4r
#define WRITE_TXQPKTQ4r BCM53101_A0_WRITE_TXQPKTQ4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TXQPKTQ4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TxQPKTQ4_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Q4 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_TXQPKTQ4_IMPr 0x00002848

#define BCM53101_A0_TXQPKTQ4_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ4_IMP.
 *
 */
typedef union BCM53101_A0_TXQPKTQ4_IMPr_s {
	uint32_t v[1];
	uint32_t txqpktq4_imp[1];
	uint32_t _txqpktq4_imp;
} BCM53101_A0_TXQPKTQ4_IMPr_t;

#define BCM53101_A0_TXQPKTQ4_IMPr_CLR(r) (r).txqpktq4_imp[0] = 0
#define BCM53101_A0_TXQPKTQ4_IMPr_SET(r,d) (r).txqpktq4_imp[0] = d
#define BCM53101_A0_TXQPKTQ4_IMPr_GET(r) (r).txqpktq4_imp[0]


/*
 * These macros can be used to access TxQPKTQ4_IMP.
 *
 */
#define BCM53101_A0_READ_TXQPKTQ4_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_TXQPKTQ4_IMPr,(r._txqpktq4_imp),4)
#define BCM53101_A0_WRITE_TXQPKTQ4_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_TXQPKTQ4_IMPr,&(r._txqpktq4_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ4_IMPr BCM53101_A0_TXQPKTQ4_IMPr
#define TXQPKTQ4_IMPr_SIZE BCM53101_A0_TXQPKTQ4_IMPr_SIZE
typedef BCM53101_A0_TXQPKTQ4_IMPr_t TXQPKTQ4_IMPr_t;
#define TXQPKTQ4_IMPr_CLR BCM53101_A0_TXQPKTQ4_IMPr_CLR
#define TXQPKTQ4_IMPr_SET BCM53101_A0_TXQPKTQ4_IMPr_SET
#define TXQPKTQ4_IMPr_GET BCM53101_A0_TXQPKTQ4_IMPr_GET
#define READ_TXQPKTQ4_IMPr BCM53101_A0_READ_TXQPKTQ4_IMPr
#define WRITE_TXQPKTQ4_IMPr BCM53101_A0_WRITE_TXQPKTQ4_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TXQPKTQ4_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TxQPKTQ5
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Tx Q5 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_TXQPKTQ5r 0x0000204c

#define BCM53101_A0_TXQPKTQ5r_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ5.
 *
 */
typedef union BCM53101_A0_TXQPKTQ5r_s {
	uint32_t v[1];
	uint32_t txqpktq5[1];
	uint32_t _txqpktq5;
} BCM53101_A0_TXQPKTQ5r_t;

#define BCM53101_A0_TXQPKTQ5r_CLR(r) (r).txqpktq5[0] = 0
#define BCM53101_A0_TXQPKTQ5r_SET(r,d) (r).txqpktq5[0] = d
#define BCM53101_A0_TXQPKTQ5r_GET(r) (r).txqpktq5[0]


/*
 * These macros can be used to access TxQPKTQ5.
 *
 */
#define BCM53101_A0_READ_TXQPKTQ5r(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_TXQPKTQ5r,(r._txqpktq5),4)
#define BCM53101_A0_WRITE_TXQPKTQ5r(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_TXQPKTQ5r,&(r._txqpktq5),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ5r BCM53101_A0_TXQPKTQ5r
#define TXQPKTQ5r_SIZE BCM53101_A0_TXQPKTQ5r_SIZE
typedef BCM53101_A0_TXQPKTQ5r_t TXQPKTQ5r_t;
#define TXQPKTQ5r_CLR BCM53101_A0_TXQPKTQ5r_CLR
#define TXQPKTQ5r_SET BCM53101_A0_TXQPKTQ5r_SET
#define TXQPKTQ5r_GET BCM53101_A0_TXQPKTQ5r_GET
#define READ_TXQPKTQ5r BCM53101_A0_READ_TXQPKTQ5r
#define WRITE_TXQPKTQ5r BCM53101_A0_WRITE_TXQPKTQ5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TXQPKTQ5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TxQPKTQ5_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Q5 Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_TXQPKTQ5_IMPr 0x0000284c

#define BCM53101_A0_TXQPKTQ5_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxQPKTQ5_IMP.
 *
 */
typedef union BCM53101_A0_TXQPKTQ5_IMPr_s {
	uint32_t v[1];
	uint32_t txqpktq5_imp[1];
	uint32_t _txqpktq5_imp;
} BCM53101_A0_TXQPKTQ5_IMPr_t;

#define BCM53101_A0_TXQPKTQ5_IMPr_CLR(r) (r).txqpktq5_imp[0] = 0
#define BCM53101_A0_TXQPKTQ5_IMPr_SET(r,d) (r).txqpktq5_imp[0] = d
#define BCM53101_A0_TXQPKTQ5_IMPr_GET(r) (r).txqpktq5_imp[0]


/*
 * These macros can be used to access TxQPKTQ5_IMP.
 *
 */
#define BCM53101_A0_READ_TXQPKTQ5_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_TXQPKTQ5_IMPr,(r._txqpktq5_imp),4)
#define BCM53101_A0_WRITE_TXQPKTQ5_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_TXQPKTQ5_IMPr,&(r._txqpktq5_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXQPKTQ5_IMPr BCM53101_A0_TXQPKTQ5_IMPr
#define TXQPKTQ5_IMPr_SIZE BCM53101_A0_TXQPKTQ5_IMPr_SIZE
typedef BCM53101_A0_TXQPKTQ5_IMPr_t TXQPKTQ5_IMPr_t;
#define TXQPKTQ5_IMPr_CLR BCM53101_A0_TXQPKTQ5_IMPr_CLR
#define TXQPKTQ5_IMPr_SET BCM53101_A0_TXQPKTQ5_IMPr_SET
#define TXQPKTQ5_IMPr_GET BCM53101_A0_TXQPKTQ5_IMPr_GET
#define READ_TXQPKTQ5_IMPr BCM53101_A0_READ_TXQPKTQ5_IMPr
#define WRITE_TXQPKTQ5_IMPr BCM53101_A0_WRITE_TXQPKTQ5_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TXQPKTQ5_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TxSingleCollision
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Tx Single Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_TXSINGLECOLLISIONr 0x00002020

#define BCM53101_A0_TXSINGLECOLLISIONr_SIZE 4

/*
 * This structure should be used to declare and program TxSingleCollision.
 *
 */
typedef union BCM53101_A0_TXSINGLECOLLISIONr_s {
	uint32_t v[1];
	uint32_t txsinglecollision[1];
	uint32_t _txsinglecollision;
} BCM53101_A0_TXSINGLECOLLISIONr_t;

#define BCM53101_A0_TXSINGLECOLLISIONr_CLR(r) (r).txsinglecollision[0] = 0
#define BCM53101_A0_TXSINGLECOLLISIONr_SET(r,d) (r).txsinglecollision[0] = d
#define BCM53101_A0_TXSINGLECOLLISIONr_GET(r) (r).txsinglecollision[0]


/*
 * These macros can be used to access TxSingleCollision.
 *
 */
#define BCM53101_A0_READ_TXSINGLECOLLISIONr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_TXSINGLECOLLISIONr,(r._txsinglecollision),4)
#define BCM53101_A0_WRITE_TXSINGLECOLLISIONr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_TXSINGLECOLLISIONr,&(r._txsinglecollision),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXSINGLECOLLISIONr BCM53101_A0_TXSINGLECOLLISIONr
#define TXSINGLECOLLISIONr_SIZE BCM53101_A0_TXSINGLECOLLISIONr_SIZE
typedef BCM53101_A0_TXSINGLECOLLISIONr_t TXSINGLECOLLISIONr_t;
#define TXSINGLECOLLISIONr_CLR BCM53101_A0_TXSINGLECOLLISIONr_CLR
#define TXSINGLECOLLISIONr_SET BCM53101_A0_TXSINGLECOLLISIONr_SET
#define TXSINGLECOLLISIONr_GET BCM53101_A0_TXSINGLECOLLISIONr_GET
#define READ_TXSINGLECOLLISIONr BCM53101_A0_READ_TXSINGLECOLLISIONr
#define WRITE_TXSINGLECOLLISIONr BCM53101_A0_WRITE_TXSINGLECOLLISIONr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TXSINGLECOLLISIONr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TxSingleCollision_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Single Collision Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_TXSINGLECOLLISION_IMPr 0x00002820

#define BCM53101_A0_TXSINGLECOLLISION_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxSingleCollision_IMP.
 *
 */
typedef union BCM53101_A0_TXSINGLECOLLISION_IMPr_s {
	uint32_t v[1];
	uint32_t txsinglecollision_imp[1];
	uint32_t _txsinglecollision_imp;
} BCM53101_A0_TXSINGLECOLLISION_IMPr_t;

#define BCM53101_A0_TXSINGLECOLLISION_IMPr_CLR(r) (r).txsinglecollision_imp[0] = 0
#define BCM53101_A0_TXSINGLECOLLISION_IMPr_SET(r,d) (r).txsinglecollision_imp[0] = d
#define BCM53101_A0_TXSINGLECOLLISION_IMPr_GET(r) (r).txsinglecollision_imp[0]


/*
 * These macros can be used to access TxSingleCollision_IMP.
 *
 */
#define BCM53101_A0_READ_TXSINGLECOLLISION_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_TXSINGLECOLLISION_IMPr,(r._txsinglecollision_imp),4)
#define BCM53101_A0_WRITE_TXSINGLECOLLISION_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_TXSINGLECOLLISION_IMPr,&(r._txsinglecollision_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXSINGLECOLLISION_IMPr BCM53101_A0_TXSINGLECOLLISION_IMPr
#define TXSINGLECOLLISION_IMPr_SIZE BCM53101_A0_TXSINGLECOLLISION_IMPr_SIZE
typedef BCM53101_A0_TXSINGLECOLLISION_IMPr_t TXSINGLECOLLISION_IMPr_t;
#define TXSINGLECOLLISION_IMPr_CLR BCM53101_A0_TXSINGLECOLLISION_IMPr_CLR
#define TXSINGLECOLLISION_IMPr_SET BCM53101_A0_TXSINGLECOLLISION_IMPr_SET
#define TXSINGLECOLLISION_IMPr_GET BCM53101_A0_TXSINGLECOLLISION_IMPr_GET
#define READ_TXSINGLECOLLISION_IMPr BCM53101_A0_READ_TXSINGLECOLLISION_IMPr
#define WRITE_TXSINGLECOLLISION_IMPr BCM53101_A0_WRITE_TXSINGLECOLLISION_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TXSINGLECOLLISION_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TxUnicastPkts
 * BLOCKS:   EPIC0 CPIC
 * DESC:     Tx Unicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_TXUNICASTPKTSr 0x00002018

#define BCM53101_A0_TXUNICASTPKTSr_SIZE 4

/*
 * This structure should be used to declare and program TxUnicastPkts.
 *
 */
typedef union BCM53101_A0_TXUNICASTPKTSr_s {
	uint32_t v[1];
	uint32_t txunicastpkts[1];
	uint32_t _txunicastpkts;
} BCM53101_A0_TXUNICASTPKTSr_t;

#define BCM53101_A0_TXUNICASTPKTSr_CLR(r) (r).txunicastpkts[0] = 0
#define BCM53101_A0_TXUNICASTPKTSr_SET(r,d) (r).txunicastpkts[0] = d
#define BCM53101_A0_TXUNICASTPKTSr_GET(r) (r).txunicastpkts[0]


/*
 * These macros can be used to access TxUnicastPkts.
 *
 */
#define BCM53101_A0_READ_TXUNICASTPKTSr(u,p,r) cdk_robo_reg_port_read(u,p,BCM53101_A0_TXUNICASTPKTSr,(r._txunicastpkts),4)
#define BCM53101_A0_WRITE_TXUNICASTPKTSr(u,p,r) cdk_robo_reg_port_write(u,p,BCM53101_A0_TXUNICASTPKTSr,&(r._txunicastpkts),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXUNICASTPKTSr BCM53101_A0_TXUNICASTPKTSr
#define TXUNICASTPKTSr_SIZE BCM53101_A0_TXUNICASTPKTSr_SIZE
typedef BCM53101_A0_TXUNICASTPKTSr_t TXUNICASTPKTSr_t;
#define TXUNICASTPKTSr_CLR BCM53101_A0_TXUNICASTPKTSr_CLR
#define TXUNICASTPKTSr_SET BCM53101_A0_TXUNICASTPKTSr_SET
#define TXUNICASTPKTSr_GET BCM53101_A0_TXUNICASTPKTSr_GET
#define READ_TXUNICASTPKTSr BCM53101_A0_READ_TXUNICASTPKTSr
#define WRITE_TXUNICASTPKTSr BCM53101_A0_WRITE_TXUNICASTPKTSr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TXUNICASTPKTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  TxUnicastPkts_IMP
 * BLOCKS:   CPIC
 * DESC:     Tx Unicast Packet Counter
 * SIZE:     32
 *
 ******************************************************************************/
#define BCM53101_A0_TXUNICASTPKTS_IMPr 0x00002818

#define BCM53101_A0_TXUNICASTPKTS_IMPr_SIZE 4

/*
 * This structure should be used to declare and program TxUnicastPkts_IMP.
 *
 */
typedef union BCM53101_A0_TXUNICASTPKTS_IMPr_s {
	uint32_t v[1];
	uint32_t txunicastpkts_imp[1];
	uint32_t _txunicastpkts_imp;
} BCM53101_A0_TXUNICASTPKTS_IMPr_t;

#define BCM53101_A0_TXUNICASTPKTS_IMPr_CLR(r) (r).txunicastpkts_imp[0] = 0
#define BCM53101_A0_TXUNICASTPKTS_IMPr_SET(r,d) (r).txunicastpkts_imp[0] = d
#define BCM53101_A0_TXUNICASTPKTS_IMPr_GET(r) (r).txunicastpkts_imp[0]


/*
 * These macros can be used to access TxUnicastPkts_IMP.
 *
 */
#define BCM53101_A0_READ_TXUNICASTPKTS_IMPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_TXUNICASTPKTS_IMPr,(r._txunicastpkts_imp),4)
#define BCM53101_A0_WRITE_TXUNICASTPKTS_IMPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_TXUNICASTPKTS_IMPr,&(r._txunicastpkts_imp),4)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define TXUNICASTPKTS_IMPr BCM53101_A0_TXUNICASTPKTS_IMPr
#define TXUNICASTPKTS_IMPr_SIZE BCM53101_A0_TXUNICASTPKTS_IMPr_SIZE
typedef BCM53101_A0_TXUNICASTPKTS_IMPr_t TXUNICASTPKTS_IMPr_t;
#define TXUNICASTPKTS_IMPr_CLR BCM53101_A0_TXUNICASTPKTS_IMPr_CLR
#define TXUNICASTPKTS_IMPr_SET BCM53101_A0_TXUNICASTPKTS_IMPr_SET
#define TXUNICASTPKTS_IMPr_GET BCM53101_A0_TXUNICASTPKTS_IMPr_GET
#define READ_TXUNICASTPKTS_IMPr BCM53101_A0_READ_TXUNICASTPKTS_IMPr
#define WRITE_TXUNICASTPKTS_IMPr BCM53101_A0_WRITE_TXUNICASTPKTS_IMPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_TXUNICASTPKTS_IMPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  ULF_DROP_MAP
 * BLOCKS:   SYS
 * DESC:     Unicast Lookup Failed Forward Map Registrer
 * SIZE:     16
 * FIELDS:
 *     UNI_LOOPUP_FAIL_FWD_MAP Unicast Lookup Failed Forward Map.When unicast lookup failed Drop is enabled (Page 00, Offset 21h) and Lookup failure happen, ARL will forward the frame according to the register.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_ULF_DROP_MAPr 0x00000032

#define BCM53101_A0_ULF_DROP_MAPr_SIZE 2

/*
 * This structure should be used to declare and program ULF_DROP_MAP.
 *
 */
typedef union BCM53101_A0_ULF_DROP_MAPr_s {
	uint32_t v[1];
	uint32_t ulf_drop_map[1];
	uint32_t _ulf_drop_map;
} BCM53101_A0_ULF_DROP_MAPr_t;

#define BCM53101_A0_ULF_DROP_MAPr_CLR(r) (r).ulf_drop_map[0] = 0
#define BCM53101_A0_ULF_DROP_MAPr_SET(r,d) (r).ulf_drop_map[0] = d
#define BCM53101_A0_ULF_DROP_MAPr_GET(r) (r).ulf_drop_map[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_ULF_DROP_MAPr_UNI_LOOPUP_FAIL_FWD_MAPf_GET(r) (((r).ulf_drop_map[0]) & 0x1ff)
#define BCM53101_A0_ULF_DROP_MAPr_UNI_LOOPUP_FAIL_FWD_MAPf_SET(r,f) (r).ulf_drop_map[0]=(((r).ulf_drop_map[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_ULF_DROP_MAPr_RESERVEDf_GET(r) ((((r).ulf_drop_map[0]) >> 9) & 0x7f)
#define BCM53101_A0_ULF_DROP_MAPr_RESERVEDf_SET(r,f) (r).ulf_drop_map[0]=(((r).ulf_drop_map[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access ULF_DROP_MAP.
 *
 */
#define BCM53101_A0_READ_ULF_DROP_MAPr(u,r) cdk_robo_reg_read(u,BCM53101_A0_ULF_DROP_MAPr,(r._ulf_drop_map),2)
#define BCM53101_A0_WRITE_ULF_DROP_MAPr(u,r) cdk_robo_reg_write(u,BCM53101_A0_ULF_DROP_MAPr,&(r._ulf_drop_map),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define ULF_DROP_MAPr BCM53101_A0_ULF_DROP_MAPr
#define ULF_DROP_MAPr_SIZE BCM53101_A0_ULF_DROP_MAPr_SIZE
typedef BCM53101_A0_ULF_DROP_MAPr_t ULF_DROP_MAPr_t;
#define ULF_DROP_MAPr_CLR BCM53101_A0_ULF_DROP_MAPr_CLR
#define ULF_DROP_MAPr_SET BCM53101_A0_ULF_DROP_MAPr_SET
#define ULF_DROP_MAPr_GET BCM53101_A0_ULF_DROP_MAPr_GET
#define ULF_DROP_MAPr_UNI_LOOPUP_FAIL_FWD_MAPf_GET BCM53101_A0_ULF_DROP_MAPr_UNI_LOOPUP_FAIL_FWD_MAPf_GET
#define ULF_DROP_MAPr_UNI_LOOPUP_FAIL_FWD_MAPf_SET BCM53101_A0_ULF_DROP_MAPr_UNI_LOOPUP_FAIL_FWD_MAPf_SET
#define ULF_DROP_MAPr_RESERVEDf_GET BCM53101_A0_ULF_DROP_MAPr_RESERVEDf_GET
#define ULF_DROP_MAPr_RESERVEDf_SET BCM53101_A0_ULF_DROP_MAPr_RESERVEDf_SET
#define READ_ULF_DROP_MAPr BCM53101_A0_READ_ULF_DROP_MAPr
#define WRITE_ULF_DROP_MAPr BCM53101_A0_WRITE_ULF_DROP_MAPr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_ULF_DROP_MAPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * MEMORY:  VLAN_1Q
 * BLOCKS:   SYS
 * DESC:     VLAN Table
 * SIZE:     24
 * FIELDS:
 *     FORWARD_MAP      Untag port bitmapBits4-0: Port 4-0.Bit5: Management Port 2(IMP1 port).Bit6: Management Port (IMP/IMP_0 port).
 *     UNTAG_MAP        Untag port bitmapBits4-0: Port 4-0.Bit5: Management Port 2(IMP1 port).Bit6: Management Port (IMP/IMP_0 port).
 *     MSPT_ID          MSTP ID
 *     FWD_MODE         It indicate wheter the packet forwarding should be based on VLANmembership of based on ARL flow.1: Based on VLAN membership(excluding ingress port)0: Based on ARL flow.Note that the VLAN membership based forwarding mode is only used forcertain ISP tagged packets received from ISP port when Falcon isoperating in Double Tag mode.
 *     POLICER_EN       policer en
 *     POLICER_ID       policer id
 *
 ******************************************************************************/
#define BCM53101_A0_VLAN_1Qm 0x20000580

#define BCM53101_A0_VLAN_1Qm_MIN 0
#define BCM53101_A0_VLAN_1Qm_MAX 4095
#define BCM53101_A0_VLAN_1Qm_CMAX(u) 4095
#define BCM53101_A0_VLAN_1Qm_SIZE 3

/*
 * This structure should be used to declare and program VLAN_1Q.
 *
 */
typedef union BCM53101_A0_VLAN_1Qm_s {
	uint32_t v[1];
	uint32_t vlan_1q[1];
	uint32_t _vlan_1q;
} BCM53101_A0_VLAN_1Qm_t;

#define BCM53101_A0_VLAN_1Qm_CLR(r) (r).vlan_1q[0] = 0
#define BCM53101_A0_VLAN_1Qm_SET(r,d) (r).vlan_1q[0] = d
#define BCM53101_A0_VLAN_1Qm_GET(r) (r).vlan_1q[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_VLAN_1Qm_FORWARD_MAPf_GET(r) (((r).vlan_1q[0]) & 0x1ff)
#define BCM53101_A0_VLAN_1Qm_FORWARD_MAPf_SET(r,f) (r).vlan_1q[0]=(((r).vlan_1q[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_VLAN_1Qm_UNTAG_MAPf_GET(r) ((((r).vlan_1q[0]) >> 9) & 0x1ff)
#define BCM53101_A0_VLAN_1Qm_UNTAG_MAPf_SET(r,f) (r).vlan_1q[0]=(((r).vlan_1q[0] & ~((uint32_t)0x1ff << 9)) | ((((uint32_t)f) & 0x1ff) << 9))
#define BCM53101_A0_VLAN_1Qm_MSPT_IDf_GET(r) ((((r).vlan_1q[0]) >> 18) & 0x7)
#define BCM53101_A0_VLAN_1Qm_MSPT_IDf_SET(r,f) (r).vlan_1q[0]=(((r).vlan_1q[0] & ~((uint32_t)0x7 << 18)) | ((((uint32_t)f) & 0x7) << 18))
#define BCM53101_A0_VLAN_1Qm_FWD_MODEf_GET(r) ((((r).vlan_1q[0]) >> 21) & 0x1)
#define BCM53101_A0_VLAN_1Qm_FWD_MODEf_SET(r,f) (r).vlan_1q[0]=(((r).vlan_1q[0] & ~((uint32_t)0x1 << 21)) | ((((uint32_t)f) & 0x1) << 21))
#define BCM53101_A0_VLAN_1Qm_POLICER_ENf_GET(r) ((((r).vlan_1q[0]) >> 22) & 0x1)
#define BCM53101_A0_VLAN_1Qm_POLICER_ENf_SET(r,f) (r).vlan_1q[0]=(((r).vlan_1q[0] & ~((uint32_t)0x1 << 22)) | ((((uint32_t)f) & 0x1) << 22))
#define BCM53101_A0_VLAN_1Qm_POLICER_IDf_GET(r) ((((r).vlan_1q[0]) >> 23) & 0x1)
#define BCM53101_A0_VLAN_1Qm_POLICER_IDf_SET(r,f) (r).vlan_1q[0]=(((r).vlan_1q[0] & ~((uint32_t)0x1 << 23)) | ((((uint32_t)f) & 0x1) << 23))

/*
 * These macros can be used to access VLAN_1Q.
 *
 */
#define BCM53101_A0_READ_VLAN_1Qm(u,i,m) cdk_robo_mem_read(u,BCM53101_A0_VLAN_1Qm,i,(m),3)
#define BCM53101_A0_WRITE_VLAN_1Qm(u,i,m) cdk_robo_mem_write(u,BCM53101_A0_VLAN_1Qm,i,&(m),3)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_1Qm BCM53101_A0_VLAN_1Qm
#define VLAN_1Qm_MIN BCM53101_A0_VLAN_1Qm_MIN
#define VLAN_1Qm_MAX BCM53101_A0_VLAN_1Qm_MAX
#define VLAN_1Qm_CMAX(u) BCM53101_A0_VLAN_1Qm_CMAX(u)
#define VLAN_1Qm_SIZE BCM53101_A0_VLAN_1Qm_SIZE
typedef BCM53101_A0_VLAN_1Qm_t VLAN_1Qm_t;
#define VLAN_1Qm_CLR BCM53101_A0_VLAN_1Qm_CLR
#define VLAN_1Qm_SET BCM53101_A0_VLAN_1Qm_SET
#define VLAN_1Qm_GET BCM53101_A0_VLAN_1Qm_GET
#define VLAN_1Qm_FORWARD_MAPf_GET BCM53101_A0_VLAN_1Qm_FORWARD_MAPf_GET
#define VLAN_1Qm_FORWARD_MAPf_SET BCM53101_A0_VLAN_1Qm_FORWARD_MAPf_SET
#define VLAN_1Qm_UNTAG_MAPf_GET BCM53101_A0_VLAN_1Qm_UNTAG_MAPf_GET
#define VLAN_1Qm_UNTAG_MAPf_SET BCM53101_A0_VLAN_1Qm_UNTAG_MAPf_SET
#define VLAN_1Qm_MSPT_IDf_GET BCM53101_A0_VLAN_1Qm_MSPT_IDf_GET
#define VLAN_1Qm_MSPT_IDf_SET BCM53101_A0_VLAN_1Qm_MSPT_IDf_SET
#define VLAN_1Qm_FWD_MODEf_GET BCM53101_A0_VLAN_1Qm_FWD_MODEf_GET
#define VLAN_1Qm_FWD_MODEf_SET BCM53101_A0_VLAN_1Qm_FWD_MODEf_SET
#define VLAN_1Qm_POLICER_ENf_GET BCM53101_A0_VLAN_1Qm_POLICER_ENf_GET
#define VLAN_1Qm_POLICER_ENf_SET BCM53101_A0_VLAN_1Qm_POLICER_ENf_SET
#define VLAN_1Qm_POLICER_IDf_GET BCM53101_A0_VLAN_1Qm_POLICER_IDf_GET
#define VLAN_1Qm_POLICER_IDf_SET BCM53101_A0_VLAN_1Qm_POLICER_IDf_SET
#define READ_VLAN_1Qm BCM53101_A0_READ_VLAN_1Qm
#define WRITE_VLAN_1Qm BCM53101_A0_WRITE_VLAN_1Qm

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_VLAN_1Qm'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  VLAN_CTRL0
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 0 Registers
 * SIZE:     8
 * FIELDS:
 *     CHANGE_1P_VID_INNER Change Inner 1P VID to PVIDThis bit controls whether to replace Ingress Inner 1P VID.(ingress VID=12'h000) to PVIDFor exampleWhen this bit is zero:(Falcon DT mode compatible)Do not change the Inner tag VIDwhen this bit is one:For a double tag frame with the inner tag VID==0, chnage the innr tag VID to PVID.
 *     CHANGE_1P_VID_OUTER Change Outer 1P VID to PVIDThis bit controls whether to replace Ingress Outer 1P VID.(ingress VID=12'h000) to PVIDFor exampleWhen this bit is zero:Do not change the Outer tag VIDwhen this bit is one:a.For a single tag frame with VID==0, change the VID to PVIDb.For a double tag frame with VID==0, chnage the outer tag VID to PVID.
 *     RESERVED_0       Reserved.
 *     CHANGE_1Q_VID    Change 1Q VID to PVIDThis bit controls whether to replace 1Q VID to PVID.(This bit can't to set in iDT_mode)For exampleWhen this bit is zero:No change for 1Q/ISP tag if VID/=0when this bit is one:a.For a single tag frame with VID==0, change the VID to PVIDb.For a double tag frame with VID==0, chnage the outer tag VID to PVID.
 *     RESERVED_1       Reserved.
 *     VLAN_LEARN_MODE  00: SVL( Shared VLAN Learning Mode)(MAC used to hash ARL table).11:IVL(Individual VLAN Learning Mode) (MAC and VID used to hash ARL table).10= illegal Setting.01= illegal Setting.This rule applies to 1Q enable mode. dt_mode and idt_mode.
 *     VLAN_EN          When set to 1, the 802.1Q VLAN function will be enabled.This bit must be set if double tagging(dt_mode or idt_mode) is enable.
 *
 ******************************************************************************/
#define BCM53101_A0_VLAN_CTRL0r 0x00003400

#define BCM53101_A0_VLAN_CTRL0r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_CTRL0.
 *
 */
typedef union BCM53101_A0_VLAN_CTRL0r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl0[1];
	uint32_t _vlan_ctrl0;
} BCM53101_A0_VLAN_CTRL0r_t;

#define BCM53101_A0_VLAN_CTRL0r_CLR(r) (r).vlan_ctrl0[0] = 0
#define BCM53101_A0_VLAN_CTRL0r_SET(r,d) (r).vlan_ctrl0[0] = d
#define BCM53101_A0_VLAN_CTRL0r_GET(r) (r).vlan_ctrl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_VLAN_CTRL0r_CHANGE_1P_VID_INNERf_GET(r) (((r).vlan_ctrl0[0]) & 0x1)
#define BCM53101_A0_VLAN_CTRL0r_CHANGE_1P_VID_INNERf_SET(r,f) (r).vlan_ctrl0[0]=(((r).vlan_ctrl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_VLAN_CTRL0r_CHANGE_1P_VID_OUTERf_GET(r) ((((r).vlan_ctrl0[0]) >> 1) & 0x1)
#define BCM53101_A0_VLAN_CTRL0r_CHANGE_1P_VID_OUTERf_SET(r,f) (r).vlan_ctrl0[0]=(((r).vlan_ctrl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_VLAN_CTRL0r_RESERVED_0f_GET(r) ((((r).vlan_ctrl0[0]) >> 2) & 0x1)
#define BCM53101_A0_VLAN_CTRL0r_RESERVED_0f_SET(r,f) (r).vlan_ctrl0[0]=(((r).vlan_ctrl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_VLAN_CTRL0r_CHANGE_1Q_VIDf_GET(r) ((((r).vlan_ctrl0[0]) >> 3) & 0x1)
#define BCM53101_A0_VLAN_CTRL0r_CHANGE_1Q_VIDf_SET(r,f) (r).vlan_ctrl0[0]=(((r).vlan_ctrl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_VLAN_CTRL0r_RESERVED_1f_GET(r) ((((r).vlan_ctrl0[0]) >> 4) & 0x1)
#define BCM53101_A0_VLAN_CTRL0r_RESERVED_1f_SET(r,f) (r).vlan_ctrl0[0]=(((r).vlan_ctrl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_VLAN_CTRL0r_VLAN_LEARN_MODEf_GET(r) ((((r).vlan_ctrl0[0]) >> 5) & 0x3)
#define BCM53101_A0_VLAN_CTRL0r_VLAN_LEARN_MODEf_SET(r,f) (r).vlan_ctrl0[0]=(((r).vlan_ctrl0[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM53101_A0_VLAN_CTRL0r_VLAN_ENf_GET(r) ((((r).vlan_ctrl0[0]) >> 7) & 0x1)
#define BCM53101_A0_VLAN_CTRL0r_VLAN_ENf_SET(r,f) (r).vlan_ctrl0[0]=(((r).vlan_ctrl0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access VLAN_CTRL0.
 *
 */
#define BCM53101_A0_READ_VLAN_CTRL0r(u,r) cdk_robo_reg_read(u,BCM53101_A0_VLAN_CTRL0r,(r._vlan_ctrl0),1)
#define BCM53101_A0_WRITE_VLAN_CTRL0r(u,r) cdk_robo_reg_write(u,BCM53101_A0_VLAN_CTRL0r,&(r._vlan_ctrl0),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL0r BCM53101_A0_VLAN_CTRL0r
#define VLAN_CTRL0r_SIZE BCM53101_A0_VLAN_CTRL0r_SIZE
typedef BCM53101_A0_VLAN_CTRL0r_t VLAN_CTRL0r_t;
#define VLAN_CTRL0r_CLR BCM53101_A0_VLAN_CTRL0r_CLR
#define VLAN_CTRL0r_SET BCM53101_A0_VLAN_CTRL0r_SET
#define VLAN_CTRL0r_GET BCM53101_A0_VLAN_CTRL0r_GET
#define VLAN_CTRL0r_CHANGE_1P_VID_INNERf_GET BCM53101_A0_VLAN_CTRL0r_CHANGE_1P_VID_INNERf_GET
#define VLAN_CTRL0r_CHANGE_1P_VID_INNERf_SET BCM53101_A0_VLAN_CTRL0r_CHANGE_1P_VID_INNERf_SET
#define VLAN_CTRL0r_CHANGE_1P_VID_OUTERf_GET BCM53101_A0_VLAN_CTRL0r_CHANGE_1P_VID_OUTERf_GET
#define VLAN_CTRL0r_CHANGE_1P_VID_OUTERf_SET BCM53101_A0_VLAN_CTRL0r_CHANGE_1P_VID_OUTERf_SET
#define VLAN_CTRL0r_RESERVED_0f_GET BCM53101_A0_VLAN_CTRL0r_RESERVED_0f_GET
#define VLAN_CTRL0r_RESERVED_0f_SET BCM53101_A0_VLAN_CTRL0r_RESERVED_0f_SET
#define VLAN_CTRL0r_CHANGE_1Q_VIDf_GET BCM53101_A0_VLAN_CTRL0r_CHANGE_1Q_VIDf_GET
#define VLAN_CTRL0r_CHANGE_1Q_VIDf_SET BCM53101_A0_VLAN_CTRL0r_CHANGE_1Q_VIDf_SET
#define VLAN_CTRL0r_RESERVED_1f_GET BCM53101_A0_VLAN_CTRL0r_RESERVED_1f_GET
#define VLAN_CTRL0r_RESERVED_1f_SET BCM53101_A0_VLAN_CTRL0r_RESERVED_1f_SET
#define VLAN_CTRL0r_VLAN_LEARN_MODEf_GET BCM53101_A0_VLAN_CTRL0r_VLAN_LEARN_MODEf_GET
#define VLAN_CTRL0r_VLAN_LEARN_MODEf_SET BCM53101_A0_VLAN_CTRL0r_VLAN_LEARN_MODEf_SET
#define VLAN_CTRL0r_VLAN_ENf_GET BCM53101_A0_VLAN_CTRL0r_VLAN_ENf_GET
#define VLAN_CTRL0r_VLAN_ENf_SET BCM53101_A0_VLAN_CTRL0r_VLAN_ENf_SET
#define READ_VLAN_CTRL0r BCM53101_A0_READ_VLAN_CTRL0r
#define WRITE_VLAN_CTRL0r BCM53101_A0_WRITE_VLAN_CTRL0r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_VLAN_CTRL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  VLAN_CTRL1
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 1 Registers
 * SIZE:     8
 * FIELDS:
 *     RESERVED_0       Reserved.
 *     RESERVED_1       Reserved.It's illegal to set 0.
 *     EN_RSV_MCAST_FWDMAP When asserted, reserved multicast frames (except GMRP and GVRP) will be checked by v_fwdmap.**This rule applies to 1Q enable, dt_mode and idt_mode.
 *     EN_RSV_MCAST_UNTAG When asserted, reserved multicast frames tag/untag will be controlled by v_untagmap.When deasserted, reserved multicast frames will be preserved tagged type of frame as follow,1.Untagged frame on ingress -> Untagged frame on egress.2.Tagged frame on ingress -> Tagged frame on egress.**This rule do not apply to MII_manage or idt_mode.**Reserved multicast frames except GMRP amd GVRP.
 *     RESERVED_2       Reserved.It's illegal to set 1.
 *     EN_IPMC_BYPASS_FWDMAP When asserted will not check IPMC frame with V_fwdmap.This rule applies to 1Q enable, dt_mode and idt_mode.
 *     EN_IPMC_BYPASS_UNTAG When deasserted, the IPMC frames tag/untag will be controlled by V_untagmap.When asserted, The IPMC frames will be preserved tagged type of frame as follow,1.Untagged frame on ingress -> Untagged frame on egress.2.Tagged frame on ingress -> Tagged frame on egress.**This rule do not apply to MII_manage or idt_mode.
 *     RESERVED_3       Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_VLAN_CTRL1r 0x00003401

#define BCM53101_A0_VLAN_CTRL1r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_CTRL1.
 *
 */
typedef union BCM53101_A0_VLAN_CTRL1r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl1[1];
	uint32_t _vlan_ctrl1;
} BCM53101_A0_VLAN_CTRL1r_t;

#define BCM53101_A0_VLAN_CTRL1r_CLR(r) (r).vlan_ctrl1[0] = 0
#define BCM53101_A0_VLAN_CTRL1r_SET(r,d) (r).vlan_ctrl1[0] = d
#define BCM53101_A0_VLAN_CTRL1r_GET(r) (r).vlan_ctrl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_VLAN_CTRL1r_RESERVED_0f_GET(r) (((r).vlan_ctrl1[0]) & 0x1)
#define BCM53101_A0_VLAN_CTRL1r_RESERVED_0f_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_VLAN_CTRL1r_RESERVED_1f_GET(r) ((((r).vlan_ctrl1[0]) >> 1) & 0x1)
#define BCM53101_A0_VLAN_CTRL1r_RESERVED_1f_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_VLAN_CTRL1r_EN_RSV_MCAST_FWDMAPf_GET(r) ((((r).vlan_ctrl1[0]) >> 2) & 0x1)
#define BCM53101_A0_VLAN_CTRL1r_EN_RSV_MCAST_FWDMAPf_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_VLAN_CTRL1r_EN_RSV_MCAST_UNTAGf_GET(r) ((((r).vlan_ctrl1[0]) >> 3) & 0x1)
#define BCM53101_A0_VLAN_CTRL1r_EN_RSV_MCAST_UNTAGf_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_VLAN_CTRL1r_RESERVED_2f_GET(r) ((((r).vlan_ctrl1[0]) >> 4) & 0x1)
#define BCM53101_A0_VLAN_CTRL1r_RESERVED_2f_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_FWDMAPf_GET(r) ((((r).vlan_ctrl1[0]) >> 5) & 0x1)
#define BCM53101_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_FWDMAPf_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_UNTAGf_GET(r) ((((r).vlan_ctrl1[0]) >> 6) & 0x1)
#define BCM53101_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_UNTAGf_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_VLAN_CTRL1r_RESERVED_3f_GET(r) ((((r).vlan_ctrl1[0]) >> 7) & 0x1)
#define BCM53101_A0_VLAN_CTRL1r_RESERVED_3f_SET(r,f) (r).vlan_ctrl1[0]=(((r).vlan_ctrl1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access VLAN_CTRL1.
 *
 */
#define BCM53101_A0_READ_VLAN_CTRL1r(u,r) cdk_robo_reg_read(u,BCM53101_A0_VLAN_CTRL1r,(r._vlan_ctrl1),1)
#define BCM53101_A0_WRITE_VLAN_CTRL1r(u,r) cdk_robo_reg_write(u,BCM53101_A0_VLAN_CTRL1r,&(r._vlan_ctrl1),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL1r BCM53101_A0_VLAN_CTRL1r
#define VLAN_CTRL1r_SIZE BCM53101_A0_VLAN_CTRL1r_SIZE
typedef BCM53101_A0_VLAN_CTRL1r_t VLAN_CTRL1r_t;
#define VLAN_CTRL1r_CLR BCM53101_A0_VLAN_CTRL1r_CLR
#define VLAN_CTRL1r_SET BCM53101_A0_VLAN_CTRL1r_SET
#define VLAN_CTRL1r_GET BCM53101_A0_VLAN_CTRL1r_GET
#define VLAN_CTRL1r_RESERVED_0f_GET BCM53101_A0_VLAN_CTRL1r_RESERVED_0f_GET
#define VLAN_CTRL1r_RESERVED_0f_SET BCM53101_A0_VLAN_CTRL1r_RESERVED_0f_SET
#define VLAN_CTRL1r_RESERVED_1f_GET BCM53101_A0_VLAN_CTRL1r_RESERVED_1f_GET
#define VLAN_CTRL1r_RESERVED_1f_SET BCM53101_A0_VLAN_CTRL1r_RESERVED_1f_SET
#define VLAN_CTRL1r_EN_RSV_MCAST_FWDMAPf_GET BCM53101_A0_VLAN_CTRL1r_EN_RSV_MCAST_FWDMAPf_GET
#define VLAN_CTRL1r_EN_RSV_MCAST_FWDMAPf_SET BCM53101_A0_VLAN_CTRL1r_EN_RSV_MCAST_FWDMAPf_SET
#define VLAN_CTRL1r_EN_RSV_MCAST_UNTAGf_GET BCM53101_A0_VLAN_CTRL1r_EN_RSV_MCAST_UNTAGf_GET
#define VLAN_CTRL1r_EN_RSV_MCAST_UNTAGf_SET BCM53101_A0_VLAN_CTRL1r_EN_RSV_MCAST_UNTAGf_SET
#define VLAN_CTRL1r_RESERVED_2f_GET BCM53101_A0_VLAN_CTRL1r_RESERVED_2f_GET
#define VLAN_CTRL1r_RESERVED_2f_SET BCM53101_A0_VLAN_CTRL1r_RESERVED_2f_SET
#define VLAN_CTRL1r_EN_IPMC_BYPASS_FWDMAPf_GET BCM53101_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_FWDMAPf_GET
#define VLAN_CTRL1r_EN_IPMC_BYPASS_FWDMAPf_SET BCM53101_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_FWDMAPf_SET
#define VLAN_CTRL1r_EN_IPMC_BYPASS_UNTAGf_GET BCM53101_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_UNTAGf_GET
#define VLAN_CTRL1r_EN_IPMC_BYPASS_UNTAGf_SET BCM53101_A0_VLAN_CTRL1r_EN_IPMC_BYPASS_UNTAGf_SET
#define VLAN_CTRL1r_RESERVED_3f_GET BCM53101_A0_VLAN_CTRL1r_RESERVED_3f_GET
#define VLAN_CTRL1r_RESERVED_3f_SET BCM53101_A0_VLAN_CTRL1r_RESERVED_3f_SET
#define READ_VLAN_CTRL1r BCM53101_A0_READ_VLAN_CTRL1r
#define WRITE_VLAN_CTRL1r BCM53101_A0_WRITE_VLAN_CTRL1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_VLAN_CTRL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  VLAN_CTRL2
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 2 Registers
 * SIZE:     8
 * FIELDS:
 *     RESERVED_0       Reserved.
 *     EN_MIIM_BYPASS_V_FWDMAP When set to 1, frames reveived by MII_manage port will bypass V_fwdmap checking.**This rule applies to 1Q enable, dt_mode and idt_mode.
 *     RESERVED_2       Reserved.
 *     EN_GMRP_GVRP_V_FWDMAP When set to 1, GMRP,GVRP will be checked by v_fwdmap.** this rule do not apply to MII_manage EXP and SPI ports.
 *     EN_GMRP_GVRP_UNTAG_MAP When asserted, GMRP/GVRP frames tag/untag will be controlled by v_untagmap.When deasserted,GMRP/GVRP  frames will be preserved tagged type of frame as follow,1.Untagged frame on ingress -> Untagged frame on egress.2.Tagged frame on ingress -> Tagged frame on egress.**This rule do not apply to MII_manage or idt_mode.
 *     RESERVED         
 *
 ******************************************************************************/
#define BCM53101_A0_VLAN_CTRL2r 0x00003402

#define BCM53101_A0_VLAN_CTRL2r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_CTRL2.
 *
 */
typedef union BCM53101_A0_VLAN_CTRL2r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl2[1];
	uint32_t _vlan_ctrl2;
} BCM53101_A0_VLAN_CTRL2r_t;

#define BCM53101_A0_VLAN_CTRL2r_CLR(r) (r).vlan_ctrl2[0] = 0
#define BCM53101_A0_VLAN_CTRL2r_SET(r,d) (r).vlan_ctrl2[0] = d
#define BCM53101_A0_VLAN_CTRL2r_GET(r) (r).vlan_ctrl2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_VLAN_CTRL2r_RESERVED_0f_GET(r) (((r).vlan_ctrl2[0]) & 0x3)
#define BCM53101_A0_VLAN_CTRL2r_RESERVED_0f_SET(r,f) (r).vlan_ctrl2[0]=(((r).vlan_ctrl2[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3))
#define BCM53101_A0_VLAN_CTRL2r_EN_MIIM_BYPASS_V_FWDMAPf_GET(r) ((((r).vlan_ctrl2[0]) >> 2) & 0x1)
#define BCM53101_A0_VLAN_CTRL2r_EN_MIIM_BYPASS_V_FWDMAPf_SET(r,f) (r).vlan_ctrl2[0]=(((r).vlan_ctrl2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_VLAN_CTRL2r_RESERVED_2f_GET(r) ((((r).vlan_ctrl2[0]) >> 3) & 0x3)
#define BCM53101_A0_VLAN_CTRL2r_RESERVED_2f_SET(r,f) (r).vlan_ctrl2[0]=(((r).vlan_ctrl2[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3))
#define BCM53101_A0_VLAN_CTRL2r_EN_GMRP_GVRP_V_FWDMAPf_GET(r) ((((r).vlan_ctrl2[0]) >> 5) & 0x1)
#define BCM53101_A0_VLAN_CTRL2r_EN_GMRP_GVRP_V_FWDMAPf_SET(r,f) (r).vlan_ctrl2[0]=(((r).vlan_ctrl2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_VLAN_CTRL2r_EN_GMRP_GVRP_UNTAG_MAPf_GET(r) ((((r).vlan_ctrl2[0]) >> 6) & 0x1)
#define BCM53101_A0_VLAN_CTRL2r_EN_GMRP_GVRP_UNTAG_MAPf_SET(r,f) (r).vlan_ctrl2[0]=(((r).vlan_ctrl2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_VLAN_CTRL2r_RESERVEDf_GET(r) ((((r).vlan_ctrl2[0]) >> 7) & 0x1)
#define BCM53101_A0_VLAN_CTRL2r_RESERVEDf_SET(r,f) (r).vlan_ctrl2[0]=(((r).vlan_ctrl2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access VLAN_CTRL2.
 *
 */
#define BCM53101_A0_READ_VLAN_CTRL2r(u,r) cdk_robo_reg_read(u,BCM53101_A0_VLAN_CTRL2r,(r._vlan_ctrl2),1)
#define BCM53101_A0_WRITE_VLAN_CTRL2r(u,r) cdk_robo_reg_write(u,BCM53101_A0_VLAN_CTRL2r,&(r._vlan_ctrl2),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL2r BCM53101_A0_VLAN_CTRL2r
#define VLAN_CTRL2r_SIZE BCM53101_A0_VLAN_CTRL2r_SIZE
typedef BCM53101_A0_VLAN_CTRL2r_t VLAN_CTRL2r_t;
#define VLAN_CTRL2r_CLR BCM53101_A0_VLAN_CTRL2r_CLR
#define VLAN_CTRL2r_SET BCM53101_A0_VLAN_CTRL2r_SET
#define VLAN_CTRL2r_GET BCM53101_A0_VLAN_CTRL2r_GET
#define VLAN_CTRL2r_RESERVED_0f_GET BCM53101_A0_VLAN_CTRL2r_RESERVED_0f_GET
#define VLAN_CTRL2r_RESERVED_0f_SET BCM53101_A0_VLAN_CTRL2r_RESERVED_0f_SET
#define VLAN_CTRL2r_EN_MIIM_BYPASS_V_FWDMAPf_GET BCM53101_A0_VLAN_CTRL2r_EN_MIIM_BYPASS_V_FWDMAPf_GET
#define VLAN_CTRL2r_EN_MIIM_BYPASS_V_FWDMAPf_SET BCM53101_A0_VLAN_CTRL2r_EN_MIIM_BYPASS_V_FWDMAPf_SET
#define VLAN_CTRL2r_RESERVED_2f_GET BCM53101_A0_VLAN_CTRL2r_RESERVED_2f_GET
#define VLAN_CTRL2r_RESERVED_2f_SET BCM53101_A0_VLAN_CTRL2r_RESERVED_2f_SET
#define VLAN_CTRL2r_EN_GMRP_GVRP_V_FWDMAPf_GET BCM53101_A0_VLAN_CTRL2r_EN_GMRP_GVRP_V_FWDMAPf_GET
#define VLAN_CTRL2r_EN_GMRP_GVRP_V_FWDMAPf_SET BCM53101_A0_VLAN_CTRL2r_EN_GMRP_GVRP_V_FWDMAPf_SET
#define VLAN_CTRL2r_EN_GMRP_GVRP_UNTAG_MAPf_GET BCM53101_A0_VLAN_CTRL2r_EN_GMRP_GVRP_UNTAG_MAPf_GET
#define VLAN_CTRL2r_EN_GMRP_GVRP_UNTAG_MAPf_SET BCM53101_A0_VLAN_CTRL2r_EN_GMRP_GVRP_UNTAG_MAPf_SET
#define VLAN_CTRL2r_RESERVEDf_GET BCM53101_A0_VLAN_CTRL2r_RESERVEDf_GET
#define VLAN_CTRL2r_RESERVEDf_SET BCM53101_A0_VLAN_CTRL2r_RESERVEDf_SET
#define READ_VLAN_CTRL2r BCM53101_A0_READ_VLAN_CTRL2r
#define WRITE_VLAN_CTRL2r BCM53101_A0_WRITE_VLAN_CTRL2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_VLAN_CTRL2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  VLAN_CTRL3
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 3 Registers
 * SIZE:     16
 * FIELDS:
 *     EN_DROP_NON1Q    When enabled , any non_1Q frame will be dropped by this port. Ports 7-0 respectively. This field makes no effect under the double tagging modes. This field is ignored by IMP porti(s), the IMP port(s) won't drop non 1Q frames even this field is set.
 *     RESERVED         Reserved.
 *
 ******************************************************************************/
#define BCM53101_A0_VLAN_CTRL3r 0x00003403

#define BCM53101_A0_VLAN_CTRL3r_SIZE 2

/*
 * This structure should be used to declare and program VLAN_CTRL3.
 *
 */
typedef union BCM53101_A0_VLAN_CTRL3r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl3[1];
	uint32_t _vlan_ctrl3;
} BCM53101_A0_VLAN_CTRL3r_t;

#define BCM53101_A0_VLAN_CTRL3r_CLR(r) (r).vlan_ctrl3[0] = 0
#define BCM53101_A0_VLAN_CTRL3r_SET(r,d) (r).vlan_ctrl3[0] = d
#define BCM53101_A0_VLAN_CTRL3r_GET(r) (r).vlan_ctrl3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_VLAN_CTRL3r_EN_DROP_NON1Qf_GET(r) (((r).vlan_ctrl3[0]) & 0x1ff)
#define BCM53101_A0_VLAN_CTRL3r_EN_DROP_NON1Qf_SET(r,f) (r).vlan_ctrl3[0]=(((r).vlan_ctrl3[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_VLAN_CTRL3r_RESERVEDf_GET(r) ((((r).vlan_ctrl3[0]) >> 9) & 0x7f)
#define BCM53101_A0_VLAN_CTRL3r_RESERVEDf_SET(r,f) (r).vlan_ctrl3[0]=(((r).vlan_ctrl3[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access VLAN_CTRL3.
 *
 */
#define BCM53101_A0_READ_VLAN_CTRL3r(u,r) cdk_robo_reg_read(u,BCM53101_A0_VLAN_CTRL3r,(r._vlan_ctrl3),2)
#define BCM53101_A0_WRITE_VLAN_CTRL3r(u,r) cdk_robo_reg_write(u,BCM53101_A0_VLAN_CTRL3r,&(r._vlan_ctrl3),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL3r BCM53101_A0_VLAN_CTRL3r
#define VLAN_CTRL3r_SIZE BCM53101_A0_VLAN_CTRL3r_SIZE
typedef BCM53101_A0_VLAN_CTRL3r_t VLAN_CTRL3r_t;
#define VLAN_CTRL3r_CLR BCM53101_A0_VLAN_CTRL3r_CLR
#define VLAN_CTRL3r_SET BCM53101_A0_VLAN_CTRL3r_SET
#define VLAN_CTRL3r_GET BCM53101_A0_VLAN_CTRL3r_GET
#define VLAN_CTRL3r_EN_DROP_NON1Qf_GET BCM53101_A0_VLAN_CTRL3r_EN_DROP_NON1Qf_GET
#define VLAN_CTRL3r_EN_DROP_NON1Qf_SET BCM53101_A0_VLAN_CTRL3r_EN_DROP_NON1Qf_SET
#define VLAN_CTRL3r_RESERVEDf_GET BCM53101_A0_VLAN_CTRL3r_RESERVEDf_GET
#define VLAN_CTRL3r_RESERVEDf_SET BCM53101_A0_VLAN_CTRL3r_RESERVEDf_SET
#define READ_VLAN_CTRL3r BCM53101_A0_READ_VLAN_CTRL3r
#define WRITE_VLAN_CTRL3r BCM53101_A0_WRITE_VLAN_CTRL3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_VLAN_CTRL3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  VLAN_CTRL4
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 4 Registers
 * SIZE:     8
 * FIELDS:
 *     RESERVED_1       Reserved.
 *     RESV_MCAST_FLOOD When chip is programmed as double tag mode(dt_mode and idt_mode) and management mode.1 : flood(include all data port and CPU) reserved mcast based on the VLAN rule.0 : trap received mcast to CPU.reserved multicast include 01-80-c2-00-00-(00,01-2f)
 *     EN_DOUBLE_TAG    Enable double taggging mode.
 *     RESERVED         Reserved.
 *     EN_MGE_REV_GMRP  When set to 1, management port ( the port with CPU) will be the destination port of GMRP frame. In multiple chip system, a GMRP frmae received by a chip without CPU will pass it to expansion port, and eventually it will be forward to CPU.
 *     EN_MGE_REV_GVRP  When set to 1. management port ( the port with CPU) will be the destination port of GVRP frame.
 *     INGR_VID_CHK     00: forward ingress VID violation frame( VID is not in v_fwdmap). But do not learn in ARL table.01: Drop frame if frame has VID violation, not Learned.10: Do not check ingress VID violation.(Forward and Learn as no violation case)11:Forward ingress VIO violation frame to IMP, but not learn(default)**This field is ignored by IMP port(s), the IMP port(s) won't check ingress VID violation frames.
 *
 ******************************************************************************/
#define BCM53101_A0_VLAN_CTRL4r 0x00003405

#define BCM53101_A0_VLAN_CTRL4r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_CTRL4.
 *
 */
typedef union BCM53101_A0_VLAN_CTRL4r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl4[1];
	uint32_t _vlan_ctrl4;
} BCM53101_A0_VLAN_CTRL4r_t;

#define BCM53101_A0_VLAN_CTRL4r_CLR(r) (r).vlan_ctrl4[0] = 0
#define BCM53101_A0_VLAN_CTRL4r_SET(r,d) (r).vlan_ctrl4[0] = d
#define BCM53101_A0_VLAN_CTRL4r_GET(r) (r).vlan_ctrl4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_VLAN_CTRL4r_RESERVED_1f_GET(r) (((r).vlan_ctrl4[0]) & 0x1)
#define BCM53101_A0_VLAN_CTRL4r_RESERVED_1f_SET(r,f) (r).vlan_ctrl4[0]=(((r).vlan_ctrl4[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_VLAN_CTRL4r_RESV_MCAST_FLOODf_GET(r) ((((r).vlan_ctrl4[0]) >> 1) & 0x1)
#define BCM53101_A0_VLAN_CTRL4r_RESV_MCAST_FLOODf_SET(r,f) (r).vlan_ctrl4[0]=(((r).vlan_ctrl4[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_VLAN_CTRL4r_EN_DOUBLE_TAGf_GET(r) ((((r).vlan_ctrl4[0]) >> 2) & 0x1)
#define BCM53101_A0_VLAN_CTRL4r_EN_DOUBLE_TAGf_SET(r,f) (r).vlan_ctrl4[0]=(((r).vlan_ctrl4[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_VLAN_CTRL4r_RESERVEDf_GET(r) ((((r).vlan_ctrl4[0]) >> 3) & 0x1)
#define BCM53101_A0_VLAN_CTRL4r_RESERVEDf_SET(r,f) (r).vlan_ctrl4[0]=(((r).vlan_ctrl4[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_VLAN_CTRL4r_EN_MGE_REV_GMRPf_GET(r) ((((r).vlan_ctrl4[0]) >> 4) & 0x1)
#define BCM53101_A0_VLAN_CTRL4r_EN_MGE_REV_GMRPf_SET(r,f) (r).vlan_ctrl4[0]=(((r).vlan_ctrl4[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_VLAN_CTRL4r_EN_MGE_REV_GVRPf_GET(r) ((((r).vlan_ctrl4[0]) >> 5) & 0x1)
#define BCM53101_A0_VLAN_CTRL4r_EN_MGE_REV_GVRPf_SET(r,f) (r).vlan_ctrl4[0]=(((r).vlan_ctrl4[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_VLAN_CTRL4r_INGR_VID_CHKf_GET(r) ((((r).vlan_ctrl4[0]) >> 6) & 0x3)
#define BCM53101_A0_VLAN_CTRL4r_INGR_VID_CHKf_SET(r,f) (r).vlan_ctrl4[0]=(((r).vlan_ctrl4[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6))

/*
 * These macros can be used to access VLAN_CTRL4.
 *
 */
#define BCM53101_A0_READ_VLAN_CTRL4r(u,r) cdk_robo_reg_read(u,BCM53101_A0_VLAN_CTRL4r,(r._vlan_ctrl4),1)
#define BCM53101_A0_WRITE_VLAN_CTRL4r(u,r) cdk_robo_reg_write(u,BCM53101_A0_VLAN_CTRL4r,&(r._vlan_ctrl4),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL4r BCM53101_A0_VLAN_CTRL4r
#define VLAN_CTRL4r_SIZE BCM53101_A0_VLAN_CTRL4r_SIZE
typedef BCM53101_A0_VLAN_CTRL4r_t VLAN_CTRL4r_t;
#define VLAN_CTRL4r_CLR BCM53101_A0_VLAN_CTRL4r_CLR
#define VLAN_CTRL4r_SET BCM53101_A0_VLAN_CTRL4r_SET
#define VLAN_CTRL4r_GET BCM53101_A0_VLAN_CTRL4r_GET
#define VLAN_CTRL4r_RESERVED_1f_GET BCM53101_A0_VLAN_CTRL4r_RESERVED_1f_GET
#define VLAN_CTRL4r_RESERVED_1f_SET BCM53101_A0_VLAN_CTRL4r_RESERVED_1f_SET
#define VLAN_CTRL4r_RESV_MCAST_FLOODf_GET BCM53101_A0_VLAN_CTRL4r_RESV_MCAST_FLOODf_GET
#define VLAN_CTRL4r_RESV_MCAST_FLOODf_SET BCM53101_A0_VLAN_CTRL4r_RESV_MCAST_FLOODf_SET
#define VLAN_CTRL4r_EN_DOUBLE_TAGf_GET BCM53101_A0_VLAN_CTRL4r_EN_DOUBLE_TAGf_GET
#define VLAN_CTRL4r_EN_DOUBLE_TAGf_SET BCM53101_A0_VLAN_CTRL4r_EN_DOUBLE_TAGf_SET
#define VLAN_CTRL4r_RESERVEDf_GET BCM53101_A0_VLAN_CTRL4r_RESERVEDf_GET
#define VLAN_CTRL4r_RESERVEDf_SET BCM53101_A0_VLAN_CTRL4r_RESERVEDf_SET
#define VLAN_CTRL4r_EN_MGE_REV_GMRPf_GET BCM53101_A0_VLAN_CTRL4r_EN_MGE_REV_GMRPf_GET
#define VLAN_CTRL4r_EN_MGE_REV_GMRPf_SET BCM53101_A0_VLAN_CTRL4r_EN_MGE_REV_GMRPf_SET
#define VLAN_CTRL4r_EN_MGE_REV_GVRPf_GET BCM53101_A0_VLAN_CTRL4r_EN_MGE_REV_GVRPf_GET
#define VLAN_CTRL4r_EN_MGE_REV_GVRPf_SET BCM53101_A0_VLAN_CTRL4r_EN_MGE_REV_GVRPf_SET
#define VLAN_CTRL4r_INGR_VID_CHKf_GET BCM53101_A0_VLAN_CTRL4r_INGR_VID_CHKf_GET
#define VLAN_CTRL4r_INGR_VID_CHKf_SET BCM53101_A0_VLAN_CTRL4r_INGR_VID_CHKf_SET
#define READ_VLAN_CTRL4r BCM53101_A0_READ_VLAN_CTRL4r
#define WRITE_VLAN_CTRL4r BCM53101_A0_WRITE_VLAN_CTRL4r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_VLAN_CTRL4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  VLAN_CTRL5
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 5 Registers
 * SIZE:     8
 * FIELDS:
 *     EN_CPU_RX_BYP_INNER_CRCCHK 1:The management port(IMP) will ignore CRC check.0:The management port(IMP) with CPU on it will check the CRC.
 *     RESERVED         Reserved
 *     EN_VID_FFF_FWD   0 : comply with standard, drop frame.1: forwaed frame.
 *     DROP_VTABLE_MISS When set to 1, a frame with V_table miss will be dropped.When set to 0, a frame with V_table miss will be fowarded to IMP.
 *     EGRESS_DIR_FRM_BYPASS_TRUNK_EN Egress Directed Frame Bypass Trunking Re-direction EnableSet to1 : Egress Directed Frame From Management Port will bypass Re-Trunking Re-directed RuleSet to 0: Egress Directed Frame will From Management Port will follow Trunking Re-directed Rule.
 *     RESERVED_0       Reserved
 *     PRESV_NON1Q      - en_preserv_non_1q_frame: (default 0)When set to 1, regardless of untag map in VLAN table, non-1Q frames(including 802.1p frames) will not be changed at TX. This field makes no effect under the double tagged modes(dt_mode and idt_mode).
 *
 ******************************************************************************/
#define BCM53101_A0_VLAN_CTRL5r 0x00003406

#define BCM53101_A0_VLAN_CTRL5r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_CTRL5.
 *
 */
typedef union BCM53101_A0_VLAN_CTRL5r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl5[1];
	uint32_t _vlan_ctrl5;
} BCM53101_A0_VLAN_CTRL5r_t;

#define BCM53101_A0_VLAN_CTRL5r_CLR(r) (r).vlan_ctrl5[0] = 0
#define BCM53101_A0_VLAN_CTRL5r_SET(r,d) (r).vlan_ctrl5[0] = d
#define BCM53101_A0_VLAN_CTRL5r_GET(r) (r).vlan_ctrl5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_VLAN_CTRL5r_EN_CPU_RX_BYP_INNER_CRCCHKf_GET(r) (((r).vlan_ctrl5[0]) & 0x1)
#define BCM53101_A0_VLAN_CTRL5r_EN_CPU_RX_BYP_INNER_CRCCHKf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_VLAN_CTRL5r_RESERVEDf_GET(r) ((((r).vlan_ctrl5[0]) >> 1) & 0x1)
#define BCM53101_A0_VLAN_CTRL5r_RESERVEDf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_VLAN_CTRL5r_EN_VID_FFF_FWDf_GET(r) ((((r).vlan_ctrl5[0]) >> 2) & 0x1)
#define BCM53101_A0_VLAN_CTRL5r_EN_VID_FFF_FWDf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_VLAN_CTRL5r_DROP_VTABLE_MISSf_GET(r) ((((r).vlan_ctrl5[0]) >> 3) & 0x1)
#define BCM53101_A0_VLAN_CTRL5r_DROP_VTABLE_MISSf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_VLAN_CTRL5r_EGRESS_DIR_FRM_BYPASS_TRUNK_ENf_GET(r) ((((r).vlan_ctrl5[0]) >> 4) & 0x1)
#define BCM53101_A0_VLAN_CTRL5r_EGRESS_DIR_FRM_BYPASS_TRUNK_ENf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_VLAN_CTRL5r_RESERVED_0f_GET(r) ((((r).vlan_ctrl5[0]) >> 5) & 0x1)
#define BCM53101_A0_VLAN_CTRL5r_RESERVED_0f_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_VLAN_CTRL5r_PRESV_NON1Qf_GET(r) ((((r).vlan_ctrl5[0]) >> 6) & 0x1)
#define BCM53101_A0_VLAN_CTRL5r_PRESV_NON1Qf_SET(r,f) (r).vlan_ctrl5[0]=(((r).vlan_ctrl5[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))

/*
 * These macros can be used to access VLAN_CTRL5.
 *
 */
#define BCM53101_A0_READ_VLAN_CTRL5r(u,r) cdk_robo_reg_read(u,BCM53101_A0_VLAN_CTRL5r,(r._vlan_ctrl5),1)
#define BCM53101_A0_WRITE_VLAN_CTRL5r(u,r) cdk_robo_reg_write(u,BCM53101_A0_VLAN_CTRL5r,&(r._vlan_ctrl5),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL5r BCM53101_A0_VLAN_CTRL5r
#define VLAN_CTRL5r_SIZE BCM53101_A0_VLAN_CTRL5r_SIZE
typedef BCM53101_A0_VLAN_CTRL5r_t VLAN_CTRL5r_t;
#define VLAN_CTRL5r_CLR BCM53101_A0_VLAN_CTRL5r_CLR
#define VLAN_CTRL5r_SET BCM53101_A0_VLAN_CTRL5r_SET
#define VLAN_CTRL5r_GET BCM53101_A0_VLAN_CTRL5r_GET
#define VLAN_CTRL5r_EN_CPU_RX_BYP_INNER_CRCCHKf_GET BCM53101_A0_VLAN_CTRL5r_EN_CPU_RX_BYP_INNER_CRCCHKf_GET
#define VLAN_CTRL5r_EN_CPU_RX_BYP_INNER_CRCCHKf_SET BCM53101_A0_VLAN_CTRL5r_EN_CPU_RX_BYP_INNER_CRCCHKf_SET
#define VLAN_CTRL5r_RESERVEDf_GET BCM53101_A0_VLAN_CTRL5r_RESERVEDf_GET
#define VLAN_CTRL5r_RESERVEDf_SET BCM53101_A0_VLAN_CTRL5r_RESERVEDf_SET
#define VLAN_CTRL5r_EN_VID_FFF_FWDf_GET BCM53101_A0_VLAN_CTRL5r_EN_VID_FFF_FWDf_GET
#define VLAN_CTRL5r_EN_VID_FFF_FWDf_SET BCM53101_A0_VLAN_CTRL5r_EN_VID_FFF_FWDf_SET
#define VLAN_CTRL5r_DROP_VTABLE_MISSf_GET BCM53101_A0_VLAN_CTRL5r_DROP_VTABLE_MISSf_GET
#define VLAN_CTRL5r_DROP_VTABLE_MISSf_SET BCM53101_A0_VLAN_CTRL5r_DROP_VTABLE_MISSf_SET
#define VLAN_CTRL5r_EGRESS_DIR_FRM_BYPASS_TRUNK_ENf_GET BCM53101_A0_VLAN_CTRL5r_EGRESS_DIR_FRM_BYPASS_TRUNK_ENf_GET
#define VLAN_CTRL5r_EGRESS_DIR_FRM_BYPASS_TRUNK_ENf_SET BCM53101_A0_VLAN_CTRL5r_EGRESS_DIR_FRM_BYPASS_TRUNK_ENf_SET
#define VLAN_CTRL5r_RESERVED_0f_GET BCM53101_A0_VLAN_CTRL5r_RESERVED_0f_GET
#define VLAN_CTRL5r_RESERVED_0f_SET BCM53101_A0_VLAN_CTRL5r_RESERVED_0f_SET
#define VLAN_CTRL5r_PRESV_NON1Qf_GET BCM53101_A0_VLAN_CTRL5r_PRESV_NON1Qf_GET
#define VLAN_CTRL5r_PRESV_NON1Qf_SET BCM53101_A0_VLAN_CTRL5r_PRESV_NON1Qf_SET
#define READ_VLAN_CTRL5r BCM53101_A0_READ_VLAN_CTRL5r
#define WRITE_VLAN_CTRL5r BCM53101_A0_WRITE_VLAN_CTRL5r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_VLAN_CTRL5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  VLAN_CTRL6
 * BLOCKS:   SYS
 * DESC:     802.1Q VLAN Control 6 Registers
 * SIZE:     8
 * FIELDS:
 *     STRICT_SFD_DETECT use_strict_sfd_detectWhen enabled, Lotus drops frames with no preamble and start with SFD regardless of the phase rx clk at which nibble data of SFD is received.When disabled (dfault), Lotus drops such frames only at certain phase of the nibble data of SFD.NOTE: This register turns on a bug fix, so should be hidden in the customer datasheet. We decided to turn it off by default for safety purpose.0
 *     RESERVED         Reserved.
 *     DIS_ARL_BUST_LMT dis_arl_burst_lmtDisable ARL arbiter burst limit of 2 cycles.When set to 1, it disables the fix for ARL arbiter problem of not granting the high-priority request immediately. Default is 0.NOTE: Engineering only. Do not release this reg to customers
 *     ARL_LATE_SEL     arl_latency_selNum of extra states to accommodate ARL latency.When 3'b000, lengthen rxfsm by 2 cycles (Default).When 3'b001, lengthen rxfsm by 3 cycles.When 3'b010, lengthen rxfsm by 4 cycles.When 3'b111, lengthen rxfsm by 1 cycles.When 3'b110, lengthen rxfsm by 0 cycles.When 3'b100, lengthen rxfsm by 2 cycles and turn off pulling in fmstopped effectively by 1 cycle.When other values, behaves the same as the 3'b000 case Default is 3'b000.NOTE: Engineering only. Do not release this reg to customers.
 *
 ******************************************************************************/
#define BCM53101_A0_VLAN_CTRL6r 0x00003407

#define BCM53101_A0_VLAN_CTRL6r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_CTRL6.
 *
 */
typedef union BCM53101_A0_VLAN_CTRL6r_s {
	uint32_t v[1];
	uint32_t vlan_ctrl6[1];
	uint32_t _vlan_ctrl6;
} BCM53101_A0_VLAN_CTRL6r_t;

#define BCM53101_A0_VLAN_CTRL6r_CLR(r) (r).vlan_ctrl6[0] = 0
#define BCM53101_A0_VLAN_CTRL6r_SET(r,d) (r).vlan_ctrl6[0] = d
#define BCM53101_A0_VLAN_CTRL6r_GET(r) (r).vlan_ctrl6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_VLAN_CTRL6r_STRICT_SFD_DETECTf_GET(r) (((r).vlan_ctrl6[0]) & 0x1)
#define BCM53101_A0_VLAN_CTRL6r_STRICT_SFD_DETECTf_SET(r,f) (r).vlan_ctrl6[0]=(((r).vlan_ctrl6[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_VLAN_CTRL6r_RESERVEDf_GET(r) ((((r).vlan_ctrl6[0]) >> 1) & 0x7)
#define BCM53101_A0_VLAN_CTRL6r_RESERVEDf_SET(r,f) (r).vlan_ctrl6[0]=(((r).vlan_ctrl6[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1))
#define BCM53101_A0_VLAN_CTRL6r_DIS_ARL_BUST_LMTf_GET(r) ((((r).vlan_ctrl6[0]) >> 4) & 0x1)
#define BCM53101_A0_VLAN_CTRL6r_DIS_ARL_BUST_LMTf_SET(r,f) (r).vlan_ctrl6[0]=(((r).vlan_ctrl6[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_VLAN_CTRL6r_ARL_LATE_SELf_GET(r) ((((r).vlan_ctrl6[0]) >> 5) & 0x7)
#define BCM53101_A0_VLAN_CTRL6r_ARL_LATE_SELf_SET(r,f) (r).vlan_ctrl6[0]=(((r).vlan_ctrl6[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5))

/*
 * These macros can be used to access VLAN_CTRL6.
 *
 */
#define BCM53101_A0_READ_VLAN_CTRL6r(u,r) cdk_robo_reg_read(u,BCM53101_A0_VLAN_CTRL6r,(r._vlan_ctrl6),1)
#define BCM53101_A0_WRITE_VLAN_CTRL6r(u,r) cdk_robo_reg_write(u,BCM53101_A0_VLAN_CTRL6r,&(r._vlan_ctrl6),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_CTRL6r BCM53101_A0_VLAN_CTRL6r
#define VLAN_CTRL6r_SIZE BCM53101_A0_VLAN_CTRL6r_SIZE
typedef BCM53101_A0_VLAN_CTRL6r_t VLAN_CTRL6r_t;
#define VLAN_CTRL6r_CLR BCM53101_A0_VLAN_CTRL6r_CLR
#define VLAN_CTRL6r_SET BCM53101_A0_VLAN_CTRL6r_SET
#define VLAN_CTRL6r_GET BCM53101_A0_VLAN_CTRL6r_GET
#define VLAN_CTRL6r_STRICT_SFD_DETECTf_GET BCM53101_A0_VLAN_CTRL6r_STRICT_SFD_DETECTf_GET
#define VLAN_CTRL6r_STRICT_SFD_DETECTf_SET BCM53101_A0_VLAN_CTRL6r_STRICT_SFD_DETECTf_SET
#define VLAN_CTRL6r_RESERVEDf_GET BCM53101_A0_VLAN_CTRL6r_RESERVEDf_GET
#define VLAN_CTRL6r_RESERVEDf_SET BCM53101_A0_VLAN_CTRL6r_RESERVEDf_SET
#define VLAN_CTRL6r_DIS_ARL_BUST_LMTf_GET BCM53101_A0_VLAN_CTRL6r_DIS_ARL_BUST_LMTf_GET
#define VLAN_CTRL6r_DIS_ARL_BUST_LMTf_SET BCM53101_A0_VLAN_CTRL6r_DIS_ARL_BUST_LMTf_SET
#define VLAN_CTRL6r_ARL_LATE_SELf_GET BCM53101_A0_VLAN_CTRL6r_ARL_LATE_SELf_GET
#define VLAN_CTRL6r_ARL_LATE_SELf_SET BCM53101_A0_VLAN_CTRL6r_ARL_LATE_SELf_SET
#define READ_VLAN_CTRL6r BCM53101_A0_READ_VLAN_CTRL6r
#define WRITE_VLAN_CTRL6r BCM53101_A0_WRITE_VLAN_CTRL6r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_VLAN_CTRL6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  VLAN_MULTI_PORT_ADDR_CTL
 * BLOCKS:   SYS
 * DESC:     VLAN Multiport Address Control Register
 * SIZE:     16
 * FIELDS:
 *     EN_MPORT0_V_FWD_MAP When set to 1, MPORT_ADD0 will be checked by v_fwdmap** this rule do not apply to MII_manage
 *     EN_MPORT0_UTG_MAP When set to 1, MPORT_ADD0 will be checked by v_untagmap** this rule do not apply to MII_manage
 *     EN_MPORT1_V_FWD_MAP When set to 1, MPORT_ADD1 will be checked by v_fwdmap** this rule do not apply to MII_manage
 *     EN_MPORT1_UTG_MAP When set to 1, MPORT_ADD1 will be checked by v_untagmap** this rule do not apply to MII_manage
 *     EN_MPORT2_V_FWD_MAP When set to 1, MPORT_ADD2 will be checked by v_fwdmap** this rule do not apply to MII_manage
 *     EN_MPORT2_UTG_MAP When set to 1, MPORT_ADD2 will be checked by v_untagmap** this rule do not apply to MII_manage
 *     EN_MPORT3_V_FWD_MAP When set to 1, MPORT_ADD3 will be checked by v_fwdmap** this rule do not apply to MII_manage
 *     EN_MPORT3_UTG_MAP When set to 1, MPORT_ADD3 will be checked by v_untagmap** this rule do not apply to MII_manage
 *     EN_MPORT4_V_FWD_MAP When set to 1, MPORT_ADD4 will be checked by v_fwdmap** this rule do not apply to MII_manage
 *     EN_MPORT4_UTG_MAP When set to 1, MPORT_ADD4 will be checked by v_untagmap** this rule do not apply to MII_manage
 *     EN_MPORT5_V_FWD_MAP When set to 1, MPORT_ADD5 will be checked by v_fwdmap** this rule do not apply to MII_manage
 *     EN_MPORT5_UTG_MAP When set to 1, MPORT_ADD5 will be checked by v_untagmap** this rule do not apply to MII_manage or idt_mode.** When set to 0, MPORT_ADDx frames will be preserved tagged type of frames as follows,1.Untagged frame on ingress -> Untagged frame on egress.2.Tagged frames on ingress -> tagges frames on egress.3.1p frame on ingress -> 1Q frame on egress.
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr 0x0000340a

#define BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_SIZE 2

/*
 * This structure should be used to declare and program VLAN_MULTI_PORT_ADDR_CTL.
 *
 */
typedef union BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_s {
	uint32_t v[1];
	uint32_t vlan_multi_port_addr_ctl[1];
	uint32_t _vlan_multi_port_addr_ctl;
} BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_t;

#define BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_CLR(r) (r).vlan_multi_port_addr_ctl[0] = 0
#define BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_SET(r,d) (r).vlan_multi_port_addr_ctl[0] = d
#define BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_GET(r) (r).vlan_multi_port_addr_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_V_FWD_MAPf_GET(r) (((r).vlan_multi_port_addr_ctl[0]) & 0x1)
#define BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_V_FWD_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1))
#define BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_UTG_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 1) & 0x1)
#define BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_UTG_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1))
#define BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_V_FWD_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 2) & 0x1)
#define BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_V_FWD_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2))
#define BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_UTG_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 3) & 0x1)
#define BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_UTG_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3))
#define BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_V_FWD_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 4) & 0x1)
#define BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_V_FWD_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_UTG_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 5) & 0x1)
#define BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_UTG_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5))
#define BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_V_FWD_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 6) & 0x1)
#define BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_V_FWD_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6))
#define BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_UTG_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 7) & 0x1)
#define BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_UTG_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))
#define BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_V_FWD_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 8) & 0x1)
#define BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_V_FWD_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8))
#define BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_UTG_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 9) & 0x1)
#define BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_UTG_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_V_FWD_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 10) & 0x1)
#define BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_V_FWD_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10))
#define BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_UTG_MAPf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 11) & 0x1)
#define BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_UTG_MAPf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11))
#define BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_RESERVEDf_GET(r) ((((r).vlan_multi_port_addr_ctl[0]) >> 12) & 0xf)
#define BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_RESERVEDf_SET(r,f) (r).vlan_multi_port_addr_ctl[0]=(((r).vlan_multi_port_addr_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12))

/*
 * These macros can be used to access VLAN_MULTI_PORT_ADDR_CTL.
 *
 */
#define BCM53101_A0_READ_VLAN_MULTI_PORT_ADDR_CTLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr,(r._vlan_multi_port_addr_ctl),2)
#define BCM53101_A0_WRITE_VLAN_MULTI_PORT_ADDR_CTLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr,&(r._vlan_multi_port_addr_ctl),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define VLAN_MULTI_PORT_ADDR_CTLr BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr
#define VLAN_MULTI_PORT_ADDR_CTLr_SIZE BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_SIZE
typedef BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_t VLAN_MULTI_PORT_ADDR_CTLr_t;
#define VLAN_MULTI_PORT_ADDR_CTLr_CLR BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_CLR
#define VLAN_MULTI_PORT_ADDR_CTLr_SET BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_GET BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_V_FWD_MAPf_GET BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_V_FWD_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_V_FWD_MAPf_SET BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_V_FWD_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_UTG_MAPf_GET BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_UTG_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_UTG_MAPf_SET BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT0_UTG_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_V_FWD_MAPf_GET BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_V_FWD_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_V_FWD_MAPf_SET BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_V_FWD_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_UTG_MAPf_GET BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_UTG_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_UTG_MAPf_SET BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT1_UTG_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_V_FWD_MAPf_GET BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_V_FWD_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_V_FWD_MAPf_SET BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_V_FWD_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_UTG_MAPf_GET BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_UTG_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_UTG_MAPf_SET BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT2_UTG_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_V_FWD_MAPf_GET BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_V_FWD_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_V_FWD_MAPf_SET BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_V_FWD_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_UTG_MAPf_GET BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_UTG_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_UTG_MAPf_SET BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT3_UTG_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_V_FWD_MAPf_GET BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_V_FWD_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_V_FWD_MAPf_SET BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_V_FWD_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_UTG_MAPf_GET BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_UTG_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_UTG_MAPf_SET BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT4_UTG_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_V_FWD_MAPf_GET BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_V_FWD_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_V_FWD_MAPf_SET BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_V_FWD_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_UTG_MAPf_GET BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_UTG_MAPf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_UTG_MAPf_SET BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_EN_MPORT5_UTG_MAPf_SET
#define VLAN_MULTI_PORT_ADDR_CTLr_RESERVEDf_GET BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_RESERVEDf_GET
#define VLAN_MULTI_PORT_ADDR_CTLr_RESERVEDf_SET BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr_RESERVEDf_SET
#define READ_VLAN_MULTI_PORT_ADDR_CTLr BCM53101_A0_READ_VLAN_MULTI_PORT_ADDR_CTLr
#define WRITE_VLAN_MULTI_PORT_ADDR_CTLr BCM53101_A0_WRITE_VLAN_MULTI_PORT_ADDR_CTLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_VLAN_MULTI_PORT_ADDR_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  WAN_PORT_SEL
 * BLOCKS:   SYS
 * DESC:     WAN Port select Register
 * SIZE:     16
 * FIELDS:
 *     WAN_SELECT       WAN Ports SelectionThis field selects the WAN ports. when set to '1', the corresponding port is the WAN port.bit5: Port 5 can be selected as WAN port only when IMP1 is disabled.
 *     RESERVED_0       Reserved
 *     EN_MAN2WAN       0: mgmt-port only uses egress direct frame to WAN-port.1: mgmt-port could send non-egress direct frame to WAN-port.
 *     RESERVED_1       Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_WAN_PORT_SELr 0x00000026

#define BCM53101_A0_WAN_PORT_SELr_SIZE 2

/*
 * This structure should be used to declare and program WAN_PORT_SEL.
 *
 */
typedef union BCM53101_A0_WAN_PORT_SELr_s {
	uint32_t v[1];
	uint32_t wan_port_sel[1];
	uint32_t _wan_port_sel;
} BCM53101_A0_WAN_PORT_SELr_t;

#define BCM53101_A0_WAN_PORT_SELr_CLR(r) (r).wan_port_sel[0] = 0
#define BCM53101_A0_WAN_PORT_SELr_SET(r,d) (r).wan_port_sel[0] = d
#define BCM53101_A0_WAN_PORT_SELr_GET(r) (r).wan_port_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_WAN_PORT_SELr_WAN_SELECTf_GET(r) (((r).wan_port_sel[0]) & 0x3f)
#define BCM53101_A0_WAN_PORT_SELr_WAN_SELECTf_SET(r,f) (r).wan_port_sel[0]=(((r).wan_port_sel[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f))
#define BCM53101_A0_WAN_PORT_SELr_RESERVED_0f_GET(r) ((((r).wan_port_sel[0]) >> 6) & 0x7)
#define BCM53101_A0_WAN_PORT_SELr_RESERVED_0f_SET(r,f) (r).wan_port_sel[0]=(((r).wan_port_sel[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6))
#define BCM53101_A0_WAN_PORT_SELr_EN_MAN2WANf_GET(r) ((((r).wan_port_sel[0]) >> 9) & 0x1)
#define BCM53101_A0_WAN_PORT_SELr_EN_MAN2WANf_SET(r,f) (r).wan_port_sel[0]=(((r).wan_port_sel[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9))
#define BCM53101_A0_WAN_PORT_SELr_RESERVED_1f_GET(r) ((((r).wan_port_sel[0]) >> 10) & 0x3f)
#define BCM53101_A0_WAN_PORT_SELr_RESERVED_1f_SET(r,f) (r).wan_port_sel[0]=(((r).wan_port_sel[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10))

/*
 * These macros can be used to access WAN_PORT_SEL.
 *
 */
#define BCM53101_A0_READ_WAN_PORT_SELr(u,r) cdk_robo_reg_read(u,BCM53101_A0_WAN_PORT_SELr,(r._wan_port_sel),2)
#define BCM53101_A0_WRITE_WAN_PORT_SELr(u,r) cdk_robo_reg_write(u,BCM53101_A0_WAN_PORT_SELr,&(r._wan_port_sel),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define WAN_PORT_SELr BCM53101_A0_WAN_PORT_SELr
#define WAN_PORT_SELr_SIZE BCM53101_A0_WAN_PORT_SELr_SIZE
typedef BCM53101_A0_WAN_PORT_SELr_t WAN_PORT_SELr_t;
#define WAN_PORT_SELr_CLR BCM53101_A0_WAN_PORT_SELr_CLR
#define WAN_PORT_SELr_SET BCM53101_A0_WAN_PORT_SELr_SET
#define WAN_PORT_SELr_GET BCM53101_A0_WAN_PORT_SELr_GET
#define WAN_PORT_SELr_WAN_SELECTf_GET BCM53101_A0_WAN_PORT_SELr_WAN_SELECTf_GET
#define WAN_PORT_SELr_WAN_SELECTf_SET BCM53101_A0_WAN_PORT_SELr_WAN_SELECTf_SET
#define WAN_PORT_SELr_RESERVED_0f_GET BCM53101_A0_WAN_PORT_SELr_RESERVED_0f_GET
#define WAN_PORT_SELr_RESERVED_0f_SET BCM53101_A0_WAN_PORT_SELr_RESERVED_0f_SET
#define WAN_PORT_SELr_EN_MAN2WANf_GET BCM53101_A0_WAN_PORT_SELr_EN_MAN2WANf_GET
#define WAN_PORT_SELr_EN_MAN2WANf_SET BCM53101_A0_WAN_PORT_SELr_EN_MAN2WANf_SET
#define WAN_PORT_SELr_RESERVED_1f_GET BCM53101_A0_WAN_PORT_SELr_RESERVED_1f_GET
#define WAN_PORT_SELr_RESERVED_1f_SET BCM53101_A0_WAN_PORT_SELr_RESERVED_1f_SET
#define READ_WAN_PORT_SELr BCM53101_A0_READ_WAN_PORT_SELr
#define WRITE_WAN_PORT_SELr BCM53101_A0_WRITE_WAN_PORT_SELr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_WAN_PORT_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  WATCH_DOG_CTRL
 * BLOCKS:   SYS
 * DESC:     Watch Dog Control Registrer
 * SIZE:     8
 * FIELDS:
 *     RESERVED_0       Reserved
 *     EN_SW_RESET      Enable Global Software Reset.
 *     RESERVED_1       Reserved
 *     SOFTWARE_RESET   Global Software Reset. (EN_SW_RST must be enabled as wellSet 1'b1 to trigger reset process.*** Reset Process except Strap value and PLL.When reset process is done, this bit is cleared to 1'b0.
 *
 ******************************************************************************/
#define BCM53101_A0_WATCH_DOG_CTRLr 0x00000079

#define BCM53101_A0_WATCH_DOG_CTRLr_SIZE 1

/*
 * This structure should be used to declare and program WATCH_DOG_CTRL.
 *
 */
typedef union BCM53101_A0_WATCH_DOG_CTRLr_s {
	uint32_t v[1];
	uint32_t watch_dog_ctrl[1];
	uint32_t _watch_dog_ctrl;
} BCM53101_A0_WATCH_DOG_CTRLr_t;

#define BCM53101_A0_WATCH_DOG_CTRLr_CLR(r) (r).watch_dog_ctrl[0] = 0
#define BCM53101_A0_WATCH_DOG_CTRLr_SET(r,d) (r).watch_dog_ctrl[0] = d
#define BCM53101_A0_WATCH_DOG_CTRLr_GET(r) (r).watch_dog_ctrl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_WATCH_DOG_CTRLr_RESERVED_0f_GET(r) (((r).watch_dog_ctrl[0]) & 0xf)
#define BCM53101_A0_WATCH_DOG_CTRLr_RESERVED_0f_SET(r,f) (r).watch_dog_ctrl[0]=(((r).watch_dog_ctrl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf))
#define BCM53101_A0_WATCH_DOG_CTRLr_EN_SW_RESETf_GET(r) ((((r).watch_dog_ctrl[0]) >> 4) & 0x1)
#define BCM53101_A0_WATCH_DOG_CTRLr_EN_SW_RESETf_SET(r,f) (r).watch_dog_ctrl[0]=(((r).watch_dog_ctrl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4))
#define BCM53101_A0_WATCH_DOG_CTRLr_RESERVED_1f_GET(r) ((((r).watch_dog_ctrl[0]) >> 5) & 0x3)
#define BCM53101_A0_WATCH_DOG_CTRLr_RESERVED_1f_SET(r,f) (r).watch_dog_ctrl[0]=(((r).watch_dog_ctrl[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5))
#define BCM53101_A0_WATCH_DOG_CTRLr_SOFTWARE_RESETf_GET(r) ((((r).watch_dog_ctrl[0]) >> 7) & 0x1)
#define BCM53101_A0_WATCH_DOG_CTRLr_SOFTWARE_RESETf_SET(r,f) (r).watch_dog_ctrl[0]=(((r).watch_dog_ctrl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7))

/*
 * These macros can be used to access WATCH_DOG_CTRL.
 *
 */
#define BCM53101_A0_READ_WATCH_DOG_CTRLr(u,r) cdk_robo_reg_read(u,BCM53101_A0_WATCH_DOG_CTRLr,(r._watch_dog_ctrl),1)
#define BCM53101_A0_WRITE_WATCH_DOG_CTRLr(u,r) cdk_robo_reg_write(u,BCM53101_A0_WATCH_DOG_CTRLr,&(r._watch_dog_ctrl),1)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define WATCH_DOG_CTRLr BCM53101_A0_WATCH_DOG_CTRLr
#define WATCH_DOG_CTRLr_SIZE BCM53101_A0_WATCH_DOG_CTRLr_SIZE
typedef BCM53101_A0_WATCH_DOG_CTRLr_t WATCH_DOG_CTRLr_t;
#define WATCH_DOG_CTRLr_CLR BCM53101_A0_WATCH_DOG_CTRLr_CLR
#define WATCH_DOG_CTRLr_SET BCM53101_A0_WATCH_DOG_CTRLr_SET
#define WATCH_DOG_CTRLr_GET BCM53101_A0_WATCH_DOG_CTRLr_GET
#define WATCH_DOG_CTRLr_RESERVED_0f_GET BCM53101_A0_WATCH_DOG_CTRLr_RESERVED_0f_GET
#define WATCH_DOG_CTRLr_RESERVED_0f_SET BCM53101_A0_WATCH_DOG_CTRLr_RESERVED_0f_SET
#define WATCH_DOG_CTRLr_EN_SW_RESETf_GET BCM53101_A0_WATCH_DOG_CTRLr_EN_SW_RESETf_GET
#define WATCH_DOG_CTRLr_EN_SW_RESETf_SET BCM53101_A0_WATCH_DOG_CTRLr_EN_SW_RESETf_SET
#define WATCH_DOG_CTRLr_RESERVED_1f_GET BCM53101_A0_WATCH_DOG_CTRLr_RESERVED_1f_GET
#define WATCH_DOG_CTRLr_RESERVED_1f_SET BCM53101_A0_WATCH_DOG_CTRLr_RESERVED_1f_SET
#define WATCH_DOG_CTRLr_SOFTWARE_RESETf_GET BCM53101_A0_WATCH_DOG_CTRLr_SOFTWARE_RESETf_GET
#define WATCH_DOG_CTRLr_SOFTWARE_RESETf_SET BCM53101_A0_WATCH_DOG_CTRLr_SOFTWARE_RESETf_SET
#define READ_WATCH_DOG_CTRLr BCM53101_A0_READ_WATCH_DOG_CTRLr
#define WRITE_WATCH_DOG_CTRLr BCM53101_A0_WRITE_WATCH_DOG_CTRLr

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_WATCH_DOG_CTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  WATCH_DOG_RPT1
 * BLOCKS:   SYS
 * DESC:     Watch Dog Report 1 Registrer
 * SIZE:     16
 * FIELDS:
 *     TX_PORT_HUNG_INDICATOR Tx Hung IndicatorBit 8:0 = Port 8:01: Means hung case happen0: Means Ok
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_WATCH_DOG_RPT1r 0x0000007a

#define BCM53101_A0_WATCH_DOG_RPT1r_SIZE 2

/*
 * This structure should be used to declare and program WATCH_DOG_RPT1.
 *
 */
typedef union BCM53101_A0_WATCH_DOG_RPT1r_s {
	uint32_t v[1];
	uint32_t watch_dog_rpt1[1];
	uint32_t _watch_dog_rpt1;
} BCM53101_A0_WATCH_DOG_RPT1r_t;

#define BCM53101_A0_WATCH_DOG_RPT1r_CLR(r) (r).watch_dog_rpt1[0] = 0
#define BCM53101_A0_WATCH_DOG_RPT1r_SET(r,d) (r).watch_dog_rpt1[0] = d
#define BCM53101_A0_WATCH_DOG_RPT1r_GET(r) (r).watch_dog_rpt1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_WATCH_DOG_RPT1r_TX_PORT_HUNG_INDICATORf_GET(r) (((r).watch_dog_rpt1[0]) & 0x1ff)
#define BCM53101_A0_WATCH_DOG_RPT1r_TX_PORT_HUNG_INDICATORf_SET(r,f) (r).watch_dog_rpt1[0]=(((r).watch_dog_rpt1[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_WATCH_DOG_RPT1r_RESERVEDf_GET(r) ((((r).watch_dog_rpt1[0]) >> 9) & 0x7f)
#define BCM53101_A0_WATCH_DOG_RPT1r_RESERVEDf_SET(r,f) (r).watch_dog_rpt1[0]=(((r).watch_dog_rpt1[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access WATCH_DOG_RPT1.
 *
 */
#define BCM53101_A0_READ_WATCH_DOG_RPT1r(u,r) cdk_robo_reg_read(u,BCM53101_A0_WATCH_DOG_RPT1r,(r._watch_dog_rpt1),2)
#define BCM53101_A0_WRITE_WATCH_DOG_RPT1r(u,r) cdk_robo_reg_write(u,BCM53101_A0_WATCH_DOG_RPT1r,&(r._watch_dog_rpt1),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define WATCH_DOG_RPT1r BCM53101_A0_WATCH_DOG_RPT1r
#define WATCH_DOG_RPT1r_SIZE BCM53101_A0_WATCH_DOG_RPT1r_SIZE
typedef BCM53101_A0_WATCH_DOG_RPT1r_t WATCH_DOG_RPT1r_t;
#define WATCH_DOG_RPT1r_CLR BCM53101_A0_WATCH_DOG_RPT1r_CLR
#define WATCH_DOG_RPT1r_SET BCM53101_A0_WATCH_DOG_RPT1r_SET
#define WATCH_DOG_RPT1r_GET BCM53101_A0_WATCH_DOG_RPT1r_GET
#define WATCH_DOG_RPT1r_TX_PORT_HUNG_INDICATORf_GET BCM53101_A0_WATCH_DOG_RPT1r_TX_PORT_HUNG_INDICATORf_GET
#define WATCH_DOG_RPT1r_TX_PORT_HUNG_INDICATORf_SET BCM53101_A0_WATCH_DOG_RPT1r_TX_PORT_HUNG_INDICATORf_SET
#define WATCH_DOG_RPT1r_RESERVEDf_GET BCM53101_A0_WATCH_DOG_RPT1r_RESERVEDf_GET
#define WATCH_DOG_RPT1r_RESERVEDf_SET BCM53101_A0_WATCH_DOG_RPT1r_RESERVEDf_SET
#define READ_WATCH_DOG_RPT1r BCM53101_A0_READ_WATCH_DOG_RPT1r
#define WRITE_WATCH_DOG_RPT1r BCM53101_A0_WRITE_WATCH_DOG_RPT1r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_WATCH_DOG_RPT1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  WATCH_DOG_RPT2
 * BLOCKS:   SYS
 * DESC:     Watch Dog Report 2 Registrer
 * SIZE:     16
 * FIELDS:
 *     RX_PORT_HUNG_INDICATOR Rx Hung IndicatorBit 8:0 = Port 8:01: Means hung case happen0: Means Ok
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_WATCH_DOG_RPT2r 0x0000007c

#define BCM53101_A0_WATCH_DOG_RPT2r_SIZE 2

/*
 * This structure should be used to declare and program WATCH_DOG_RPT2.
 *
 */
typedef union BCM53101_A0_WATCH_DOG_RPT2r_s {
	uint32_t v[1];
	uint32_t watch_dog_rpt2[1];
	uint32_t _watch_dog_rpt2;
} BCM53101_A0_WATCH_DOG_RPT2r_t;

#define BCM53101_A0_WATCH_DOG_RPT2r_CLR(r) (r).watch_dog_rpt2[0] = 0
#define BCM53101_A0_WATCH_DOG_RPT2r_SET(r,d) (r).watch_dog_rpt2[0] = d
#define BCM53101_A0_WATCH_DOG_RPT2r_GET(r) (r).watch_dog_rpt2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_WATCH_DOG_RPT2r_RX_PORT_HUNG_INDICATORf_GET(r) (((r).watch_dog_rpt2[0]) & 0x1ff)
#define BCM53101_A0_WATCH_DOG_RPT2r_RX_PORT_HUNG_INDICATORf_SET(r,f) (r).watch_dog_rpt2[0]=(((r).watch_dog_rpt2[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_WATCH_DOG_RPT2r_RESERVEDf_GET(r) ((((r).watch_dog_rpt2[0]) >> 9) & 0x7f)
#define BCM53101_A0_WATCH_DOG_RPT2r_RESERVEDf_SET(r,f) (r).watch_dog_rpt2[0]=(((r).watch_dog_rpt2[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access WATCH_DOG_RPT2.
 *
 */
#define BCM53101_A0_READ_WATCH_DOG_RPT2r(u,r) cdk_robo_reg_read(u,BCM53101_A0_WATCH_DOG_RPT2r,(r._watch_dog_rpt2),2)
#define BCM53101_A0_WRITE_WATCH_DOG_RPT2r(u,r) cdk_robo_reg_write(u,BCM53101_A0_WATCH_DOG_RPT2r,&(r._watch_dog_rpt2),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define WATCH_DOG_RPT2r BCM53101_A0_WATCH_DOG_RPT2r
#define WATCH_DOG_RPT2r_SIZE BCM53101_A0_WATCH_DOG_RPT2r_SIZE
typedef BCM53101_A0_WATCH_DOG_RPT2r_t WATCH_DOG_RPT2r_t;
#define WATCH_DOG_RPT2r_CLR BCM53101_A0_WATCH_DOG_RPT2r_CLR
#define WATCH_DOG_RPT2r_SET BCM53101_A0_WATCH_DOG_RPT2r_SET
#define WATCH_DOG_RPT2r_GET BCM53101_A0_WATCH_DOG_RPT2r_GET
#define WATCH_DOG_RPT2r_RX_PORT_HUNG_INDICATORf_GET BCM53101_A0_WATCH_DOG_RPT2r_RX_PORT_HUNG_INDICATORf_GET
#define WATCH_DOG_RPT2r_RX_PORT_HUNG_INDICATORf_SET BCM53101_A0_WATCH_DOG_RPT2r_RX_PORT_HUNG_INDICATORf_SET
#define WATCH_DOG_RPT2r_RESERVEDf_GET BCM53101_A0_WATCH_DOG_RPT2r_RESERVEDf_GET
#define WATCH_DOG_RPT2r_RESERVEDf_SET BCM53101_A0_WATCH_DOG_RPT2r_RESERVEDf_SET
#define READ_WATCH_DOG_RPT2r BCM53101_A0_READ_WATCH_DOG_RPT2r
#define WRITE_WATCH_DOG_RPT2r BCM53101_A0_WRITE_WATCH_DOG_RPT2r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_WATCH_DOG_RPT2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCM53101_A0
 * REGISTER:  WATCH_DOG_RPT3
 * BLOCKS:   SYS
 * DESC:     Watch Dog Report 3 Registrer
 * SIZE:     16
 * FIELDS:
 *     ARL_HUNG_INDICATOR ARL Indicator.Bit 8:0 = Port 8:01: Means hung case happen0: Means Ok
 *     RESERVED         Reserved
 *
 ******************************************************************************/
#define BCM53101_A0_WATCH_DOG_RPT3r 0x0000007e

#define BCM53101_A0_WATCH_DOG_RPT3r_SIZE 2

/*
 * This structure should be used to declare and program WATCH_DOG_RPT3.
 *
 */
typedef union BCM53101_A0_WATCH_DOG_RPT3r_s {
	uint32_t v[1];
	uint32_t watch_dog_rpt3[1];
	uint32_t _watch_dog_rpt3;
} BCM53101_A0_WATCH_DOG_RPT3r_t;

#define BCM53101_A0_WATCH_DOG_RPT3r_CLR(r) (r).watch_dog_rpt3[0] = 0
#define BCM53101_A0_WATCH_DOG_RPT3r_SET(r,d) (r).watch_dog_rpt3[0] = d
#define BCM53101_A0_WATCH_DOG_RPT3r_GET(r) (r).watch_dog_rpt3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCM53101_A0_WATCH_DOG_RPT3r_ARL_HUNG_INDICATORf_GET(r) (((r).watch_dog_rpt3[0]) & 0x1ff)
#define BCM53101_A0_WATCH_DOG_RPT3r_ARL_HUNG_INDICATORf_SET(r,f) (r).watch_dog_rpt3[0]=(((r).watch_dog_rpt3[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff))
#define BCM53101_A0_WATCH_DOG_RPT3r_RESERVEDf_GET(r) ((((r).watch_dog_rpt3[0]) >> 9) & 0x7f)
#define BCM53101_A0_WATCH_DOG_RPT3r_RESERVEDf_SET(r,f) (r).watch_dog_rpt3[0]=(((r).watch_dog_rpt3[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9))

/*
 * These macros can be used to access WATCH_DOG_RPT3.
 *
 */
#define BCM53101_A0_READ_WATCH_DOG_RPT3r(u,r) cdk_robo_reg_read(u,BCM53101_A0_WATCH_DOG_RPT3r,(r._watch_dog_rpt3),2)
#define BCM53101_A0_WRITE_WATCH_DOG_RPT3r(u,r) cdk_robo_reg_write(u,BCM53101_A0_WATCH_DOG_RPT3r,&(r._watch_dog_rpt3),2)

/*
 * Unless CDK_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define CDK_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef CDK_EXCLUDE_CHIPLESS_TYPES

#define WATCH_DOG_RPT3r BCM53101_A0_WATCH_DOG_RPT3r
#define WATCH_DOG_RPT3r_SIZE BCM53101_A0_WATCH_DOG_RPT3r_SIZE
typedef BCM53101_A0_WATCH_DOG_RPT3r_t WATCH_DOG_RPT3r_t;
#define WATCH_DOG_RPT3r_CLR BCM53101_A0_WATCH_DOG_RPT3r_CLR
#define WATCH_DOG_RPT3r_SET BCM53101_A0_WATCH_DOG_RPT3r_SET
#define WATCH_DOG_RPT3r_GET BCM53101_A0_WATCH_DOG_RPT3r_GET
#define WATCH_DOG_RPT3r_ARL_HUNG_INDICATORf_GET BCM53101_A0_WATCH_DOG_RPT3r_ARL_HUNG_INDICATORf_GET
#define WATCH_DOG_RPT3r_ARL_HUNG_INDICATORf_SET BCM53101_A0_WATCH_DOG_RPT3r_ARL_HUNG_INDICATORf_SET
#define WATCH_DOG_RPT3r_RESERVEDf_GET BCM53101_A0_WATCH_DOG_RPT3r_RESERVEDf_GET
#define WATCH_DOG_RPT3r_RESERVEDf_SET BCM53101_A0_WATCH_DOG_RPT3r_RESERVEDf_SET
#define READ_WATCH_DOG_RPT3r BCM53101_A0_READ_WATCH_DOG_RPT3r
#define WRITE_WATCH_DOG_RPT3r BCM53101_A0_WRITE_WATCH_DOG_RPT3r

#endif /* CDK_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCM53101_A0_WATCH_DOG_RPT3r'
 ******************************************************************************/




#endif /* CDK_CONFIG_CHIP_DEFS_USE_DSYMS */
#endif /* __BCM53101_A0_DEFS_H__ */
